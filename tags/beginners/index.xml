<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Beginners on Maxbit Docs</title>
    <link>https://docs.cakepanit.com/tags/beginners/</link>
    <description>Recent content in Beginners on Maxbit Docs</description>
    <generator>Hugo</generator>
    <language>zh-CN</language>
    <managingEditor>admin@cakepanit.com (饼铛)</managingEditor>
    <webMaster>admin@cakepanit.com (饼铛)</webMaster>
    <lastBuildDate>Tue, 22 Oct 2024 23:43:28 +0800</lastBuildDate>
    <atom:link href="https://docs.cakepanit.com/tags/beginners/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>第一篇WIKI</title>
      <link>https://docs.cakepanit.com/docs/dba/dome/</link>
      <pubDate>Wed, 03 May 2023 22:37:22 +0100</pubDate><author>admin@cakepanit.com (饼铛)</author>
      <guid>https://docs.cakepanit.com/docs/dba/dome/</guid>
      <description>Create New Content linkNavigate to the root of your Hugo project and use the hugo new command to create a file in the content/docs directory:&#xA;hugo new docs/examplepage.md </description>
    </item>
    <item>
      <title>1.单例模式</title>
      <link>https://docs.cakepanit.com/docs/dev/23designpattern/1.%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Wed, 03 May 2023 22:37:22 +0100</pubDate><author>admin@cakepanit.com (饼铛)</author>
      <guid>https://docs.cakepanit.com/docs/dev/23designpattern/1.%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</guid>
      <description>需求 link【设计模式专题之单例模式】1.小明的购物车&#xA;题目描述&#xA;小明去了一家大型商场，拿到了一个购物车，并开始购物。请你设计一个购物车管理器，记录商品添加到购物车的信息（商品名称和购买数量），并在购买结束后打印出商品清单。（在整个购物过程中，小明只有一个购物车实例存在）。 输入描述&#xA;输入包含若干行，每行包含两部分信息，分别是商品名称和购买数量。商品名称和购买数量之间用空格隔开。 输出描述&#xA;输出包含小明购物车中的所有商品及其购买数量。每行输出一种商品的信息，格式为 &amp;ldquo;商品名称 购买数量&amp;rdquo;。 输入示例 Apple 3 Banana 2 Orange 5 输出示例 Apple 3 Banana 2 Orange 5 提示信息 本道题目请使用单例设计模式： 使用私有静态变量来保存购物车实例。 使用私有构造函数防止外部直接实例化。 什么是单例设计模式 link单例模式是一种创建型设计模式， 它的核心思想是保证一个类只有一个实例，并提供一个全局访问点来访问这个实例。&#xA;只有一个实例的意思是，在整个应用程序中，只存在该类的一个实例对象，而不是创建多个相同类型的对象。 全局访问点的意思是，为了让其他类能够获取到这个唯一实例，该类提供了一个全局访问点（通常是一个静态方法），通过这个方法就能获得实例。 为什么要使用单例设计模式呢 link简易来说，单例设计模式有以下几个优点让我们考虑使用它：&#xA;全局控制：保证只有一个实例，这样就可以严格的控制客户怎样访问它以及何时访问它，简单的说就是对唯一实例的受控访问（引用自《大话设计模式》第21章） 节省资源：也正是因为只有一个实例存在，就避免多次创建了相同的对象，从而节省了系统资源，而且多个模块还可以通过单例实例共享数据。 懒加载：单例模式可以实现懒加载，只有在需要时才进行实例化，这无疑会提高程序的性能。 单例设计模式的基本要求 link想要实现一个单例设计模式，必须遵循以下规则：&#xA;私有的构造函数：防止外部代码直接创建类的实例 私有的静态实例变量：保存该类的唯一实例 公有的静态方法：通过公有的静态方法来获取类的实例 单例设计模式的实现 link单例模式的实现方式有多种，包括懒汉式、饿汉式等。&#xA;饿汉式指的是在类加载时就已经完成了实例的创建，不管后面创建的实例有没有使用，先创建再说，所以叫做 “饿汉”。&#xA;而懒汉式指的是只有在请求实例时才会创建，如果在首次请求时还没有创建，就创建一个新的实例，如果已经创建，就返回已有的实例，意思就是需要使用了再创建，所以称为“懒汉”。&#xA;在多线程环境下，由于饿汉式在程序启动阶段就完成了实例的初始化，因此不存在多个线程同时尝试初始化实例的问题，但是懒汉式中多个线程同时访问 getInstance() 方法，并且在同一时刻检测到实例没有被创建，就可能会同时创建实例，从而导致多个实例被创建，这种情况下我们可以采用一些同步机制，例如使用互斥锁来确保在任何时刻只有一个线程能够执行实例的创建。&#xA;举个例子，你和小明都发现家里没米了，在你们没有相互通知的情况下，都会去超市买一袋米，这样就重复购买了，违背了单例模式。&#xA;下面以Java的代码作为实例，说明单例设计模式的基本写法：&#xA;饿汉模式：实例在类加载时就被创建, 这种方式的实现相对简单，但是实例有可能没有使用而造成资源浪费。 public class Singleton { private static final Singleton instance = new Singleton(); private Singleton() { // 私有构造方法，防止外部实例化 } public static Singleton getInstance() { return instance; } } 懒汉模式：第一次使用时才创建 public class Singleton { private static Singleton instance; private Singleton() { // 私有构造方法，防止外部实例化 } // 使用了同步关键字来确保线程安全, 可能会影响性能 public static synchronized Singleton getInstance() { if (instance == null) { instance = new Singleton(); } return instance; } } 在懒汉模式的基础上，可以使用双重检查锁来提高性能。</description>
    </item>
    <item>
      <title>2.工厂方法模式</title>
      <link>https://docs.cakepanit.com/docs/dev/23designpattern/2.%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Wed, 03 May 2023 22:37:22 +0100</pubDate><author>admin@cakepanit.com (饼铛)</author>
      <guid>https://docs.cakepanit.com/docs/dev/23designpattern/2.%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</guid>
      <description>需求 link【设计模式专题之工厂方法模式】2.积木工厂&#xA;题目描述&#xA;小明家有两个工厂，一个用于生产圆形积木，一个用于生产方形积木，请你帮他设计一个积木工厂系统，记录积木生产的信息。 输入描述&#xA;输入的第一行是一个整数 N（1 ≤ N ≤ 100），表示生产的次数。 接下来的 N 行，每行输入一个字符串和一个整数，字符串表示积木的类型。积木类型分为 &amp;ldquo;Circle&amp;rdquo; 和 &amp;ldquo;Square&amp;rdquo; 两种。整数表示该积木生产的数量 输出描述&#xA;对于每个积木，输出一行字符串表示该积木的信息。 输入示例 3 Circle 1 Square 2 Circle 1 输出示例 Circle Block Square Block Square Block Circle Block 提示信息 在示例中，积木工厂生产了3块积木，其中有2块是圆形积木，1块是方形积木。根据输入的类型，每块积木的信息被输出到控制台。&#xA;简单工厂模式 link在了解工厂方法模式之前，有必要对“简单工厂”模式进行一定的了解，简单工厂模式是一种创建型设计模式，但并不属于23种设计模式之一，更多的是一种编程习惯。&#xA;简单工厂模式的核心思想是将产品的创建过程封装在一个工厂类中，把创建对象的流程集中在这个工厂类里面。&#xA;简单工厂模式包括三个主要角色，工厂类、抽象产品、具体产品，下面的图示则展示了工厂类的基本结构。&#xA;抽象产品，比如上图中的Shape 接口，描述产品的通用行为。 具体产品: 实现抽象产品接口或继承抽象产品类，比如上面的Circle类和Square类，具体产品通过简单工厂类的if-else逻辑来实例化。 工厂类：负责创建产品，根据传递的不同参数创建不同的产品示例。 简单工厂类简化了客户端操作，客户端可以调用工厂方法来获取具体产品，而无需直接与具体产品类交互，降低了耦合，但是有一个很大的问题就是不够灵活，如果需要添加新的产品，就需要修改工厂类的代码。&#xA;什么是工厂方法模式 link工厂方法模式也是一种创建型设计模式，简单工厂模式只有一个工厂类，负责创建所有产品，如果要添加新的产品，通常需要修改工厂类的代码。而工厂方法模式引入了抽象工厂和具体工厂的概念，每个具体工厂只负责创建一个具体产品，添加新的产品只需要添加新的工厂类而无需修改原来的代码，这样就使得产品的生产更加灵活，支持扩展，符合开闭原则。&#xA;工厂方法模式分为以下几个角色：&#xA;抽象工厂：一个接口，包含一个抽象的工厂方法（用于创建产品对象）。 具体工厂：实现抽象工厂接口，创建具体的产品。 抽象产品：定义产品的接口。 具体产品：实现抽象产品接口，是工厂创建的对象。 实际上工厂方法模式也很好理解，就拿“手机Phone”这个产品举例，手机是一个抽象产品，小米手机、华为手机、苹果手机是具体的产品实现，而不同品牌的手机在各自的生产厂家生产。&#xA;基本实现 link根据上面的类图，我们可以写出工厂方法模式的基本实现。&#xA;// 抽象产品 interface Shape { void draw(); } // 具体产品 - 圆形 class Circle implements Shape { @Override public void draw() { System.</description>
    </item>
    <item>
      <title>3.抽象工厂模式</title>
      <link>https://docs.cakepanit.com/docs/dev/23designpattern/3.%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Wed, 03 May 2023 22:37:22 +0100</pubDate><author>admin@cakepanit.com (饼铛)</author>
      <guid>https://docs.cakepanit.com/docs/dev/23designpattern/3.%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</guid>
      <description>需求 link【设计模式专题之抽象工厂模式】3. 家具工厂&#xA;题目描述&#xA;小明家新开了两个工厂用来生产家具，一个生产现代风格的沙发和椅子，一个生产古典风格的沙发和椅子，现在工厂收到了一笔订单，请你帮他设计一个系统，描述订单需要生产家具的信息。 输入描述&#xA;输入的第一行是一个整数 N（1 ≤ N ≤ 100），表示订单的数量。 接下来的 N 行，每行输入一个字符串，字符串表示家具的类型。家具类型分为 &amp;ldquo;modern&amp;rdquo; 和 &amp;ldquo;classical&amp;rdquo; 两种。 输出描述&#xA;对于每笔订单，输出字符串表示该订单需要生产家具的信息。 modern订单会输出下面两行字符串 modern chair modern sofa classical订单会输出下面两行字符串 classical chair classical soft 输入示例 3 modern classical modern 输出示例 modern chair modern sofa classical chair classical sofa modern chair modern sofa 提示信息 在示例中，工厂收到了3笔订单，其中有2笔要求生产modern风格，1笔要求生产classical风格。根据输入的类型，每次订单生产的家具信息被输出到控制台上。&#xA;什么是抽象工厂模式 link抽象工厂模式也是一种创建型设计模式，提供了一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类【引用自大话设计模式第15章】&#xA;这样的描述似乎理解起来很困难，我们可以把它与【工厂方法模式】联系起来看。&#xA;之前我们已经介绍了“工厂方法模式”，那为什么还有要抽象工厂模式呢？&#xA;这就涉及到创建“多类”对象了，在工厂方法模式中，每个具体工厂只负责创建单一的产品。但是如果有多类产品呢，比如说“手机”，一个品牌的手机有高端机、中低端机之分，这些具体的产品都需要建立一个单独的工厂类，但是它们都是相互关联的，都共同属于同一个品牌，这就可以使用到【抽象工厂模式】。&#xA;抽象工厂模式可以确保一系列相关的产品被一起创建，这些产品能够相互配合使用，再举个例子，有一些家具，比如沙发、茶几、椅子，都具有古典风格的和现代风格的，抽象工厂模式可以将生产现代风格的家具放在一个工厂类中，将生产古典风格的家具放在另一个工厂类中，这样每个工厂类就可以生产一系列的家具。&#xA;基本结构 link抽象工厂模式包含多个抽象产品接口，多个具体产品类，一个抽象工厂接口和多个具体工厂，每个具体工厂负责创建一组相关的产品。&#xA;抽象产品接口AbstractProduct: 定义产品的接口，可以定义多个抽象产品接口，比如说沙发、椅子、茶几都是抽象产品。 具体产品类ConcreteProduct: 实现抽象产品接口，产品的具体实现，古典风格和沙发和现代风格的沙发都是具体产品。 抽象工厂接口AbstractFactory: 声明一组用于创建产品的方法，每个方法对应一个产品。 具体工厂类ConcreteFactory： 实现抽象工厂接口，负责创建一组具体产品的对象，在本例中，生产古典风格的工厂和生产现代风格的工厂都是具体实例。 在上面的图示中：AbstractProductA/B/C 就是抽象产品，ConcreteProductA2/A2/B1/B2/C1/C2就是抽象产品的实现，AbstractFactory定义了抽象工厂接口，接口里的方法用于创建具体的产品，而ConcreteFactory就是具体工厂类，可以创建一组相关的产品。&#xA;基本实现 link想要实现抽象工厂模式，需要遵循以下步骤：</description>
    </item>
    <item>
      <title>4.建造者模式</title>
      <link>https://docs.cakepanit.com/docs/dev/23designpattern/4.%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Wed, 03 May 2023 22:37:22 +0100</pubDate><author>admin@cakepanit.com (饼铛)</author>
      <guid>https://docs.cakepanit.com/docs/dev/23designpattern/4.%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/</guid>
      <description>需求 link【设计模式专题之建造者模式】4. 自行车加工&#xA;题目描述&#xA;小明家新开了一家自行车工厂，用于使用自行车配件（车架 frame 和车轮 tires ）进行组装定制不同的自行车，包括山地车和公路车。 山地车使用的是Aluminum Frame（铝制车架）和 Knobby Tires（可抓地轮胎），公路车使用的是 Carbon Frame （碳车架）和 Slim Tries。 现在它收到了一笔订单，要求定制一批自行车，请你使用【建造者模式】告诉小明这笔订单需要使用那些自行车配置吧。 输入描述&#xA;输入的第一行是一个整数 N（1 ≤ N ≤ 100），表示订单的数量。 接下来的 N 行，每行输入一个字符串，字符串表示客户的自行车需求。 字符串可以包含关键词 &amp;ldquo;mountain&amp;rdquo; 或 &amp;ldquo;road&amp;rdquo;，表示客户需要山地自行车或公路自行车。 **输出描述 对于每笔订单，输出该订单定制的自行车配置。&#xA;输入示例 3 mountain road mountain 输出示例&#xA;Aluminum Frame Knobby Tires Carbon Frame Slim Tires Aluminum Frame Knobby Tires 提示信息 在本例中：产品为自行车，可以有两个建造者：山地车建造者和公路车建造者。&#xA;什么是建造者模式 link建造者模式（也被成为生成器模式），是一种创建型设计模式，软件开发过程中有的时候需要创建很复杂的对象，而建造者模式的主要思想是**将对象的构建过程分为多个步骤，并为每个步骤定义一个抽象的接口。具体的构建过程由实现了这些接口的具体建造者类来完成。**同时有一个指导者类负责协调建造者的工作，按照一定的顺序或逻辑来执行构建步骤，最终生成产品。&#xA;举个例子，假如我们要创建一个计算机对象，计算机由很多组件组成，例如 CPU、内存、硬盘、显卡等。每个组件可能有不同的型号、配置和制造，这个时候计算机就可以被视为一个复杂对象，构建过程相对复杂，而我们使用建造者模式将计算机的构建过程封装在一个具体的建造者类中，而指导者类则负责指导构建的步骤和顺序。每个具体的建造者类可以负责构建不同型号或配置的计算机，客户端代码可以通过选择不同的建造者来创建不同类型的计算机，这样就可以根据需要构建不同表示的复杂对象，更加灵活。&#xA;基本结构 link建造者模式有下面几个关键角色：&#xA;产品Product：被构建的复杂对象, 包含多个组成部分。 抽象建造者Builder: 定义构建产品各个部分的抽象接口和一个返回复杂产品的方法getResult 具体建造者Concrete Builder：实现抽象建造者接口，构建产品的各个组成部分，并提供一个方法返回最终的产品。 指导者Director：调用具体建造者的方法，按照一定的顺序或逻辑来构建产品。 在客户端中，通过指导者来构建产品，而并不和具体建造者进行直接的交互。&#xA;简易实现 link建造者模式的实现步骤通常包括以下几个阶段</description>
    </item>
    <item>
      <title>5.原型模式</title>
      <link>https://docs.cakepanit.com/docs/dev/23designpattern/5.%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Wed, 03 May 2023 22:37:22 +0100</pubDate><author>admin@cakepanit.com (饼铛)</author>
      <guid>https://docs.cakepanit.com/docs/dev/23designpattern/5.%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/</guid>
      <description>需求 link【设计模式专题之原型模式】5. 矩形原型&#xA;题目描述&#xA;公司正在开发一个图形设计软件，其中有一个常用的图形元素是矩形。设计师在工作时可能需要频繁地创建相似的矩形，而这些矩形的基本属性是相同的（颜色、宽度、高度），为了提高设计师的工作效率，请你使用原型模式设计一个矩形对象的原型。使用该原型可以快速克隆生成新的矩形对象。 输入描述&#xA;首先输入一个字符串，表示矩形的基本属性信息，包括颜色、长度和宽度，用空格分隔，例如 &amp;ldquo;Red 10 5&amp;rdquo;。 然后输入一个整数 N（1 ≤ N ≤ 100），表示使用原型创建的矩形数量。 输出描述&#xA;对于每个矩形，输出一行字符串表示矩形的详细信息，如 &amp;ldquo;Color: Red, Width: 10,Height: 5&amp;rdquo;。 输入示例 Red 10 5 3 输出示例 Color: Red, Width: 10, Height: 5 Color: Red, Width: 10, Height: 5 Color: Red, Width: 10, Height: 5 提示信息 使用原型模式中的克隆方法实现矩形对象的创建。&#xA;什么是原型模式 link原型模式一种创建型设计模式，该模式的核心思想是基于现有的对象创建新的对象，而不是从头开始创建。&#xA;在原型模式中，通常有一个原型对象，它被用作创建新对象的模板。新对象通过复制原型对象的属性和状态来创建，而无需知道具体的创建细节。&#xA;为什么要使用原型模式 link如果一个对象的创建过程比较复杂时（比如需要经过一系列的计算和资源消耗），那每次创建该对象都需要消耗资源，而通过原型模式就可以复制现有的一个对象来迅速创建/克隆一个新对象，不必关心具体的创建细节，可以降低对象创建的成本。&#xA;下面是一个简短的Python代码示例了模拟了上面的问题：&#xA;import copy class ComplexObject: def __init__(self, data): # 耗时的资源型操作 self.data = data def clone(self): # 复制 return copy.</description>
    </item>
    <item>
      <title>6.适配器模式</title>
      <link>https://docs.cakepanit.com/docs/dev/23designpattern/6.%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Wed, 03 May 2023 22:37:22 +0100</pubDate><author>admin@cakepanit.com (饼铛)</author>
      <guid>https://docs.cakepanit.com/docs/dev/23designpattern/6.%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</guid>
      <description>需求 link【设计模式专题之适配器模式】6. 扩展坞&#xA;题目描述&#xA;小明购买了一台新电脑，该电脑使用 TypeC 接口，他已经有了一个USB接口的充电器和数据线，为了确保新电脑可以使用现有的USB接口充电器和数据线，他购买了一个TypeC到USB的扩展坞。 请你使用适配器模式设计并实现这个扩展坞系统，确保小明的新电脑既可以通过扩展坞使用现有的USB接口充电线和数据线，也可以使用TypeC接口充电。 输入描述&#xA;题目包含多行输入，第一行输入一个数字 N （1 &amp;lt; N &amp;lt;= 20)，表示后面有N组测试数据。 之后N行都是一个整数，1表示使用电脑本身的TypeC接口，2表示使用扩展坞的USB接口充电。 输入示例 3 1 2 1 输出示例 TypeC USB Adapter TypeC 什么是适配器 link适配器模式Adapter是一种结构型设计模式，它可以将一个类的接口转换成客户希望的另一个接口，主要目的是充当两个不同接口之间的桥梁，使得原本接口不兼容的类能够一起工作。&#xA;基本结构 link适配器模式分为以下几个基本角色：&#xA;可以把适配器模式理解成拓展坞，起到转接的作用，原有的接口是USB，但是客户端需要使用type-c， 便使用拓展坞提供一个type-c接口给客户端使用&#xA;目标接口Target: 客户端希望使用的接口 适配器类Adapter: 实现客户端使用的目标接口，持有一个需要适配的类实例。 被适配者Adaptee: 需要被适配的类 这样，客户端就可以使用目标接口，而不需要对原来的Adaptee进行修改，Adapter起到一个转接扩展的作用。&#xA;基本实现 link // 目标接口 interface Target { void request(); } // 被适配者类 class Adaptee { void specificRequest() { System.out.println(&amp;#34;Specific request&amp;#34;); } } // 适配器类 class Adapter implements Target { // 持有一个被适配者实例 private Adaptee adaptee; public Adapter(Adaptee adaptee) { this.</description>
    </item>
    <item>
      <title>7.代理模式</title>
      <link>https://docs.cakepanit.com/docs/dev/23designpattern/7.%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Wed, 03 May 2023 22:37:22 +0100</pubDate><author>admin@cakepanit.com (饼铛)</author>
      <guid>https://docs.cakepanit.com/docs/dev/23designpattern/7.%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</guid>
      <description>需求 link【设计模式专题之代理模式】7-小明买房子&#xA;题目描述&#xA;小明想要购买一套房子，他决定寻求一家房屋中介来帮助他找到一个面积超过100平方米的房子，只有符合条件的房子才会被传递给小明查看。 输入描述&#xA;第一行是一个整数 N（1 ≤ N ≤ 100），表示可供查看的房子的数量。 接下来的 N 行，每行包含一个整数，表示对应房子的房屋面积。 输出描述&#xA;对于每个房子，输出一行，表示是否符合购房条件。如果房屋面积超过100平方米，输出 &amp;ldquo;YES&amp;rdquo;；否则输出 &amp;ldquo;NO&amp;rdquo;。 输入示例 3 120 80 110 输出示例 YES NO YES 基本概念 link代理模式Proxy Pattern是一种结构型设计模式，用于控制对其他对象的访问。&#xA;在代理模式中，允许一个对象（代理）充当另一个对象（真实对象）的接口，以控制对这个对象的访问。通常用于在访问某个对象时引入一些间接层(中介的作用)，这样可以在访问对象时添加额外的控制逻辑，比如限制访问权限，延迟加载。&#xA;比如说有一个文件加载的场景，为了避免直接访问“文件”对象，我们可以新增一个代理对象，代理对象中有一个对“文件对象”的引用，在代理对象的 load 方法中，可以在访问真实的文件对象之前进行一些操作，比如权限检查，然后调用真实文件对象的 load 方法，最后在访问真实对象后进行其他操作，比如记录访问日志。&#xA;基本结构 link代理模式的主要角色有：&#xA;Subject（抽象主题）： 抽象类，通过接口或抽象类声明真实主题和代理对象实现的业务方法。&#xA;RealSubject（真实主题）：定义了Proxy所代表的真实对象，是客户端最终要访问的对象。&#xA;Proxy（代理）：包含一个引用，该引用可以是RealSubject的实例，控制对RealSubject的访问，并可能负责创建和删除RealSubject的实例。&#xA;实现方式 link代理模式的基本实现分为以下几个步骤：&#xA;定义抽象主题, 一般是接口或者抽象类，声明真实主题和代理对象实现的业务方法。 // 1. 定义抽象主题 interface Subject { void request(); } 定义真实主题，实现抽象主题中的具体业务 // 2. 定义真实主题 class RealSubject implements Subject { @Override public void request() { System.out.println(&amp;#34;RealSubject handles the request.</description>
    </item>
    <item>
      <title>8.装饰模式</title>
      <link>https://docs.cakepanit.com/docs/dev/23designpattern/8.%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Wed, 03 May 2023 22:37:22 +0100</pubDate><author>admin@cakepanit.com (饼铛)</author>
      <guid>https://docs.cakepanit.com/docs/dev/23designpattern/8.%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/</guid>
      <description>需求 link【设计模式专题装饰模式】8-咖啡加糖&#xA;题目描述&#xA;小明喜欢品尝不同口味的咖啡，他发现每种咖啡都可以加入不同的调料，比如牛奶、糖和巧克力。他决定使用装饰者模式制作自己喜欢的咖啡。 请设计一个简单的咖啡制作系统，使用装饰者模式为咖啡添加不同的调料。系统支持两种咖啡类型：黑咖啡（Black Coffee）和拿铁（Latte）。 输入描述&#xA;多行输入，每行包含两个数字。第一个数字表示咖啡的选择（1 表示黑咖啡，2 表示拿铁），第二个数字表示要添加的调料类型（1 表示牛奶，2 表示糖）。 输出描述&#xA;根据每行输入，输出制作咖啡的过程，包括咖啡类型和添加的调料。 输入示例 1 1 2 2 输出示例 Brewing Black Coffee Adding Milk Brewing Latte Adding Sugar 基本概念 link通常情况下，扩展类的功能可以通过继承实现，但是扩展越多，子类越多，装饰模式（Decorator Pattern, 结构型设计模式）可以在**不定义子类的情况下动态的给对象添加一些额外的功能。**具体的做法是将原始对象放入包含行为的特殊封装类(装饰类)，从而为原始对象动态添加新的行为，而无需修改其代码。&#xA;举个简单的例子，假设你有一个基础的图形类，你想要为图形类添加颜色、边框、阴影等功能，如果每个功能都实现一个子类，就会导致产生大量的类，这时就可以考虑使用装饰模式来动态地添加，而不需要修改图形类本身的代码，这样可以使得代码更加灵活、更容易维护和扩展。&#xA;基本结构： link装饰模式包含以下四个主要角色：&#xA;组件Component：通常是抽象类或者接口，是具体组件和装饰者的父类，定义了具体组件需要实现的方法，比如说我们定义Coffee为组件。 具体组件ConcreteComponent: 实现了Component接口的具体类，是被装饰的对象。 装饰类Decorator: 一个抽象类，给具体组件添加功能，但是具体的功能由其子类具体装饰者完成，持有一个指向Component对象的引用。 具体装饰类ConcreteDecorator: 扩展Decorator类，负责向Component对象添加新的行为，加牛奶的咖啡是一个具体装饰类，加糖的咖啡也是一个具体装饰类。 基本实现 link装饰模式的实现包括以下步骤：&#xA;定义Component接口 // 组件接口 public interface Component { void operation(); } 实现 ConcreteComponent // 具体组件 public class ConcreteComponent implements Component { @Override public void operation() { System.</description>
    </item>
    <item>
      <title>9.外观模式</title>
      <link>https://docs.cakepanit.com/docs/dev/23designpattern/9.%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Wed, 03 May 2023 22:37:22 +0100</pubDate><author>admin@cakepanit.com (饼铛)</author>
      <guid>https://docs.cakepanit.com/docs/dev/23designpattern/9.%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/</guid>
      <description>需求 link【设计模式专题之外观模式】9-电源开关&#xA;题目描述&#xA;小明家的电源总开关控制了家里的三个设备：空调、台灯和电视机。每个设备都有独立的开关密码，分别用数字1、2和3表示。即输入1时，空调关闭，输入2时，台灯关闭，输入3时，电视机关闭，当输入为4时，表示要关闭所有设备。请你使用外观模式编写程序来描述电源总开关的操作。 输入描述&#xA;第一行是一个整数 N（1 &amp;lt;= N &amp;lt;= 100），表示后面有 N 行输入。 接下来的 N 行，每行包含一个数字，表示对应设备的开关操作（1表示关闭空调，2表示关闭台灯，3表示关闭电视机，4表示关闭所有设备）。 输出描述&#xA;输出关闭所有设备后的状态，当输入的数字不在1-4范围内时，输出Invalid device code. 输入示例 4 1 2 3 4 输出示例 Air Conditioner is turned off. Desk Lamp is turned off. Television is turned off. All devices are off. 基本概念 link外观模式Facade Pattern, 也被称为“门面模式”，是一种结构型设计模式，外观模式定义了一个高层接口，这个接口使得子系统更容易使用，同时也隐藏了子系统的复杂性。&#xA;门面模式可以将子系统关在“门里”隐藏起来，客户端只需要通过外观接口与外观对象进行交互，而不需要直接和多个子系统交互，无论子系统多么复杂，对于外部来说是隐藏的，这样可以降低系统的耦合度。&#xA;举个例子，假设你正在编写的一个模块用来处理文件读取、解析、存储，我们可以将这个过程拆成三部分，然后创建一个外观类，将文件系统操作、数据解析和存储操作封装在外观类中，为客户端提供一个简化的接口，如果后续需要修改文件处理的流程或替换底层子系统，也只需在外观类中进行调整，不会影响客户端代码。&#xA;基本结构 link外观模式的基本结构比较简单，只包括“外观”和“子系统类”&#xA;外观类：对外提供一个统一的高层次接口，使复杂的子系统变得更易使用。 子系统类：实现子系统的功能，处理外观类指派的任务。 简易实现 link下面使用Java代码实现外观模式的通用结构&#xA;// 子系统A class SubsystemA { public void operationA() { System.out.println(&amp;#34;SubsystemA operation&amp;#34;); } } // 子系统B class SubsystemB { public void operationB() { System.</description>
    </item>
    <item>
      <title>10.桥接模式</title>
      <link>https://docs.cakepanit.com/docs/dev/23designpattern/10.%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Wed, 03 May 2023 22:37:22 +0100</pubDate><author>admin@cakepanit.com (饼铛)</author>
      <guid>https://docs.cakepanit.com/docs/dev/23designpattern/10.%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/</guid>
      <description>需求 link【设计模式专题之桥接模式】10-万能遥控器&#xA;**题目描述&#xA;小明家有一个万能遥控器，能够支持多个品牌的电视。每个电视可以执行开机、关机和切换频道的操作，请你使用桥接模式模拟这个操作。 **输入描述&#xA;第一行是一个整数 N（1 &amp;lt;= N &amp;lt;= 100），表示后面有 N 行输入。 接下来的 N 行，每行包含两个数字。第一个数字表示创建某个品牌的遥控和电视，第二个数字表示执行的操作。 其中，0 表示创建 Sony 品牌的电视，1 表示创建 TCL 品牌的遥控和电视； 2 表示开启电视、3表示关闭电视，4表示切换频道。 输入示例 6 0 2 1 2 0 4 0 3 1 4 1 3 输出示例&#xA;Sony TV is ON TCL TV is ON Switching Sony TV channel Sony TV is OFF Switching TCL TV channel TCL TV is OFF 基本概念 link桥接模式（Bridge Pattern）是一种结构型设计模式，它的UML图很像一座桥，它通过将【抽象部分】与【实现部分】分离，使它们可以独立变化，从而达到降低系统耦合度的目的。桥接模式的主要目的是通过组合建立两个类之间的联系，而不是继承的方式。&#xA;举个简单的例子，图形编辑器中，每一种图形都需要蓝色、红色、黄色不同的颜色，如果不使用桥接模式，可能需要为每一种图形类型和每一种颜色都创建一个具体的子类，而使用桥接模式可以将图形和颜色两个维度分离，两个维度都可以独立进行变化和扩展，如果要新增其他颜色，只需添加新的 Color 子类，不影响图形类；反之亦然。</description>
    </item>
    <item>
      <title>11.组合模式</title>
      <link>https://docs.cakepanit.com/docs/dev/23designpattern/11.%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Wed, 03 May 2023 22:37:22 +0100</pubDate><author>admin@cakepanit.com (饼铛)</author>
      <guid>https://docs.cakepanit.com/docs/dev/23designpattern/11.%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/</guid>
      <description>需求 link【设计模式专题之组合模式】11-公司组织架构&#xA;题目描述&#xA;小明所在的公司内部有多个部门，每个部门下可能有不同的子部门或者员工。 请你设计一个组合模式来管理这些部门和员工，实现对公司组织结构的统一操作。部门和员工都具有一个通用的接口，可以获取他们的名称以及展示公司组织结构。 输入描述&#xA;第一行是一个整数 N（1 &amp;lt;= N &amp;lt;= 100），表示后面有 N 行输入。 接下来的 N 行，每行描述一个部门或员工的信息。部门的信息格式为 D 部门名称，员工的信息格式为 E 员工名称，其中 D 或 E 表示部门或员工。 输出描述&#xA;输出公司的组织结构，展示每个部门下的子部门和员工 输入示例 MyCompany 8 D HR E HRManager D Finance E AccountantA E AccountantB D IT E DeveloperA E DeveloperB 输出示例 Company Structure: MyCompany HR HRManager Finance AccountantA AccountantB IT DeveloperA DeveloperB 基本概念 link组合模式是一种结构型设计模式，它将对象组合成树状结构来表示“部分-整体”的层次关系。组合模式使得客户端可以统一处理单个对象和对象的组合，而无需区分它们的具体类型。&#xA;基本结构 link组合模式包括下面几个角色：&#xA;理解起来比较抽象，我们用“省份-城市”举个例子，省份中包含了多个城市，如果将之比喻成一个树形结构，城市就是叶子节点，它是省份的组成部分，而“省份”就是合成节点，可以包含其他城市，形成一个整体，省份和城市都是组件，它们都有一个共同的操作，比如获取信息。&#xA;Component组件： 组合模式的“根节点”，定义组合中所有对象的通用接口，可以是抽象类或接口。该类中定义了子类的共性内容。 Leaf叶子：实现了Component接口的叶子节点，表示组合中的叶子对象，叶子节点没有子节点。 Composite合成： 作用是存储子部件，并且在Composite中实现了对子部件的相关操作，比如添加、删除、获取子组件等。 通过组合模式，整个省份的获取信息操作可以一次性地执行，而无需关心省份中的具体城市。这样就实现了对国家省份和城市的管理和操作。&#xA;简易实现 link // 组件接口 interface Component { void operation(); } // 叶子节点 class Leaf implements Component { @Override public void operation() { System.</description>
    </item>
    <item>
      <title>12.享元模式</title>
      <link>https://docs.cakepanit.com/docs/dev/23designpattern/12.%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Wed, 03 May 2023 22:37:22 +0100</pubDate><author>admin@cakepanit.com (饼铛)</author>
      <guid>https://docs.cakepanit.com/docs/dev/23designpattern/12.%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/</guid>
      <description>需求 link【设计模式专题之享元模式】12-图形编辑器&#xA;题目描述&#xA;在一个图形编辑器中，用户可以绘制不同类型的图形，包括圆形（CIRCLE）、矩形（RECTANGLE）、三角形（TRIANGLE）等。现在，请你实现一个图形绘制程序，要求能够共享相同类型的图形对象，以减少内存占用。 输入描述 输入包含多行，每行表示一个绘制命令。每个命令包括两部分：&#xA;图形类型（Circle、Rectangle 或 Triangle） 绘制的坐标位置（两个整数，分别表示 x 和 y） 输出描述&#xA;对于每个绘制命令，输出相应图形被绘制的位置信息。如果图形是首次绘制，输出 &amp;ldquo;drawn at&amp;rdquo;，否则输出 &amp;ldquo;shared at&amp;rdquo;。 输入示例 CIRCLE 10 20 RECTANGLE 30 40 CIRCLE 15 25 TRIANGLE 5 15 CIRCLE 10 20 RECTANGLE 30 40 输出示例 CIRCLE drawn at (10, 20) RECTANGLE drawn at (30, 40) CIRCLE shared at (15, 25) TRIANGLE drawn at (5, 15) CIRCLE shared at (10, 20) RECTANGLE shared at (30, 40) 基础概念 link享元模式是一种结构型设计模式，在享元模式中，对象被设计为可共享的，可以被多个上下文使用，而不必在每个上下文中都创建新的对象。</description>
    </item>
    <item>
      <title>13.观察者模式</title>
      <link>https://docs.cakepanit.com/docs/dev/23designpattern/13.%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Wed, 03 May 2023 22:37:22 +0100</pubDate><author>admin@cakepanit.com (饼铛)</author>
      <guid>https://docs.cakepanit.com/docs/dev/23designpattern/13.%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</guid>
      <description>需求 link【设计模式专题之观察者模式】13. 时间观察者&#xA;题目描述&#xA;小明所在的学校有一个时钟（主题），每到整点时，它就会通知所有的学生（观察者）当前的时间，请你使用观察者模式实现这个时钟通知系统。 注意点：时间从 0 开始，并每隔一个小时更新一次。 输入描述&#xA;输入的第一行是一个整数 N（1 ≤ N ≤ 20），表示学生的数量。 接下来的 N 行，每行包含一个字符串，表示学生的姓名。 最后一行是一个整数，表示时钟更新的次数。 输出描述&#xA;对于每一次时钟更新，输出每个学生的姓名和当前的时间。 输入示例 2 Alice Bob 3 输出示例 Alice 1 Bob 1 Alice 2 Bob 2 Alice 3 Bob 3 提示信息&#xA;初始时钟时间为0（12:00 AM）。 第一次更新后，时钟变为1（1:00 AM），然后通知每个学生，输出学生名称和时钟点数。 第二次更新后，时钟变为2（2:00 AM），然后再次通知每个学生，输出学生名称和时钟点数 第三次更新后，时钟变为3（3:00 AM），然后再次通知每个学生，输出学生名称和时钟点数。 什么是观察者模式 link观察者模式（发布-订阅模式）属于行为型模式，定义了一种一对多的依赖关系，让多个观察者对象同时监听一个主题对象，当主题对象的状态发生变化时，所有依赖于它的观察者都得到通知并被自动更新。&#xA;观察者模式依赖两个模块：&#xA;Subject(主题)：也就是被观察的对象，它可以维护一组观察者，当主题本身发生改变时就会通知观察者。 Observer(观察者)：观察主题的对象，当“被观察”的主题发生变化时，观察者就会得到通知并执行相应的处理。 使用观察者模式有很多好处，比如说观察者模式将主题和观察者之间的关系解耦，主题只需要关注自己的状态变化，而观察者只需要关注在主题状态变化时需要执行的操作，两者互不干扰，并且由于观察者和主题是相互独立的，可以轻松的增加和删除观察者，这样实现的系统更容易扩展和维护。&#xA;观察者模式的结构 link观察者模式依赖主题和观察者，但是一般有4个组成部分：&#xA;主题Subject， 一般会定义成一个接口，提供方法用于注册、删除和通知观察者，通常也包含一个状态，当状态发生改变时，通知所有的观察者。 观察者Observer: 观察者也需要实现一个接口，包含一个更新方法，在接收主题通知时执行对应的操作。 具体主题ConcreteSubject: 主题的具体实现, 维护一个观察者列表，包含了观察者的注册、删除和通知方法。 具体观察者ConcreteObserver: 观察者接口的具体实现，每个具体观察者都注册到具体主题中，当主题状态变化并通知到具体观察者，具体观察者进行处理。 观察者模式的基本实现 link根据上面的类图，我们可以写出观察者模式的基本实现&#xA;// 主题接口 （主题） interface Subject { // 注册观察者 void registerObserver(Observer observer); // 移除观察者 void removeObserver(Observer observer); // 通知观察者 void notifyObservers(); } // 观察者接口 (观察者) interface Observer { // 更新方法 void update(String message); } // 具体主题实现 class ConcreteSubject implements Subject { // 观察者列表 private List&amp;lt;Observer&amp;gt; observers = new ArrayList&amp;lt;&amp;gt;(); // 状态 private String state; // 注册观察者 @Override public void registerObserver(Observer observer) { observers.</description>
    </item>
    <item>
      <title>14.策略模式</title>
      <link>https://docs.cakepanit.com/docs/dev/23designpattern/14.%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Wed, 03 May 2023 22:37:22 +0100</pubDate><author>admin@cakepanit.com (饼铛)</author>
      <guid>https://docs.cakepanit.com/docs/dev/23designpattern/14.%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</guid>
      <description>需求 link【设计模式专题之策略模式】14. 超市打折&#xA;题目描述&#xA;小明家的超市推出了不同的购物优惠策略，你可以根据自己的需求选择不同的优惠方式。其中，有两种主要的优惠策略： 九折优惠策略：原价的90%。 满减优惠策略：购物满一定金额时，可以享受相应的减免优惠。 具体的满减规则如下： 满100元减5元 满150元减15元 满200元减25元 满300元减40元 请你设计一个购物优惠系统，用户输入商品的原价和选择的优惠策略编号，系统输出计算后的价格。 输入描述&#xA;输入的第一行是一个整数 N（1 ≤ N ≤ 20），表示需要计算优惠的次数。 接下来的 N 行，每行输入两个整数，第一个整数M( 0 &amp;lt; M &amp;lt; 400) 表示商品的价格, 第二个整数表示优惠策略，1表示九折优惠策略，2表示满减优惠策略 输入示例 4 100 1 200 2 300 1 300 2 输出示例 90 175 270 260 什么是策略模式 link策略模式是一种行为型设计模式，它定义了一系列算法（这些算法完成的是相同的工作，只是实现不同），并将每个算法封装起来，使它们可以相互替换，而且算法的变化不会影响使用算法的客户。&#xA;举个例子，电商网站对于商品的折扣策略有不同的算法，比如新用户满减优惠，不同等级会员的打折情况不同，这种情况下会产生大量的if-else语句, 并且如果优惠政策修改时，还需要修改原来的代码，不符合开闭原则。&#xA;这就可以将不同的优惠算法封装成独立的类来避免大量的条件语句，如果新增优惠算法，可以添加新的策略类来实现，客户端在运行时选择不同的具体策略，而不必修改客户端代码改变优惠策略。&#xA;基本结构 link策略模式包含下面几个结构：&#xA;策略类Strategy: 定义所有支持的算法的公共接口。 具体策略类ConcreteStrategy: 实现了策略接口，提供具体的算法实现。 上下文类Context: 包含一个策略实例，并在需要时调用策略对象的方法。 简单实现 link下面是一个简单的策略模式的基本实现:&#xA;// 1. 抽象策略抽象类 abstract class Strategy { // 抽象方法 public abstract void algorithmInterface(); } // 2.</description>
    </item>
    <item>
      <title>15.命令模式</title>
      <link>https://docs.cakepanit.com/docs/dev/23designpattern/15.%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Wed, 03 May 2023 22:37:22 +0100</pubDate><author>admin@cakepanit.com (饼铛)</author>
      <guid>https://docs.cakepanit.com/docs/dev/23designpattern/15.%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/</guid>
      <description>需求 link【设计模式专题之命令模式】15-自助点餐机&#xA;题目描述&#xA;小明去奶茶店买奶茶，他可以通过在自助点餐机上来点不同的饮品，请你使用命令模式设计一个程序，模拟这个自助点餐系统的功能。 输入描述&#xA;第一行是一个整数 n（1 ≤ n ≤ 100），表示点单的数量。 接下来的 n 行，每行包含一个字符串，表示点餐的饮品名称。 输出描述&#xA;输出执行完所有点单后的制作情况，每行输出一种饮品的制作情况。如果制作完成，输出 &amp;ldquo;XXX is ready!&amp;quot;，其中 XXX 表示饮品名称。 输入示例 4 MilkTea Coffee Cola MilkTea 输出示例 MilkTea is ready! Coffee is ready! Cola is ready! MilkTea is ready! 基本概念 link命令模式是一种行为型设计模式，其允许将请求封装成一个对象(命令对象，包含执行操作所需的所有信息)，并将命令对象按照一定的顺序存储在队列中，然后再逐一调用执行，这些命令也可以支持反向操作，进行撤销和重做。&#xA;这样一来，发送者只需要触发命令就可以完成操作，不需要知道接受者的具体操作，从而实现两者间的解耦。&#xA;举个现实中的应用场景，遥控器可以控制不同的设备，在命令模式中，可以假定每个按钮都是一个命令对象，包含执行特定操作的命令，不同设备对同一命令的具体操作也不同，这样就可以方便的添加设备和命令对象。&#xA;基本结构 link命令模式包含以下几个基本角色：&#xA;命令接口Command：接口或者抽象类，定义执行操作的接口。 具体命令类ConcreteCommand: 实现命令接口，执行具体操作，在调用execute方法时使“接收者对象”根据命令完成具体的任务，比如遥控器中的“开机”，“关机”命令。 接收者类Receiver: 接受并执行命令的对象，可以是任何对象，遥控器可以控制空调，也可以控制电视机，电视机和空调负责执行具体操作，是接收者。 调用者类Invoker: 发起请求的对象，有一个将命令作为参数传递的方法。它不关心命令的具体实现，只负责调用命令对象的 execute() 方法来传递请求，在本例中，控制遥控器的“人”就是调用者。 客户端：创建具体的命令对象和接收者对象，然后将它们组装起来。 简易实现 link 定义执行操作的接口：包含一个execute方法。有的时候还会包括unExecute方法，表示撤销命令。 public interface Command { void execute(); } 实现命令接口，执行具体的操作。 public class ConcreteCommand implements Command { // 接收者对象 private Receiver receiver; public ConcreteCommand(Receiver receiver) { this.</description>
    </item>
    <item>
      <title>16.中介者模式</title>
      <link>https://docs.cakepanit.com/docs/dev/23designpattern/16.%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Wed, 03 May 2023 22:37:22 +0100</pubDate><author>admin@cakepanit.com (饼铛)</author>
      <guid>https://docs.cakepanit.com/docs/dev/23designpattern/16.%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/</guid>
      <description>需求 link【设计模式专题之中介者模式】16-简易聊天室&#xA;题目描述&#xA;小明正在设计一个简单的多人聊天室系统，有多个用户和一个聊天室中介者，用户通过中介者进行聊天，请你帮他完成这个系统的设计。 输入描述&#xA;第一行包括一个整数N,表示用户的数量（1 &amp;lt;= N &amp;lt;= 100) 第二行是N个用户，比如User1 User2 User3，用空格分隔。第三行开始，每行包含两个字符串，表示消息的发出者和消息内容，用空格分隔 输出描述 对于每个用户，输出一行，包含该用户收到的所有消息内容。&#xA;输入示例 3 User1 User2 User3 User1 Hello_All! User2 Hi_User1! User3 How_is_everyone? 输出示例 User2 received: Hello_All! User3 received: Hello_All! User1 received: Hi_User1! User3 received: Hi_User1! User1 received: How_is_everyone? User2 received: How_is_everyone? 基本概念 link中介者模式（Mediator Pattern）也被称为调停者模式，是一种行为型设计模式，它通过一个中介对象来封装一组对象之间的交互，从而使这些对象不需要直接相互引用。这样可以降低对象之间的耦合度，使系统更容易维护和扩展。&#xA;当一个系统中的对象有很多且多个对象之间有复杂的相互依赖关系时，其结构图可能是下面这样的。&#xA;这种依赖关系很难理清，这时我们可以引入一个中介者对象来进行协调和交互。中介者模式可以使得系统的网状结构变成以中介者为中心的星形结构，每个具体对象不再通过直接的联系与另一个对象发生相互作用，而是通过“中介者”对象与另一个对象发生相互作用。&#xA;基本结构 link中介者模式包括以下几个重要角色：&#xA;抽象中介者（Mediator）： 定义中介者的接口，用于各个具体同事对象之间的通信。&#xA;具体中介者（Concrete Mediator）： 实现抽象中介者接口，负责协调各个具体同事对象的交互关系，它需要知道所有具体同事类，并从具体同事接收消息，向具体同事对象发出命令。&#xA;抽象同事类（Colleague）： 定义同事类的接口，维护一个对中介者对象的引用，用于通信。&#xA;具体同事类（Concrete Colleague）： 实现抽象同事类接口，每个具体同事类只知道自己的行为，而不了解其他同事类的情况，因为它们都需要与中介者通信，通过中介者协调与其他同事对象的交互。&#xA;简易实现 link // 抽象中介者 public abstract class Mediator { void register(Colleague colleague); // 定义一个抽象的发送消息方法 public abstract void send(String message, Player player); } // 具体中介者 public class ConcreteMediator extends Mediator { private List&amp;lt;Colleague&amp;gt; colleagues = new ArrayList&amp;lt;&amp;gt;(); public void register((Colleague colleague) { colleagues.</description>
    </item>
    <item>
      <title>17.备忘录模式</title>
      <link>https://docs.cakepanit.com/docs/dev/23designpattern/17.%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Wed, 03 May 2023 22:37:22 +0100</pubDate><author>admin@cakepanit.com (饼铛)</author>
      <guid>https://docs.cakepanit.com/docs/dev/23designpattern/17.%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F/</guid>
      <description>需求 link【设计模式专题之备忘录模式】17-redo计数器应用&#xA;题目描述 小明正在设计一个简单的计数器应用，支持增加（Increment）和减少（Decrement）操作，以及撤销（Undo）和重做（Redo）操作，请你使用备忘录模式帮他实现。&#xA;输入描述&#xA;输入包含若干行，每行包含一个字符串，表示计数器应用的操作，操作包括 &amp;ldquo;Increment&amp;rdquo;、&amp;ldquo;Decrement&amp;rdquo;、&amp;ldquo;Undo&amp;rdquo; 和 &amp;ldquo;Redo&amp;rdquo;。 输出描述&#xA;对于每个 &amp;ldquo;Increment&amp;rdquo; 和 &amp;ldquo;Decrement&amp;rdquo; 操作，输出当前计数器的值，计数器数值从0开始 对于每个 &amp;ldquo;Undo&amp;rdquo; 操作，输出撤销后的计数器值。 对于每个 &amp;ldquo;Redo&amp;rdquo; 操作，输出重做后的计数器值。 输入示例 Increment Increment Decrement Undo Redo Increment 输出示例 1 2 1 2 1 2 基本概念 link备忘录模式（Memento Pattern）是一种行为型设计模式，它允许在不暴露对象实现的情况下捕获对象的内部状态并在对象之外保存这个状态，以便稍后可以将其还原到先前的状态。&#xA;基本结构 link备忘录模式包括以下几个重要角色：&#xA;发起人Originator： 需要还原状态的那个对象，负责创建一个【备忘录】，并使用备忘录记录当前时刻的内部状态。&#xA;备忘录Memento: 存储发起人对象的内部状态，它可以包含发起人的部分或全部状态信息，但是对外部是不可见的，只有发起人能够访问备忘录对象的状态。&#xA;备忘录有两个接口，发起人能够通过宽接口访问数据，管理者只能看到窄接口，并将备忘录传递给其他对象。&#xA;管理者Caretaker: 负责存储备忘录对象，但并不了解其内部结构，管理者可以存储多个备忘录对象。&#xA;客户端：在需要恢复状态时，客户端可以从管理者那里获取备忘录对象，并将其传递给发起人进行状态的恢复。&#xA;基本实现 link 创建发起人类：可以创建备忘录对象 class Originator { private String state; public void setState(String state) { this.state = state; } public String getState() { return state; } // 创建备忘录对象 public Memento createMemento() { return new Memento(state); } // 通过备忘录对象恢复状态 public void restoreFromMemento(Memento memento) { state = memento.</description>
    </item>
    <item>
      <title>18.模板方法模式</title>
      <link>https://docs.cakepanit.com/docs/dev/23designpattern/18.%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Wed, 03 May 2023 22:37:22 +0100</pubDate><author>admin@cakepanit.com (饼铛)</author>
      <guid>https://docs.cakepanit.com/docs/dev/23designpattern/18.%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</guid>
      <description>需求 link【设计模式专题之模板方法模式】18-咖啡馆&#xA;题目描述&#xA;小明喜欢品尝不同类型的咖啡，她发现每种咖啡的制作过程有一些相同的步骤，他决定设计一个简单的咖啡制作系统，使用模板方法模式定义咖啡的制作过程。系统支持两种咖啡类型：美式咖啡（American Coffee）和拿铁（Latte）。&#xA;咖啡制作过程包括以下步骤：&#xA;研磨咖啡豆 Grinding coffee beans 冲泡咖啡 Brewing coffee 添加调料 Adding condiments 其中，美式咖啡和拿铁的调料添加方式略有不同, 拿铁在添加调料时需要添加牛奶Adding milk&#xA;输入描述&#xA;多行输入，每行包含一个数字，表示咖啡的选择（1 表示美式咖啡，2 表示拿铁）。 输出描述&#xA;根据每行输入，输出制作咖啡的过程，包括咖啡类型和各个制作步骤，末尾有一个空行。 输入示例 1 2 输出示例&#xA;Making American Coffee: Grinding coffee beans Brewing coffee Adding condiments Making Latte: Grinding coffee beans Brewing coffee Adding milk Adding condiments 基本概念 link模板方法模式（Template Method Pattern）是一种行为型设计模式, 它定义了一个算法的骨架，将**一些步骤的实现延迟到子类。**模板方法模式使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤。【引用自大话设计第10章】&#xA;举个简单的例子，做一道菜通常都需要包含至少三步：&#xA;准备食材 亨饪过程 上菜 不同菜品的亨饪过程是不一样的，但是我们可以先定义一个”骨架”，包含这三个步骤，亨饪过程的过程放到具体的炒菜类中去实现，这样，无论炒什么菜，都可以沿用相同的炒菜算法，只需在子类中实现具体的炒菜步骤，从而提高了代码的复用性。&#xA;基本结构 link模板方法模式的基本结构包含以下两个角色：&#xA;模板类AbstractClass：由一个模板方法和若干个基本方法构成，模板方法定义了逻辑的骨架，按照顺序调用包含的基本方法，基本方法通常是一些抽象方法，这些方法由子类去实现。基本方法还包含一些具体方法，它们是算法的一部分但已经有默认实现，在具体子类中可以继承或者重写。 具体类ConcreteClass：继承自模板类，实现了在模板类中定义的抽象方法，以完成算法中特定步骤的具体实现。 简易实现 link模板方法模式的简单示例如下：&#xA;定义模板类，包含模板方法，定义了算法的骨架, 一般都加上final关键字，避免子类重写。 // 模板类 abstract class AbstractClass { // 模板方法，定义了算法的骨架 public final void templateMethod() { step1(); step2(); step3(); } // 抽象方法，由子类实现 protected abstract void step1(); protected abstract void step2(); protected abstract void step3(); } 定义具体类, 实现模板类中的抽象方法 // 具体类 class ConcreteClass extends AbstractClass { @Override protected void step1() { System.</description>
    </item>
    <item>
      <title>19.迭代器模式</title>
      <link>https://docs.cakepanit.com/docs/dev/23designpattern/19.%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Wed, 03 May 2023 22:37:22 +0100</pubDate><author>admin@cakepanit.com (饼铛)</author>
      <guid>https://docs.cakepanit.com/docs/dev/23designpattern/19.%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/</guid>
      <description>需求 link【设计模式专题之迭代器模式】19-学生名单&#xA;题目描述&#xA;小明是一位老师，在进行班级点名时，希望有一个学生名单系统，请你实现迭代器模式提供一个迭代器使得可以按顺序遍历学生列表。 输入描述&#xA;第一行是一个整数 N （1 &amp;lt;= N &amp;lt;= 100), 表示学生的数量。 接下来的 N 行，每行包含一个学生的信息，格式为 姓名 学号 输出描述&#xA;输出班级点名的结果，即按顺序遍历学生列表，输出学生的姓名和学号 输入示例 3 Alice 1001 Bob 1002 Charlie 1003 输出示例 Alice 1001 Bob 1002 Charlie 1003 基本概念 link迭代器模式是一种行为设计模式，是一种使用频率非常高的设计模式，在各个语言中都有应用，其主要目的是**提供一种统一的方式来访问一个聚合对象中的各个元素，**而不需要暴露该对象的内部表示。通过迭代器，客户端可以顺序访问聚合对象的元素，而无需了解底层数据结构。&#xA;迭代器模式应用广泛，但是大多数语言都已经内置了迭代器接口，不需要自己实现。&#xA;基本结构 link迭代器模式包括以下几个重要角色&#xA;迭代器接口Iterator：定义访问和遍历元素的接口, 通常会包括hasNext()方法用于检查是否还有下一个元素，以及next()方法用于获取下一个元素。有的还会实现获取第一个元素以及获取当前元素的方法。 具体迭代器ConcreateIterator：实现迭代器接口，实现遍历逻辑对聚合对象进行遍历。 抽象聚合类：定义了创建迭代器的接口，包括一个createIterator方法用于创建一个迭代器对象。 具体聚合类：实现在抽象聚合类中声明的createIterator() 方法，返回一个与具体聚合对应的具体迭代器 简易实现 link 定义迭代器接口：通常会有检查是否还有下一个元素以及获取下一个元素的方法。 // 迭代器接口 public interface Iterator{ // 检查是否还会有下一个元素 boolean hasNext(); // 获取下一个元素 Object next(); } 定义具体迭代器：实现迭代器接口，遍历集合。 public class ConcreteIterator implements Iterator { private int index; private List&amp;lt;Object&amp;gt; elements; // 构造函数初始化迭代器 public ConcreteIterator(List&amp;lt;Object&amp;gt; elements) { this.</description>
    </item>
    <item>
      <title>20.状态模式</title>
      <link>https://docs.cakepanit.com/docs/dev/23designpattern/20.%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Wed, 03 May 2023 22:37:22 +0100</pubDate><author>admin@cakepanit.com (饼铛)</author>
      <guid>https://docs.cakepanit.com/docs/dev/23designpattern/20.%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/</guid>
      <description>需求 link【设计模式专题之状态模式】20-开关台灯&#xA;题目描述&#xA;小明家有一个灯泡，刚开始为关闭状态（OffState）。台灯可以接收一系列的指令，包括打开（&amp;ldquo;ON&amp;rdquo;）、关闭（&amp;ldquo;OFF&amp;rdquo;）和闪烁（&amp;ldquo;blink&amp;rdquo;）。每次接收到一个指令后，台灯会执行相应的操作，并输出当前灯泡的状态。请设计一个程序模拟这个灯泡系统。 输入描述&#xA;第一行是一个整数 n（1 &amp;lt;= n &amp;lt;= 1000），表示接收的命令数量。 接下来的 n 行，每行包含一个字符串 s，表示一个命令（&amp;ldquo;ON&amp;rdquo;、&amp;ldquo;OFF&amp;quot;或&amp;quot;blink&amp;rdquo;）。 输出描述&#xA;对于每个命令，输出一行，表示执行该命令后灯泡的状态。 输入示例 5 ON OFF BLINK OFF ON 输出示例 Light is ON Light is OFF Light is Blinking Light is OFF Light is ON 基本结构 link状态模式（State Pattern）是一种行为型设计模式，它适用于一个对象在在不同的状态下有不同的行为时，比如说电灯的开、关、闪烁是不停的状态，状态不同时，对应的行为也不同，在没有状态模式的情况下，为了添加新的状态或修改现有的状态，往往需要修改已有的代码，这违背了开闭原则，而且如果对象的状态切换逻辑和各个状态的行为都在同一个类中实现，就可能导致该类的职责过重，不符合单一职责原则。&#xA;而状态模式将每个状态的行为封装在一个具体状态类中，使得每个状态类相对独立，并将对象在不同状态下的行为进行委托，从而使得对象的状态可以在运行时动态改变，每个状态的实现也不会影响其他状态。&#xA;基本结构： link状态模式包括以下几个重要角色：&#xA;State（状态）： 定义一个接口，用于封装与Context的一个特定状态相关的行为。&#xA;ConcreteState（具体状态）： 负责处理Context在状态改变时的行为, 每一个具体状态子类实现一个与Context的一个状态相关的行为。&#xA;Context（上下文）: 维护一个具体状态子类的实例，这个实例定义当前的状态。&#xA;基本使用 link 定义状态接口：创建一个状态接口，该接口声明了对象可能的各种状态对应的方法。 // 状态接口 public interface State { void handle(); } 实现具体状态类： 为对象可能的每种状态创建具体的状态类，实现状态接口中定义的方法。 // 具体状态类1 public class ConcreteState1 implements State { @Override public void handle() { // 执行在状态1下的操作 } } // 具体状态类2 public class ConcreteState2 implements State { @Override public void handle() { // 执行在状态2下的操作 } } 创建上下文类：该类包含对状态的引用，并在需要时调用当前状态的方法。 // 上下文类 public class Context { private State currentState; public void setState(State state) { this.</description>
    </item>
    <item>
      <title>21.责任链模式</title>
      <link>https://docs.cakepanit.com/docs/dev/23designpattern/21.%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Wed, 03 May 2023 22:37:22 +0100</pubDate><author>admin@cakepanit.com (饼铛)</author>
      <guid>https://docs.cakepanit.com/docs/dev/23designpattern/21.%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/</guid>
      <description>需求 link【设计模式专题之责任链模式】21-请假审批&#xA;题目描述&#xA;小明所在的公司请假需要在OA系统上发布申请，整个请求流程包括多个处理者，每个处理者负责处理不同范围的请假天数，如果一个处理者不能处理请求，就会将请求传递给下一个处理者，请你实现责任链模式，可以根据请求天数找到对应的处理者。 审批责任链由主管(Supervisor), 经理(Manager)和董事（Director)组成，他们分别能够处理3天、7天和10天的请假天数。如果超过10天，则进行否决。 输入描述&#xA;第一行是一个整数N（1 &amp;lt;= N &amp;lt;= 100), 表示请求申请的数量。 接下来的N行，每行包括一个请求申请的信息，格式为&amp;quot;姓名 请假天数&amp;quot; 输出描述&#xA;对于每个请假请求，输出一行，表示该请求是否被批准。如果被批准/否决，输出被哪一个职级的人批准/否决。 输入示例 4 Alice 2 Bob 5 Tom 10 Jerry 12 输出示例 Alice Approved by Supervisor. Bob Approved by Manager. Tom Approved by Director. Jerry Denied by Director. 基本概念 link责任链模式是一种行为型设计模式，它允许你构建一个对象链，让请求从链的一端进入，然后沿着链上的对象依次处理，直到链上的某个对象能够处理该请求为止。&#xA;职责链上的处理者就是一个对象，可以对请求进行处理或者将请求转发给下一个节点，这个场景在生活中很常见，就是一个逐层向上递交的过程，最终的请求要么被处理者所处理，要么处理不了，这也因此可能导致请求无法被处理。&#xA;组成结构 link责任链模式包括以下几个基本结构：&#xA;处理者Handler ：定义一个处理请求的接口，包含一个处理请求的抽象方法和一个指向下一个处理者的链接。 具体处理者ConcreteHandler: 实现处理请求的方法，并判断能否处理请求，如果能够处理请求则进行处理，否则将请求传递给下一个处理者。 客户端：创建并组装处理者对象链，并将请求发送到链上的第一个处理者。 简易实现 link 处理者：定义处理请求的接口 interface Handler { // 处理请求的方法 void handleRequest(double amount); // 设置下一个处理者的方法 void setNextHandler(Handler nextHandler); } 具体处理者：实现处理请求 class ConcreteHandler implements Handler { private Handler nextHandler; @Override public void handleRequest(Request request) { // 根据具体情况处理请求，如果无法处理则交给下一个处理者 if (canHandle(request)) { // 处理请求的逻辑 } else if (nextHandler !</description>
    </item>
    <item>
      <title>22.解释器模式</title>
      <link>https://docs.cakepanit.com/docs/dev/23designpattern/22.%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Wed, 03 May 2023 22:37:22 +0100</pubDate><author>admin@cakepanit.com (饼铛)</author>
      <guid>https://docs.cakepanit.com/docs/dev/23designpattern/22.%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F/</guid>
      <description>需求 link【设计模式专题之解释器模式】22-数学表达式&#xA;题目描述&#xA;小明正在设计一个计算器，用于解释用户输入的简单数学表达式，每个表达式都是由整数、加法操作符+、乘法操作符组成的，表达式中的元素之间用空格分隔，请你使用解释器模式帮他实现这个系统。 输入描述&#xA;每行包含一个数学表达式，表达式中包含整数、加法操作符（+）和乘法操作符（*）。 表达式中的元素之间用空格分隔。 输出描述&#xA;对于每个输入的数学表达式，每行输出一个整数，表示对应表达式的计算结果。 输入示例 2 &amp;#43; 3 5 * 2 3 &amp;#43; 4 * 2 输出示例 5 10 11 基本概念 link解释器模式（Interpreter Pattern）是一种行为型设计模式，它定义了一个语言的文法，并且建立一个【解释器】来解释该语言中的句子。&#xA;比如说SQL语法、正则表达式，这些内容比较简短，但是表达的内容可不仅仅是字面上的那些符号，计算机想要理解这些语法，就需要解释这个语法规则，因此解释器模式常用于实现编程语言解释器、正则表达式处理等场景。&#xA;组成结构 link解释器模式主要包含以下几个角色：&#xA;抽象表达式（Abstract Expression）： 定义了解释器的接口，包含了解释器的方法 interpret。 终结符表达式（Terminal Expression）： 在语法中不能再分解为更小单元的符号。 非终结符表达式（Non-terminal Expression）： 文法中的复杂表达式，它由终结符和其他非终结符组成。 上下文（Context）： 包含解释器之外的一些全局信息，可以存储解释器中间结果，也可以用于向解释器传递信息。 举例来说，表达式 &amp;ldquo;3 + 5 * 2&amp;rdquo;，数字 &amp;ldquo;3&amp;rdquo; 和 &amp;ldquo;5&amp;rdquo;， &amp;ldquo;2&amp;rdquo; 是终结符，而运算符 &amp;ldquo;+&amp;rdquo;, &amp;ldquo;*&amp;ldquo;都需要两个操作数, 属于非终结符。&#xA;简易实现 link 创建抽象表达式接口： 定义解释器的接口，声明一个 interpret 方法，用于解释语言中的表达式。 // 抽象表达式接口 public interface Expression { int interpret(); } 创建具体的表达式类： 实现抽象表达式接口，用于表示语言中的具体表达式。 public class TerminalExpression implements Expression { private int value; public TerminalExpression(int value) { this.</description>
    </item>
    <item>
      <title>23.访问者模式</title>
      <link>https://docs.cakepanit.com/docs/dev/23designpattern/23.%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Wed, 03 May 2023 22:37:22 +0100</pubDate><author>admin@cakepanit.com (饼铛)</author>
      <guid>https://docs.cakepanit.com/docs/dev/23designpattern/23.%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F/</guid>
      <description>需求 link【设计模式专题之访问者模式】23-图形的面积&#xA;题目描述&#xA;小明家有一些圆形和长方形面积的土地，请你帮他实现一个访问者模式，使得可以通过访问者计算每块土地的面积。 图形的面积计算规则如下： 圆形的面积计算公式为：3.14 * 半径 * 半径 矩形的面积计算公式为：长 * 宽 输入描述&#xA;第一行是一个整数 n（1 &amp;lt;= n &amp;lt;= 1000），表示图形的数量。 接下来的 n 行，每行描述一个图形，格式为 &amp;ldquo;Circle r&amp;rdquo; 或 &amp;ldquo;Rectangle width height&amp;rdquo;，其中 r、width、height 是正整数。 输出描述&#xA;对于每个图形，输出一行，表示该图形的面积。 输入示例 3 Circle 5 Rectangle 3 4 Circle 2 输出示例 78.5 12 12.56 基本概念 link访问者模式（Visitor Pattern）是一种行为型设计模式，可以在不改变对象结构的前提下，对对象中的元素进行新的操作。&#xA;举个例子，假设有一个动物园，里面有不同种类的动物，比如狮子、大象、猴子等。每个动物都会被医生检查身体，被管理员投喂，被游客观看，医生，游客，管理员都属于访问者。&#xA;// 定义动物接口 interface Animal { void accept(Visitor visitor); } // 具体元素类：狮子 class Lion implements Element { @Override public void accept(Visitor visitor) { visitor.</description>
    </item>
    <item>
      <title>1.为什么要学习Fyne？</title>
      <link>https://docs.cakepanit.com/docs/dev/golang/fyne/1.%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%AD%A6%E4%B9%A0fyne/</link>
      <pubDate>Wed, 03 May 2023 22:37:22 +0100</pubDate><author>admin@cakepanit.com (饼铛)</author>
      <guid>https://docs.cakepanit.com/docs/dev/golang/fyne/1.%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%AD%A6%E4%B9%A0fyne/</guid>
      <description>GUI Application 的定义 linkGUI(Graphical User Interface/图形用户界面)程序是指使用图形界面与用户进行交互的软件应用程序。图形界面通常包括窗口、图标、按钮、文本框、菜单等可视化元素, 使用户可以通过直观的操作(如点击、拖动, 输入内容)与程序进行交互, 而不需要通过如命令行进行操作。&#xA;例子: 好比 VS Code 就是。&#xA;使用 Fyne 开发 GUI(图形用户界面)程序有许多优势, 我们简单地和 Electron 比较一下。&#xA;1. 轻量 link Fyne：Fyne 是一个轻量级的 GUI 框架, 应用程序的体积相对较小, 占用的系统资源也较少。 Electron：Electron 打包了整个 Chromium 和 Node.js, 导致应用程序的体积较大, 并且在运行时占用不少内存。 2. 性能 link Fyne：Fyne 应用是用 Go 语言编写的, Go 语言本身以其高效和快速的性能而闻名。Fyne 应用在启动和运行时的性能通常优于 Electron 应用。 Electron：由于 Electron 依赖于 Chromium 和 Node.js, 其性能受限于这些底层技术的性能。Electron 应用启动较慢, 运行时占用较多的内存和 CPU 资源。 3. 资源消耗 link Fyne：Fyne 应用程序消耗的系统资源较少, 特别是在内存和 CPU 使用方面。这使得 Fyne 应用在低配置的系统上也能顺畅运行。 Electron：Electron 应用通常消耗更多的内存和 CPU 资源, 特别是在打开多个窗口或运行复杂的应用时, 这在低配置系统上可能会导致性能问题。 4.</description>
    </item>
    <item>
      <title>2.第一个小项目</title>
      <link>https://docs.cakepanit.com/docs/dev/golang/fyne/2.%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%B0%8F%E9%A1%B9%E7%9B%AE/</link>
      <pubDate>Wed, 03 May 2023 22:37:22 +0100</pubDate><author>admin@cakepanit.com (饼铛)</author>
      <guid>https://docs.cakepanit.com/docs/dev/golang/fyne/2.%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%B0%8F%E9%A1%B9%E7%9B%AE/</guid>
      <description>基本命令&#xA;go mod init fyneTest01 fyneTest01可以随便写。&#xA;go get fyne.io/fyne/v2 GOPATH 介绍说明&#xA;$GOPATH 是一个环境变量，它指定了你的 Go 工作空间的位置。工作空间中往往包含编译后的包文件和可执行文件。&#xA;如何找到它?&#xA;go env GOPATH 即可。&#xA;成品代码&#xA;package main import ( &amp;#34;fmt&amp;#34; &amp;#34;fyne.io/fyne/v2/app&amp;#34; &amp;#34;fyne.io/fyne/v2/widget&amp;#34; ) func main() { a:= app.New() w:= a.NewWindow(&amp;#34;Gofer gogogo&amp;#34;) w.SetContent(widget.NewLabel(&amp;#34;Gofer gogogo&amp;#34;)) w.ShowAndRun() fmt.Println(&amp;#34;close!&amp;#34;) } Go 要点: go mod tidy linkgo mod tidy 命令会清理 go.mod 文件，移除不再需要的依赖，并确保所有实际使用的依赖都在文件中声明。同时，它还会更新 go.sum 文件，确保其中的记录是最新的和完整的。&#xA;go mod tidy 运行程序&#xA;go run . 即可&#xA;Go 要点: go run . link参考文档 https://shellytw.medium.com/golang-learning-journey-from-an-ex-javascript-developer-1-go-run-and-packages-d107fdff147</description>
    </item>
    <item>
      <title>3.处理多窗口问题</title>
      <link>https://docs.cakepanit.com/docs/dev/golang/fyne/3.%E5%A4%84%E7%90%86%E5%A4%9A%E7%AA%97%E5%8F%A3/</link>
      <pubDate>Wed, 03 May 2023 22:37:22 +0100</pubDate><author>admin@cakepanit.com (饼铛)</author>
      <guid>https://docs.cakepanit.com/docs/dev/golang/fyne/3.%E5%A4%84%E7%90%86%E5%A4%9A%E7%AA%97%E5%8F%A3/</guid>
      <description>代码案例 link package main import ( &amp;#34;fyne.io/fyne/v2/app&amp;#34; &amp;#34;fyne.io/fyne/v2/container&amp;#34; &amp;#34;fyne.io/fyne/v2/widget&amp;#34; ) func main() { a := app.New() w1 := a.NewWindow(&amp;#34;Window 1&amp;#34;) w1.SetContent(container.NewVBox( widget.NewLabel(&amp;#34;Test01&amp;#34;), )) w2 := a.NewWindow(&amp;#34;Window 2&amp;#34;) w2.SetContent(container.NewVBox( widget.NewLabel(&amp;#34;Test02&amp;#34;), )) w1.Show() w2.Show() a.Run() } </description>
    </item>
    <item>
      <title>4.Go基础速通</title>
      <link>https://docs.cakepanit.com/docs/dev/golang/fyne/4.go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%BF%AB%E9%80%9F%E9%80%9A%E5%85%B3/</link>
      <pubDate>Wed, 03 May 2023 22:37:22 +0100</pubDate><author>admin@cakepanit.com (饼铛)</author>
      <guid>https://docs.cakepanit.com/docs/dev/golang/fyne/4.go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%BF%AB%E9%80%9F%E9%80%9A%E5%85%B3/</guid>
      <description>代码案例 01 link type Person struct{ Name string Age int Email string } func main() { p := Person{ Name: &amp;#34;Inkka&amp;#34;, Age: 17, Email: &amp;#34;inkkaplumbilibili@example.com&amp;#34;, } // 访问结构体字段 fmt.Println(&amp;#34;Name:&amp;#34;, p.Name) fmt.Println(&amp;#34;Age:&amp;#34;, p.Age) fmt.Println(&amp;#34;Email:&amp;#34;, p.Email) // 修改结构体字段 p.Age = 18 fmt.Println(&amp;#34;Updated Age:&amp;#34;, p.Age) } 代码案例 02 link package main import &amp;#34;fmt&amp;#34; func main() { // 初始化一个整数变量 i i := 114514 // 将 i 的值赋给 j j := i // 修改 j 的值 j = 1919810 // 打印 i 和 j 的值 fmt.</description>
    </item>
    <item>
      <title>5.更复杂的项目</title>
      <link>https://docs.cakepanit.com/docs/dev/golang/fyne/5.%E6%9B%B4%E5%A4%8D%E6%9D%82%E7%9A%84%E9%A1%B9%E7%9B%AE/</link>
      <pubDate>Wed, 03 May 2023 22:37:22 +0100</pubDate><author>admin@cakepanit.com (饼铛)</author>
      <guid>https://docs.cakepanit.com/docs/dev/golang/fyne/5.%E6%9B%B4%E5%A4%8D%E6%9D%82%E7%9A%84%E9%A1%B9%E7%9B%AE/</guid>
      <description>要求和最终效果 link参考任意一篇 Fyne 官方文档, 可以看到写法:&#xA;func makeUI() (*widget.Label, *widget.Entry) { return widget.NewLabel(&amp;#34;Hello world!&amp;#34;), widget.NewEntry() } func main() { a := app.New() w := a.NewWindow(&amp;#34;Hello Person&amp;#34;) w.SetContent(container.NewVBox(makeUI())) w.ShowAndRun() } 所以, 我们也会写makeUI()。&#xA;优势 link 逻辑清晰 便于测试 读法的小提示 link*... 可以读成Pointer to ...。&#xA;成品代码 link package main import ( &amp;#34;fmt&amp;#34; &amp;#34;fyne.io/fyne/v2&amp;#34; &amp;#34;fyne.io/fyne/v2/app&amp;#34; &amp;#34;fyne.io/fyne/v2/container&amp;#34; &amp;#34;fyne.io/fyne/v2/widget&amp;#34; ) type App struct{ output *widget.Label } var myApp App func (app *App) makeUI()(*widget.Label, *widget.Entry, *widget.Button, *widget.Label, *widget.Button ){ output := widget.</description>
    </item>
    <item>
      <title>Fyne-Markdown编辑器</title>
      <link>https://docs.cakepanit.com/docs/dev/golang/fyne/project/1.markdown%E7%BC%96%E8%BE%91%E5%99%A8/</link>
      <pubDate>Wed, 03 May 2023 22:37:22 +0100</pubDate><author>admin@cakepanit.com (饼铛)</author>
      <guid>https://docs.cakepanit.com/docs/dev/golang/fyne/project/1.markdown%E7%BC%96%E8%BE%91%E5%99%A8/</guid>
      <description>Markdown 编辑器&#xA;此项目的要求和最终效果 link能够支持中文, 程序窗口左半边写 markdown, 右边则显示富文本, 也就是现在我们 Vs code 里面的 Preview(プレビュー)&#xA;解决语言问题 linkFyne 默认字体不支持中文, 我们可以复制一下下面的测试文本, 基于我们第一个案例, 会发现是乱码。&#xA;package main import ( &amp;#34;fmt&amp;#34; &amp;#34;fyne.io/fyne/v2/app&amp;#34; &amp;#34;fyne.io/fyne/v2/widget&amp;#34; ) func main() { a:= app.New() w:= a.NewWindow(&amp;#34;让我们一起来学习Go语言吧!&amp;#34;) w.SetContent(widget.NewLabel(&amp;#34;让我们一起来学习Go语言吧!&amp;#34;)) w.ShowAndRun() fmt.Println(&amp;#34;close!&amp;#34;) } 在项目文件夹中(必要文件), 找到字体文件(NotoSansHans-Regular.ttf)或者亦可以用你喜好的字体。将项目文件夹中的theme.go和util.go复制到项目目录下。&#xA;然后, 在项目中添加如下代码:&#xA;customFont := fyne.NewStaticResource(&amp;#34;NotoSansHans.ttf&amp;#34;, loadFont(&amp;#34;NotoSansHans-Regular.ttf&amp;#34;)) a.Settings().SetTheme(&amp;amp;myTheme{font: customFont}) 只需要改loadFont内的内容即可。&#xA;实战 Struct 和 Receiver link package main import ( &amp;#34;fyne.io/fyne/v2&amp;#34; &amp;#34;fyne.io/fyne/v2/app&amp;#34; &amp;#34;fyne.io/fyne/v2/container&amp;#34; &amp;#34;fyne.io/fyne/v2/widget&amp;#34; ) type config struct { EditWidget *widget.Entry PreviewWidget *widget.RichText CurrentFile fyne.</description>
    </item>
    <item>
      <title>Fyne-趣味整活项目</title>
      <link>https://docs.cakepanit.com/docs/dev/golang/fyne/project/2.%E8%B6%A3%E5%91%B3%E6%95%B4%E6%B4%BB%E9%A1%B9%E7%9B%AE/</link>
      <pubDate>Wed, 03 May 2023 22:37:22 +0100</pubDate><author>admin@cakepanit.com (饼铛)</author>
      <guid>https://docs.cakepanit.com/docs/dev/golang/fyne/project/2.%E8%B6%A3%E5%91%B3%E6%95%B4%E6%B4%BB%E9%A1%B9%E7%9B%AE/</guid>
      <description>全部代码 link package main import ( &amp;#34;time&amp;#34; &amp;#34;fyne.io/fyne/v2&amp;#34; &amp;#34;fyne.io/fyne/v2/app&amp;#34; &amp;#34;fyne.io/fyne/v2/container&amp;#34; &amp;#34;fyne.io/fyne/v2/dialog&amp;#34; &amp;#34;fyne.io/fyne/v2/widget&amp;#34; ) func main() { // 创建一个 Fyne 应用 a := app.New() // 创建一个窗口 customFont := fyne.NewStaticResource(&amp;#34;NotoSansHans.ttf&amp;#34;, loadFont(&amp;#34;NotoSansHans-Regular.ttf&amp;#34;)) a.Settings().SetTheme(&amp;amp;myTheme{font: customFont}) win := a.NewWindow(&amp;#34;高端检测器&amp;#34;) // 创建一个按钮 btn := widget.NewButton(&amp;#34;检测是否开机&amp;#34;, func() { // 创建一个进度条 progress := widget.NewProgressBarInfinite() progressContainer := container.NewVBox(progress) // 显示加载动画 loadingDialog := dialog.NewCustom(&amp;#34;正在检测...&amp;#34;, &amp;#34;取消&amp;#34;, progressContainer, win) loadingDialog.Show() // 模拟加载时间 go func(){ time.Sleep(10 * time.Second) // 10 秒模拟加载时间 // 关闭加载动画并弹出结果窗口 loadingDialog.</description>
    </item>
    <item>
      <title>1.Go的面向对象</title>
      <link>https://docs.cakepanit.com/docs/dev/golang/1.go%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</link>
      <pubDate>Wed, 03 May 2023 22:37:22 +0100</pubDate><author>admin@cakepanit.com (饼铛)</author>
      <guid>https://docs.cakepanit.com/docs/dev/golang/1.go%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</guid>
      <description>封装 - 工厂模式 link golang的结构体没有构造函数，通常可以使用工厂模式来解决这个问题。 如果包里面的结构体变量首字母小写，引入后，不能直接使用，可以工厂模式解决。 只关心结果，不关心实现过程，因为过程是由封闭的工厂来实现的。 package demo //定义一个结构体 type student struct{ Name string score float64 } // *student返回结构体的指针 func NewStudent(name string, score float64) *student { //外包引用不了，但本包是可以引用的 stu := student{ Name : name, score : score, } return &amp;amp;stu } // 结构体中的score字段也是小写所以需要写一个方法返回 func (s *student) GetScore() float64 { return s.score } func (s *student) SetScore(score float64) { s.score = score } package main import ( &amp;#34;fmt&amp;#34; &amp;#34;go-demo/demo&amp;#34; ) func main() { s := demo.</description>
    </item>
    <item>
      <title>2.Go的并发编程</title>
      <link>https://docs.cakepanit.com/docs/dev/golang/2.go%E7%9A%84%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</link>
      <pubDate>Wed, 03 May 2023 22:37:22 +0100</pubDate><author>admin@cakepanit.com (饼铛)</author>
      <guid>https://docs.cakepanit.com/docs/dev/golang/2.go%E7%9A%84%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</guid>
      <description>并发介绍 link 并发和并行 并发：本质还是串行 食堂窗口一个大妈（同一时间类只能给一个人打饭） Python 本质没有并行的线程 并行：任务分布在不同 CPU 上，同一时间点同时执行 并行就是有多个食堂大妈，同时给不同人打饭 协程和线程 协程：独立的栈空间，共享堆空间，调度由用户自己控制，本质上有点类似于用户级线程，这些用户级线程的调度也是自己实现的 线程：一个线程上可以跑多个协程，协程是轻量级的线程。 线程和协程最大的区别： 开启一个线程需要大概 2M 空间，而且需要 CPU 调度才能执行，线程会强占 CPU 开启一个协程大概只需要 2K 的空间，而且是由 Go 解释器自己实现的 GPM 调度，主动退出 可以同时启动成千上万个 goroutine 而不会过度占用内存 如果开启成千上万个线程，不仅会大量占用内存，甚至导致机器崩溃；操作系统调度线程也需要耗费大量时间 协程如果需要用 CPU 才会去使用 CPU，如果没有使用 CPU 的需求，它就会主动把 CPU 让给其他协程执行 线程在时间片内，即使不使用 CPU，比如当前正在从磁盘读数据，它也不会让出 CPU goroutine link 多线程编程缺点&#xA;在 Java/C++ 中我们要实现并发编程时，通常需要自己维护一个线程池，并且需要自己去包装一个又一个的任务，同时需要自己去调度线程执行任务并维护上下文切换 goroutine&#xA;Go 语言中的 goroutine 是由 Go 的运行时（runtime）调度和管理的。 Go 程序会智能地将 goroutine 中的任务合理地分配给每个 CPU。 Go 语言之所以被称为现代化的编程语言，就是因为它在语言层面已经内置了调度和上下文切换的机制。 在 Go 语言编程中，你不需要自己写进程、线程、协程，你的技能包里只有一个技能 —— goroutine 当你需要让某个任务并发执行时，只需将该任务包装成一个函数，并开启一个 goroutine 去执行该函数即可。 协程基本使用 link 启动一个协程</description>
    </item>
    <item>
      <title>3.Go常用库</title>
      <link>https://docs.cakepanit.com/docs/dev/golang/3.go%E5%B8%B8%E7%94%A8%E5%BA%93/</link>
      <pubDate>Wed, 03 May 2023 22:37:22 +0100</pubDate><author>admin@cakepanit.com (饼铛)</author>
      <guid>https://docs.cakepanit.com/docs/dev/golang/3.go%E5%B8%B8%E7%94%A8%E5%BA%93/</guid>
      <description>时间库time link package main import ( &amp;#34;fmt&amp;#34; &amp;#34;time&amp;#34; ) func main() { now := time.Now() fmt.Printf(&amp;#34;原始时间对象：%s\n&amp;#34;, now) //格式化时间 timePrf := now.Format(&amp;#34;2006-01-02 15:04:05&amp;#34;) fmt.Printf(&amp;#34;格式化时间戳：%s\n&amp;#34;, timePrf) /* output: 原始时间对象：2024-09-26 23:49:32.920331 &amp;#43;0800 CST m=&amp;#43;0.000064395 格式化时间戳：2024-09-26 23:49:32 */ //时间戳 fmt.Printf(&amp;#34;秒时间戳：%v\n&amp;#34;, now.Unix()) fmt.Printf(&amp;#34;毫秒时间戳：%v\n&amp;#34;, now.UnixMilli()) fmt.Printf(&amp;#34;微秒时间戳：%v\n&amp;#34;, now.UnixMicro()) fmt.Printf(&amp;#34;纳秒时间戳：%v\n&amp;#34;, now.UnixNano()) /* output: 秒时间戳：1727365772 毫秒时间戳：1727365772920 微秒时间戳：1727365772920331 纳秒时间戳：1727365772920331000 */ //格式化后的时间（string）转时间对象 loc, _ := time.LoadLocation(&amp;#34;Asia/Shanghai&amp;#34;) inLocation, _ := time.ParseInLocation(&amp;#34;2006-01-02 15:04:05&amp;#34;, timePrf, loc) fmt.Printf(&amp;#34;格式化后的时间字符串转时间对象：%s\n&amp;#34;, inLocation) /* output: 格式化后的时间字符串转时间对象：2024-09-26 23:49:32 &amp;#43;0800 CST */ //获取年月日、时分秒 year := now.</description>
    </item>
    <item>
      <title>4.Go-net-http</title>
      <link>https://docs.cakepanit.com/docs/dev/golang/4.go-net-http/</link>
      <pubDate>Wed, 03 May 2023 22:37:22 +0100</pubDate><author>admin@cakepanit.com (饼铛)</author>
      <guid>https://docs.cakepanit.com/docs/dev/golang/4.go-net-http/</guid>
      <description>net-http介绍 link . ├─ ClientGet │ └── main.go // 发送get请求 ├─ ClientPost │ └── main.go // 发送post请求 ├─ Server │ └── main.go // web服务 Go语言内置的net/http包十分的优秀，提供了HTTP客户端和服务端的实现。&#xA;1.Server/main.go link 客户端 请求信息 封装在http.Request对象中 服务端返回的 响应报文 会被保存在http.Response结构体中 发送给客户端响应的并不是http.Response，而是通过http.ResponseWriter接口来实现的 方法签名 描述 Header() 用户设置或获取响应头信息 Write() 用于写入数据到响应体 WriteHeader() 用于设置响应状态码，若不调用则默认状态码为200 OK。 package main import ( &amp;#34;encoding/json&amp;#34; &amp;#34;io&amp;#34; &amp;#34;log&amp;#34; &amp;#34;net/http&amp;#34; ) // 定义入参结构体 type Data struct { Speak string `json:&amp;#34;speak&amp;#34;` } // 处理get请求 func dealGetReqHandler(w http.ResponseWriter, r *http.Request) { query := r.</description>
    </item>
    <item>
      <title>5.Go-gRPC</title>
      <link>https://docs.cakepanit.com/docs/dev/golang/5.go-grpc/</link>
      <pubDate>Wed, 03 May 2023 22:37:22 +0100</pubDate><author>admin@cakepanit.com (饼铛)</author>
      <guid>https://docs.cakepanit.com/docs/dev/golang/5.go-grpc/</guid>
      <description>1.gRPC 是什么 linkgRPC是google开源的一个RPC框架和库，支持多语言之间的通信。底层通信采用的是 HTTP2 协议。gRPC在设计上使用了 ProtoBuf 这种接口描述语言。这种IDL语言可以定义各种服务，google还提供了一种工具 protoc 来编译这种IDL语言，生成各种各样的语言来操作服务。&#xA;2.gRPC特点 link 定义服务简单，可以很快的搭建出一个RPC调度的服务 gRPC是与语言无关，平台无关的。你定义好了一个protobuf协议，就可以用protoc生成不同语言的协议框架 使用HTTP2协议，支持双向流。客户端和服务端可以双向通信 3.RPC与RESTful区别是什么 link 在客户端和服务端通信还有一种基于http协议的 RESTful 架构模式，RESTful一般是对于资源的操作，它是名词（资源地址），然后添加一些动作对这些资源进行操作。而RPC是基于函数，它是动词。 RPC一般基于TCP协议，当然gRPC是基于HTTP2，但它也是比HTTP协议更加有效率和更多特性。RESTful一般都是基于HTTP协议。 传输方面：自定义的TCP协议或者使用HTTP2协议，报文体积更小，所以传输效率更高，RESTful一般基于http协议，报文体积大。 gRPC用的是protobuf的IDL语言，会编码为二进制协议的数据，而RESTful一般是用json的数据格式，所以json格式的编解码更耗时。 4.gRPC通信流程 link 客户端(gRPC Stub)调用A方法，发起RPC调用 对请求信息使用Protobuf进行对象序列化压缩（IDL） 服务端（gPRC Server)接收到请求后，解码请求体，进行业务逻辑处理并返回。 对响应结果使用Protobuf进行对象序列化压缩（IDL） 客户端接受到服务端响应，解码请求体。回调被调用的A方法，唤醒正在等待响应（阻塞）的客户端调用并返回响应结果 5.gRPC环境安装 link5.1安装 protobuf link从官方仓库：https://github.com/google/protobuf/releases 下载适合你平台的预编译好的二进制文件（protoc-&amp;lt;version&amp;gt;-&amp;lt;platform&amp;gt;.zip）。&#xA;适用Windows 64位protoc-3.20.1-win64.zip 适用于Mac Intel 64位protoc-3.20.1-osx-x86_64.zip 适用于Mac ARM 64位protoc-3.20.1-osx-aarch_64.zip 适用于Linux 64位protoc-3.20.1-linux-x86_64.zip 将下载的zip解压到指定位置，这里以mac系统为例 fei@feideMBP protoc % pwd /usr/local/protoc fei@feideMBP protoc % tree -L 2 ./ ./ ├── bin │ └── protoc └── include ├── github.com └── google 5 directories, 1 file fei@feideMBP protoc % protoc --version libprotoc 3.</description>
    </item>
    <item>
      <title>6.Go-Gin</title>
      <link>https://docs.cakepanit.com/docs/dev/golang/6.go-gin/</link>
      <pubDate>Wed, 03 May 2023 22:37:22 +0100</pubDate><author>admin@cakepanit.com (饼铛)</author>
      <guid>https://docs.cakepanit.com/docs/dev/golang/6.go-gin/</guid>
      <description>1.Gin介绍 link Gin 是一个高性能的Go语言Web框架，封装比较优雅，API友好，源代码比较明确。具有快速灵活，容错方便等特点。 其实对于golang而言，web框架的依赖远比Python，Java之类的要小。自身的net/http足够简单，性能也非常不错。 框架更像是一个常用函数或者工具的集合。借助框架开发，不仅可以省去很多常用的封装带来的时间，也有助于团队的编码风格和形成规范。 Gin官网:Gin Github&#xA;2.Gin第一个应用 link package main import ( &amp;#34;github.com/gin-gonic/gin&amp;#34; &amp;#34;net/http&amp;#34; ) func main() { //实例化gin对象 ginSer := gin.Default() //定义路由：当使用 GET 方法访问路径为 /api/gin-test 时，执行回调函数 ginSer.GET(&amp;#34;/api/gin-test&amp;#34;, func(c *gin.Context) { //在回调函数中，返回一个字符串 &amp;#34;hello, go&amp;#34; 并设置HTTP状态码为200 OK c.String(http.StatusOK, &amp;#34;Hello Gin&amp;#34;) }) ginSer.Run(&amp;#34;:8000&amp;#34;) } 2.1测试 link //启动服务端 fei@feideMBP test % go run main.go [GIN-debug] [WARNING] Creating an Engine instance with the Logger and Recovery middleware already attached. [GIN-debug] [WARNING] Running in &amp;#34;debug&amp;#34; mode.</description>
    </item>
    <item>
      <title>7.Go-GORM</title>
      <link>https://docs.cakepanit.com/docs/dev/golang/7.go-gorm/</link>
      <pubDate>Wed, 03 May 2023 22:37:22 +0100</pubDate><author>admin@cakepanit.com (饼铛)</author>
      <guid>https://docs.cakepanit.com/docs/dev/golang/7.go-gorm/</guid>
      <description>1.什么是ORM？ linkorm是一种术语而不是软件&#xA;orm英文全称object relational mapping,就是 ==对象映射关系== 程序； 简单来说类似python这种面向对象的程序来说一切皆对象，但是我们使用的数据库却都是关系型的； 为了保证一致的使用习惯，通过 orm将编程语言的对象模型和数据库的关系模型建立映射关系； 这样我们直接 使用编程语言的对象模型进行操作数据库 就可以了，而不用直接使用sql语言； 2.什么是GORM？ linkGORM 官方文档&#xA;全功能 ORM (无限接近) 关联 (Has One, Has Many, Belongs To, Many To Many, 多态) 钩子 (在创建/保存/更新/删除/查找之前或之后) 预加载 事务 复合主键 SQL 生成器 数据库自动迁移 自定义日志 可扩展性, 可基于 GORM 回调编写插件 所有功能都被测试覆盖 开发者友好 3.GORM(v2)基本使用 link3.1安装 link go get -u gorm.io/gorm 4.准备MySQL环境 link4.1docker拉起一个mysql link docker run --name fly-mysql -e MYSQL_ROOT_PASSWORD=123456 -p 3306:3306 -d mysql:8.0 4.2创建数据库 link create database test_db charset utf8mb4; use test_db; show tables; 4.</description>
    </item>
    <item>
      <title>1.HTML</title>
      <link>https://docs.cakepanit.com/docs/dev/front-end/1.html/</link>
      <pubDate>Wed, 03 May 2023 22:37:22 +0100</pubDate><author>admin@cakepanit.com (饼铛)</author>
      <guid>https://docs.cakepanit.com/docs/dev/front-end/1.html/</guid>
      <description>1.1 一个基础例子 link一个基础的HTML例子：&#xA;&amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta charset=&amp;#34;utf-8&amp;#34;&amp;gt; &amp;lt;title&amp;gt;page name&amp;lt;/title&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;h1&amp;gt;title 1&amp;lt;/h1&amp;gt; &amp;lt;h2&amp;gt;sub title&amp;lt;/h2&amp;gt; &amp;lt;p&amp;gt;paragraph text&amp;lt;/p&amp;gt; &amp;lt;h1&amp;gt;title 2&amp;lt;/h1&amp;gt; &amp;lt;p&amp;gt;paragraph text&amp;lt;/p&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt; 整个文件由html标签包着，其中由分为首部和主体两部分，分别用head标签和body标签包裹。&#xA;首部告诉浏览器关于网页的信息，如页面标题，首部包括&amp;lt;head&amp;gt;和&amp;lt;/head&amp;gt;之间的所有内容。其中的title标签定义了网页的标题，meta标签指定了字符编码。&#xA;主体包含网页的所有内容和结构，也就是在浏览器直接看到的部分，主体包括&amp;lt;body&amp;gt;和&amp;lt;/body&amp;gt;之间的所有内容。其中的h1标签和h2标签分别是一级标题和二级标题，p标签则是段落。&#xA;保存为HTML文件，在浏览器打开后，页面效果如下：&#xA;此外，还可以在HTML的首部里增加一些样式，就是style标签。style标签有一个可选的属性type，一般指定为&amp;quot;text/css&amp;quot;。&#xA;&amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta charset=&amp;#34;utf-8&amp;#34;&amp;gt; &amp;lt;title&amp;gt;page name&amp;lt;/title&amp;gt; &amp;lt;style type=&amp;#34;text/css&amp;#34;&amp;gt; body { background-color: #d2b48c; margin-left: 20%; margin-right: 20%; border: 2px dotted black; padding: 10px 10px 10px 10px; font-family: sans-serif; } &amp;lt;/style&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;h1&amp;gt;title 1&amp;lt;/h1&amp;gt; &amp;lt;h2&amp;gt;sub title&amp;lt;/h2&amp;gt; &amp;lt;p&amp;gt;paragraph text&amp;lt;/p&amp;gt; &amp;lt;h1&amp;gt;title 2&amp;lt;/h1&amp;gt; &amp;lt;p&amp;gt;paragraph text&amp;lt;/p&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt; style标签中的body表示这段配置应用于主体中的body标签。</description>
    </item>
    <item>
      <title>2.CSS</title>
      <link>https://docs.cakepanit.com/docs/dev/front-end/2.css/</link>
      <pubDate>Wed, 03 May 2023 22:37:22 +0100</pubDate><author>admin@cakepanit.com (饼铛)</author>
      <guid>https://docs.cakepanit.com/docs/dev/front-end/2.css/</guid>
      <description>1.CSS样式语言 link 为了让网页元素的样式更加丰富，也为了让网页的内容和样式能拆分开，CSS由此思想而诞生。 CSS是 Cascading Style Sheets 的首字母缩写，意思是层叠样式表。 有了CSS，html中大部分表现样式的标签就废弃不用了，html只负责文档的结构和内容，表现形式完全交给CSS，html文档变得更加简洁。 2.CSS使用方式 link 内联方式（行内样式） &amp;lt;p style=&amp;#34;color:red&amp;#34;&amp;gt;直接在html内使用样式&amp;lt;/p&amp;gt; 内部方式（内嵌方式）在head标签中使用 &amp;lt;head&amp;gt; &amp;lt;meta charset=&amp;#34;UTF-8&amp;#34;&amp;gt; &amp;lt;title&amp;gt;Title&amp;lt;/title&amp;gt; &amp;lt;style type=&amp;#34;text/css&amp;#34;&amp;gt; p { color: red; } &amp;lt;/style&amp;gt; &amp;lt;/head&amp;gt; 外部导入式（推荐）在head标签中使用 &amp;lt;link rel=&amp;#34;stylesheet&amp;#34; type=&amp;#34;text/css&amp;#34; href=&amp;#34;css/index.css&amp;#34;&amp;gt; 3.CSS选择器 link 选择器：需要改变样式的HTML元素 格式：选择器（属性:值;属性:值;属性:值;&amp;hellip;..） 常见选择器：标签(元素)选择器、类型选择器、ID选择器、派生选择器 3.1元素选择器 link 使用html标签作为选择器，为指定标签设置样式 示例1：h1元素设置样式 h1 { color: darkcyan; font-size: 14; } 示例2：为多个元素设置样式 h2,h3 { color: chartreuse; } 示例3：子元素会继承最高级元素所有属性 如果子元素有自己的样式优先用自己，如果没有则用父元素样式 body { color: darkcyan; font-family: Verdana, sarif; /*字体*/ } h1 { color: brown; font-size: 14; } 3.</description>
    </item>
    <item>
      <title>1.Kubernetes-v1.28.3高可用集群二进制部署(IPv4&#43;IPv6双栈)</title>
      <link>https://docs.cakepanit.com/docs/ops/kubernetes/1.kubernetes-v1.28.3%E4%BA%8C%E8%BF%9B%E5%88%B6%E9%83%A8%E7%BD%B2/</link>
      <pubDate>Wed, 03 May 2023 22:37:22 +0100</pubDate><author>admin@cakepanit.com (饼铛)</author>
      <guid>https://docs.cakepanit.com/docs/ops/kubernetes/1.kubernetes-v1.28.3%E4%BA%8C%E8%BF%9B%E5%88%B6%E9%83%A8%E7%BD%B2/</guid>
      <description>介绍 link kubernetes（k8s）二进制高可用安装部署，支持IPv4+IPv6双栈。 我使用IPV6的目的是在公网进行访问，所以我配置了IPV6静态地址。 若您没有IPV6环境，或者不想使用IPv6，不对主机进行配置IPv6地址即可。 不配置IPV6，不影响后续，不过集群依旧是支持IPv6的。为后期留有扩展可能性。 若不要IPv6 ，不给网卡配置IPv6即可，不要对IPv6相关配置删除或操作，否则会出问题。 1.环境 link 主机名称 IP地址 说明 软件 192.168.1.60 外网节点 下载各种所需安装包 Master01 192.168.1.31 master节点 kube-apiserver、kube-controller-manager、kube-scheduler、etcd、&#xA;kubelet、kube-proxy、nfs-client、haproxy、keepalived、nginx Master02 192.168.1.32 master节点 kube-apiserver、kube-controller-manager、kube-scheduler、etcd、&#xA;kubelet、kube-proxy、nfs-client、haproxy、keepalived、nginx Master03 192.168.1.33 master节点 kube-apiserver、kube-controller-manager、kube-scheduler、etcd、&#xA;kubelet、kube-proxy、nfs-client、haproxy、keepalived、nginx Node01 192.168.1.34 node节点 kubelet、kube-proxy、nfs-client、nginx Node02 192.168.1.35 node节点 kubelet、kube-proxy、nfs-client、nginx 192.168.1.36 VIP 网段 物理主机：192.168.1.0/24 service：10.96.0.0/12 pod：172.16.0.0/12&#xA;1.1.k8s基础系统环境配置 link1.2.配置IP link # 注意！ # 若虚拟机是进行克隆的那么网卡的UUID会重复 # 若UUID重复需要重新生成新的UUID # UUID重复无法获取到IPV6地址 # # 查看当前的网卡列表和 UUID： # nmcli con show # 删除要更改 UUID 的网络连接： # nmcli con delete uuid &amp;lt;原 UUID&amp;gt; # 重新生成 UUID： # nmcli con add type ethernet ifname &amp;lt;接口名称&amp;gt; con-name &amp;lt;新名称&amp;gt; # 重新启用网络连接： # nmcli con up &amp;lt;新名称&amp;gt; # 更改网卡的UUID ssh root@192.</description>
    </item>
    <item>
      <title>2.Kubernetes-v1.30.2高可用集群二进制部署(IPv4&#43;IPv6双栈)</title>
      <link>https://docs.cakepanit.com/docs/ops/kubernetes/2.kubernetes-v1.30.2%E4%BA%8C%E8%BF%9B%E5%88%B6%E9%83%A8%E7%BD%B2/</link>
      <pubDate>Wed, 03 May 2023 22:37:22 +0100</pubDate><author>admin@cakepanit.com (饼铛)</author>
      <guid>https://docs.cakepanit.com/docs/ops/kubernetes/2.kubernetes-v1.30.2%E4%BA%8C%E8%BF%9B%E5%88%B6%E9%83%A8%E7%BD%B2/</guid>
      <description>介绍 link kubernetes（k8s）二进制高可用安装部署，支持IPv4+IPv6双栈。 我使用IPV6的目的是在公网进行访问，所以我配置了IPV6静态地址。 若您没有IPV6环境，或者不想使用IPv6，不对主机进行配置IPv6地址即可。 不配置IPV6，不影响后续，不过集群依旧是支持IPv6的。为后期留有扩展可能性。 若不要IPv6 ，不给网卡配置IPv6即可，不要对IPv6相关配置删除或操作，否则会出问题。 1.环境 link 主机名称 IP地址 说明 软件 192.168.1.60 外网节点 下载各种所需安装包 Master01 192.168.1.41 master节点 kube-apiserver、kube-controller-manager、kube-scheduler、etcd、&#xA;kubelet、kube-proxy、nfs-client、haproxy、keepalived、nginx Master02 192.168.1.42 master节点 kube-apiserver、kube-controller-manager、kube-scheduler、etcd、&#xA;kubelet、kube-proxy、nfs-client、haproxy、keepalived、nginx Master03 192.168.1.43 master节点 kube-apiserver、kube-controller-manager、kube-scheduler、etcd、&#xA;kubelet、kube-proxy、nfs-client、haproxy、keepalived、nginx Node01 192.168.1.44 node节点 kubelet、kube-proxy、nfs-client、nginx Node02 192.168.1.45 node节点 kubelet、kube-proxy、nfs-client、nginx 192.168.1.46 VIP 网段 物理主机：192.168.1.0/24 service：10.96.0.0/12 pod：172.16.0.0/12&#xA;1.1.k8s基础系统环境配置 link1.2.配置IP link # 注意！ # 若虚拟机是进行克隆的那么网卡的UUID和MachineID会重复 # 需要重新生成新的UUIDUUID和MachineID # UUID和MachineID重复无法DHCP获取到IPV6地址 ssh root@192.168.1.155 &amp;#34;rm -rf /etc/machine-id; systemd-machine-id-setup;reboot&amp;#34; ssh root@192.168.1.158 &amp;#34;rm -rf /etc/machine-id; systemd-machine-id-setup;reboot&amp;#34; ssh root@192.</description>
    </item>
    <item>
      <title>3.升级二进制部署的kubernetes集群</title>
      <link>https://docs.cakepanit.com/docs/ops/kubernetes/3.%E5%8D%87%E7%BA%A7%E4%BA%8C%E8%BF%9B%E5%88%B6%E9%83%A8%E7%BD%B2%E7%9A%84kubernetes%E9%9B%86%E7%BE%A4/</link>
      <pubDate>Wed, 03 May 2023 22:37:22 +0100</pubDate><author>admin@cakepanit.com (饼铛)</author>
      <guid>https://docs.cakepanit.com/docs/ops/kubernetes/3.%E5%8D%87%E7%BA%A7%E4%BA%8C%E8%BF%9B%E5%88%B6%E9%83%A8%E7%BD%B2%E7%9A%84kubernetes%E9%9B%86%E7%BE%A4/</guid>
      <description>基础操作 link查看当前版本信息 link [root@k8s-master01 ~]# kubectl get node NAME STATUS ROLES AGE VERSION k8s-master01 Ready &amp;lt;none&amp;gt; 57d v1.23.6 k8s-master02 Ready &amp;lt;none&amp;gt; 57d v1.23.6 k8s-master03 Ready &amp;lt;none&amp;gt; 57d v1.23.6 k8s-node01 Ready &amp;lt;none&amp;gt; 57d v1.23.6 k8s-node02 Ready &amp;lt;none&amp;gt; 57d v1.23.6 [root@k8s-master01 ~]# 主机域名以及IP地址 link [root@k8s-master01 ~]# cat /etc/hosts | grep k8s 192.168.1.230 k8s-master01 192.168.1.231 k8s-master02 192.168.1.232 k8s-master03 192.168.1.233 k8s-node01 192.168.1.234 k8s-node02 [root@k8s-master01 ~]# 下载二进制安装包 link [root@k8s-master01 ~]# wget https://dl.k8s.io/v1.23.9/kubernetes-server-linux-amd64.tar.gz [root@k8s-master01 ~]# 解压二进制安装包 link [root@k8s-master01 ~]# tar xf kubernetes-server-linux-amd64.</description>
    </item>
    <item>
      <title>4.Kubernetes核心概念介绍</title>
      <link>https://docs.cakepanit.com/docs/ops/kubernetes/4.kubernetes%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%E4%BB%8B%E7%BB%8D/</link>
      <pubDate>Wed, 03 May 2023 22:37:22 +0100</pubDate><author>admin@cakepanit.com (饼铛)</author>
      <guid>https://docs.cakepanit.com/docs/ops/kubernetes/4.kubernetes%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%E4%BB%8B%E7%BB%8D/</guid>
      <description>1. kubernetes核心概念 link1.1 Pod linkPod是可以在 Kubernetes 中创建和管理的、最小的可部署的计算单元。&#xA;Pod就像豌豆荚一样，其中包含着一组（一个或多个）容器； 这些容器共享存储、网络、以及怎样运行这些容器的声明。&#xA;Pod就像一台物理服务器一样，其中包含一个或多个应用容器， 这些容器中运行着用户应用程序。&#xA;举例说明Pod、Container、应用程序三者之间的关系：麻屋子,红帐子,里面住着白胖子。Pod就是麻屋子,Container就是红帐子,应用程序就是里面的白胖子。&#xA;1.2 Controller link在 Kubernetes 中，用于管理和运行Pod的对象&#xA;在 Kubernetes 中，控制器通过监控集群的公共状态，并致力于将当前状态转变为期望的状态&#xA;举例说明Controller(控制器)作用：房间里的温度自动调节器&#xA;当你设置了温度，告诉了温度自动调节器你的期望状态（Desired State）。 房间的实际温度是当前状态（Current State）。 通过对设备的开关控制，温度自动调节器让其当前状态接近期望状态。&#xA;一个控制器至少追踪一种类型的 Kubernetes 资源。这些对象有一个代表期望状态的 spec 字段。 该资源的控制器负责确保其当前状态接近期望状态。&#xA;不同的类型的控制器所实现的控制方式不一样，例如：&#xA;deployment 部署无状态应用 部署无状态应用: 认为pod 都一样，没有顺序要求， 不用考虑在哪个node 运行，随意进行扩展和伸缩 管理Pod和 ReplicaSet 部署、滚动升级等 典型的像web服务、分布式服务等 StatefulSet 部署有状态应用 有状态应用，每个pod 都独立运行，保持pod 启动顺序和唯一性； 有唯一的网络标识符，持久存储； 有序，比如mysql 主从； 主机名称固定。 而且其扩容以及升级等操作也是按顺序进行的操作。 DaemonSet 部署守护进程 DaemonSet保证在每个Node上都运行一个容器副本，常用来部署一些集群的日志、监控或者其他系统管理应用。 新加入的node 也同样运行在一个pod 里面。 job 一次性任务 Job负责批量处理短暂的一次性任务 (short lived one-off tasks)，即仅执行一次的任务，它保证批处理任务的一个或多个Pod成功结束。 Cronjob 周期性定时任务 1.3 Label link1.</description>
    </item>
    <item>
      <title>1.容器技术所涉及的Linux内核关键技术</title>
      <link>https://docs.cakepanit.com/docs/ops/container/1.%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF%E6%89%80%E6%B6%89%E5%8F%8A%E7%9A%84linux%E5%86%85%E6%A0%B8%E5%85%B3%E9%94%AE%E6%8A%80%E6%9C%AF/</link>
      <pubDate>Wed, 03 May 2023 22:37:22 +0100</pubDate><author>admin@cakepanit.com (饼铛)</author>
      <guid>https://docs.cakepanit.com/docs/ops/container/1.%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF%E6%89%80%E6%B6%89%E5%8F%8A%E7%9A%84linux%E5%86%85%E6%A0%B8%E5%85%B3%E9%94%AE%E6%8A%80%E6%9C%AF/</guid>
      <description>1. 容器技术前世今生 link1.1 1979年 — chroot link 容器技术的概念可以追溯到1979年的UNIX chroot。 它是一套“UNIX操作系统”系统，旨在将其root目录及其它子目录变更至文件系统内的新位置，且只接受特定进程的访问。 这项功能的设计目的在于为每个进程提供一套隔离化磁盘空间。 1982年其被添加至BSD当中。 1.2 2000年 — FreeBSD Jails link FreeBSD Jails是由Derrick T. Woolworth于2000年在FreeBSD研发协会中构建而成的早期容器技术之一。 这是一套“操作系统”系统，与chroot的定位类似，不过其中包含有其它进程沙箱机制以对文件系统、用户及网络等资源进行隔离。 通过这种方式，它能够为每个Jail、定制化软件安装包乃至配置方案等提供一个对应的IP地址。 1.3 2001年 — Linux VServer link Linux VServer属于另一种jail机制，其能够被用于保护计算机系统之上各分区资源的安全(包括文件系统、CPU时间、网络地址以及内存等)。 每个分区被称为一套安全背景(security context)，而其中的虚拟化系统则被称为一套虚拟私有服务器。 1.4 2004年 — Solaris容器 link Solaris容器诞生之时面向x86与SPARC系统架构，其最初亮相于2004年2月的Solaris 10 Build 51 beta当中，随后于2005年正式登陆Solaris 10的完整版本。 Solaris容器相当于将系统资源控制与由分区提供的边界加以结合。各分区立足于单一操作系统实例之内以完全隔离的虚拟服务器形式运行。 1.5 2005年 — OpenVZ link OpenVZ与Solaris容器非常相似，且使用安装有补丁的Linux内核以实现虚拟化、隔离能力、资源管理以及检查点交付。 每套OpenVZ容器拥有一套隔离化文件系统、用户与用户群组、一套进程树、网络、设备以及IPC对象。 1.6 2006年 — Process容器 link Process容器于2006年由谷歌公司推出，旨在对一整套进程集合中的资源使用量(包括CPU、内存、磁盘I/O以及网络等等)加以限制、分配与隔离。 此后其被更名为Control Groups(即控制组)，从而避免其中的“容器”字眼与Linux内核2.6.24中的另一术语出现冲突。这表明了谷歌公司率先重视容器技术的敏锐眼光以及为其做出的突出贡献。 1.7 2007年 — Control Groups linkControl Groups也就是谷歌实现的cgroups，其于2007年被添加至Linux内核当中。&#xA;1.8 2008年 — LXC link LXC指代的是Linux Containers 是第一套完整的Linux容器管理实现方案。 其功能通过cgroups以及Linux namespaces实现。 LXC通过liblxc库进行交付，并提供可与Python3、Python2、Lua、Go、Ruby以及Haskell等语言相对接的API。 相较于其它容器技术，LXC能够在无需任何额外补丁的前提下运行在原版Linux内核之上。 1.</description>
    </item>
    <item>
      <title>1.Containerd轻量级or工业级的容器管理工具</title>
      <link>https://docs.cakepanit.com/docs/ops/container/containerd/1.containerd%E8%BD%BB%E9%87%8F%E7%BA%A7or%E5%B7%A5%E4%B8%9A%E7%BA%A7%E7%9A%84%E5%AE%B9%E5%99%A8%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/</link>
      <pubDate>Wed, 03 May 2023 22:37:22 +0100</pubDate><author>admin@cakepanit.com (饼铛)</author>
      <guid>https://docs.cakepanit.com/docs/ops/container/containerd/1.containerd%E8%BD%BB%E9%87%8F%E7%BA%A7or%E5%B7%A5%E4%B8%9A%E7%BA%A7%E7%9A%84%E5%AE%B9%E5%99%A8%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/</guid>
      <description>1. Containerd介绍 link1.0 前言 link 早在2016年3月，Docker 1.11的Docker Engine里就包含了containerd，而现在则是把containerd从Docker Engine里彻底剥离出来，作为一个独立的开源项目独立发展，目标是提供一个更加开放、稳定的容器运行基础设施。和原先包含在Docker Engine里containerd相比，独立的containerd将具有更多的功能，可以涵盖整个容器运行时管理的所有需求。&#xA;containerd并不是直接面向最终用户的，而是主要用于集成到更上层的系统里，比如Swarm, Kubernetes, Mesos等容器编排系统。&#xA;containerd以Daemon的形式运行在系统上，通过暴露底层的gRPC API，上层系统可以通过这些API管理机器上的容器。&#xA;每个containerd只负责一台机器，Pull镜像，对容器的操作（启动、停止等），网络，存储都是由containerd完成。具体运行容器由runC负责，实际上只要是符合OCI规范的容器都可以支持。&#xA;对于容器编排服务来说，运行时只需要使用containerd+runC，更加轻量，容易管理。&#xA;独立之后containerd的特性演进可以和Docker Engine分开，专注容器运行时管理，可以更稳定。&#xA;1.1 Containerd前世今生 link2013年docker公司在推出docker产品后,由于其对全球技术产生了一定的影响力，Google公司明显感觉到自己公司内部所使用的Brog系统江湖地位受到的威胁，希望Docker公司能够与自己联合打造一款开源的容器运行时作为Docker核心依赖，但Docker公司拒绝了；接着Google公司联合RedHat、IBM等公司说服Docker公司把其容器核心技术libcontainer捐给中立社区(OCI,Open Container Intiative)，并更名为runC。 为了进一步遏制Docker在未来技术市场影响力，避免在容器市场上Docker一家独大，Google公司带领导RedHat、IBM等成立了CNCF(Cloud Native Computing Fundation)基金会，即云原生计算基金会。CNCF的目标很明确，既然在容器应用领域无法与Docker相抗衡，那就做Google更有经验的技术市场&amp;mdash;&amp;mdash;大规模容器编排应用场景，Google公司把自己内部使用的Brog系统开源&amp;mdash;&amp;mdash;Kubernetes，也就是我们今天所说的云原生技术生态。&#xA;2016年Docker公司推出了Docker Swarm，意在一统Docker生态，让Docker既可以实现容器应用管理，也可以实现大规模容器编排，经过近1年左右时间的市场验证后，发现在容器编排方面无法独立抗衡kubernetes,所以Docker公司于2017年正式宣布原生支持Kubernetes,至此，Docker在大规模容器编排应用市场败下阵来，但是Docker依然不甘心失败，把Docker核心依赖Containerd捐给了CNCF，依此说明Docker依旧是一个PaaS平台。&#xA;2020年CNCF基金会宣布Kubernetes 1.20版本将不再仅支持Docker容器管理工具，此事的起因主要也与Docker捐给CNCF基金会的Containerd有关，早期为了实现Kubernetes能够使用Docker实现容器管理，专门在Kubernetes组件中集成一个shim（垫片）技术，用来将Kubernetes容器运行时接口（CRI，Container Runntime Interface）调用翻译成Docker的API,这样就可以很好地使用Docker了，但是随着Kubernetes在全球技术市场的广泛应用，有更多的容器管理工具的出现，它们都想能够借助于Kubernetes被用户所使用，所以就提出标准化容器运行时接口，只要适配了这个接口就可以集成到Kubernetes生态当中，所以Kubernetes取消了对shim的维护，并且由于Containerd技术的成功，可以实现无缝对接Kubernetes，所以接下来Kubernetes容器运行时的主角是Containerd。&#xA;1.2 Containerd架构 link1.2.1 架构图 linkContainerd设计的目的是为了嵌入到Kubernetes中使用，它是一个工业级的容器运行时，不提供给开发人员和终端用户直接使用，这样就避免了与Docker产生竞争，但事实上，Containerd已经实现大多数容器管理功能，例如：容器生命周期管理、容器镜像传输和管理、容器存储与网络管理等。&#xA;Containerd 采用标准的 C/S 架构&#xA;服务端通过 GRPC 协议提供稳定的 API 客户端通过调用服务端的 API 进行高级的操作 为了实现解耦，Containerd 将不同的职责划分给不同的组件，每个组件就相当于一个子系统（subsystem）。连接不同子系统的组件被称为模块。&#xA;Containerd 两大子系统为：&#xA;Bundle : 在 Containerd 中，Bundle 包含了配置、元数据和根文件系统数据，你可以理解为容器的文件系统。而 Bundle 子系统允许用户从镜像中提取和打包 Bundles。 Runtime : Runtime 子系统用来执行 Bundles，比如创建容器。 其中，每一个子系统的行为都由一个或多个模块协作完成（架构图中的 Core 部分）。每一种类型的模块都以插件的形式集成到 Containerd 中，而且插件之间是相互依赖的。</description>
    </item>
    <item>
      <title>1.Docker镜像基本操作和介绍</title>
      <link>https://docs.cakepanit.com/docs/ops/container/docker/1.docker%E9%95%9C%E5%83%8F%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E5%92%8C%E4%BB%8B%E7%BB%8D/</link>
      <pubDate>Wed, 03 May 2023 22:37:22 +0100</pubDate><author>admin@cakepanit.com (饼铛)</author>
      <guid>https://docs.cakepanit.com/docs/ops/container/docker/1.docker%E9%95%9C%E5%83%8F%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E5%92%8C%E4%BB%8B%E7%BB%8D/</guid>
      <description>1. Docker容器镜像操作 link1.1 查看本地容器镜像 link1.1.1 使用docker images命令查看 link # docker images REPOSITORY TAG IMAGE ID CREATED SIZE bash latest 5557e073f11c 2 weeks ago 13MB nginx latest 605c77e624dd 3 weeks ago 141MB centos latest 5d0da3dc9764 4 months ago 231MB 1.1.2 使用docker image命令查看 link # docker image list REPOSITORY TAG IMAGE ID CREATED SIZE bash latest 5557e073f11c 2 weeks ago 13MB nginx latest 605c77e624dd 3 weeks ago 141MB centos latest 5d0da3dc9764 4 months ago 231MB 1.</description>
    </item>
    <item>
      <title>2.Docker容器镜像国内加速及本地容器镜像仓库搭建</title>
      <link>https://docs.cakepanit.com/docs/ops/container/docker/2.docker%E5%AE%B9%E5%99%A8%E9%95%9C%E5%83%8F%E5%9B%BD%E5%86%85%E5%8A%A0%E9%80%9F%E5%8F%8A%E6%9C%AC%E5%9C%B0%E5%AE%B9%E5%99%A8%E9%95%9C%E5%83%8F%E4%BB%93%E5%BA%93%E6%90%AD%E5%BB%BA/</link>
      <pubDate>Wed, 03 May 2023 22:37:22 +0100</pubDate><author>admin@cakepanit.com (饼铛)</author>
      <guid>https://docs.cakepanit.com/docs/ops/container/docker/2.docker%E5%AE%B9%E5%99%A8%E9%95%9C%E5%83%8F%E5%9B%BD%E5%86%85%E5%8A%A0%E9%80%9F%E5%8F%8A%E6%9C%AC%E5%9C%B0%E5%AE%B9%E5%99%A8%E9%95%9C%E5%83%8F%E4%BB%93%E5%BA%93%E6%90%AD%E5%BB%BA/</guid>
      <description>1. 容器镜像加速器 link 由于国内访问国外的容器镜像仓库速度比较慢，因此国内企业创建了容器镜像加速器，以方便国内用户使用容器镜像。&#xA;1.1 获取阿里云容器镜像加速地址 link 1.2 配置docker daemon使用加速器 link 添加daemon.json配置文件 # vim /etc/docker/daemon.json # cat /etc/docker/daemon.json { &amp;#34;registry-mirrors&amp;#34;: [&amp;#34;https://s27w6kze.mirror.aliyuncs.com&amp;#34;] } 重启docker # systemctl daemon-reload # systemctl restart docker 尝试下载容器镜像 # docker pull centos 2. 容器镜像仓库 link2.1 docker hub link2.1.1 注册 link 准备邮箱及用户ID&#xA;2.1.2 登录 link 2.1.3 创建容器镜像仓库 link 2.1.4 在本地登录Docker Hub link 默认可以不添加docker hub容器镜像仓库地址 # docker login Login with your Docker ID to push and pull images from Docker Hub.</description>
    </item>
    <item>
      <title>3.Dockerfile介绍</title>
      <link>https://docs.cakepanit.com/docs/ops/container/docker/3.dockerfile%E4%BB%8B%E7%BB%8D/</link>
      <pubDate>Wed, 03 May 2023 22:37:22 +0100</pubDate><author>admin@cakepanit.com (饼铛)</author>
      <guid>https://docs.cakepanit.com/docs/ops/container/docker/3.dockerfile%E4%BB%8B%E7%BB%8D/</guid>
      <description>1. 容器与容器镜像之间的关系 link说到Docker管理的容器不得不说容器镜像，主要因为容器镜像是容器模板，通过容器镜像我们才能快速创建容器。&#xA;如下图所示：&#xA;Docker Daemon通过容器镜像创建容器。&#xA;2. 容器镜像分类 link 操作系统类 CentOS Ubuntu 在dockerhub下载或自行制作 应用类 Tomcat Nginx MySQL Redis 3. 容器镜像获取的方法 link主要有以下几种：&#xA;1、在DockerHub直接下载&#xA;2、把操作系统中文件系统打包为容器镜像&#xA;3、把正在运行的容器打包为容器镜像，即docker commit&#xA;4、通过Dockerfile实现容器镜像的自定义及生成&#xA;4. 容器镜像获取方法演示 link4.1 在DockerHub直接下载 link # docker pull centos:latest # docker pull nginx:latest 4.2 把操作系统中文件系统打包为容器镜像 link4.2.1 安装一个最化的操作系统 link 4.2.2 把操作系统中文件系统进行打包 link # tar --numeric-owner --exclude=/proc --exclude=/sys -cvf centos7u6.tar / 4.2.3 把打包后文件加载至本地文件系统生成本地容器镜像 link # ls centos7u6.tar # docker import centos7u6.tar centos7u6:v1 # docker images REPOSITORY TAG IMAGE ID CREATED SIZE centos7u6 v1 130cb005b2dc 7 seconds ago 1.</description>
    </item>
    <item>
      <title>1.Nginx配置小全</title>
      <link>https://docs.cakepanit.com/docs/ops/1.nginx%E9%85%8D%E7%BD%AE%E5%B0%8F%E5%85%A8/</link>
      <pubDate>Wed, 03 May 2023 22:37:22 +0100</pubDate><author>admin@cakepanit.com (饼铛)</author>
      <guid>https://docs.cakepanit.com/docs/ops/1.nginx%E9%85%8D%E7%BD%AE%E5%B0%8F%E5%85%A8/</guid>
      <description>安装 nginx link下载 nginx 的压缩包文件到根目录，官网下载地址：nginx.org/download/nginx-x.xx.xx.tar.gz&#xA;yum update #更新系统软件 cd / wget nginx.org/download/nginx-1.17.2.tar.gz 解压tar.gz压缩包文件，进去 nginx-1.17.2&#xA;tar -xzvf nginx-1.17.2.tar.gz cd nginx-1.17.2 进入文件夹后进行配置检查&#xA;通过安装前的配置检查，发现有报错。检查中发现一些依赖库没有找到，这时候需要先安装nginx的一些依赖库&#xA;yum -y install pcre* #安装使nginx支持rewrite yum -y install gcc-c&amp;#43;&amp;#43; yum -y install zlib* yum -y install openssl openssl-devel 再次进行检查操作 ./configure 没发现报错显示，接下来进行编译并安装的操作&#xA;// 检查模块支持 ./configure --prefix=/usr/local/nginx --with-http_ssl_module --with-http_v2_module --with-http_realip_module --with-http_addition_module --with-http_sub_module --with-http_dav_module --with-http_flv_module --with-http_mp4_module --with-http_gunzip_module --with-http_gzip_static_module --with-http_auth_request_module --with-http_random_index_module --with-http_secure_link_module --with-http_degradation_module --with-http_slice_module --with-http_stub_status_module --with-mail --with-mail_ssl_module --with-stream --with-stream_ssl_module --with-stream_realip_module --with-stream_ssl_preread_module --with-threads --user=www --group=www 这里得特别注意下，你以后需要用到的功能模块是否存在，不然以后添加新的包会比较麻烦。</description>
    </item>
  </channel>
</rss>
