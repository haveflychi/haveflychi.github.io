<!DOCTYPE html>





    
        
    

    

    

    

<html lang="zh-CN"><head>
    <meta charset="utf-8" />
    <title>2.工厂方法模式 | Maxbit Docs</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="简单工厂模式的核心思想是将产品的创建过程封装在一个工厂类中，把创建对象的流程集中在这个工厂类里面。">
    <meta name="keywords" content="Maxbit,上海大比特,DBA,SRE,Go,Golang,Linux,运维,系统运维,自动化运维,分布式,高可用,负载均衡,老菜鸟,Docker,k8s,虚拟化,云计算,DevOps,CI&#x2F;CD,network,system,存储" />
    <meta name="author" content="饼铛" />
    <meta name="email" content="admin@cakepanit.com" />
    <meta name="website" content="https://cakepanit.com" />
    <meta name="Version" content="v0.1.0" />
    
    <link rel="icon" href="https://docs.cakepanit.com/favicon.ico" sizes="any">
<link rel="icon" type="image/svg+xml" href="https://docs.cakepanit.com/favicon.svg">
<link rel="apple-touch-icon" sizes="180x180" href="https://docs.cakepanit.com/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://docs.cakepanit.com/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="https://docs.cakepanit.com/favicon-16x16.png">
<link rel="manifest" crossorigin="use-credentials" href="https://docs.cakepanit.com/site.webmanifest">
<meta property="og:title" content="2.工厂方法模式" />
<meta property="og:description" content="简单工厂模式的核心思想是将产品的创建过程封装在一个工厂类中，把创建对象的流程集中在这个工厂类里面。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://docs.cakepanit.com/docs/dev/23designpattern/2.%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/" /><meta property="og:image" content="https://docs.cakepanit.com/opengraph/card-base-2_hu06b1a92291a380a0d2e0ec03dab66b2f_17642_filter_15532169464878969580.png"/><meta property="article:section" content="docs" />
<meta property="article:published_time" content="2023-05-03T22:37:22+01:00" />
<meta property="article:modified_time" content="2023-05-03T22:37:22+01:00" /><meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://docs.cakepanit.com/opengraph/card-base-2_hu06b1a92291a380a0d2e0ec03dab66b2f_17642_filter_15532169464878969580.png"/>
<meta name="twitter:title" content="2.工厂方法模式"/>
<meta name="twitter:description" content="简单工厂模式的核心思想是将产品的创建过程封装在一个工厂类中，把创建对象的流程集中在这个工厂类里面。"/>

    
    <script>(()=>{var t=window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches,e=localStorage.getItem("theme");t&&e===null&&(localStorage.setItem("theme","dark"),document.documentElement.setAttribute("data-dark-mode","")),t&&e==="dark"&&document.documentElement.setAttribute("data-dark-mode",""),e==="dark"&&document.documentElement.setAttribute("data-dark-mode","")})()</script>
    
    
            
                
                <script type="text/javascript" src="https://docs.cakepanit.com/docs/js/flexsearch.bundle.min.249548594cb6843f3060a3cdd3043799676c59ce8db83358a3fc2e4d20598d05dfa6ce4994805d2835cb33b54dc9b9e7.js" integrity="sha384-JJVIWUy2hD8wYKPN0wQ3mWdsWc6NuDNYo/wuTSBZjQXfps5JlIBdKDXLM7VNybnn" crossorigin="anonymous"></script>
                
        
    
    
    
    
        
        
        
        
    
        
        
        
        
    
    
    <link rel="preconnect" href="https://fonts.gstatic.com/" />
    <link rel="preconnect" href="https://fonts.gstatic.com/" crossorigin />
    <link href="https://fonts.googleapis.com/css?family=Inter:300,400,600,700|Fira+Code:500,700&display=block" rel="stylesheet">

    <link rel="stylesheet" href="/docs/scss/style.min.c192029c65686157242dc1ec592017ac3aee67550ca58756b09fc7d0ead882b74a61f12253e9114c8aed414ccfcbf673.css" integrity="sha384-wZICnGVoYVckLcHsWSAXrDruZ1UMpYdWsJ/H0OrYgrdKYfEiU&#43;kRTIrtQUzPy/Zz"crossorigin="anonymous">
    
    
    
    
  
    
      <script async src="https://www.googletagmanager.com/gtag/js?id=G-YZYFSV46F3"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-YZYFSV46F3');
        }
      </script>
    
  

</head>
<body>
        <div class="content">
            <div class="page-wrapper toggled">
<nav id="sidebar" class="sidebar-wrapper">
    <div class="sidebar-brand">
        <a href='/' aria-label="HomePage" alt="HomePage">
            
                <?xml version="1.0" encoding="UTF-8"?><svg id="Layer_1" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 250 250"><path d="m143,39.5c-18,0-18,18-18,18,0,0,0-18-18-18H22c-2.76,0-5,2.24-5,5v143c0,2.76,2.24,5,5,5h76c7.2,0,8.64,11.52,8.93,16.13.07,1.05.95,1.87,2,1.87h32.14c1.06,0,1.94-.82,2-1.87.29-4.61,1.73-16.13,8.93-16.13h76c2.76,0,5-2.24,5-5V44.5c0-2.76-2.24-5-5-5h-85Zm63,123.5c0,1.38-1.12,2.5-2.5,2.5h-60.5c-18,0-18,18-18,18,0,0,0-18-18-18h-60.5c-1.38,0-2.5-1.12-2.5-2.5v-94c0-1.38,1.12-2.5,2.5-2.5h51.5c7.2,0,8.64,11.52,8.93,16.13.07,1.05.95,1.87,2,1.87h32.14c1.06,0,1.94-.82,2-1.87.29-4.61,1.73-16.13,8.93-16.13h51.5c1.38,0,2.5,1.12,2.5,2.5v94Z" style="fill:#06f;"/></svg>
            
        </a>
    </div>
    <div class="sidebar-content" style="height: calc(100% - 131px);">
        <ul class="sidebar-menu">
            
                
                
                    
                    
                        <li class="sidebar-dropdown  current active">
                            <button class="btn">
                                <i class="material-icons me-2">Code</i>
                                DEV
                            </button>
                            <div class="sidebar-submenu d-block">
                                <ul>
                                    
                                        
                                        
                                            <li class="sidebar-dropdown nested  current active">
                                                <button class="btn">
                                                    
                                                    23种设计模式
                                                </button>
                                                <div class="sidebar-submenu d-block">
                                                    <ul>
                                                        
                                                            
                                                            
                                                                <li class=" "><a class="sidebar-nested-link" href="https://docs.cakepanit.com/docs/dev/23designpattern/1.%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/">1.单例模式</a></li>
                                                            
                                                        
                                                            
                                                            
                                                                <li class="current "><a class="sidebar-nested-link" href="https://docs.cakepanit.com/docs/dev/23designpattern/2.%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/">2.工厂方法模式</a></li>
                                                            
                                                        
                                                            
                                                            
                                                                <li class=" "><a class="sidebar-nested-link" href="https://docs.cakepanit.com/docs/dev/23designpattern/3.%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/">3.抽象工厂模式</a></li>
                                                            
                                                        
                                                            
                                                            
                                                                <li class=" "><a class="sidebar-nested-link" href="https://docs.cakepanit.com/docs/dev/23designpattern/4.%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/">4.建造者模式</a></li>
                                                            
                                                        
                                                            
                                                            
                                                                <li class=" "><a class="sidebar-nested-link" href="https://docs.cakepanit.com/docs/dev/23designpattern/5.%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/">5.原型模式</a></li>
                                                            
                                                        
                                                            
                                                            
                                                                <li class=" "><a class="sidebar-nested-link" href="https://docs.cakepanit.com/docs/dev/23designpattern/6.%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/">6.适配器模式</a></li>
                                                            
                                                        
                                                            
                                                            
                                                                <li class=" "><a class="sidebar-nested-link" href="https://docs.cakepanit.com/docs/dev/23designpattern/7.%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/">7.代理模式</a></li>
                                                            
                                                        
                                                            
                                                            
                                                                <li class=" "><a class="sidebar-nested-link" href="https://docs.cakepanit.com/docs/dev/23designpattern/8.%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/">8.装饰模式</a></li>
                                                            
                                                        
                                                            
                                                            
                                                                <li class=" "><a class="sidebar-nested-link" href="https://docs.cakepanit.com/docs/dev/23designpattern/9.%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/">9.外观模式</a></li>
                                                            
                                                        
                                                            
                                                            
                                                                <li class=" "><a class="sidebar-nested-link" href="https://docs.cakepanit.com/docs/dev/23designpattern/10.%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/">10.桥接模式</a></li>
                                                            
                                                        
                                                            
                                                            
                                                                <li class=" "><a class="sidebar-nested-link" href="https://docs.cakepanit.com/docs/dev/23designpattern/11.%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/">11.组合模式</a></li>
                                                            
                                                        
                                                            
                                                            
                                                                <li class=" "><a class="sidebar-nested-link" href="https://docs.cakepanit.com/docs/dev/23designpattern/12.%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/">12.享元模式</a></li>
                                                            
                                                        
                                                            
                                                            
                                                                <li class=" "><a class="sidebar-nested-link" href="https://docs.cakepanit.com/docs/dev/23designpattern/13.%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/">13.观察者模式</a></li>
                                                            
                                                        
                                                            
                                                            
                                                                <li class=" "><a class="sidebar-nested-link" href="https://docs.cakepanit.com/docs/dev/23designpattern/14.%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/">14.策略模式</a></li>
                                                            
                                                        
                                                            
                                                            
                                                                <li class=" "><a class="sidebar-nested-link" href="https://docs.cakepanit.com/docs/dev/23designpattern/15.%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/">15.命令模式</a></li>
                                                            
                                                        
                                                            
                                                            
                                                                <li class=" "><a class="sidebar-nested-link" href="https://docs.cakepanit.com/docs/dev/23designpattern/16.%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/">16.中介者模式</a></li>
                                                            
                                                        
                                                            
                                                            
                                                                <li class=" "><a class="sidebar-nested-link" href="https://docs.cakepanit.com/docs/dev/23designpattern/17.%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F/">17.备忘录模式</a></li>
                                                            
                                                        
                                                            
                                                            
                                                                <li class=" "><a class="sidebar-nested-link" href="https://docs.cakepanit.com/docs/dev/23designpattern/18.%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/">18.模板方法模式</a></li>
                                                            
                                                        
                                                            
                                                            
                                                                <li class=" "><a class="sidebar-nested-link" href="https://docs.cakepanit.com/docs/dev/23designpattern/19.%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/">19.迭代器模式</a></li>
                                                            
                                                        
                                                            
                                                            
                                                                <li class=" "><a class="sidebar-nested-link" href="https://docs.cakepanit.com/docs/dev/23designpattern/20.%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/">20.状态模式</a></li>
                                                            
                                                        
                                                            
                                                            
                                                                <li class=" "><a class="sidebar-nested-link" href="https://docs.cakepanit.com/docs/dev/23designpattern/21.%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/">21.责任链模式</a></li>
                                                            
                                                        
                                                            
                                                            
                                                                <li class=" "><a class="sidebar-nested-link" href="https://docs.cakepanit.com/docs/dev/23designpattern/22.%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F/">22.解释器模式</a></li>
                                                            
                                                        
                                                            
                                                            
                                                                <li class=" "><a class="sidebar-nested-link" href="https://docs.cakepanit.com/docs/dev/23designpattern/23.%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F/">23.访问者模式</a></li>
                                                            
                                                        
                                                    </ul>
                                                </div>
                                            </li>
                                        
                                    
                                        
                                        
                                            <li class="sidebar-dropdown nested  ">
                                                <button class="btn">
                                                    
                                                    Golang
                                                </button>
                                                <div class="sidebar-submenu ">
                                                    <ul>
                                                        
                                                            
                                                            
                                                                <li class="sidebar-dropdown nested  ">
                                                                    <button class="btn">
                                                                        
                                                                        Fyne
                                                                    </button>
                                                                    <div class="sidebar-submenu ">
                                                                        <ul>
                                                                            
                                                                                
                                                                                
                                                                                    <li class=" "><a class="sidebar-nested-link" href="https://docs.cakepanit.com/docs/dev/golang/fyne/1.%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%AD%A6%E4%B9%A0fyne/">1.为什么要学习Fyne？</a></li>
                                                                                
                                                                            
                                                                                
                                                                                
                                                                                    <li class=" "><a class="sidebar-nested-link" href="https://docs.cakepanit.com/docs/dev/golang/fyne/2.%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%B0%8F%E9%A1%B9%E7%9B%AE/">2.第一个小项目</a></li>
                                                                                
                                                                            
                                                                                
                                                                                
                                                                                    <li class=" "><a class="sidebar-nested-link" href="https://docs.cakepanit.com/docs/dev/golang/fyne/3.%E5%A4%84%E7%90%86%E5%A4%9A%E7%AA%97%E5%8F%A3/">3.处理多窗口问题</a></li>
                                                                                
                                                                            
                                                                                
                                                                                
                                                                                    <li class=" "><a class="sidebar-nested-link" href="https://docs.cakepanit.com/docs/dev/golang/fyne/4.go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%BF%AB%E9%80%9F%E9%80%9A%E5%85%B3/">4.Go基础速通</a></li>
                                                                                
                                                                            
                                                                                
                                                                                
                                                                                    <li class=" "><a class="sidebar-nested-link" href="https://docs.cakepanit.com/docs/dev/golang/fyne/5.%E6%9B%B4%E5%A4%8D%E6%9D%82%E7%9A%84%E9%A1%B9%E7%9B%AE/">5.更复杂的项目</a></li>
                                                                                
                                                                            
                                                                                
                                                                                
                                                                                    <li class="sidebar-dropdown nested  ">
                                                                                        <button class="btn">
                                                                                            
                                                                                            项目案例
                                                                                        </button>
                                                                                        <div class="sidebar-submenu ">
                                                                                            <ul>
                                                                                                
                                                                                                    
                                                                                                    <li class=" "><a class="sidebar-nested-link" href="https://docs.cakepanit.com/docs/dev/golang/fyne/project/1.markdown%E7%BC%96%E8%BE%91%E5%99%A8/">Fyne-Markdown编辑器</a></li>
                                                                                                
                                                                                                    
                                                                                                    <li class=" "><a class="sidebar-nested-link" href="https://docs.cakepanit.com/docs/dev/golang/fyne/project/2.%E8%B6%A3%E5%91%B3%E6%95%B4%E6%B4%BB%E9%A1%B9%E7%9B%AE/">Fyne-趣味整活项目</a></li>
                                                                                                
                                                                                            </ul>
                                                                                        </div>
                                                                                    </li>
                                                                                
                                                                            
                                                                        </ul>
                                                                    </div>
                                                                </li>
                                                            
                                                        
                                                            
                                                            
                                                                <li class=" "><a class="sidebar-nested-link" href="https://docs.cakepanit.com/docs/dev/golang/1.go%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/">1.Go的面向对象</a></li>
                                                            
                                                        
                                                            
                                                            
                                                                <li class=" "><a class="sidebar-nested-link" href="https://docs.cakepanit.com/docs/dev/golang/2.go%E7%9A%84%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">2.Go的并发编程</a></li>
                                                            
                                                        
                                                            
                                                            
                                                                <li class=" "><a class="sidebar-nested-link" href="https://docs.cakepanit.com/docs/dev/golang/3.go%E5%B8%B8%E7%94%A8%E5%BA%93/">3.Go常用库</a></li>
                                                            
                                                        
                                                            
                                                            
                                                                <li class=" "><a class="sidebar-nested-link" href="https://docs.cakepanit.com/docs/dev/golang/4.go-net-http/">4.Go-net-http</a></li>
                                                            
                                                        
                                                            
                                                            
                                                                <li class=" "><a class="sidebar-nested-link" href="https://docs.cakepanit.com/docs/dev/golang/5.go-grpc/">5.Go-gRPC</a></li>
                                                            
                                                        
                                                            
                                                            
                                                                <li class=" "><a class="sidebar-nested-link" href="https://docs.cakepanit.com/docs/dev/golang/6.go-gin/">6.Go-Gin</a></li>
                                                            
                                                        
                                                            
                                                            
                                                                <li class=" "><a class="sidebar-nested-link" href="https://docs.cakepanit.com/docs/dev/golang/7.go-gorm/">7.Go-GORM</a></li>
                                                            
                                                        
                                                    </ul>
                                                </div>
                                            </li>
                                        
                                    
                                        
                                        
                                            <li class="sidebar-dropdown nested  ">
                                                <button class="btn">
                                                    
                                                    前端
                                                </button>
                                                <div class="sidebar-submenu ">
                                                    <ul>
                                                        
                                                            
                                                            
                                                                <li class=" "><a class="sidebar-nested-link" href="https://docs.cakepanit.com/docs/dev/front-end/1.html/">1.HTML</a></li>
                                                            
                                                        
                                                            
                                                            
                                                                <li class=" "><a class="sidebar-nested-link" href="https://docs.cakepanit.com/docs/dev/front-end/2.css/">2.CSS</a></li>
                                                            
                                                        
                                                            
                                                            
                                                                <li class=" "><a class="sidebar-nested-link" href="https://docs.cakepanit.com/docs/dev/front-end/3.js/">3.JavaScript</a></li>
                                                            
                                                        
                                                            
                                                            
                                                                <li class=" "><a class="sidebar-nested-link" href="https://docs.cakepanit.com/docs/dev/front-end/4.vue/">4.Vue</a></li>
                                                            
                                                        
                                                    </ul>
                                                </div>
                                            </li>
                                        
                                    
                                </ul>
                            </div>
                        </li>
                    
                
                    
                    
                        <li class="sidebar-dropdown  ">
                            <button class="btn">
                                <i class="material-icons me-2">cloud_done</i>
                                OPS
                            </button>
                            <div class="sidebar-submenu ">
                                <ul>
                                    
                                        
                                        
                                            <li class="sidebar-dropdown nested  ">
                                                <button class="btn">
                                                    
                                                    Kubernetes
                                                </button>
                                                <div class="sidebar-submenu ">
                                                    <ul>
                                                        
                                                            
                                                            
                                                                <li class=" "><a class="sidebar-nested-link" href="https://docs.cakepanit.com/docs/ops/kubernetes/1.kubernetes-v1.28.3%E4%BA%8C%E8%BF%9B%E5%88%B6%E9%83%A8%E7%BD%B2/">1.Kubernetes-v1.28.3高可用集群二进制部署(IPv4&#43;IPv6双栈)</a></li>
                                                            
                                                        
                                                            
                                                            
                                                                <li class=" "><a class="sidebar-nested-link" href="https://docs.cakepanit.com/docs/ops/kubernetes/2.kubernetes-v1.30.2%E4%BA%8C%E8%BF%9B%E5%88%B6%E9%83%A8%E7%BD%B2/">2.Kubernetes-v1.30.2高可用集群二进制部署(IPv4&#43;IPv6双栈)</a></li>
                                                            
                                                        
                                                            
                                                            
                                                                <li class=" "><a class="sidebar-nested-link" href="https://docs.cakepanit.com/docs/ops/kubernetes/3.%E5%8D%87%E7%BA%A7%E4%BA%8C%E8%BF%9B%E5%88%B6%E9%83%A8%E7%BD%B2%E7%9A%84kubernetes%E9%9B%86%E7%BE%A4/">3.升级二进制部署的kubernetes集群</a></li>
                                                            
                                                        
                                                            
                                                            
                                                                <li class=" "><a class="sidebar-nested-link" href="https://docs.cakepanit.com/docs/ops/kubernetes/4.kubernetes%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%E4%BB%8B%E7%BB%8D/">4.Kubernetes核心概念介绍</a></li>
                                                            
                                                        
                                                    </ul>
                                                </div>
                                            </li>
                                        
                                    
                                        
                                        
                                            <li class="sidebar-dropdown nested  ">
                                                <button class="btn">
                                                    
                                                    Container
                                                </button>
                                                <div class="sidebar-submenu ">
                                                    <ul>
                                                        
                                                            
                                                            
                                                                <li class="sidebar-dropdown nested  ">
                                                                    <button class="btn">
                                                                        
                                                                        Containerd
                                                                    </button>
                                                                    <div class="sidebar-submenu ">
                                                                        <ul>
                                                                            
                                                                                
                                                                                
                                                                                    <li class=" "><a class="sidebar-nested-link" href="https://docs.cakepanit.com/docs/ops/container/containerd/1.containerd%E8%BD%BB%E9%87%8F%E7%BA%A7or%E5%B7%A5%E4%B8%9A%E7%BA%A7%E7%9A%84%E5%AE%B9%E5%99%A8%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/">1.Containerd轻量级or工业级的容器管理工具</a></li>
                                                                                
                                                                            
                                                                        </ul>
                                                                    </div>
                                                                </li>
                                                            
                                                        
                                                            
                                                            
                                                                <li class="sidebar-dropdown nested  ">
                                                                    <button class="btn">
                                                                        
                                                                        Docker
                                                                    </button>
                                                                    <div class="sidebar-submenu ">
                                                                        <ul>
                                                                            
                                                                                
                                                                                
                                                                                    <li class=" "><a class="sidebar-nested-link" href="https://docs.cakepanit.com/docs/ops/container/docker/1.docker%E9%95%9C%E5%83%8F%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E5%92%8C%E4%BB%8B%E7%BB%8D/">1.Docker镜像基本操作和介绍</a></li>
                                                                                
                                                                            
                                                                                
                                                                                
                                                                                    <li class=" "><a class="sidebar-nested-link" href="https://docs.cakepanit.com/docs/ops/container/docker/2.docker%E5%AE%B9%E5%99%A8%E9%95%9C%E5%83%8F%E5%9B%BD%E5%86%85%E5%8A%A0%E9%80%9F%E5%8F%8A%E6%9C%AC%E5%9C%B0%E5%AE%B9%E5%99%A8%E9%95%9C%E5%83%8F%E4%BB%93%E5%BA%93%E6%90%AD%E5%BB%BA/">2.Docker容器镜像国内加速及本地容器镜像仓库搭建</a></li>
                                                                                
                                                                            
                                                                                
                                                                                
                                                                                    <li class=" "><a class="sidebar-nested-link" href="https://docs.cakepanit.com/docs/ops/container/docker/3.dockerfile%E4%BB%8B%E7%BB%8D/">3.Dockerfile介绍</a></li>
                                                                                
                                                                            
                                                                        </ul>
                                                                    </div>
                                                                </li>
                                                            
                                                        
                                                            
                                                            
                                                                <li class=" "><a class="sidebar-nested-link" href="https://docs.cakepanit.com/docs/ops/container/1.%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF%E6%89%80%E6%B6%89%E5%8F%8A%E7%9A%84linux%E5%86%85%E6%A0%B8%E5%85%B3%E9%94%AE%E6%8A%80%E6%9C%AF/">1.容器技术所涉及的Linux内核关键技术</a></li>
                                                            
                                                        
                                                    </ul>
                                                </div>
                                            </li>
                                        
                                    
                                        
                                        
                                            <li class=" "><a class="sidebar-nested-link" href="https://docs.cakepanit.com/docs/ops/1.nginx%E9%85%8D%E7%BD%AE%E5%B0%8F%E5%85%A8/">1.Nginx配置小全</a></li>
                                        
                                    
                                </ul>
                            </div>
                        </li>
                    
                
                    
                    
                        <li class="sidebar-dropdown  ">
                            <button class="btn">
                                <i class="material-icons me-2">database</i>
                                DBA
                            </button>
                            <div class="sidebar-submenu ">
                                <ul>
                                    
                                        
                                        
                                            <li class=" "><a class="sidebar-nested-link" href="https://docs.cakepanit.com/docs/dba/dome/">第一篇WIKI</a></li>
                                        
                                    
                                </ul>
                            </div>
                        </li>
                    
                
                    
                    
                        <li class="sidebar-dropdown  ">
                            <button class="btn">
                                <i class="material-icons me-2">edit</i>
                                DEMO
                            </button>
                            <div class="sidebar-submenu ">
                                <ul>
                                    
                                        
                                        
                                            <li class="sidebar-dropdown nested  ">
                                                <button class="btn">
                                                    
                                                    Features
                                                </button>
                                                <div class="sidebar-submenu ">
                                                    <ul>
                                                        
                                                            
                                                            
                                                                <li class=" "><a class="sidebar-nested-link" href="https://docs.cakepanit.com/docs/demo/features/syntax-highlighting/">Syntax Highlighting</a></li>
                                                            
                                                        
                                                            
                                                            
                                                                <li class=" "><a class="sidebar-nested-link" href="https://docs.cakepanit.com/docs/demo/features/katex/">KaTex</a></li>
                                                            
                                                        
                                                            
                                                            
                                                                <li class=" "><a class="sidebar-nested-link" href="https://docs.cakepanit.com/docs/demo/features/mermaid/">Mermaid</a></li>
                                                            
                                                        
                                                    </ul>
                                                </div>
                                            </li>
                                        
                                    
                                        
                                        
                                            <li class="sidebar-dropdown nested  ">
                                                <button class="btn">
                                                    
                                                    Shortcodes
                                                </button>
                                                <div class="sidebar-submenu ">
                                                    <ul>
                                                        
                                                            
                                                            
                                                                <li class=" "><a class="sidebar-nested-link" href="https://docs.cakepanit.com/docs/demo/shortcodes/alerts/">Alerts</a></li>
                                                            
                                                        
                                                            
                                                            
                                                                <li class=" "><a class="sidebar-nested-link" href="https://docs.cakepanit.com/docs/demo/shortcodes/tables/">Tables</a></li>
                                                            
                                                        
                                                            
                                                            
                                                                <li class=" "><a class="sidebar-nested-link" href="https://docs.cakepanit.com/docs/demo/shortcodes/tabs/">Tabs</a></li>
                                                            
                                                        
                                                            
                                                            
                                                                <li class=" "><a class="sidebar-nested-link" href="https://docs.cakepanit.com/docs/demo/shortcodes/prism/">Prism</a></li>
                                                            
                                                        
                                                            
                                                            
                                                                <li class=" "><a class="sidebar-nested-link" href="https://docs.cakepanit.com/docs/demo/shortcodes/markdownify/">Markdownify</a></li>
                                                            
                                                        
                                                            
                                                            
                                                                <li class=" "><a class="sidebar-nested-link" href="https://docs.cakepanit.com/docs/demo/shortcodes/katex/">KaTex</a></li>
                                                            
                                                        
                                                    </ul>
                                                </div>
                                            </li>
                                        
                                    
                                </ul>
                            </div>
                        </li>
                    
                
            
        </ul>
        
    </div>
    
        <ul class="sidebar-footer list-unstyled mb-0">
            
        </ul>
    
</nav>

                    <main class="page-content bg-transparent">
                        
<div id="top-header" class="top-header d-print-none">
    <div class="header-bar d-flex justify-content-between">
        <div class="d-flex align-items-center">
            <a href='/' class="logo-icon me-3" aria-label="HomePage" alt="HomePage">
                <div class="small">
                    
                            <?xml version="1.0" encoding="UTF-8"?><svg id="Layer_1" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 250 250"><path d="m143,39.5c-18,0-18,18-18,18,0,0,0-18-18-18H22c-2.76,0-5,2.24-5,5v143c0,2.76,2.24,5,5,5h76c7.2,0,8.64,11.52,8.93,16.13.07,1.05.95,1.87,2,1.87h32.14c1.06,0,1.94-.82,2-1.87.29-4.61,1.73-16.13,8.93-16.13h76c2.76,0,5-2.24,5-5V44.5c0-2.76-2.24-5-5-5h-85Zm63,123.5c0,1.38-1.12,2.5-2.5,2.5h-60.5c-18,0-18,18-18,18,0,0,0-18-18-18h-60.5c-1.38,0-2.5-1.12-2.5-2.5v-94c0-1.38,1.12-2.5,2.5-2.5h51.5c7.2,0,8.64,11.52,8.93,16.13.07,1.05.95,1.87,2,1.87h32.14c1.06,0,1.94-.82,2-1.87.29-4.61,1.73-16.13,8.93-16.13h51.5c1.38,0,2.5,1.12,2.5,2.5v94Z" style="fill:#06f;"/></svg>
                    
                </div>
                <div class="big">
                    
                            <?xml version="1.0" encoding="UTF-8"?><svg id="Layer_1" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 250 250"><path d="m143,39.5c-18,0-18,18-18,18,0,0,0-18-18-18H22c-2.76,0-5,2.24-5,5v143c0,2.76,2.24,5,5,5h76c7.2,0,8.64,11.52,8.93,16.13.07,1.05.95,1.87,2,1.87h32.14c1.06,0,1.94-.82,2-1.87.29-4.61,1.73-16.13,8.93-16.13h76c2.76,0,5-2.24,5-5V44.5c0-2.76-2.24-5-5-5h-85Zm63,123.5c0,1.38-1.12,2.5-2.5,2.5h-60.5c-18,0-18,18-18,18,0,0,0-18-18-18h-60.5c-1.38,0-2.5-1.12-2.5-2.5v-94c0-1.38,1.12-2.5,2.5-2.5h51.5c7.2,0,8.64,11.52,8.93,16.13.07,1.05.95,1.87,2,1.87h32.14c1.06,0,1.94-.82,2-1.87.29-4.61,1.73-16.13,8.93-16.13h51.5c1.38,0,2.5,1.12,2.5,2.5v94Z" style="fill:#06f;"/></svg>
                    
                </div>
            </a>
            <button id="close-sidebar" class="btn btn-icon btn-soft">
                <span class="material-icons size-20 menu-icon align-middle">menu</span>
            </button>
            
            
                    
                    <button id="flexsearch-button" class="ms-3 btn btn-soft" data-bs-toggle="collapse" data-bs-target="#FlexSearchCollapse" aria-expanded="false" aria-controls="FlexSearchCollapse">
                        <span class="material-icons size-20 menu-icon align-middle">search</span>
                        <span class="flexsearch-button-placeholder ms-1 me-2 d-none d-sm-block">Search</span>
                        <div class="d-none d-sm-block">
                            <span class="flexsearch-button-keys">
                                <kbd class="flexsearch-button-cmd-key">
                                    <svg width="44" height="15"><path d="M2.118,11.5A1.519,1.519,0,0,1,1,11.042,1.583,1.583,0,0,1,1,8.815a1.519,1.519,0,0,1,1.113-.458h.715V6.643H2.118A1.519,1.519,0,0,1,1,6.185,1.519,1.519,0,0,1,.547,5.071,1.519,1.519,0,0,1,1,3.958,1.519,1.519,0,0,1,2.118,3.5a1.519,1.519,0,0,1,1.114.458A1.519,1.519,0,0,1,3.69,5.071v.715H5.4V5.071A1.564,1.564,0,0,1,6.976,3.5,1.564,1.564,0,0,1,8.547,5.071,1.564,1.564,0,0,1,6.976,6.643H6.261V8.357h.715a1.575,1.575,0,0,1,1.113,2.685,1.583,1.583,0,0,1-2.227,0A1.519,1.519,0,0,1,5.4,9.929V9.214H3.69v.715a1.519,1.519,0,0,1-.458,1.113A1.519,1.519,0,0,1,2.118,11.5Zm0-.857a.714.714,0,0,0,.715-.714V9.214H2.118a.715.715,0,1,0,0,1.429Zm4.858,0a.715.715,0,1,0,0-1.429H6.261v.715a.714.714,0,0,0,.715.714ZM3.69,8.357H5.4V6.643H3.69ZM2.118,5.786h.715V5.071a.714.714,0,0,0-.715-.714.715.715,0,0,0-.5,1.22A.686.686,0,0,0,2.118,5.786Zm4.143,0h.715a.715.715,0,0,0,.5-1.22.715.715,0,0,0-1.22.5Z" fill="currentColor"></path><path d="M12.4,11.475H11.344l3.879-7.95h1.056Z" fill="currentColor"></path><path d="M25.073,5.384l-.864.576a2.121,2.121,0,0,0-1.786-.923,2.207,2.207,0,0,0-2.266,2.326,2.206,2.206,0,0,0,2.266,2.325,2.1,2.1,0,0,0,1.782-.918l.84.617a3.108,3.108,0,0,1-2.622,1.293,3.217,3.217,0,0,1-3.349-3.317,3.217,3.217,0,0,1,3.349-3.317A3.046,3.046,0,0,1,25.073,5.384Z" fill="currentColor"></path><path d="M30.993,5.142h-2.07v5.419H27.891V5.142h-2.07V4.164h5.172Z" fill="currentColor"></path><path d="M34.67,4.164c1.471,0,2.266.658,2.266,1.851,0,1.087-.832,1.809-2.134,1.855l2.107,2.691h-1.28L33.591,7.87H33.07v2.691H32.038v-6.4Zm-1.6.969v1.8h1.572c.832,0,1.22-.3,1.22-.918s-.411-.882-1.22-.882Z" fill="currentColor"></path><path d="M42.883,10.561H38.31v-6.4h1.033V9.583h3.54Z" fill="currentColor"></path></svg>
                                </kbd>
                                <kbd class="flexsearch-button-key">
                                    <svg width="15" height="15"><path d="M5.926,12.279H4.41L9.073,2.721H10.59Z" fill="currentColor"/></svg>
                                </kbd>
                            </span>
                        </div>
                    </button>
                
            </div>

        <div class="d-flex align-items-center">
            <ul class="list-unstyled mb-0">
                
                
                    
                    <li class="list-inline-item mb-0">
                        <a href=" https://github.com/bingdang " alt="github" rel="noopener noreferrer" target="_blank">
                            <div class="btn btn-icon btn-default border-0">
                                
                                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><title>GitHub</title><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path></svg>
                                
                            </div>
                        </a>
                    </li>
                    
                
            </ul>
            <button id="mode" class="btn btn-icon btn-default ms-2" type="button" aria-label="Toggle user interface mode">
                <span class="toggle-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" height="30" width="30" viewBox="0 0 48 48" fill="currentColor">
                        <title>Enable dark mode</title>
                        <path d="M24 42q-7.5 0-12.75-5.25T6 24q0-7.5 5.25-12.75T24 6q.4 0 .85.025.45.025 1.15.075-1.8 1.6-2.8 3.95-1 2.35-1 4.95 0 4.5 3.15 7.65Q28.5 25.8 33 25.8q2.6 0 4.95-.925T41.9 22.3q.05.6.075.975Q42 23.65 42 24q0 7.5-5.25 12.75T24 42Zm0-3q5.45 0 9.5-3.375t5.05-7.925q-1.25.55-2.675.825Q34.45 28.8 33 28.8q-5.75 0-9.775-4.025T19.2 15q0-1.2.25-2.575.25-1.375.9-3.125-4.9 1.35-8.125 5.475Q9 18.9 9 24q0 6.25 4.375 10.625T24 39Zm-.2-14.85Z"/>
                    </svg>
                </span>
                <span class="toggle-light">
                    <svg xmlns="http://www.w3.org/2000/svg" height="30" width="30" viewBox="0 0 48 48" fill="currentColor">
                        <title>Enable light mode</title>
                        <path d="M24 31q2.9 0 4.95-2.05Q31 26.9 31 24q0-2.9-2.05-4.95Q26.9 17 24 17q-2.9 0-4.95 2.05Q17 21.1 17 24q0 2.9 2.05 4.95Q21.1 31 24 31Zm0 3q-4.15 0-7.075-2.925T14 24q0-4.15 2.925-7.075T24 14q4.15 0 7.075 2.925T34 24q0 4.15-2.925 7.075T24 34ZM3.5 25.5q-.65 0-1.075-.425Q2 24.65 2 24q0-.65.425-1.075Q2.85 22.5 3.5 22.5h5q.65 0 1.075.425Q10 23.35 10 24q0 .65-.425 1.075-.425.425-1.075.425Zm36 0q-.65 0-1.075-.425Q38 24.65 38 24q0-.65.425-1.075.425-.425 1.075-.425h5q.65 0 1.075.425Q46 23.35 46 24q0 .65-.425 1.075-.425.425-1.075.425ZM24 10q-.65 0-1.075-.425Q22.5 9.15 22.5 8.5v-5q0-.65.425-1.075Q23.35 2 24 2q.65 0 1.075.425.425.425.425 1.075v5q0 .65-.425 1.075Q24.65 10 24 10Zm0 36q-.65 0-1.075-.425-.425-.425-.425-1.075v-5q0-.65.425-1.075Q23.35 38 24 38q.65 0 1.075.425.425.425.425 1.075v5q0 .65-.425 1.075Q24.65 46 24 46ZM12 14.1l-2.85-2.8q-.45-.45-.425-1.075.025-.625.425-1.075.45-.45 1.075-.45t1.075.45L14.1 12q.4.45.4 1.05 0 .6-.4 1-.4.45-1.025.45-.625 0-1.075-.4Zm24.7 24.75L33.9 36q-.4-.45-.4-1.075t.45-1.025q.4-.45 1-.45t1.05.45l2.85 2.8q.45.45.425 1.075-.025.625-.425 1.075-.45.45-1.075.45t-1.075-.45ZM33.9 14.1q-.45-.45-.45-1.05 0-.6.45-1.05l2.8-2.85q.45-.45 1.075-.425.625.025 1.075.425.45.45.45 1.075t-.45 1.075L36 14.1q-.4.4-1.025.4-.625 0-1.075-.4ZM9.15 38.85q-.45-.45-.45-1.075t.45-1.075L12 33.9q.45-.45 1.05-.45.6 0 1.05.45.45.45.45 1.05 0 .6-.45 1.05l-2.8 2.85q-.45.45-1.075.425-.625-.025-1.075-.425ZM24 24Z"/>
                    </svg>
                </span>
            </button>
            
        </div>
    </div>
    
    
            <div class="collapse" id="FlexSearchCollapse">
                <div class="flexsearch-container">
                    <div class="flexsearch-keymap">
                        <li>
                            <kbd class="flexsearch-button-cmd-key"><svg width="15" height="15" aria-label="Arrow down" role="img"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.2"><path d="M7.5 3.5v8M10.5 8.5l-3 3-3-3"></path></g></svg></kbd>
                            <kbd class="flexsearch-button-cmd-key"><svg width="15" height="15" aria-label="Arrow up" role="img"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.2"><path d="M7.5 11.5v-8M10.5 6.5l-3-3-3 3"></path></g></svg></kbd>
                            <span class="flexsearch-key-label">to navigate</span>
                        </li>
                        <li>
                            <kbd class="flexsearch-button-cmd-key"><svg width="15" height="15" aria-label="Enter key" role="img"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.2"><path d="M12 3.53088v3c0 1-1 2-2 2H4M7 11.53088l-3-3 3-3"></path></g></svg></kbd>
                            <span class="flexsearch-key-label">to select</span>
                        </li>
                        <li>
                            <kbd class="flexsearch-button-cmd-key"><svg width="15" height="15" aria-label="Escape key" role="img"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.2"><path d="M13.6167 8.936c-.1065.3583-.6883.962-1.4875.962-.7993 0-1.653-.9165-1.653-2.1258v-.5678c0-1.2548.7896-2.1016 1.653-2.1016.8634 0 1.3601.4778 1.4875 1.0724M9 6c-.1352-.4735-.7506-.9219-1.46-.8972-.7092.0246-1.344.57-1.344 1.2166s.4198.8812 1.3445.9805C8.465 7.3992 8.968 7.9337 9 8.5c.032.5663-.454 1.398-1.4595 1.398C6.6593 9.898 6 9 5.963 8.4851m-1.4748.5368c-.2635.5941-.8099.876-1.5443.876s-1.7073-.6248-1.7073-2.204v-.4603c0-1.0416.721-2.131 1.7073-2.131.9864 0 1.6425 1.031 1.5443 2.2492h-2.956"></path></g></svg></kbd>
                            <span class="flexsearch-key-label">to close</span>
                        </li>
                    </div>
                    <form class="flexsearch position-relative flex-grow-1 ms-2 me-2">
                        <div class="d-flex flex-row">
                            <input id="flexsearch" class="form-control" type="search" placeholder="Search" aria-label="Search" autocomplete="off">
                            <button id="hideFlexsearch" type="button" class="ms-2 btn btn-soft">
                                cancel
                            </button>
                        </div>
                        <div id="suggestions" class="shadow rounded-1 d-none"></div>
                    </form>
                </div>
            </div>
        
    
    
</div>

                            <div class="container-fluid">
                                <div class="layout-spacing">
                                    
                                        <div class="d-md-flex justify-content-between align-items-center"><nav aria-label="breadcrumb" class="d-inline-block pb-2 mt-1 mt-sm-0">
    <ul id="breadcrumbs" class="breadcrumb bg-transparent mb-0" itemscope itemtype="https://schema.org/BreadcrumbList">
        
            
                <li class="breadcrumb-item text-capitalize active" aria-current="page" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem">
                    <a itemprop="item" href="/docs/">
                        <i class="material-icons size-20 align-text-bottom" itemprop="name">Home</i>
                    </a>
                    <meta itemprop="position" content='1' />
                </li>
            
            
                <li class="breadcrumb-item text-capitalize" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem">
                    <a itemprop="item" href="/docs/dev/">
                        <span itemprop="name">DEV</span>
                    </a>
                    <meta itemprop="position" content='2' />
                </li>
            
            
                <li class="breadcrumb-item text-capitalize" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem">
                    <a itemprop="item" href="/docs/dev/23designpattern/">
                        <span itemprop="name">23种设计模式</span>
                    </a>
                    <meta itemprop="position" content='3' />
                </li>
            
        
            <li class="breadcrumb-item text-capitalize active" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem">
                <span itemprop="name">2.工厂方法模式</span>
                <meta itemprop="position" content='4' />
            </li>
        
    </ul>
</nav></div>
                                    
                                    <div class="row flex-xl-nowrap">
                                        
                                        <div class="docs-toc col-xl-3    d-xl-block"><toc>
    <div class="fw-bold text-uppercase mb-2">On this page</div>
    <nav id="toc">
  <ul>
    <li>
      <ul>
        <li>
          <ul>
            <li><a href="#需求">需求</a></li>
            <li><a href="#简单工厂模式">简单工厂模式</a></li>
            <li><a href="#什么是工厂方法模式">什么是工厂方法模式</a></li>
            <li><a href="#基本实现">基本实现</a></li>
            <li><a href="#应用场景">应用场景</a></li>
            <li><a href="#本题代码">本题代码</a></li>
          </ul>
        </li>
        <li><a href="#其他语言版本">其他语言版本</a>
          <ul>
            <li><a href="#java">Java</a></li>
            <li><a href="#cpp">Cpp</a></li>
            <li><a href="#python">Python</a></li>
            <li><a href="#go">Go</a></li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</nav>
    </toc></div>
                                        
                                        
                                        <div class="docs-toc-mobile    d-print-none d-xl-none">
                                            <button id="toc-dropdown-btn" class="btn-secondary dropdown-toggle" type="button" data-bs-toggle="dropdown" data-bs-offset="0,0" aria-expanded="false">
                                                Table of Contents
                                            </button>
<nav id="toc-mobile">
  <ul class="dropdown-menu">
    <li>
      <ul>
        <li>
          <ul>
            <li><a href="#需求">需求</a></li>
            <li><a href="#简单工厂模式">简单工厂模式</a></li>
            <li><a href="#什么是工厂方法模式">什么是工厂方法模式</a></li>
            <li><a href="#基本实现">基本实现</a></li>
            <li><a href="#应用场景">应用场景</a></li>
            <li><a href="#本题代码">本题代码</a></li>
          </ul>
        </li>
        <li><a href="#其他语言版本">其他语言版本</a>
          <ul>
            <li><a href="#java">Java</a></li>
            <li><a href="#cpp">Cpp</a></li>
            <li><a href="#python">Python</a></li>
            <li><a href="#go">Go</a></li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</nav></div>
                                        <div class="docs-content col-12 col-xl-9 mt-0">
                                            <div class="mb-0 d-flex">
                                                
                                                <i class="material-icons title-icon me-2">article</i>
                                                
                                                <h1 class="content-title mb-0">
                                                    2.工厂方法模式
                                                    
                                                </h1>
                                            </div>
                                            
                                                <p class="lead mb-3">简单工厂模式的核心思想是将产品的创建过程封装在一个工厂类中，把创建对象的流程集中在这个工厂类里面。</p>
                                            
                                            <div id="content" class="main-content" data-bs-spy="scroll" data-bs-root-margin="0px 0px -65%" data-bs-target="#toc-mobile">
                                                
    
    <div data-prismjs-copy="" data-prismjs-copy-success="" data-prismjs-copy-error="">
        <h3 id="需求">需求 <a href="#%e9%9c%80%e6%b1%82" class="anchor" aria-hidden="true"><i class="material-icons align-middle">link</i></a></h3><p>【设计模式专题之工厂方法模式】2.积木工厂</p>
<p><strong>题目描述</strong></p>
<ul>
<li>小明家有两个工厂，一个用于生产圆形积木，一个用于生产方形积木，请你帮他设计一个积木工厂系统，记录积木生产的信息。</li>
</ul>
<p><strong>输入描述</strong></p>
<ul>
<li>输入的第一行是一个整数 N（1 ≤ N ≤ 100），表示生产的次数。</li>
<li>接下来的 N 行，每行输入一个字符串和一个整数，字符串表示积木的类型。积木类型分为 &ldquo;Circle&rdquo; 和 &ldquo;Square&rdquo; 两种。整数表示该积木生产的数量</li>
</ul>
<p><strong>输出描述</strong></p>
<ul>
<li>对于每个积木，输出一行字符串表示该积木的信息。</li>
</ul>
<p><strong>输入示例</strong>






  
      <div class="prism-shortcode">
      <pre id="c2dee19" class="language-auto line-numbers"
        ><code class="language-auto"
        >3
Circle 1
Square 2
Circle 1
</code></pre>
      </div>
  
</p>
<p><strong>输出示例</strong>






  
      <div class="prism-shortcode">
      <pre id="738e7a3" class="language-auto line-numbers"
        ><code class="language-auto"
        >Circle Block
Square Block
Square Block
Circle Block
</code></pre>
      </div>
  
</p>
<p><strong>提示信息</strong>
在示例中，积木工厂生产了3块积木，其中有2块是圆形积木，1块是方形积木。根据输入的类型，每块积木的信息被输出到控制台。</p>
<h3 id="简单工厂模式">简单工厂模式 <a href="#%e7%ae%80%e5%8d%95%e5%b7%a5%e5%8e%82%e6%a8%a1%e5%bc%8f" class="anchor" aria-hidden="true"><i class="material-icons align-middle">link</i></a></h3><p>在了解工厂方法模式之前，有必要对“简单工厂”模式进行一定的了解，简单工厂模式是一种创建型设计模式，但并不属于23种设计模式之一，更多的是一种编程习惯。</p>
<p>简单工厂模式的核心思想是将产品的创建过程封装在一个工厂类中，把创建对象的流程集中在这个工厂类里面。</p>
<p>简单工厂模式包括三个主要角色，工厂类、抽象产品、具体产品，下面的图示则展示了工厂类的基本结构。</p>
<p>





  



  
    
      <img src="/images/23DesignPattern/image-2.png" alt="" width="1912" height="786" loading="lazy">
    
  
</p>
<ul>
<li>抽象产品，比如上图中的<code>Shape</code> 接口，描述产品的通用行为。</li>
<li>具体产品:  实现抽象产品接口或继承抽象产品类，比如上面的<code>Circle</code>类和<code>Square</code>类，具体产品通过简单工厂类的<code>if-else</code>逻辑来实例化。</li>
<li>工厂类：负责创建产品，根据传递的不同参数创建不同的产品示例。</li>
</ul>
<p>简单工厂类简化了客户端操作，客户端可以调用工厂方法来获取具体产品，而无需直接与具体产品类交互，降低了耦合，但是有一个很大的问题就是不够灵活，如果需要添加新的产品，就需要修改工厂类的代码。</p>
<h3 id="什么是工厂方法模式">什么是工厂方法模式 <a href="#%e4%bb%80%e4%b9%88%e6%98%af%e5%b7%a5%e5%8e%82%e6%96%b9%e6%b3%95%e6%a8%a1%e5%bc%8f" class="anchor" aria-hidden="true"><i class="material-icons align-middle">link</i></a></h3><p>工厂方法模式也是一种创建型设计模式，简单工厂模式只有一个工厂类，负责创建所有产品，如果要添加新的产品，通常需要修改工厂类的代码。而工厂方法模式引入了抽象工厂和具体工厂的概念，每个具体工厂只负责创建一个具体产品，添加新的产品只需要添加新的工厂类而无需修改原来的代码，这样就使得产品的生产更加灵活，支持扩展，符合开闭原则。</p>
<p>工厂方法模式分为以下几个角色：</p>
<ul>
<li>抽象工厂：一个接口，包含一个抽象的工厂方法（用于创建产品对象）。</li>
<li>具体工厂：实现抽象工厂接口，创建具体的产品。</li>
<li>抽象产品：定义产品的接口。</li>
<li>具体产品：实现抽象产品接口，是工厂创建的对象。</li>
</ul>
<blockquote>
<p>实际上工厂方法模式也很好理解，就拿“手机Phone”这个产品举例，手机是一个抽象产品，小米手机、华为手机、苹果手机是具体的产品实现，而不同品牌的手机在各自的生产厂家生产。</p>
</blockquote>
<p>





  



  
    
      <img src="/images/23DesignPattern/image-3.png" alt="" width="1726" height="922" loading="lazy">
    
  
</p>
<h3 id="基本实现">基本实现 <a href="#%e5%9f%ba%e6%9c%ac%e5%ae%9e%e7%8e%b0" class="anchor" aria-hidden="true"><i class="material-icons align-middle">link</i></a></h3><p>根据上面的类图，我们可以写出工厂方法模式的基本实现。</p>






  
      <div class="prism-shortcode">
      <pre id="17d9857" class="language-java line-numbers"
        ><code class="language-java"
        >// 抽象产品
interface Shape {
    void draw();
}

// 具体产品 - 圆形
class Circle implements Shape {
    @Override
    public void draw() {
        System.out.println(&#34;Circle&#34;);
    }
}

// 具体产品 - 正方形
class Square implements Shape {
    @Override
    public void draw() {
        System.out.println(&#34;Square&#34;);
    }
}

// 抽象工厂
interface ShapeFactory {
    Shape createShape();
}

// 具体工厂 - 创建圆形
class CircleFactory implements ShapeFactory {
    @Override
    public Shape createShape() {
        return new Circle();
    }
}

// 具体工厂 - 创建正方形
class SquareFactory implements ShapeFactory {
    @Override
    public Shape createShape() {
        return new Square();
    }
}

// 客户端代码
public class Client {
    public static void main(String[] args) {
        ShapeFactory circleFactory = new CircleFactory();
        Shape circle = circleFactory.createShape();
        circle.draw();  // 输出：Circle

        ShapeFactory squareFactory = new SquareFactory();
        Shape square = squareFactory.createShape();
        square.draw();  // 输出：Square
    }
}
</code></pre>
      </div>
  

<h3 id="应用场景">应用场景 <a href="#%e5%ba%94%e7%94%a8%e5%9c%ba%e6%99%af" class="anchor" aria-hidden="true"><i class="material-icons align-middle">link</i></a></h3><p>工厂方法模式使得每个工厂类的职责单一，每个工厂只负责创建一种产品，当创建对象涉及一系列复杂的初始化逻辑，而这些逻辑在不同的子类中可能有所不同时，可以使用工厂方法模式将这些初始化逻辑封装在子类的工厂中。在现有的工具、库中，工厂方法模式也有广泛的应用，比如：</p>
<ul>
<li>Spring 框架中的 Bean 工厂：通过配置文件或注解，Spring 可以根据配置信息动态地创建和管理对象。</li>
<li>JDBC 中的 Connection 工厂：在 Java 数据库连接中，<code>DriverManager</code> 使用工厂方法模式来创建数据库连接。不同的数据库驱动（如 MySQL、PostgreSQL 等）都有对应的工厂来创建连接。</li>
</ul>
<h3 id="本题代码">本题代码 <a href="#%e6%9c%ac%e9%a2%98%e4%bb%a3%e7%a0%81" class="anchor" aria-hidden="true"><i class="material-icons align-middle">link</i></a></h3>





  
      <div class="prism-shortcode">
      <pre id="54ffc80" class="language-java line-numbers"
        ><code class="language-java"
        >import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;

// 抽象积木接口
interface Block {
    void produce();
}

// 具体圆形积木实现
class CircleBlock implements Block {
    @Override
    public void produce() {
        System.out.println(&#34;Circle Block&#34;);
    }
}

// 具体方形积木实现
class SquareBlock implements Block {
    @Override
    public void produce() {
        System.out.println(&#34;Square Block&#34;);
    }
}

// 抽象积木工厂接口
interface BlockFactory {
    Block createBlock();
}

// 具体圆形积木工厂实现
class CircleBlockFactory implements BlockFactory {
    @Override
    public Block createBlock() {
        return new CircleBlock();
    }
}

// 具体方形积木工厂实现
class SquareBlockFactory implements BlockFactory {
    @Override
    public Block createBlock() {
        return new SquareBlock();
    }
}

// 积木工厂系统
class BlockFactorySystem {
    private List&lt;Block&gt; blocks = new ArrayList&lt;&gt;();

    public void produceBlocks(BlockFactory factory, int quantity) {
        for (int i = 0; i &lt; quantity; i&#43;&#43;) {
            Block block = factory.createBlock();
            blocks.add(block);
            block.produce();
        }
    }

    public List&lt;Block&gt; getBlocks() {
        return blocks;
    }
}

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        // 创建积木工厂系统
        BlockFactorySystem factorySystem = new BlockFactorySystem();

        // 读取生产次数
        int productionCount = scanner.nextInt();
        scanner.nextLine();

        // 读取每次生产的积木类型和数量
        for (int i = 0; i &lt; productionCount; i&#43;&#43;) {
            String[] productionInfo = scanner.nextLine().split(&#34; &#34;);
            String blockType = productionInfo[0];
            int quantity = Integer.parseInt(productionInfo[1]);

            if (blockType.equals(&#34;Circle&#34;)) {
                factorySystem.produceBlocks(new CircleBlockFactory(), quantity);
            } else if (blockType.equals(&#34;Square&#34;)) {
                factorySystem.produceBlocks(new SquareBlockFactory(), quantity);
            }
        }
    }
}
</code></pre>
      </div>
  

<h2 id="其他语言版本">其他语言版本 <a href="#%e5%85%b6%e4%bb%96%e8%af%ad%e8%a8%80%e7%89%88%e6%9c%ac" class="anchor" aria-hidden="true"><i class="material-icons align-middle">link</i></a></h2><h3 id="java">Java <a href="#java" class="anchor" aria-hidden="true"><i class="material-icons align-middle">link</i></a></h3><p>利用反射实现工厂方法






  
      <div class="prism-shortcode">
      <pre id="daa8ecc" class="language-java line-numbers"
        ><code class="language-java"
        >import java.lang.reflect.Constructor;
import java.util.Scanner;

// 抽象工厂类
abstract class BlocksFactory {
    public abstract blocks createBlocks(Class&lt;blocks&gt; c, String str, int num);
}

//具体工厂实现类 
class BlocksFactoryImpl extends BlocksFactory {
		
    @Override
    public blocks createBlocks(Class&lt;blocks&gt; c, String str, int num) {
        try {
	    //反射获取blocks类中带有两个参数的构造器
            Constructor&lt;blocks&gt; constructor = c.getConstructor(String.class, int.class);
            return constructor.newInstance(str, num);
        } catch (Exception e) {
            e.printStackTrace();
            return null;
        }
    }
}

//定义积木接口
interface blocks {
    void blockPrint(String str, int num);
}

//圆形积木 
class CircleBlocks implements blocks{
    private String str;
    private int num;
     
    public CircleBlocks(String str, int num) {
        this.str = str;
        this.num = num;
    }
     
    public void blockPrint(String str,int num){
        for(int i=0;i&lt;num;i&#43;&#43;){
            System.out.println(str&#43;&#34; Block&#34;);
        }
    }
}

//方形积木 
class SquareBlocks implements blocks{
     
    private String str;
    private int num;
     
    public SquareBlocks(String str, int num) {
        this.str = str;
        this.num = num;
    }
     
    public void blockPrint(String str,int num){
        for(int i=0;i&lt;num;i&#43;&#43;){
            System.out.println(str&#43;&#34; Block&#34;);
        }
    }
}
 
public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int N = scanner.nextInt();
        
        //获取工厂实例
        BlocksFactory factory = new BlocksFactoryImpl();
 
        for (int n = 0; n &lt; N; n&#43;&#43;) { 
            String type = scanner.next();//用户输入类型（Circle 或 Square）
            int num = scanner.nextInt();// 用户输入数量
            
            //构建正确的类名，并第一个字母大写
            String className = type.substring(0, 1).toUpperCase() &#43; type.substring(1) &#43; &#34;Blocks&#34;; // 构造正确的类名
            try {
		//使用工厂方法创建对象
                blocks block = factory.createBlocks((Class&lt;blocks&gt;) Class.forName(className), type, num);
                if (block != null) {
                    block.blockPrint(type, num);
                }
            } catch (ClassNotFoundException e) {
                e.printStackTrace();
            }
        }
 
        scanner.close();
    }
}
</code></pre>
      </div>
  
</p>
<h3 id="cpp">Cpp <a href="#cpp" class="anchor" aria-hidden="true"><i class="material-icons align-middle">link</i></a></h3>





  
      <div class="prism-shortcode">
      <pre id="39ef8cf" class="language-cpp line-numbers"
        ><code class="language-cpp"
        >#include &lt;iostream&gt;
#include &lt;vector&gt;
 
// 抽象积木接口
class Block {
public:
    virtual void produce() = 0;
};
 
// 具体圆形积木实现
class CircleBlock : public Block {
public:
    void produce() override {
        std::cout &lt;&lt; &#34;Circle Block&#34; &lt;&lt; std::endl;
    }
};
 
// 具体方形积木实现
class SquareBlock : public Block {
public:
    void produce() override {
        std::cout &lt;&lt; &#34;Square Block&#34; &lt;&lt; std::endl;
    }
};
 
// 抽象积木工厂接口
class BlockFactory {
public:
    virtual Block* createBlock() = 0;
};
 
// 具体圆形积木工厂实现
class CircleBlockFactory : public BlockFactory {
public:
    Block* createBlock() override {
        return new CircleBlock();
    }
};
 
// 具体方形积木工厂实现
class SquareBlockFactory : public BlockFactory {
public:
    Block* createBlock() override {
        return new SquareBlock();
    }
};
 
// 积木工厂系统
class BlockFactorySystem {
private:
    std::vector&lt;Block*&gt; blocks;
 
public:
    void produceBlocks(BlockFactory* factory, int quantity) {
        for (int i = 0; i &lt; quantity; i&#43;&#43;) {
            Block* block = factory-&gt;createBlock();
            blocks.push_back(block);
            block-&gt;produce();
        }
    }
 
    const std::vector&lt;Block*&gt;&amp; getBlocks() const {
        return blocks;
    }
 
    ~BlockFactorySystem() {
        // 释放所有动态分配的积木对象
        for (Block* block : blocks) {
            delete block;
        }
    }
};
 
int main() {
    // 创建积木工厂系统
    BlockFactorySystem factorySystem;
 
    // 读取生产次数
    int productionCount;
    std::cin &gt;&gt; productionCount;
 
    // 读取每次生产的积木类型和数量
    for (int i = 0; i &lt; productionCount; i&#43;&#43;) {
        std::string blockType;
        int quantity;
        std::cin &gt;&gt; blockType &gt;&gt; quantity;
 
        if (blockType == &#34;Circle&#34;) {
            factorySystem.produceBlocks(new CircleBlockFactory(), quantity);
        } else if (blockType == &#34;Square&#34;) {
            factorySystem.produceBlocks(new SquareBlockFactory(), quantity);
        }
    }
 
    return 0;
}
</code></pre>
      </div>
  

<h3 id="python">Python <a href="#python" class="anchor" aria-hidden="true"><i class="material-icons align-middle">link</i></a></h3>





  
      <div class="prism-shortcode">
      <pre id="f95cbea" class="language-python line-numbers"
        ><code class="language-python"
        >from abc import ABC, abstractmethod

# 抽象积木接口
class Block(ABC):
    @abstractmethod
    def produce(self):
        pass

# 具体圆形积木实现
class CircleBlock(Block):
    def produce(self):
        print(&#34;Circle Block&#34;)

# 具体方形积木实现
class SquareBlock(Block):
    def produce(self):
        print(&#34;Square Block&#34;)

# 抽象积木工厂接口
class BlockFactory(ABC):
    @abstractmethod
    def create_block(self):
        pass

# 具体圆形积木工厂实现
class CircleBlockFactory(BlockFactory):
    def create_block(self):
        return CircleBlock()

# 具体方形积木工厂实现
class SquareBlockFactory(BlockFactory):
    def create_block(self):
        return SquareBlock()

# 积木工厂系统
class BlockFactorySystem:
    def __init__(self):
        self.blocks = []

    def produce_blocks(self, factory, quantity):
        for _ in range(quantity):
            block = factory.create_block()
            self.blocks.append(block)
            block.produce()

    def get_blocks(self):
        return self.blocks

# 主函数
def main():
    # 创建积木工厂系统
    factory_system = BlockFactorySystem()

    # 读取生产次数
    production_count = int(input())

    # 读取每次生产的积木类型和数量
    for _ in range(production_count):
        block_type, quantity = input().split()
        quantity = int(quantity)

        if block_type == &#34;Circle&#34;:
            factory_system.produce_blocks(CircleBlockFactory(), quantity)
        elif block_type == &#34;Square&#34;:
            factory_system.produce_blocks(SquareBlockFactory(), quantity)

if __name__ == &#34;__main__&#34;:
    main()
</code></pre>
      </div>
  

<h3 id="go">Go <a href="#go" class="anchor" aria-hidden="true"><i class="material-icons align-middle">link</i></a></h3>





  
      <div class="prism-shortcode">
      <pre id="e2af026" class="language-go line-numbers"
        ><code class="language-go"
        >package main

import (
	&#34;fmt&#34;
)

// 抽象积木接口
type Block interface {
	produce()
}

// 具体圆形积木实现
type CircleBlock struct{}

func (c *CircleBlock) produce() {
	fmt.Println(&#34;Circle Block&#34;)
}

// 具体方形积木实现
type SquareBlock struct{}

func (s *SquareBlock) produce() {
	fmt.Println(&#34;Square Block&#34;)
}

// 抽象积木工厂接口
type BlockFactory interface {
	createBlock() Block
}

// 具体圆形积木工厂实现
type CircleBlockFactory struct{}

func (cf *CircleBlockFactory) createBlock() Block {
	return &amp;CircleBlock{}
}

// 具体方形积木工厂实现
type SquareBlockFactory struct{}

func (sf *SquareBlockFactory) createBlock() Block {
	return &amp;SquareBlock{}
}

// 积木工厂系统
type BlockFactorySystem struct {
	blocks []Block
}

func (bfs *BlockFactorySystem) produceBlocks(factory BlockFactory, quantity int) {
	for i := 0; i &lt; quantity; i&#43;&#43; {
		block := factory.createBlock()
		bfs.blocks = append(bfs.blocks, block)
		block.produce()
	}
}

func (bfs *BlockFactorySystem) getBlocks() []Block {
	return bfs.blocks
}

func main() {
	// 创建积木工厂系统
	factorySystem := &amp;BlockFactorySystem{}

	// 读取生产次数
	var productionCount int
	fmt.Scan(&amp;productionCount)

	// 读取每次生产的积木类型和数量
	for i := 0; i &lt; productionCount; i&#43;&#43; {
		var blockType string
		var quantity int
		fmt.Scan(&amp;blockType, &amp;quantity)

		if blockType == &#34;Circle&#34; {
			factorySystem.produceBlocks(&amp;CircleBlockFactory{}, quantity)
		} else if blockType == &#34;Square&#34; {
			factorySystem.produceBlocks(&amp;SquareBlockFactory{}, quantity)
		}
	}
}
</code></pre>
      </div>
  


    </div>

    

    
                                            </div>
                                            <div><hr class="doc-hr">
<div id="doc-nav" class="d-print-none">

	<div class="row flex-xl-nowrap ">
	<div class="col-sm-6 pt-2 doc-next">
		<a href="/docs/dev/23designpattern/1.%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/">
			<div class="card h-100 my-1">
				<div class="card-body py-2">
                    <p class="card-title fs-5 fw-semibold lh-base mb-0"><i class="material-icons align-middle">navigate_before</i> 1.单例模式</p>
					<p class="card-text ms-2">单例模式是一种**创建型设计模式**， 它的核心思想是保 …</p>
					
				</div>
			</div>
		</a>
        </div>
	<div class="col-sm-6 pt-2 doc-prev">
		<a class="ms-auto" href="/docs/dev/23designpattern/3.%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/">
			<div class="card h-100 my-1 text-end">
				<div class="card-body py-2">
                    <p class="card-title fs-5 fw-semibold lh-base mb-0">3.抽象工厂模式 <i class="material-icons align-middle">navigate_next</i></p>
					<p class="card-text me-2">抽象工厂模式也是一种创建型设计模式，提供了一个创建一系列相关 …</p>
					
				</div>
			</div>
		</a>
        </div>
	</div>
</div></div>
                                        </div>
                                    </div>
                                </div>
                            </div>
<footer class="shadow py-3 d-print-none">
    <div class="container-fluid">
        <div class="row align-items-center">
            <div class="col">
                <div class="text-sm-start text-center mx-md-2">
                    <p class="mb-0">
                        
                        © 2024 <a href="https://cakepanit.com"><strong>Maxbit</strong></a>
                    </p>
                </div>
            </div>
        </div>
    </div>
</footer>
</main>
            </div>
        </div>

        
        
        <button onclick="topFunction()" id="back-to-top" aria-label="Back to Top Button" class="back-to-top fs-5"><svg width="24" height="24"><path d="M12,10.224l-6.3,6.3L4.32,15.152,12,7.472l7.68,7.68L18.3,16.528Z" style="fill:#fff"/></svg></button>
        
        

        
        
            <script>(()=>{var e=document.getElementById("mode");e!==null&&(window.matchMedia("(prefers-color-scheme: dark)").addEventListener("change",e=>{e.matches?(localStorage.setItem("theme","dark"),document.documentElement.setAttribute("data-dark-mode","")):(localStorage.setItem("theme","light"),document.documentElement.removeAttribute("data-dark-mode"))}),e.addEventListener("click",()=>{document.documentElement.toggleAttribute("data-dark-mode"),localStorage.setItem("theme",document.documentElement.hasAttribute("data-dark-mode")?"dark":"light")}),localStorage.getItem("theme")==="dark"?document.documentElement.setAttribute("data-dark-mode",""):document.documentElement.removeAttribute("data-dark-mode"))})()</script>
        




    
        
        
    
    






    

    <script src="/docs/js/bootstrap.eac7ee3f6fa791c684e7a51fc2fd50b6f724271b9e39562e4fe8c3942412df3acbfc4045f043d03399dac70091207507.js" integrity="sha384-6sfuP2&#43;nkcaE56Ufwv1QtvckJxueOVYuT&#43;jDlCQS3zrL/EBF8EPQM5naxwCRIHUH"defer></script>


    <script type="text/javascript" src="https://docs.cakepanit.com/docs/js/bundle.min.439192da4aa99015318b887b8fa242c713dcd7b69074f642b989fc9e7a043d0210c0af413ceccab86df420f2032593b8.js" integrity="sha384-Q5GS2kqpkBUxi4h7j6JCxxPc17aQdPZCuYn8nnoEPQIQwK9BPOzKuG30IPIDJZO4" crossorigin="anonymous" defer></script>
        

        
        <script type="module">
    var suggestions = document.getElementById('suggestions');
    var search = document.getElementById('flexsearch');

    const flexsearchContainer = document.getElementById('FlexSearchCollapse');

    const hideFlexsearchBtn = document.getElementById('hideFlexsearch');

    const configObject = { toggle: false }
    const flexsearchContainerCollapse = new Collapse(flexsearchContainer, configObject) 

    if (search !== null) {
        document.addEventListener('keydown', inputFocus);
        flexsearchContainer.addEventListener('shown.bs.collapse', function () {
            search.focus();
        });
        
        var topHeader = document.getElementById("top-header");
        document.addEventListener('click', function(elem) {
            if (!flexsearchContainer.contains(elem.target) && !topHeader.contains(elem.target))
                flexsearchContainerCollapse.hide();
        });
    }

    hideFlexsearchBtn.addEventListener('click', () =>{
        flexsearchContainerCollapse.hide()
    })

    function inputFocus(e) {
        if (e.ctrlKey && e.key === '/') {
            e.preventDefault();
            flexsearchContainerCollapse.toggle();
        }
        if (e.key === 'Escape' ) {
            search.blur();
            
            flexsearchContainerCollapse.hide();
        }
    };

    document.addEventListener('click', function(event) {

    var isClickInsideElement = suggestions.contains(event.target);

    if (!isClickInsideElement) {
        suggestions.classList.add('d-none');
    }

    });

    


    document.addEventListener('keydown',suggestionFocus);

    function suggestionFocus(e) {
    const suggestionsHidden = suggestions.classList.contains('d-none');
    if (suggestionsHidden) return;

    const focusableSuggestions= [...suggestions.querySelectorAll('a')];
    if (focusableSuggestions.length === 0) return;

    const index = focusableSuggestions.indexOf(document.activeElement);

    if (e.key === "ArrowUp") {
        e.preventDefault();
        const nextIndex = index > 0 ? index - 1 : 0;
        focusableSuggestions[nextIndex].focus();
    }
    else if (e.key === "ArrowDown") {
        e.preventDefault();
        const nextIndex= index + 1 < focusableSuggestions.length ? index + 1 : index;
        focusableSuggestions[nextIndex].focus();
    }

    }

    


    (function(){

    var index = new FlexSearch.Document({
        
        tokenize: "forward",
        minlength:  0 ,
        cache:  100 ,
        optimize:  true ,
        document: {
        id: 'id',
        store: [
            "href", "title", "description"
        ],
        index: ["title", "description", "content"]
        }
    });


    


    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    


    

    

    index.add(
            {
                id:  0 ,
                href: "\/docs\/dev\/23designpattern\/",
                title: "23种设计模式",
                description: "设计模式是一套理论, 由软件界先辈们总结出的一套可以反复使用的经验, 可以帮助开发人员降低代码耦合度、提高代码的重用性、扩展性和系统可维护性，以及巧妙解决一系列逻辑复杂的问题(运用套路)。然而需要注意的是，过度使用设计模式也可能会导致代码过于复杂和晦涩，因此在实际开发中需要根据具体情况进行选择和应用。",
                content: ""
            }
        );
    index.add(
            {
                id:  1 ,
                href: "\/docs\/dev\/",
                title: "DEV",
                description: "编码相关",
                content: ""
            }
        );
    index.add(
            {
                id:  2 ,
                href: "\/docs\/",
                title: "Index",
                description: "仰望星空，脚踏实地",
                content: ""
            }
        );
    index.add(
            {
                id:  3 ,
                href: "\/docs\/ops\/",
                title: "OPS",
                description: "SRE/运维相关",
                content: ""
            }
        );
    index.add(
            {
                id:  4 ,
                href: "\/docs\/dba\/",
                title: "DBA",
                description: "数据库相关",
                content: ""
            }
        );
    index.add(
            {
                id:  5 ,
                href: "\/docs\/dba\/dome\/",
                title: "第一篇WIKI",
                description: "A quickstart guide to creating new content in Lotus Docs",
                content: "Create New Content linkNavigate to the root of your Hugo project and use the hugo new command to create a file in the content/docs directory:\nhugo new docs/examplepage.md "
            }
        );
    index.add(
            {
                id:  6 ,
                href: "\/docs\/demo\/",
                title: "DEMO",
                description: "模版",
                content: ""
            }
        );
    index.add(
            {
                id:  7 ,
                href: "\/docs\/dev\/golang\/",
                title: "Golang",
                description: "Go语言相关文档",
                content: ""
            }
        );
    index.add(
            {
                id:  8 ,
                href: "\/docs\/dev\/front-end\/",
                title: "前端",
                description: "前端开发相关文档",
                content: ""
            }
        );
    index.add(
            {
                id:  9 ,
                href: "\/docs\/ops\/kubernetes\/",
                title: "Kubernetes",
                description: "Kubernetes（简称k8s）是Google在2014年6月开源的一个容器集群管理系统，使用Go语言开发，用于管理云平台中多个主机上的容器化的应用，Kubernetes的目标是让部署容器化的应用简单并且高效,Kubernetes提供了资源调度、部署管理、服务发现、扩容缩容、监控，维护等一整套功能。努力成为跨主机集群的自动部署、扩展以及运行应用程序容器的平台。 它支持一系列容器工具。",
                content: ""
            }
        );
    index.add(
            {
                id:  10 ,
                href: "\/docs\/ops\/container\/",
                title: "Container",
                description: "Linux 容器是一种操作系统级别的虚拟化技术，它允许在单个Linux 系统上运行多个独立的应用程序，每个应用程序都运行在自己的隔离容器中，就好像它们在独立的计算机上运行一样。 Linux 容器使用一些Linux 内核的特性，例如cgroups 和命名空间，来实现容器之间的隔离和资源管理。",
                content: ""
            }
        );
    index.add(
            {
                id:  11 ,
                href: "\/docs\/ops\/container\/containerd\/",
                title: "Containerd",
                description: "Containerd 是一个工业级标准的容器运行时，它强调简单性、健壮性和可移植性。",
                content: ""
            }
        );
    index.add(
            {
                id:  12 ,
                href: "\/docs\/ops\/container\/docker\/",
                title: "Docker",
                description: "Docker是一个开放源代码的开放平台软件，用于开发应用、交付应用和运行应用。Docker允许用户将基础设施中的应用单独分割出来，形成更小的颗粒，从而提高交付软件的速度。",
                content: ""
            }
        );
    index.add(
            {
                id:  13 ,
                href: "\/docs\/dev\/23designpattern\/1.%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F\/",
                title: "1.单例模式",
                description: "单例模式是一种**创建型设计模式**， 它的核心思想是保证**一个类只有一个实例，并提供一个全局访问点来访问这个实例。**",
                content: "需求 link【设计模式专题之单例模式】1.小明的购物车\n题目描述\n小明去了一家大型商场，拿到了一个购物车，并开始购物。请你设计一个购物车管理器，记录商品添加到购物车的信息（商品名称和购买数量），并在购买结束后打印出商品清单。（在整个购物过程中，小明只有一个购物车实例存在）。 输入描述\n输入包含若干行，每行包含两部分信息，分别是商品名称和购买数量。商品名称和购买数量之间用空格隔开。 输出描述\n输出包含小明购物车中的所有商品及其购买数量。每行输出一种商品的信息，格式为 “商品名称 购买数量”。 输入示例 Apple 3 Banana 2 Orange 5 输出示例 Apple 3 Banana 2 Orange 5 提示信息 本道题目请使用单例设计模式： 使用私有静态变量来保存购物车实例。 使用私有构造函数防止外部直接实例化。 什么是单例设计模式 link单例模式是一种创建型设计模式， 它的核心思想是保证一个类只有一个实例，并提供一个全局访问点来访问这个实例。\n只有一个实例的意思是，在整个应用程序中，只存在该类的一个实例对象，而不是创建多个相同类型的对象。 全局访问点的意思是，为了让其他类能够获取到这个唯一实例，该类提供了一个全局访问点（通常是一个静态方法），通过这个方法就能获得实例。 为什么要使用单例设计模式呢 link简易来说，单例设计模式有以下几个优点让我们考虑使用它：\n全局控制：保证只有一个实例，这样就可以严格的控制客户怎样访问它以及何时访问它，简单的说就是对唯一实例的受控访问（引用自《大话设计模式》第21章） 节省资源：也正是因为只有一个实例存在，就避免多次创建了相同的对象，从而节省了系统资源，而且多个模块还可以通过单例实例共享数据。 懒加载：单例模式可以实现懒加载，只有在需要时才进行实例化，这无疑会提高程序的性能。 单例设计模式的基本要求 link想要实现一个单例设计模式，必须遵循以下规则：\n私有的构造函数：防止外部代码直接创建类的实例 私有的静态实例变量：保存该类的唯一实例 公有的静态方法：通过公有的静态方法来获取类的实例 单例设计模式的实现 link单例模式的实现方式有多种，包括懒汉式、饿汉式等。\n饿汉式指的是在类加载时就已经完成了实例的创建，不管后面创建的实例有没有使用，先创建再说，所以叫做 “饿汉”。\n而懒汉式指的是只有在请求实例时才会创建，如果在首次请求时还没有创建，就创建一个新的实例，如果已经创建，就返回已有的实例，意思就是需要使用了再创建，所以称为“懒汉”。\n在多线程环境下，由于饿汉式在程序启动阶段就完成了实例的初始化，因此不存在多个线程同时尝试初始化实例的问题，但是懒汉式中多个线程同时访问 getInstance() 方法，并且在同一时刻检测到实例没有被创建，就可能会同时创建实例，从而导致多个实例被创建，这种情况下我们可以采用一些同步机制，例如使用互斥锁来确保在任何时刻只有一个线程能够执行实例的创建。\n举个例子，你和小明都发现家里没米了，在你们没有相互通知的情况下，都会去超市买一袋米，这样就重复购买了，违背了单例模式。\n下面以Java的代码作为实例，说明单例设计模式的基本写法：\n饿汉模式：实例在类加载时就被创建, 这种方式的实现相对简单，但是实例有可能没有使用而造成资源浪费。 public class Singleton { private static final Singleton instance = new Singleton(); private Singleton() { // 私有构造方法，防止外部实例化 } public static Singleton getInstance() { return instance; } } 懒汉模式：第一次使用时才创建 public class Singleton { private static Singleton instance; private Singleton() { // 私有构造方法，防止外部实例化 } // 使用了同步关键字来确保线程安全, 可能会影响性能 public static synchronized Singleton getInstance() { if (instance == null) { instance = new Singleton(); } return instance; } } 在懒汉模式的基础上，可以使用双重检查锁来提高性能。\npublic class Singleton { private static volatile Singleton instance; private Singleton() { // 私有构造方法，防止外部实例化 } public static Singleton getInstance() { if (instance == null) { synchronized (Singleton.class) { if (instance == null) { instance = new Singleton(); } } } return instance; } } 什么时候使用单例设计模式 link说了这么多，那在什么场景下应该考虑使用单例设计模式呢？可以结合单例设计模式的优点来看。\n资源共享 多个模块共享某个资源的时候，可以使用单例模式，比如说应用程序需要一个全局的配置管理器来存储和管理配置信息、亦或是使用单例模式管理数据库连接池。\n只有一个实例 当系统中某个类只需要一个实例来协调行为的时候，可以考虑使用单例模式， 比如说管理应用程序中的缓存，确保只有一个缓存实例，避免重复的缓存创建和管理，或者使用单例模式来创建和管理线程池。\n懒加载 如果对象创建本身就比较消耗资源，而且可能在整个程序中都不一定会使用，可以使用单例模式实现懒加载。\n在许多流行的工具和库中，也都使用到了单例设计模式，比如Java中的Runtime类就是一个经典的单例，表示程序的运行时环境。此外 Spring 框架中的应用上下文 (ApplicationContext) 也被设计为单例，以提供对应用程序中所有 bean 的集中式访问点。\n本道题目代码 link import java.util.LinkedHashMap; import java.util.Map; import java.util.Scanner; public class Main { public static void main(String[] args) { ShoppingCartManager cart = ShoppingCartManager.getInstance(); Scanner scanner = new Scanner(System.in); while (scanner.hasNext()) { String itemName = scanner.next(); int quantity = scanner.nextInt(); // 获取购物车实例并添加商品 cart.addToCart(itemName, quantity); } // 输出购物车内容 cart.viewCart(); } } class ShoppingCartManager { // 饿汉模式实现单例 private static final ShoppingCartManager instance = new ShoppingCartManager(); // 购物车存储商品和数量的映射 private Map cart; // 私有构造函数 private ShoppingCartManager() { cart = new LinkedHashMap\u003c\u003e(); } // 获取购物车实例 public static ShoppingCartManager getInstance() { return instance; } // 添加商品到购物车 public void addToCart(String itemName, int quantity) { cart.put(itemName, cart.getOrDefault(itemName, 0) + quantity); } // 查看购物车 public void viewCart() { for (Map.Entry entry : cart.entrySet()) { System.out.println(entry.getKey() + \" \" + entry.getValue()); } } } 其他语言版本 linkJava版本 link懒汉+双重锁检查\nimport java.util.Scanner; import java.util.ArrayList; class ShoppingCart { // 购物车类的单例实例变量，使用volatile关键字确保线程安全 private static volatile ShoppingCart instance; // 存储商品名称 private static ArrayList productNames = new ArrayList\u003c\u003e(); // 存储商品数量 private static ArrayList productQuantities = new ArrayList\u003c\u003e(); // 私有构造函数，防止外部直接创建ShoppingCart对象 private ShoppingCart() { } // 获取购物车单例实例的方法，确保线程安全 public static ShoppingCart getInstance() { if (instance == null) { synchronized (ShoppingCart.class) { if (instance == null) { instance = new ShoppingCart(); } } } return instance; } // 添加商品到购物车的方法 public void Add(String name, int quantity) { productNames.add(name); productQuantities.add(quantity); System.out.println(name + \" \" + quantity); } } public class Main { public static void main(String[] args) { ShoppingCart cart = ShoppingCart.getInstance(); Scanner scanner = new Scanner(System.in); String inputLine; // 循环读取用户输入，直到用户输入\"exit\" while (scanner.hasNextLine()) { inputLine = scanner.nextLine(); if (\"exit\".equalsIgnoreCase(inputLine)) { break; } // 使用空格分割输入的字符串，获取商品名称和数量 String[] parts = inputLine.split(\" \"); // 确保输入格式正确，即包含两个部分：商品名称和数量 if (parts.length == 2) { // 商品名称 String name = parts[0]; // 商品数量 int quantity; try { // 将第二部分转换为整数 quantity = Integer.parseInt(parts[1]); cart.Add(name, quantity); } catch (NumberFormatException e) { // 如果转换失败，输出错误信息 System.out.println(\"转换失败，请重新输入\"); } } else { // 如果输入格式不正确，输出错误信息 System.out.println(\"如果输入格式不正确，请重新输入\"); } } scanner.close(); } } CPP link #include #include using namespace std; class ShoppingCartManager { public: // 获取购物车实例 static ShoppingCartManager\u0026 getInstance() { static ShoppingCartManager instance; return instance; } // 添加商品到购物车 void addToCart(const string\u0026 itemName, int quantity) { cart[itemName] += quantity; } // 查看购物车 void viewCart() const { for (const auto\u0026 item : cart) { cout \u003c\u003c item.first \u003c\u003c \" \" \u003c\u003c item.second \u003c\u003c endl; } } private: // 私有构造函数 ShoppingCartManager() {} // 购物车存储商品和数量的映射 map cart; }; int main() { string itemName; int quantity; while (cin \u003e\u003e itemName \u003e\u003e quantity) { // 获取购物车实例并添加商品 ShoppingCartManager\u0026 cart = ShoppingCartManager::getInstance(); cart.addToCart(itemName, quantity); } // 输出购物车内容 const ShoppingCartManager\u0026 cart = ShoppingCartManager::getInstance(); cart.viewCart(); return 0; } Python link 饿汉模式 3 class Singleton: instance = None def __init__(self): if Singleton.instance is not None: raise Exception(\"Only one instance of Singleton class is allowed\") else: Singleton.instance = self 懒汉模式 3 class Singleton: __instance: Singleton = None @staticmethod def getInstance(): if Singleton.__instance is None: Singleton.__instance = Singleton() return Singleton.__instance 懒汉+双重锁检查 3 import threading class Singleton: __instance = None __lock = threading.Lock() @classmethod def getInstance(cls): if cls.__instance is None: with cls.__lock: if cls.__instance is None: # cls.__instance = super().__new__(cls) cls.__instance = Singleton() return cls.__instance Go link package main import ( \"bufio\" \"fmt\" \"os\" \"strings\" \"sync\" ) // ShoppingCartManager 实现购物车管理 type ShoppingCartManager struct { cart map[string]int keys []string // 用于保存插入顺序的键 mutext sync.Mutex } var once sync.Once var instance *ShoppingCartManager // getInstance 获取购物车实例 func getInstance() *ShoppingCartManager { once.Do(func() { instance = \u0026ShoppingCartManager{ cart: make(map[string]int), } }) return instance } // addToCart 将商品添加到购物车 func (scm *ShoppingCartManager) addToCart(itemName string, quantity int) { scm.mutext.Lock() defer scm.mutext.Unlock() // 检查是否已经存在，不存在则添加到 keys 中 if _, exists := scm.cart[itemName]; !exists { scm.keys = append(scm.keys, itemName) } scm.cart[itemName] += quantity } // viewCart 查看购物车内容并按照插入顺序输出 func (scm *ShoppingCartManager) viewCart() { scm.mutext.Lock() defer scm.mutext.Unlock() for _, itemName := range scm.keys { quantity := scm.cart[itemName] fmt.Printf(\"%s %d\\n\", itemName, quantity) } } func main() { cart := getInstance() scanner := bufio.NewScanner(os.Stdin) for scanner.Scan() { input := scanner.Text() if input == \"\" { break } parts := strings.Fields(input) itemName := parts[0] quantity := 0 if len(parts) \u003e 1 { fmt.Sscanf(parts[1], \"%d\", \u0026quantity) } // 获取购物车实例并添加商品 cart.addToCart(itemName, quantity) } // 输出购物车内容 cart.viewCart() } "
            }
        );
    index.add(
            {
                id:  14 ,
                href: "\/docs\/dev\/23designpattern\/2.%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F\/",
                title: "2.工厂方法模式",
                description: "简单工厂模式的核心思想是将产品的创建过程封装在一个工厂类中，把创建对象的流程集中在这个工厂类里面。",
                content: "需求 link【设计模式专题之工厂方法模式】2.积木工厂\n题目描述\n小明家有两个工厂，一个用于生产圆形积木，一个用于生产方形积木，请你帮他设计一个积木工厂系统，记录积木生产的信息。 输入描述\n输入的第一行是一个整数 N（1 ≤ N ≤ 100），表示生产的次数。 接下来的 N 行，每行输入一个字符串和一个整数，字符串表示积木的类型。积木类型分为 “Circle” 和 “Square” 两种。整数表示该积木生产的数量 输出描述\n对于每个积木，输出一行字符串表示该积木的信息。 输入示例 3 Circle 1 Square 2 Circle 1 输出示例 Circle Block Square Block Square Block Circle Block 提示信息 在示例中，积木工厂生产了3块积木，其中有2块是圆形积木，1块是方形积木。根据输入的类型，每块积木的信息被输出到控制台。\n简单工厂模式 link在了解工厂方法模式之前，有必要对“简单工厂”模式进行一定的了解，简单工厂模式是一种创建型设计模式，但并不属于23种设计模式之一，更多的是一种编程习惯。\n简单工厂模式的核心思想是将产品的创建过程封装在一个工厂类中，把创建对象的流程集中在这个工厂类里面。\n简单工厂模式包括三个主要角色，工厂类、抽象产品、具体产品，下面的图示则展示了工厂类的基本结构。\n抽象产品，比如上图中的Shape 接口，描述产品的通用行为。 具体产品: 实现抽象产品接口或继承抽象产品类，比如上面的Circle类和Square类，具体产品通过简单工厂类的if-else逻辑来实例化。 工厂类：负责创建产品，根据传递的不同参数创建不同的产品示例。 简单工厂类简化了客户端操作，客户端可以调用工厂方法来获取具体产品，而无需直接与具体产品类交互，降低了耦合，但是有一个很大的问题就是不够灵活，如果需要添加新的产品，就需要修改工厂类的代码。\n什么是工厂方法模式 link工厂方法模式也是一种创建型设计模式，简单工厂模式只有一个工厂类，负责创建所有产品，如果要添加新的产品，通常需要修改工厂类的代码。而工厂方法模式引入了抽象工厂和具体工厂的概念，每个具体工厂只负责创建一个具体产品，添加新的产品只需要添加新的工厂类而无需修改原来的代码，这样就使得产品的生产更加灵活，支持扩展，符合开闭原则。\n工厂方法模式分为以下几个角色：\n抽象工厂：一个接口，包含一个抽象的工厂方法（用于创建产品对象）。 具体工厂：实现抽象工厂接口，创建具体的产品。 抽象产品：定义产品的接口。 具体产品：实现抽象产品接口，是工厂创建的对象。 实际上工厂方法模式也很好理解，就拿“手机Phone”这个产品举例，手机是一个抽象产品，小米手机、华为手机、苹果手机是具体的产品实现，而不同品牌的手机在各自的生产厂家生产。\n基本实现 link根据上面的类图，我们可以写出工厂方法模式的基本实现。\n// 抽象产品 interface Shape { void draw(); } // 具体产品 - 圆形 class Circle implements Shape { @Override public void draw() { System.out.println(\"Circle\"); } } // 具体产品 - 正方形 class Square implements Shape { @Override public void draw() { System.out.println(\"Square\"); } } // 抽象工厂 interface ShapeFactory { Shape createShape(); } // 具体工厂 - 创建圆形 class CircleFactory implements ShapeFactory { @Override public Shape createShape() { return new Circle(); } } // 具体工厂 - 创建正方形 class SquareFactory implements ShapeFactory { @Override public Shape createShape() { return new Square(); } } // 客户端代码 public class Client { public static void main(String[] args) { ShapeFactory circleFactory = new CircleFactory(); Shape circle = circleFactory.createShape(); circle.draw(); // 输出：Circle ShapeFactory squareFactory = new SquareFactory(); Shape square = squareFactory.createShape(); square.draw(); // 输出：Square } } 应用场景 link工厂方法模式使得每个工厂类的职责单一，每个工厂只负责创建一种产品，当创建对象涉及一系列复杂的初始化逻辑，而这些逻辑在不同的子类中可能有所不同时，可以使用工厂方法模式将这些初始化逻辑封装在子类的工厂中。在现有的工具、库中，工厂方法模式也有广泛的应用，比如：\nSpring 框架中的 Bean 工厂：通过配置文件或注解，Spring 可以根据配置信息动态地创建和管理对象。 JDBC 中的 Connection 工厂：在 Java 数据库连接中，DriverManager 使用工厂方法模式来创建数据库连接。不同的数据库驱动（如 MySQL、PostgreSQL 等）都有对应的工厂来创建连接。 本题代码 link import java.util.ArrayList; import java.util.List; import java.util.Scanner; // 抽象积木接口 interface Block { void produce(); } // 具体圆形积木实现 class CircleBlock implements Block { @Override public void produce() { System.out.println(\"Circle Block\"); } } // 具体方形积木实现 class SquareBlock implements Block { @Override public void produce() { System.out.println(\"Square Block\"); } } // 抽象积木工厂接口 interface BlockFactory { Block createBlock(); } // 具体圆形积木工厂实现 class CircleBlockFactory implements BlockFactory { @Override public Block createBlock() { return new CircleBlock(); } } // 具体方形积木工厂实现 class SquareBlockFactory implements BlockFactory { @Override public Block createBlock() { return new SquareBlock(); } } // 积木工厂系统 class BlockFactorySystem { private List blocks = new ArrayList\u003c\u003e(); public void produceBlocks(BlockFactory factory, int quantity) { for (int i = 0; i \u003c quantity; i++) { Block block = factory.createBlock(); blocks.add(block); block.produce(); } } public List getBlocks() { return blocks; } } public class Main { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); // 创建积木工厂系统 BlockFactorySystem factorySystem = new BlockFactorySystem(); // 读取生产次数 int productionCount = scanner.nextInt(); scanner.nextLine(); // 读取每次生产的积木类型和数量 for (int i = 0; i \u003c productionCount; i++) { String[] productionInfo = scanner.nextLine().split(\" \"); String blockType = productionInfo[0]; int quantity = Integer.parseInt(productionInfo[1]); if (blockType.equals(\"Circle\")) { factorySystem.produceBlocks(new CircleBlockFactory(), quantity); } else if (blockType.equals(\"Square\")) { factorySystem.produceBlocks(new SquareBlockFactory(), quantity); } } } } 其他语言版本 linkJava link利用反射实现工厂方法 import java.lang.reflect.Constructor; import java.util.Scanner; // 抽象工厂类 abstract class BlocksFactory { public abstract blocks createBlocks(Class c, String str, int num); } //具体工厂实现类 class BlocksFactoryImpl extends BlocksFactory { @Override public blocks createBlocks(Class c, String str, int num) { try { //反射获取blocks类中带有两个参数的构造器 Constructor constructor = c.getConstructor(String.class, int.class); return constructor.newInstance(str, num); } catch (Exception e) { e.printStackTrace(); return null; } } } //定义积木接口 interface blocks { void blockPrint(String str, int num); } //圆形积木 class CircleBlocks implements blocks{ private String str; private int num; public CircleBlocks(String str, int num) { this.str = str; this.num = num; } public void blockPrint(String str,int num){ for(int i=0;i"
            }
        );
    index.add(
            {
                id:  15 ,
                href: "\/docs\/dev\/23designpattern\/3.%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F\/",
                title: "3.抽象工厂模式",
                description: "抽象工厂模式也是一种创建型设计模式，提供了一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类",
                content: "需求 link【设计模式专题之抽象工厂模式】3. 家具工厂\n题目描述\n小明家新开了两个工厂用来生产家具，一个生产现代风格的沙发和椅子，一个生产古典风格的沙发和椅子，现在工厂收到了一笔订单，请你帮他设计一个系统，描述订单需要生产家具的信息。 输入描述\n输入的第一行是一个整数 N（1 ≤ N ≤ 100），表示订单的数量。 接下来的 N 行，每行输入一个字符串，字符串表示家具的类型。家具类型分为 “modern” 和 “classical” 两种。 输出描述\n对于每笔订单，输出字符串表示该订单需要生产家具的信息。 modern订单会输出下面两行字符串 modern chair modern sofa classical订单会输出下面两行字符串 classical chair classical soft 输入示例 3 modern classical modern 输出示例 modern chair modern sofa classical chair classical sofa modern chair modern sofa 提示信息 在示例中，工厂收到了3笔订单，其中有2笔要求生产modern风格，1笔要求生产classical风格。根据输入的类型，每次订单生产的家具信息被输出到控制台上。\n什么是抽象工厂模式 link抽象工厂模式也是一种创建型设计模式，提供了一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类【引用自大话设计模式第15章】\n这样的描述似乎理解起来很困难，我们可以把它与【工厂方法模式】联系起来看。\n之前我们已经介绍了“工厂方法模式”，那为什么还有要抽象工厂模式呢？\n这就涉及到创建“多类”对象了，在工厂方法模式中，每个具体工厂只负责创建单一的产品。但是如果有多类产品呢，比如说“手机”，一个品牌的手机有高端机、中低端机之分，这些具体的产品都需要建立一个单独的工厂类，但是它们都是相互关联的，都共同属于同一个品牌，这就可以使用到【抽象工厂模式】。\n抽象工厂模式可以确保一系列相关的产品被一起创建，这些产品能够相互配合使用，再举个例子，有一些家具，比如沙发、茶几、椅子，都具有古典风格的和现代风格的，抽象工厂模式可以将生产现代风格的家具放在一个工厂类中，将生产古典风格的家具放在另一个工厂类中，这样每个工厂类就可以生产一系列的家具。\n基本结构 link抽象工厂模式包含多个抽象产品接口，多个具体产品类，一个抽象工厂接口和多个具体工厂，每个具体工厂负责创建一组相关的产品。\n抽象产品接口AbstractProduct: 定义产品的接口，可以定义多个抽象产品接口，比如说沙发、椅子、茶几都是抽象产品。 具体产品类ConcreteProduct: 实现抽象产品接口，产品的具体实现，古典风格和沙发和现代风格的沙发都是具体产品。 抽象工厂接口AbstractFactory: 声明一组用于创建产品的方法，每个方法对应一个产品。 具体工厂类ConcreteFactory： 实现抽象工厂接口，负责创建一组具体产品的对象，在本例中，生产古典风格的工厂和生产现代风格的工厂都是具体实例。 在上面的图示中：AbstractProductA/B/C 就是抽象产品，ConcreteProductA2/A2/B1/B2/C1/C2就是抽象产品的实现，AbstractFactory定义了抽象工厂接口，接口里的方法用于创建具体的产品，而ConcreteFactory就是具体工厂类，可以创建一组相关的产品。\n基本实现 link想要实现抽象工厂模式，需要遵循以下步骤：\n定义抽象产品接口（可以有多个），接口中声明产品的公共方法。 实现具体产品类，在类中实现抽象产品接口中的方法。 定义抽象工厂接口，声明一组用于创建产品的方法。 实现具体工厂类，分别实现抽象工厂接口中的方法，每个方法负责创建一组相关的产品。 在客户端中使用抽象工厂和抽象产品，而不直接使用具体产品的类名。 // 1. 定义抽象产品 // 抽象产品A interface ProductA { void display(); } // 抽象产品B interface ProductB { void show(); } // 2. 实现具体产品类 // 具体产品A1 class ConcreteProductA1 implements ProductA { @Override public void display() { System.out.println(\"Concrete Product A1\"); } } // 具体产品A2 class ConcreteProductA2 implements ProductA { @Override public void display() { System.out.println(\"Concrete Product A2\"); } } // 具体产品B1 class ConcreteProductB1 implements ProductB { @Override public void show() { System.out.println(\"Concrete Product B1\"); } } // 具体产品B2 class ConcreteProductB2 implements ProductB { @Override public void show() { System.out.println(\"Concrete Product B2\"); } } // 3. 定义抽象工厂接口 interface AbstractFactory { ProductA createProductA(); ProductB createProductB(); } // 4. 实现具体工厂类 // 具体工厂1，生产产品A1和B1 class ConcreteFactory1 implements AbstractFactory { @Override public ProductA createProductA() { return new ConcreteProductA1(); } @Override public ProductB createProductB() { return new ConcreteProductB1(); } } // 具体工厂2,生产产品A2和B2 class ConcreteFactory2 implements AbstractFactory { @Override public ProductA createProductA() { return new ConcreteProductA2(); } @Override public ProductB createProductB() { return new ConcreteProductB2(); } } // 客户端代码 public class AbstractFactoryExample { public static void main(String[] args) { // 使用工厂1创建产品A1和产品B1 AbstractFactory factory1 = new ConcreteFactory1(); ProductA productA1 = factory1.createProductA(); ProductB productB1 = factory1.createProductB(); productA1.display(); productB1.show(); // 使用工厂2创建产品A2和产品B2 AbstractFactory factory2 = new ConcreteFactory2(); ProductA productA2 = factory2.createProductA(); ProductB productB2 = factory2.createProductB(); productA2.display(); productB2.show(); } } 应用场景 link抽象工厂模式能够保证一系列相关的产品一起使用，并且在不修改客户端代码的情况下，可以方便地替换整个产品系列。但是当需要增加新的产品类时，除了要增加新的具体产品类，还需要修改抽象工厂接口及其所有的具体工厂类，扩展性相对较差。因此抽象工厂模式特别适用于一系列相关或相互依赖的产品被一起创建的情况，典型的应用场景是使用抽象工厂模式来创建与不同数据库的连接对象。\n简单工厂、工厂方法、抽象工厂的区别 link 简单工厂模式：一个工厂方法创建所有具体产品\n工厂方法模式：一个工厂方法创建一个具体产品\n抽象工厂模式：一个工厂方法可以创建一类具体产品\n本题代码 link import java.util.Scanner; // 抽象椅子接口 interface Chair { void showInfo(); } // 具体现代风格椅子 class ModernChair implements Chair { @Override public void showInfo() { System.out.println(\"modern chair\"); } } // 具体古典风格椅子 class ClassicalChair implements Chair { @Override public void showInfo() { System.out.println(\"classical chair\"); } } // 抽象沙发接口 interface Sofa { void displayInfo(); } // 具体现代风格沙发 class ModernSofa implements Sofa { @Override public void displayInfo() { System.out.println(\"modern sofa\"); } } // 具体古典风格沙发 class ClassicalSofa implements Sofa { @Override public void displayInfo() { System.out.println(\"classical sofa\"); } } // 抽象家居工厂接口 interface FurnitureFactory { Chair createChair(); Sofa createSofa(); } // 具体现代风格家居工厂 class ModernFurnitureFactory implements FurnitureFactory { @Override public Chair createChair() { return new ModernChair(); } @Override public Sofa createSofa() { return new ModernSofa(); } } // 具体古典风格家居工厂 class ClassicalFurnitureFactory implements FurnitureFactory { @Override public Chair createChair() { return new ClassicalChair(); } @Override public Sofa createSofa() { return new ClassicalSofa(); } } public class Main { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); // 读取订单数量 int N = scanner.nextInt(); // 处理每个订单 for (int i = 0; i \u003c N; i++) { // 读取家具类型 String furnitureType = scanner.next(); // 创建相应风格的家居装饰品工厂 FurnitureFactory factory = null; if (furnitureType.equals(\"modern\")) { factory = new ModernFurnitureFactory(); } else if (furnitureType.equals(\"classical\")) { factory = new ClassicalFurnitureFactory(); } // 根据工厂生产椅子和沙发 Chair chair = factory.createChair(); Sofa sofa = factory.createSofa(); // 输出家具信息 chair.showInfo(); sofa.displayInfo(); } } } 其他语言代码 linkJava link三元运算符简化工厂选择的逻辑。\nimport java.util.Scanner; // 定义一个家具工厂接口，可以创建椅子和沙发 interface FurnitureFactory{ Chair createChair(); Sofa createSofa(); } // 实现古典家具工厂，生产古典风格的椅子和沙发 class ClassicalFurnitureFactory implements FurnitureFactory{ @Override public Chair createChair(){ return new ClassicalChair(); } @Override public Sofa createSofa(){ return new ClassicalSofa(); } } // 实现现代家具工厂，生产现代风格的椅子和沙发 class ModernFurnitureFactory implements FurnitureFactory{ @Override public Chair createChair(){ return new ModernChair(); } @Override public Sofa createSofa(){ return new ModernSofa(); } } // 定义椅子接口，包含生产椅子的方法 interface Chair{ void produceChair(); } // 实现古典椅子类，继承椅子接口 class ClassicalChair implements Chair{ @Override public void produceChair(){ System.out.println(\"classical chair\"); } } // 实现现代椅子类，继承椅子接口 class ModernChair implements Chair{ @Override public void produceChair(){ System.out.println(\"modern chair\"); } } // 定义沙发接口，包含生产沙发的方法 interface Sofa{ void produceSofa(); } // 实现古典沙发类，继承沙发接口 class ClassicalSofa implements Sofa{ @Override public void produceSofa(){ System.out.println(\"classical sofa\"); } } // 实现现代沙发类，继承沙发接口 class ModernSofa implements Sofa{ @Override public void produceSofa(){ System.out.println(\"modern sofa\"); } } //主程序类 public class Main{ public static void main (String[] args) { Scanner scanner = new Scanner(System.in); // 创建古典和现代家具工厂实例 FurnitureFactory classicalFurnitureFactory = new ClassicalFurnitureFactory(); FurnitureFactory modernFurnitureFactory = new ModernFurnitureFactory(); // 读取生产次数 int productionCount = scanner.nextInt(); scanner.nextLine(); for (int i = 0; i \u003c productionCount; i++) { String type = scanner.nextLine(); // 根据用户输入选择相应的家具工厂，并创建家具 FurnitureFactory factory = (type.equals(\"modern\")) ? modernFurnitureFactory : classicalFurnitureFactory; Chair chair = factory.createChair(); chair.produceChair(); Sofa sofa = factory.createSofa(); sofa.produceSofa(); } scanner.close(); } } Cpp link #include #include // 抽象椅子接口 class Chair { public: virtual void showInfo() = 0; }; // 具体现代风格椅子 class ModernChair : public Chair { public: void showInfo() override { std::cout \u003c\u003c \"modern chair\" \u003c\u003c std::endl; } }; // 具体古典风格椅子 class ClassicalChair : public Chair { public: void showInfo() override { std::cout \u003c\u003c \"classical chair\" \u003c\u003c std::endl; } }; // 抽象沙发接口 class Sofa { public: virtual void displayInfo() = 0; }; // 具体现代风格沙发 class ModernSofa : public Sofa { public: void displayInfo() override { std::cout \u003c\u003c \"modern sofa\" \u003c\u003c std::endl; } }; // 具体古典风格沙发 class ClassicalSofa : public Sofa { public: void displayInfo() override { std::cout \u003c\u003c \"classical sofa\" \u003c\u003c std::endl; } }; // 抽象家居工厂接口 class FurnitureFactory { public: virtual Chair* createChair() = 0; virtual Sofa* createSofa() = 0; }; // 具体现代风格家居工厂 class ModernFurnitureFactory : public FurnitureFactory { public: Chair* createChair() override { return new ModernChair(); } Sofa* createSofa() override { return new ModernSofa(); } }; // 具体古典风格家居工厂 class ClassicalFurnitureFactory : public FurnitureFactory { public: Chair* createChair() override { return new ClassicalChair(); } Sofa* createSofa() override { return new ClassicalSofa(); } }; int main() { // 读取订单数量 int N; std::cin \u003e\u003e N; // 处理每个订单 for (int i = 0; i \u003c N; i++) { // 读取家具类型 std::string furnitureType; std::cin \u003e\u003e furnitureType; // 创建相应风格的家居装饰品工厂 FurnitureFactory* factory = nullptr; if (furnitureType == \"modern\") { factory = new ModernFurnitureFactory(); } else if (furnitureType == \"classical\") { factory = new ClassicalFurnitureFactory(); } // 根据工厂生产椅子和沙发 Chair* chair = factory-\u003ecreateChair(); Sofa* sofa = factory-\u003ecreateSofa(); // 输出家具信息 chair-\u003eshowInfo(); sofa-\u003edisplayInfo(); // 释放动态分配的对象 delete chair; delete sofa; delete factory; } return 0; } Python link from abc import ABC, abstractmethod # 抽象椅子接口 class Chair(ABC): @abstractmethod def show_info(self): pass # 具体现代风格椅子 class ModernChair(Chair): def show_info(self): print(\"modern chair\") # 具体古典风格椅子 class ClassicalChair(Chair): def show_info(self): print(\"classical chair\") # 抽象沙发接口 class Sofa(ABC): @abstractmethod def display_info(self): pass # 具体现代风格沙发 class ModernSofa(Sofa): def display_info(self): print(\"modern sofa\") # 具体古典风格沙发 class ClassicalSofa(Sofa): def display_info(self): print(\"classical sofa\") # 抽象家居工厂接口 class FurnitureFactory(ABC): @abstractmethod def create_chair(self): pass @abstractmethod def create_sofa(self): pass # 具体现代风格家居工厂 class ModernFurnitureFactory(FurnitureFactory): def create_chair(self): return ModernChair() def create_sofa(self): return ModernSofa() # 具体古典风格家居工厂 class ClassicalFurnitureFactory(FurnitureFactory): def create_chair(self): return ClassicalChair() def create_sofa(self): return ClassicalSofa() def main(): # 读取订单数量 N = int(input()) # 处理每个订单 for _ in range(N): # 读取家具类型 furniture_type = input() # 创建相应风格的家居装饰品工厂 factory = None if furniture_type == \"modern\": factory = ModernFurnitureFactory() elif furniture_type == \"classical\": factory = ClassicalFurnitureFactory() # 根据工厂生产椅子和沙发 chair = factory.create_chair() sofa = factory.create_sofa() # 输出家具信息 chair.show_info() sofa.display_info() if __name__ == \"__main__\": main() Go link package main import \"fmt\" // 抽象椅子接口 type Chair interface { showInfo() } // 具体现代风格椅子 type ModernChair struct{} func (mc *ModernChair) showInfo() { fmt.Println(\"modern chair\") } // 具体古典风格椅子 type ClassicalChair struct{} func (cc *ClassicalChair) showInfo() { fmt.Println(\"classical chair\") } // 抽象沙发接口 type Sofa interface { displayInfo() } // 具体现代风格沙发 type ModernSofa struct{} func (ms *ModernSofa) displayInfo() { fmt.Println(\"modern sofa\") } // 具体古典风格沙发 type ClassicalSofa struct{} func (cs *ClassicalSofa) displayInfo() { fmt.Println(\"classical sofa\") } // 抽象家居工厂接口 type FurnitureFactory interface { createChair() Chair createSofa() Sofa } // 具体现代风格家居工厂 type ModernFurnitureFactory struct{} func (mf *ModernFurnitureFactory) createChair() Chair { return \u0026ModernChair{} } func (mf *ModernFurnitureFactory) createSofa() Sofa { return \u0026ModernSofa{} } // 具体古典风格家居工厂 type ClassicalFurnitureFactory struct{} func (cf *ClassicalFurnitureFactory) createChair() Chair { return \u0026ClassicalChair{} } func (cf *ClassicalFurnitureFactory) createSofa() Sofa { return \u0026ClassicalSofa{} } func main() { // 读取订单数量 var N int fmt.Scan(\u0026N) // 处理每个订单 for i := 0; i \u003c N; i++ { // 读取家具类型 var furnitureType string fmt.Scan(\u0026furnitureType) // 创建相应风格的家居装饰品工厂 var factory FurnitureFactory if furnitureType == \"modern\" { factory = \u0026ModernFurnitureFactory{} } else if furnitureType == \"classical\" { factory = \u0026ClassicalFurnitureFactory{} } // 根据工厂生产椅子和沙发 chair := factory.createChair() sofa := factory.createSofa() // 输出家具信息 chair.showInfo() sofa.displayInfo() } } "
            }
        );
    index.add(
            {
                id:  16 ,
                href: "\/docs\/dev\/golang\/fyne\/",
                title: "Fyne",
                description: "用Golang-Fyne开发GUI程序",
                content: ""
            }
        );
    index.add(
            {
                id:  17 ,
                href: "\/docs\/dev\/23designpattern\/4.%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F\/",
                title: "4.建造者模式",
                description: "将对象的构建过程分为多个步骤，并为每个步骤定义一个抽象的接口。具体的构建过程由实现了这些接口的具体建造者类来完成。",
                content: "需求 link【设计模式专题之建造者模式】4. 自行车加工\n题目描述\n小明家新开了一家自行车工厂，用于使用自行车配件（车架 frame 和车轮 tires ）进行组装定制不同的自行车，包括山地车和公路车。 山地车使用的是Aluminum Frame（铝制车架）和 Knobby Tires（可抓地轮胎），公路车使用的是 Carbon Frame （碳车架）和 Slim Tries。 现在它收到了一笔订单，要求定制一批自行车，请你使用【建造者模式】告诉小明这笔订单需要使用那些自行车配置吧。 输入描述\n输入的第一行是一个整数 N（1 ≤ N ≤ 100），表示订单的数量。 接下来的 N 行，每行输入一个字符串，字符串表示客户的自行车需求。 字符串可以包含关键词 “mountain” 或 “road”，表示客户需要山地自行车或公路自行车。 **输出描述 对于每笔订单，输出该订单定制的自行车配置。\n输入示例 3 mountain road mountain 输出示例\nAluminum Frame Knobby Tires Carbon Frame Slim Tires Aluminum Frame Knobby Tires 提示信息 在本例中：产品为自行车，可以有两个建造者：山地车建造者和公路车建造者。\n什么是建造者模式 link建造者模式（也被成为生成器模式），是一种创建型设计模式，软件开发过程中有的时候需要创建很复杂的对象，而建造者模式的主要思想是**将对象的构建过程分为多个步骤，并为每个步骤定义一个抽象的接口。具体的构建过程由实现了这些接口的具体建造者类来完成。**同时有一个指导者类负责协调建造者的工作，按照一定的顺序或逻辑来执行构建步骤，最终生成产品。\n举个例子，假如我们要创建一个计算机对象，计算机由很多组件组成，例如 CPU、内存、硬盘、显卡等。每个组件可能有不同的型号、配置和制造，这个时候计算机就可以被视为一个复杂对象，构建过程相对复杂，而我们使用建造者模式将计算机的构建过程封装在一个具体的建造者类中，而指导者类则负责指导构建的步骤和顺序。每个具体的建造者类可以负责构建不同型号或配置的计算机，客户端代码可以通过选择不同的建造者来创建不同类型的计算机，这样就可以根据需要构建不同表示的复杂对象，更加灵活。\n基本结构 link建造者模式有下面几个关键角色：\n产品Product：被构建的复杂对象, 包含多个组成部分。 抽象建造者Builder: 定义构建产品各个部分的抽象接口和一个返回复杂产品的方法getResult 具体建造者Concrete Builder：实现抽象建造者接口，构建产品的各个组成部分，并提供一个方法返回最终的产品。 指导者Director：调用具体建造者的方法，按照一定的顺序或逻辑来构建产品。 在客户端中，通过指导者来构建产品，而并不和具体建造者进行直接的交互。\n简易实现 link建造者模式的实现步骤通常包括以下几个阶段\n定义产品类：产品类应该包含多个组成部分，这些部分的属性和方法构成了产品的接口 // 产品类 class Product { private String part1; private String part2; public void setPart1(String part1) { this.part1 = part1; } public void setPart2(String part2) { this.part2 = part2; } // 其他属性和方法 } 定义抽象建造者接口：创建一个接口，包含构建产品各个部分的抽象方法。这些方法通常用于设置产品的各个属性。 // 抽象建造者接口 interface Builder { void buildPart1(String part1); void buildPart2(String part2); Product getResult(); } 创建具体建造者：实现抽象建造者接口，构建具体的产品。 // 具体建造者类 class ConcreteBuilder implements Builder { private Product product = new Product(); @Override public void buildPart1(String part1) { product.setPart1(part1); } @Override public void buildPart2(String part2) { product.setPart2(part2); } @Override public Product getResult() { return product; } } 定义Director类： 指导者类来控制构建产品的顺序和步骤。 // 指导者类 class Director { private Builder builder; public Director(Builder builder) { this.builder = builder; } // 调用方法构建产品 public void construct() { builder.buildPart1(\"Part1\"); builder.buildPart2(\"Part2\"); } } 客户端使用建造者模式：在客户端中创建【具体建造者对象】和【指导者对象】，通过指导者来构建产品。 // 客户端代码 public class Main{ public static void main(String[] args) { // 创建具体建造者 Builder builder = new ConcreteBuilder(); // 创建指导者 Director director = new Director(builder); // 指导者构建产品 director.construct(); // 获取构建好的产品 Product product = builder.getResult(); // 输出产品信息 System.out.println(product); } } 使用场景 link使用建造者模式有下面几处优点：\n使用建造者模式可以**将一个复杂对象的构建与其表示分离，**通过将构建复杂对象的过程抽象出来，可以使客户端代码与具体的构建过程解耦\n同样的构建过程可以创建不同的表示，可以有多个具体的建造者(相互独立），可以更加灵活地创建不同组合的对象。\n对应的，建造者模式适用于复杂对象的创建，当对象构建过程相对复杂时可以考虑使用建造者模式，但是当产品的构建过程发生变化时，可能需要同时修改指导类和建造者类，这就使得重构变得相对困难。\n建造者模式在现有的工具和库中也有着广泛的应用，比如JUnit 中的测试构建器TestBuilder就采用了建造者模式，用于构建测试对象。\n本题代码 link import java.util.Scanner; // 自行车产品 class Bike { private String frame; private String tires; public void setFrame(String frame) { this.frame = frame; } public void setTires(String tires) { this.tires = tires; } @Override public String toString() { return frame + \" \" + tires; } } // 自行车建造者接口 interface BikeBuilder { void buildFrame(); void buildTires(); Bike getResult(); } // 山地自行车建造者 class MountainBikeBuilder implements BikeBuilder { private Bike bike; public MountainBikeBuilder() { this.bike = new Bike(); } @Override public void buildFrame() { bike.setFrame(\"Aluminum Frame\"); } @Override public void buildTires() { bike.setTires(\"Knobby Tires\"); } @Override public Bike getResult() { return bike; } } // 公路自行车建造者 class RoadBikeBuilder implements BikeBuilder { private Bike bike; public RoadBikeBuilder() { this.bike = new Bike(); } @Override public void buildFrame() { bike.setFrame(\"Carbon Frame\"); } @Override public void buildTires() { bike.setTires(\"Slim Tires\"); } @Override public Bike getResult() { return bike; } } // 自行车Director，负责构建自行车 class BikeDirector { public Bike construct(BikeBuilder builder) { builder.buildFrame(); builder.buildTires(); return builder.getResult(); } } public class Main { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); int N = scanner.nextInt(); // 订单数量 scanner.nextLine(); BikeDirector director = new BikeDirector(); for (int i = 0; i \u003c N; i++) { String bikeType = scanner.nextLine(); BikeBuilder builder; // 根据输入类别，创建不同类型的具体建造者 if (bikeType.equals(\"mountain\")) { builder = new MountainBikeBuilder(); } else { builder = new RoadBikeBuilder(); } // Director负责指导生产产品 Bike bike = director.construct(builder); System.out.println(bike); } } } 其他语言代码 linkJava link使用模版方法模式和建造者模式实现自行车工厂。\nimport java.util.ArrayList; import java.util.Scanner; //抽象类，模版方法模式创建 abstract class Bicycle{ private ArrayList fittingsList = new ArrayList(); //选用不同配件的方法 protected void useAluminumFrame(){}; protected void useKnobbyTires(){}; protected void useCarbonFrame(){}; protected void useSlimTires(){}; //设置配件列表 public final void setFittingsList(ArrayList list){ this.fittingsList = list; } //选用配件，构建自行车 public final void maker(){ for (String fitting : fittingsList) { switch (fitting) { case \"useAluminumFrame\": useAluminumFrame(); break; case \"useKnobbyTires\": useKnobbyTires(); break; case \"useCarbonFrame\": useCarbonFrame(); break; case \"useSlimTires\": useSlimTires(); break; default: System.out.println(\"不清楚的配件：\" + fitting + \"请重新输入！\"); } } } } //山地自行车类，并重写父类方法 class MountainBicycle extends Bicycle{ @Override protected void useAluminumFrame(){ System.out.print(\"Aluminum Frame \"); } @Override protected void useKnobbyTires(){ System.out.println(\"Knobby Tires \"); } } //公路自行车类，并重写父类方法 class RoadBicycle extends Bicycle{ @Override protected void useCarbonFrame(){ System.out.print(\"Carbon Frame \"); } @Override protected void useSlimTires(){ System.out.println(\"Slim Tires \"); } } //定义建造者接口 interface Builder{ void setFittingList(ArrayList list); Bicycle getBicycle(); } //山地自行车建造类 class MountainBicycleBuilder implements Builder{ private MountainBicycle mountainBicycle = new MountainBicycle(); public void setFittingList(ArrayList list){ this.mountainBicycle.setFittingsList(list); } public Bicycle getBicycle(){ return this.mountainBicycle; } } //公路自行车建造者类 class RoadBicycleBuilder implements Builder{ private RoadBicycle roadBicycle = new RoadBicycle(); public void setFittingList(ArrayList list){ this.roadBicycle.setFittingsList(list); } public Bicycle getBicycle(){ return this.roadBicycle; } } //导演类 class Director{ private ArrayList arrayList = new ArrayList(); private MountainBicycleBuilder mountainBicycleBuilder = new MountainBicycleBuilder(); private RoadBicycleBuilder roadBicycleBuilder = new RoadBicycleBuilder(); public MountainBicycle getMountainBicycle(){ //清理场景 this.arrayList.clear(); //选用配件 this.arrayList.add(\"useAluminumFrame\"); this.arrayList.add(\"useKnobbyTires\"); this.mountainBicycleBuilder.setFittingList(this.arrayList); return (MountainBicycle)this.mountainBicycleBuilder.getBicycle(); } public RoadBicycle getRoadBicycle(){ //清理场景 this.arrayList.clear(); //选用配件 this.arrayList.add(\"useCarbonFrame\"); this.arrayList.add(\"useSlimTires\"); this.roadBicycleBuilder.setFittingList(this.arrayList); return (RoadBicycle)this.roadBicycleBuilder.getBicycle(); } } //主程序类 public class Main{ public static void main (String[] args) { Scanner scanner = new Scanner(System.in); try { int num = scanner.nextInt(); scanner.nextLine(); Director director = new Director(); for (int i = 0; i \u003c num; i++) { String type = scanner.nextLine().toLowerCase().trim(); Bicycle bicycle; if (\"mountain\".equals(type)) { bicycle = director.getMountainBicycle(); } else if (\"road\".equals(type)) { bicycle = director.getRoadBicycle(); } else { System.out.println(\"无效输入. 请输入 'mountain' 或 'road'.\"); continue; } bicycle.maker(); } } catch (Exception e) { System.out.println(\"An error occurred: \" + e.getMessage()); } finally { scanner.close(); } } } Cpp link #include #include // 自行车产品 class Bike { public: std::string frame; std::string tires; void setFrame(const std::string\u0026 frame) { this-\u003eframe = frame; } void setTires(const std::string\u0026 tires) { this-\u003etires = tires; } friend std::ostream\u0026 operator\u003c\u003c(std::ostream\u0026 os, const Bike\u0026 bike) { os \u003c\u003c bike.frame \u003c\u003c \" \" \u003c\u003c bike.tires; return os; } }; // 自行车建造者接口 class BikeBuilder { public: virtual void buildFrame() = 0; virtual void buildTires() = 0; virtual Bike getResult() = 0; }; // 山地自行车建造者 class MountainBikeBuilder : public BikeBuilder { private: Bike bike; public: void buildFrame() override { bike.setFrame(\"Aluminum Frame\"); } void buildTires() override { bike.setTires(\"Knobby Tires\"); } Bike getResult() override { return bike; } }; // 公路自行车建造者 class RoadBikeBuilder : public BikeBuilder { private: Bike bike; public: void buildFrame() override { bike.setFrame(\"Carbon Frame\"); } void buildTires() override { bike.setTires(\"Slim Tires\"); } Bike getResult() override { return bike; } }; // 自行车Director，负责构建自行车 class BikeDirector { public: Bike construct(BikeBuilder\u0026 builder) { builder.buildFrame(); builder.buildTires(); return builder.getResult(); } }; int main() { int N; std::cin \u003e\u003e N; // 订单数量 BikeDirector director; for (int i = 0; i \u003c N; i++) { std::string bikeType; std::cin \u003e\u003e bikeType; BikeBuilder* builder; // 根据输入类别，创建不同类型的具体建造者 if (bikeType == \"mountain\") { builder = new MountainBikeBuilder(); } else { builder = new RoadBikeBuilder(); } // Director负责指导生产产品 Bike bike = director.construct(*builder); std::cout \u003c\u003c bike \u003c\u003c std::endl; // 释放动态分配的对象 delete builder; } return 0; } Python link # 自行车产品 class Bike: def __init__(self): self.frame = None self.tires = None def set_frame(self, frame): self.frame = frame def set_tires(self, tires): self.tires = tires def __str__(self): return f\"{self.frame} {self.tires}\" # 自行车建造者接口 class BikeBuilder: def build_frame(self): pass def build_tires(self): pass def get_result(self): pass # 山地自行车建造者 class MountainBikeBuilder(BikeBuilder): def __init__(self): self.bike = Bike() def build_frame(self): self.bike.set_frame(\"Aluminum Frame\") def build_tires(self): self.bike.set_tires(\"Knobby Tires\") def get_result(self): return self.bike # 公路自行车建造者 class RoadBikeBuilder(BikeBuilder): def __init__(self): self.bike = Bike() def build_frame(self): self.bike.set_frame(\"Carbon Frame\") def build_tires(self): self.bike.set_tires(\"Slim Tires\") def get_result(self): return self.bike # 自行车Director，负责构建自行车 class BikeDirector: def construct(self, builder): builder.build_frame() builder.build_tires() return builder.get_result() def main(): N = int(input()) # 订单数量 director = BikeDirector() for _ in range(N): bike_type = input() # 根据输入类别，创建不同类型的具体建造者 if bike_type == \"mountain\": builder = MountainBikeBuilder() else: builder = RoadBikeBuilder() # Director负责指导生产产品 bike = director.construct(builder) print(bike) if __name__ == \"__main__\": main() Go link package main import \"fmt\" // 自行车产品 type Bike struct { frame string tires string } func (b *Bike) setFrame(frame string) { b.frame = frame } func (b *Bike) setTires(tires string) { b.tires = tires } func (b *Bike) String() string { return b.frame + \" \" + b.tires } // 自行车建造者接口 type BikeBuilder interface { buildFrame() buildTires() getResult() *Bike } // 山地自行车建造者 type MountainBikeBuilder struct { bike *Bike } func NewMountainBikeBuilder() *MountainBikeBuilder { return \u0026MountainBikeBuilder{ bike: \u0026Bike{}, } } func (mbb *MountainBikeBuilder) buildFrame() { mbb.bike.setFrame(\"Aluminum Frame\") } func (mbb *MountainBikeBuilder) buildTires() { mbb.bike.setTires(\"Knobby Tires\") } func (mbb *MountainBikeBuilder) getResult() *Bike { return mbb.bike } // 公路自行车建造者 type RoadBikeBuilder struct { bike *Bike } func NewRoadBikeBuilder() *RoadBikeBuilder { return \u0026RoadBikeBuilder{ bike: \u0026Bike{}, } } func (rbb *RoadBikeBuilder) buildFrame() { rbb.bike.setFrame(\"Carbon Frame\") } func (rbb *RoadBikeBuilder) buildTires() { rbb.bike.setTires(\"Slim Tires\") } func (rbb *RoadBikeBuilder) getResult() *Bike { return rbb.bike } // 自行车Director，负责构建自行车 type BikeDirector struct{} func (bd *BikeDirector) construct(builder BikeBuilder) *Bike { builder.buildFrame() builder.buildTires() return builder.getResult() } func main() { var N int fmt.Scan(\u0026N) // 订单数量 director := \u0026BikeDirector{} for i := 0; i \u003c N; i++ { var bikeType string fmt.Scan(\u0026bikeType) var builder BikeBuilder // 根据输入类别，创建不同类型的具体建造者 if bikeType == \"mountain\" { builder = NewMountainBikeBuilder() } else { builder = NewRoadBikeBuilder() } // Director负责指导生产产品 bike := director.construct(builder) fmt.Println(bike) } } "
            }
        );
    index.add(
            {
                id:  18 ,
                href: "\/docs\/dev\/23designpattern\/5.%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F\/",
                title: "5.原型模式",
                description: "原型模式一种创建型设计模式，该模式的核心思想是基于现有的对象创建新的对象，而不是从头开始创建。",
                content: "需求 link【设计模式专题之原型模式】5. 矩形原型\n题目描述\n公司正在开发一个图形设计软件，其中有一个常用的图形元素是矩形。设计师在工作时可能需要频繁地创建相似的矩形，而这些矩形的基本属性是相同的（颜色、宽度、高度），为了提高设计师的工作效率，请你使用原型模式设计一个矩形对象的原型。使用该原型可以快速克隆生成新的矩形对象。 输入描述\n首先输入一个字符串，表示矩形的基本属性信息，包括颜色、长度和宽度，用空格分隔，例如 “Red 10 5”。 然后输入一个整数 N（1 ≤ N ≤ 100），表示使用原型创建的矩形数量。 输出描述\n对于每个矩形，输出一行字符串表示矩形的详细信息，如 “Color: Red, Width: 10,Height: 5”。 输入示例 Red 10 5 3 输出示例 Color: Red, Width: 10, Height: 5 Color: Red, Width: 10, Height: 5 Color: Red, Width: 10, Height: 5 提示信息 使用原型模式中的克隆方法实现矩形对象的创建。\n什么是原型模式 link原型模式一种创建型设计模式，该模式的核心思想是基于现有的对象创建新的对象，而不是从头开始创建。\n在原型模式中，通常有一个原型对象，它被用作创建新对象的模板。新对象通过复制原型对象的属性和状态来创建，而无需知道具体的创建细节。\n为什么要使用原型模式 link如果一个对象的创建过程比较复杂时（比如需要经过一系列的计算和资源消耗），那每次创建该对象都需要消耗资源，而通过原型模式就可以复制现有的一个对象来迅速创建/克隆一个新对象，不必关心具体的创建细节，可以降低对象创建的成本。\n下面是一个简短的Python代码示例了模拟了上面的问题：\nimport copy class ComplexObject: def __init__(self, data): # 耗时的资源型操作 self.data = data def clone(self): # 复制 return copy.deepcopy(self) # 创建原型对象 original_object = ComplexObject(data=\"large date\") # 创建新对象，直接拷贝原对象 new_object = original_object.clone() 原型模式的基本结构 link实现原型模式需要给【原型对象】声明一个克隆方法，执行该方法会创建一个当前类的新对象，并将原始对象中的成员变量复制到新生成的对象中，而不必实例化。并且在这个过程中只需要调用原型对象的克隆方法，而无需知道原型对象的具体类型。\n原型模式包含两个重点模块：\n抽象原型接口prototype: 声明一个克隆自身的方法clone 具体原型类ConcretePrototype: 实现clone方法，复制当前对象并返回一个新对象。 在客户端代码中，可以声明一个具体原型类的对象，然后调用clone()方法复制原对象生成一个新的对象。\n原型模式的基本实现 link原型模式的实现过程即上面描述模块的实现过程：\n创建一个抽象类或接口，声明一个克隆方法clone 实现具体原型类，重写克隆方法 客户端中实例化具体原型类的对象，并调用其克隆方法来创建新的对象。 // 1. 定义抽象原型类 public abstract class Prototype implements Cloneable { public abstract Prototype clone(); } // 2. 创建具体原型类 public class ConcretePrototype extends Prototype { private String data; public ConcretePrototype(String data) { this.data = data; } @Override public Prototype clone() { return new ConcretePrototype(this.data); } public String getData() { return data; } } // 3. 客户端代码 public class Client { public static void main(String[] args) { // 创建原型对象 Prototype original = new ConcretePrototype(\"Original Data\"); // 克隆原型对象 Prototype clone = original.clone(); // 输出克隆对象的数据 System.out.println(\"Clone Data: \" + ((ConcretePrototype) clone).getData()); } } 什么时候实现原型模式 link相比于直接实例化对象，通过原型模式复制对象可以减少资源消耗，提高性能，尤其在对象的创建过程复杂或对象的创建代价较大的情况下。当需要频繁创建相似对象、并且可以通过克隆避免重复初始化工作的场景时可以考虑使用原型模式，在克隆对象的时候还可以动态地添加或删除原型对象的属性，创造出相似但不完全相同的对象，提高了灵活性。\n但是使用原型模式也需要考虑到如果对象的内部状态包含了引用类型的成员变量，那么实现深拷贝就会变得较为复杂，需要考虑引用类型对象的克隆问题。\n原型模式在现有的很多语言中都有应用，比如以下几个经典例子。\nJava 提供了 Object 类的 clone() 方法，可以实现对象的浅拷贝。类需要实现 Cloneable 接口并重写 clone() 方法。\n在 .NET 中，ICloneable 接口提供了 Clone 方法，可以用于实现对象的克隆。\nSpring 框架中的 Bean 的作用域之一是原型作用域（Prototype Scope），在这个作用域下，Spring 框架会为每次请求创建一个新的 Bean 实例，类似于原型模式。\n本题代码 link import java.util.Scanner; // 抽象原型类 abstract class Prototype implements Cloneable { public abstract Prototype clone(); public abstract String getDetails(); // 公共的 clone 方法 public Prototype clonePrototype() { try { return (Prototype) super.clone(); } catch (CloneNotSupportedException e) { e.printStackTrace(); return null; } } } // 具体矩形原型类 class RectanglePrototype extends Prototype { private String color; private int width; private int height; // 构造方法 public RectanglePrototype(String color, int width, int height) { this.color = color; this.width = width; this.height = height; } // 克隆方法 @Override public Prototype clone() { return clonePrototype(); } // 获取矩形的详细信息 @Override public String getDetails() { return \"Color: \" + color + \", Width: \" + width + \", Height: \" + height; } } // 客户端程序 public class Main { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); // 读取需要创建的矩形数量 int N = scanner.nextInt(); // 读取每个矩形的属性信息并创建矩形对象 for (int i = 0; i \u003c N; i++) { String color = scanner.next(); int width = scanner.nextInt(); int height = scanner.nextInt(); // 创建原型对象 Prototype originalRectangle = new RectanglePrototype(color, width, height); // 克隆对象并输出详细信息 Prototype clonedRectangle = originalRectangle.clone(); System.out.println(clonedRectangle.getDetails()); } } } 其他语言代码 linkJava link使用原型注册表来实现 import java.util.HashMap; import java.util.Map; import java.util.Scanner; // 原型模式抽象类Shape，表示形状的基类 abstract class Shape { protected int height; protected int width; protected String color; public Shape() {} public Shape(int height, int width, String color) { this.height = height; this.width = width; this.color = color; } // 抽象方法 clone，用于克隆形状 public abstract Shape clone(); //get、set方法。 public int getHeight() { return height; } public void setHeight(int height) { this.height = height; } public int getWidth() { return width; } public void setWidth(int width) { this.width = width; } public String getColor() { return color; } public void setColor(String color) { this.color = color; } } // Rectangle 类，继承自 Shape 表示矩形 class Rectangle extends Shape { public Rectangle(int height, int width, String color) { super(height, width, color); } // 克隆方法，返回一个新的矩形对象 @Override public Shape clone() { return new Rectangle(this.height, this.width, this.color); } } // 原型注册表类，用于存储和管理形状 class ShapeRegistry { private Map shapeMap = new HashMap\u003c\u003e(); // 注册形状，使用形状 ID 作为键 public void registerShape(String shapeId, Shape shape) { shapeMap.put(shapeId, shape); } // 获取形状，通过克隆返回一个新的对象 public Shape getShape(String shapeId) { Shape shape = shapeMap.get(shapeId); return shape != null ? shape.clone() : null; } } public class Main { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); ShapeRegistry shapeRegistry = new ShapeRegistry(); // 注册一个默认的矩形形状 shapeRegistry.registerShape(\"defaultRectangle\", new Rectangle(10, 20, \"red\")); String input = scanner.nextLine(); String[] parts = input.split(\" \"); if (parts.length == 3) { String color = parts[0]; try { int width = Integer.parseInt(parts[1]); int height = Integer.parseInt(parts[2]); //创建并注册一个新的矩形 Shape newRectangle = new Rectangle(height, width, color); shapeRegistry.registerShape(\"userRectangle\", newRectangle); int num = scanner.nextInt(); for (int i = 0; i \u003c num; i++) { Shape clonedShape = shapeRegistry.getShape(\"userRectangle\"); if (clonedShape != null) { System.out.println(\"Color: \" + clonedShape.getColor() + \", Width: \" + clonedShape.getWidth() + \", Height: \" + clonedShape.getHeight()); } else { System.out.println(\"在注册表中找不到形状.\"); } } } catch (NumberFormatException e) { System.out.println(\"输入错误，请重新输入.\"); } } else { System.out.println(\"输入格式错误，请按格式输入：颜色 宽度 高度.\"); } scanner.close(); } } C++ link #include #include #include // 抽象原型类 class Prototype { public: virtual Prototype* clone() const = 0; virtual std::string getDetails() const = 0; virtual ~Prototype() {} }; // 具体矩形原型类 class RectanglePrototype : public Prototype { private: std::string color; int width; int height; public: // 构造方法 RectanglePrototype(std::string color, int width, int height) : color(color), width(width), height(height) {} // 克隆方法 Prototype* clone() const override { return new RectanglePrototype(*this); } // 获取矩形的详细信息 std::string getDetails() const override { return \"Color: \" + color + \", Width: \" + std::to_string(width) + \", Height: \" + std::to_string(height); } }; // 客户端程序 int main() { std::vector rectangles; // 读取需要创建的矩形数量 int N; std::cin \u003e\u003e N; // 读取每个矩形的属性信息并创建矩形对象 for (int i = 0; i \u003c N; i++) { std::string color; int width, height; std::cin \u003e\u003e color \u003e\u003e width \u003e\u003e height; // 创建原型对象 Prototype* originalRectangle = new RectanglePrototype(color, width, height); // 将原型对象保存到向量中 rectangles.push_back(originalRectangle); } // 克隆对象并输出详细信息 for (const auto\u0026 rectangle : rectangles) { Prototype* clonedRectangle = rectangle-\u003eclone(); std::cout \u003c\u003c clonedRectangle-\u003egetDetails() \u003c\u003c std::endl; // 释放克隆对象的内存 delete clonedRectangle; } // 释放原型对象的内存 for (const auto\u0026 rectangle : rectangles) { delete rectangle; } return 0; } Python link from abc import ABC, abstractmethod # 抽象原型类 class Prototype(ABC): @abstractmethod def clone(self): pass @abstractmethod def get_details(self): pass # 公共的 clone 方法 def clone_prototype(self): try: return self.clone() except Exception as e: print(e) return None # 具体矩形原型类 class RectanglePrototype(Prototype): def __init__(self, color, width, height): self.color = color self.width = width self.height = height # 克隆方法 def clone(self): return RectanglePrototype(self.color, self.width, self.height) # 获取矩形的详细信息 def get_details(self): return f\"Color: {self.color}, Width: {self.width}, Height: {self.height}\" # 客户端程序 if __name__ == \"__main__\": # 读取需要创建的矩形数量 N = int(input()) # 读取每个矩形的属性信息并创建矩形对象 for _ in range(N): line = input() parts = line.split() color = parts[0] width = int(parts[1]) height = int(parts[2]) # 创建原型对象 original_rectangle = RectanglePrototype(color, width, height) # 克隆对象并输出详细信息 cloned_rectangle = original_rectangle.clone() print(cloned_rectangle.get_details()) Go link package main import ( \"fmt\" ) // 抽象原型类 type Prototype interface { clone() Prototype getDetails() string } // 具体矩形原型类 type RectanglePrototype struct { color string width int height int } // 构造方法 func NewRectanglePrototype(color string, width, height int) *RectanglePrototype { return \u0026RectanglePrototype{ color: color, width: width, height: height, } } // 实现 Prototype 接口的 clone 方法 func (r *RectanglePrototype) clone() Prototype { return \u0026RectanglePrototype{ color: r.color, width: r.width, height: r.height, } } // 获取矩形的详细信息 func (r *RectanglePrototype) getDetails() string { return fmt.Sprintf(\"Color: %s, Width: %d, Height: %d\", r.color, r.width, r.height) } // 客户端程序 func main() { // 读取需要创建的矩形数量 var N int fmt.Scan(\u0026N) // 读取每个矩形的属性信息并创建矩形对象 for i := 0; i \u003c N; i++ { var color string var width, height int fmt.Scan(\u0026color, \u0026width, \u0026height) // 创建原型对象 originalRectangle := NewRectanglePrototype(color, width, height) // 克隆对象并输出详细信息 clonedRectangle := originalRectangle.clone() fmt.Println(clonedRectangle.getDetails()) } } "
            }
        );
    index.add(
            {
                id:  19 ,
                href: "\/docs\/dev\/23designpattern\/6.%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F\/",
                title: "6.适配器模式",
                description: "它可以将一个类的接口转换成客户希望的另一个接口，主要目的是充当两个不同接口之间的桥梁，使得原本接口不兼容的类能够一起工作。",
                content: "需求 link【设计模式专题之适配器模式】6. 扩展坞\n题目描述\n小明购买了一台新电脑，该电脑使用 TypeC 接口，他已经有了一个USB接口的充电器和数据线，为了确保新电脑可以使用现有的USB接口充电器和数据线，他购买了一个TypeC到USB的扩展坞。 请你使用适配器模式设计并实现这个扩展坞系统，确保小明的新电脑既可以通过扩展坞使用现有的USB接口充电线和数据线，也可以使用TypeC接口充电。 输入描述\n题目包含多行输入，第一行输入一个数字 N （1 \u003c N \u003c= 20)，表示后面有N组测试数据。 之后N行都是一个整数，1表示使用电脑本身的TypeC接口，2表示使用扩展坞的USB接口充电。 输入示例 3 1 2 1 输出示例 TypeC USB Adapter TypeC 什么是适配器 link适配器模式Adapter是一种结构型设计模式，它可以将一个类的接口转换成客户希望的另一个接口，主要目的是充当两个不同接口之间的桥梁，使得原本接口不兼容的类能够一起工作。\n基本结构 link适配器模式分为以下几个基本角色：\n可以把适配器模式理解成拓展坞，起到转接的作用，原有的接口是USB，但是客户端需要使用type-c， 便使用拓展坞提供一个type-c接口给客户端使用\n目标接口Target: 客户端希望使用的接口 适配器类Adapter: 实现客户端使用的目标接口，持有一个需要适配的类实例。 被适配者Adaptee: 需要被适配的类 这样，客户端就可以使用目标接口，而不需要对原来的Adaptee进行修改，Adapter起到一个转接扩展的作用。\n基本实现 link // 目标接口 interface Target { void request(); } // 被适配者类 class Adaptee { void specificRequest() { System.out.println(\"Specific request\"); } } // 适配器类 class Adapter implements Target { // 持有一个被适配者实例 private Adaptee adaptee; public Adapter(Adaptee adaptee) { this.adaptee = adaptee; } @Override public void request() { // 调用被适配者类的方法 adaptee.specificRequest(); } } // 客户端代码 public class Client { public static void main(String[] args) { Target target = new Adapter(new Adaptee()); target.request(); } } 应用场景 link在开发过程中，适配器模式往往扮演者“补救”和“扩展”的角色：\n当使用一个已经存在的类，但是它的接口与你的代码不兼容时，可以使用适配器模式。\n在系统扩展阶段需要增加新的类时，并且类的接口和系统现有的类不一致时，可以使用适配器模式。\n使用适配器模式可以将客户端代码与具体的类解耦，客户端不需要知道被适配者的细节，客户端代码也不需要修改，这使得它具有良好的扩展性，但是这也势必导致系统变得更加复杂。\n具体来说，适配器模式有着以下应用：\n不同的项目和库可能使用不同的日志框架，不同的日志框架提供的API也不同，因此引入了适配器模式使得不同的API适配为统一接口。\nSpring MVC中，HandlerAdapter 接口是适配器模式的一种应用。它负责将处理器（Handler）适配到框架中，使得不同类型的处理器能够统一处理请求。\n在.NET中，DataAdapter 用于在数据源（如数据库）和 DataSet 之间建立适配器，将数据从数据源适配到 DataSet 中，以便在.NET应用程序中使用。\n本题代码 link // 测试程序 import java.util.Scanner; // USB 接口 interface USB { void charge(); } // TypeC 接口 interface TypeC { void chargeWithTypeC(); } // 适配器类 class TypeCAdapter implements USB { private TypeC typeC; public TypeCAdapter(TypeC typeC) { this.typeC = typeC; } @Override public void charge() { typeC.chargeWithTypeC(); } } // 新电脑类，使用 TypeC 接口 class NewComputer implements TypeC { @Override public void chargeWithTypeC() { System.out.println(\"TypeC\"); } } // 适配器充电器类，使用 USB 接口 class AdapterCharger implements USB { @Override public void charge() { System.out.println(\"USB Adapter\"); } } public class Main { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); // 读取连接次数 int N = scanner.nextInt(); scanner.nextLine(); // 消耗换行符 for (int i = 0; i \u003c N; i++) { // 读取用户选择 int choice = scanner.nextInt(); // 根据用户的选择创建相应对象 if (choice == 1) { TypeC newComputer = new NewComputer(); newComputer.chargeWithTypeC(); } else if (choice == 2) { USB usbAdapter = new AdapterCharger(); usbAdapter.charge(); } } scanner.close(); } } 其他语言代码 linkJava link类适配器模式代码：\nimport java.util.*; // 定义计算机端口接口 interface ComputerPort { void connect(); } // TypeC端口类实现ComputerPort接口 class TypeCPort implements ComputerPort { @Override public void connect() { System.out.println(\"TypeC\"); } } // USB设备类 class USBDevice { public void connectUSB() { System.out.println(\"USB Adapter\"); } } // TypeC到USB适配器类 class TypeCToUSBAdapter extends USBDevice implements ComputerPort { @Override public void connect() { super.connectUSB(); } } public class Main{ public static void main(String[] args) { Scanner inputScanner = new Scanner(System.in); Map connectionModes = new HashMap\u003c\u003e(); connectionModes.put(1, new TypeCPort()); connectionModes.put(2, new TypeCToUSBAdapter()); int totalConnections = inputScanner.nextInt(); inputScanner.nextLine(); while (inputScanner.hasNextInt()) { int choice = inputScanner.nextInt(); connectionModes.getOrDefault(choice, () -\u003e System.out.println(\"\")).connect(); } inputScanner.close(); } } C++ link #include // USB 接口 class USB { public: virtual void charge() = 0; }; // TypeC 接口 class TypeC { public: virtual void chargeWithTypeC() = 0; }; // 适配器类 class TypeCAdapter : public USB { private: TypeC* typeC; public: TypeCAdapter(TypeC* typeC) : typeC(typeC) {} void charge() override { typeC-\u003echargeWithTypeC(); } }; // 新电脑类，使用 TypeC 接口 class NewComputer : public TypeC { public: void chargeWithTypeC() override { std::cout \u003c\u003c \"TypeC\" \u003c\u003c std::endl; } }; // 适配器充电器类，使用 USB 接口 class AdapterCharger : public USB { public: void charge() override { std::cout \u003c\u003c \"USB Adapter\" \u003c\u003c std::endl; } }; int main() { // 读取连接次数 int N; std::cin \u003e\u003e N; std::cin.ignore(); // 消耗换行符 for (int i = 0; i \u003c N; i++) { // 读取用户选择 int choice; std::cin \u003e\u003e choice; // 根据用户的选择创建相应对象 if (choice == 1) { TypeC* newComputer = new NewComputer(); newComputer-\u003echargeWithTypeC(); delete newComputer; } else if (choice == 2) { USB* usbAdapter = new AdapterCharger(); usbAdapter-\u003echarge(); delete usbAdapter; } } return 0; } Python link # USB 接口 class USB: def charge(self): pass # TypeC 接口 class TypeC: def charge_with_type_c(self): pass # 适配器类 class TypeCAdapter(USB): def __init__(self, type_c): self.type_c = type_c def charge(self): self.type_c.charge_with_type_c() # 新电脑类，使用 TypeC 接口 class NewComputer(TypeC): def charge_with_type_c(self): print(\"TypeC\") # 适配器充电器类，使用 USB 接口 class AdapterCharger(USB): def charge(self): print(\"USB Adapter\") if __name__ == \"__main__\": # 读取连接次数 N = int(input()) for _ in range(N): # 读取用户选择 choice = int(input()) # 根据用户的选择创建相应对象 if choice == 1: new_computer = NewComputer() new_computer.charge_with_type_c() elif choice == 2: usb_adapter = AdapterCharger() usb_adapter.charge() Go link package main import \"fmt\" // USB 接口 type USB interface { charge() } // TypeC 接口 type TypeC interface { chargeWithTypeC() } // 适配器类 type TypeCAdapter struct { typeC TypeC } func (tca *TypeCAdapter) charge() { tca.typeC.chargeWithTypeC() } // 新电脑类，使用 TypeC 接口 type NewComputer struct{} func (nc *NewComputer) chargeWithTypeC() { fmt.Println(\"TypeC\") } // 适配器充电器类，使用 USB 接口 type AdapterCharger struct{} func (ac *AdapterCharger) charge() { fmt.Println(\"USB Adapter\") } func main() { var N int fmt.Scan(\u0026N) // 读取连接次数 for i := 0; i \u003c N; i++ { var choice int fmt.Scan(\u0026choice) // 读取用户选择 // 根据用户的选择创建相应对象 if choice == 1 { newComputer := \u0026NewComputer{} adapter := \u0026TypeCAdapter{typeC: newComputer} adapter.charge() } else if choice == 2 { usbAdapter := \u0026AdapterCharger{} usbAdapter.charge() } } } "
            }
        );
    index.add(
            {
                id:  20 ,
                href: "\/docs\/dev\/23designpattern\/7.%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F\/",
                title: "7.代理模式",
                description: "代理模式中，允许一个对象（代理）充当另一个对象（真实对象）的接口，以控制对这个对象的访问。",
                content: "需求 link【设计模式专题之代理模式】7-小明买房子\n题目描述\n小明想要购买一套房子，他决定寻求一家房屋中介来帮助他找到一个面积超过100平方米的房子，只有符合条件的房子才会被传递给小明查看。 输入描述\n第一行是一个整数 N（1 ≤ N ≤ 100），表示可供查看的房子的数量。 接下来的 N 行，每行包含一个整数，表示对应房子的房屋面积。 输出描述\n对于每个房子，输出一行，表示是否符合购房条件。如果房屋面积超过100平方米，输出 “YES”；否则输出 “NO”。 输入示例 3 120 80 110 输出示例 YES NO YES 基本概念 link代理模式Proxy Pattern是一种结构型设计模式，用于控制对其他对象的访问。\n在代理模式中，允许一个对象（代理）充当另一个对象（真实对象）的接口，以控制对这个对象的访问。通常用于在访问某个对象时引入一些间接层(中介的作用)，这样可以在访问对象时添加额外的控制逻辑，比如限制访问权限，延迟加载。\n比如说有一个文件加载的场景，为了避免直接访问“文件”对象，我们可以新增一个代理对象，代理对象中有一个对“文件对象”的引用，在代理对象的 load 方法中，可以在访问真实的文件对象之前进行一些操作，比如权限检查，然后调用真实文件对象的 load 方法，最后在访问真实对象后进行其他操作，比如记录访问日志。\n基本结构 link代理模式的主要角色有：\nSubject（抽象主题）： 抽象类，通过接口或抽象类声明真实主题和代理对象实现的业务方法。\nRealSubject（真实主题）：定义了Proxy所代表的真实对象，是客户端最终要访问的对象。\nProxy（代理）：包含一个引用，该引用可以是RealSubject的实例，控制对RealSubject的访问，并可能负责创建和删除RealSubject的实例。\n实现方式 link代理模式的基本实现分为以下几个步骤：\n定义抽象主题, 一般是接口或者抽象类，声明真实主题和代理对象实现的业务方法。 // 1. 定义抽象主题 interface Subject { void request(); } 定义真实主题，实现抽象主题中的具体业务 // 2. 定义真实主题 class RealSubject implements Subject { @Override public void request() { System.out.println(\"RealSubject handles the request.\"); } } 定义代理类，包含对RealSubject的引用，并提供和真实主题相同的接口，这样代理就可以替代真实主题，并对真实主题进行功能扩展。 // 3. 定义代理 class Proxy implements Subject { // 包含一个引用 private RealSubject realSubject; @Override public void request() { // 在访问真实主题之前可以添加额外的逻辑 if (realSubject == null) { realSubject = new RealSubject(); } // 调用真实主题的方法 realSubject.request(); // 在访问真实主题之后可以添加额外的逻辑 } } 客户端使用代理 // 4. 客户端使用代理 public class Main { public static void main(String[] args) { // 使用代理 Subject proxy = new Proxy(); proxy.request(); } } 使用场景 link代理模式可以控制客户端对真实对象的访问，从而限制某些客户端的访问权限，此外代理模式还常用在访问真实对象之前或之后执行一些额外的操作（比如记录日志），对功能进行扩展。\n以上特性决定了代理模式在以下几个场景中有着广泛的应用：\n虚拟代理：当一个对象的创建和初始化比较昂贵时，可以使用虚拟代理，虚拟代理可以延迟对象的实际创建和初始化，只有在需要时才真正创建并初始化对象。 安全代理：安全代理可以根据访问者的权限决定是否允许访问真实对象的方法。 但是代理模式涉及到多个对象之间的交互，引入代理模式会增加系统的复杂性，在需要频繁访问真实对象时，还可能会有一些性能问题。\n代理模式在许多工具和库中也有应用：\nSpring 框架的 AOP 模块使用了代理模式来实现切面编程。通过代理，Spring 能够在目标对象的方法执行前、执行后或抛出异常时插入切面逻辑，而不需要修改原始代码。 Java 提供了动态代理机制，允许在运行时生成代理类。 Android中的Glide框架使用了代理模式来实现图片的延迟加载。 本题代码 link import java.util.Scanner; // 抽象主题 interface HomePurchase { void requestPurchase(int area); } //真实主题 class HomeBuyer implements HomePurchase { @Override public void requestPurchase(int area) { System.out.println(\"YES\"); } } // 代理类 class HomeAgentProxy implements HomePurchase { private HomeBuyer homeBuyer = new HomeBuyer(); @Override public void requestPurchase(int area) { if (area \u003e 100) { homeBuyer.requestPurchase(area); } else { System.out.println(\"NO\"); } } } public class Main { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); HomePurchase buyerProxy = new HomeAgentProxy(); int n = scanner.nextInt(); for (int i = 0; i \u003c n; i++) { int area = scanner.nextInt(); buyerProxy.requestPurchase(area); } scanner.close(); } } 扩展：代理模式和适配器模式有什么区别 link代理模式的主要目的是控制对对象的访问。通常用于在访问真实对象时引入一些额外的控制逻辑，如权限控制、延迟加载等。\n适配器模式的主要目的是使接口不兼容的对象能够协同工作。适配器模式允许将一个类的接口转换成另一个类的接口，使得不同接口的类可以协同工作。\n其他语言代码 linkC++ link #include // 抽象主题 class HomePurchase { public: virtual void requestPurchase(int area) = 0; }; // 真实主题 class HomeBuyer : public HomePurchase { public: void requestPurchase(int area) override { std::cout \u003c\u003c \"YES\" \u003c\u003c std::endl; } }; // 代理类 class HomeAgentProxy : public HomePurchase { private: HomeBuyer homeBuyer; public: void requestPurchase(int area) override { if (area \u003e 100) { homeBuyer.requestPurchase(area); } else { std::cout \u003c\u003c \"NO\" \u003c\u003c std::endl; } } }; int main() { HomePurchase* buyerProxy = new HomeAgentProxy(); int n; std::cin \u003e\u003e n; for (int i = 0; i \u003c n; i++) { int area; std::cin \u003e\u003e area; buyerProxy-\u003erequestPurchase(area); } delete buyerProxy; return 0; } Python link # 抽象主题 class HomePurchase: def request_purchase(self, area): pass # 真实主题 class HomeBuyer(HomePurchase): def request_purchase(self, area): print(\"YES\") # 代理类 class HomeAgentProxy(HomePurchase): def __init__(self): self.home_buyer = HomeBuyer() def request_purchase(self, area): if area \u003e 100: self.home_buyer.request_purchase(area) else: print(\"NO\") if __name__ == \"__main__\": buyer_proxy = HomeAgentProxy() n = int(input()) for _ in range(n): area = int(input()) buyer_proxy.request_purchase(area) Go link package main import \"fmt\" // 抽象主题 type HomePurchase interface { requestPurchase(area int) } // 真实主题 type HomeBuyer struct{} func (hb *HomeBuyer) requestPurchase(area int) { fmt.Println(\"YES\") } // 代理类 type HomeAgentProxy struct { homeBuyer HomePurchase } func (hap *HomeAgentProxy) requestPurchase(area int) { if area \u003e 100 { hap.homeBuyer.requestPurchase(area) } else { fmt.Println(\"NO\") } } func main() { var buyerProxy HomePurchase = \u0026HomeAgentProxy{homeBuyer: \u0026HomeBuyer{}} var n int fmt.Scan(\u0026n) for i := 0; i \u003c n; i++ { var area int fmt.Scan(\u0026area) buyerProxy.requestPurchase(area) } } "
            }
        );
    index.add(
            {
                id:  21 ,
                href: "\/docs\/dev\/23designpattern\/8.%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F\/",
                title: "8.装饰模式",
                description: " 通常情况下，扩展类的功能可以通过继承实现，但是扩展越多，子类越多，装饰模式可以在**不定义子类的情况下动态的给对象添加一些额外的功能。**",
                content: "需求 link【设计模式专题装饰模式】8-咖啡加糖\n题目描述\n小明喜欢品尝不同口味的咖啡，他发现每种咖啡都可以加入不同的调料，比如牛奶、糖和巧克力。他决定使用装饰者模式制作自己喜欢的咖啡。 请设计一个简单的咖啡制作系统，使用装饰者模式为咖啡添加不同的调料。系统支持两种咖啡类型：黑咖啡（Black Coffee）和拿铁（Latte）。 输入描述\n多行输入，每行包含两个数字。第一个数字表示咖啡的选择（1 表示黑咖啡，2 表示拿铁），第二个数字表示要添加的调料类型（1 表示牛奶，2 表示糖）。 输出描述\n根据每行输入，输出制作咖啡的过程，包括咖啡类型和添加的调料。 输入示例 1 1 2 2 输出示例 Brewing Black Coffee Adding Milk Brewing Latte Adding Sugar 基本概念 link通常情况下，扩展类的功能可以通过继承实现，但是扩展越多，子类越多，装饰模式（Decorator Pattern, 结构型设计模式）可以在**不定义子类的情况下动态的给对象添加一些额外的功能。**具体的做法是将原始对象放入包含行为的特殊封装类(装饰类)，从而为原始对象动态添加新的行为，而无需修改其代码。\n举个简单的例子，假设你有一个基础的图形类，你想要为图形类添加颜色、边框、阴影等功能，如果每个功能都实现一个子类，就会导致产生大量的类，这时就可以考虑使用装饰模式来动态地添加，而不需要修改图形类本身的代码，这样可以使得代码更加灵活、更容易维护和扩展。\n基本结构： link装饰模式包含以下四个主要角色：\n组件Component：通常是抽象类或者接口，是具体组件和装饰者的父类，定义了具体组件需要实现的方法，比如说我们定义Coffee为组件。 具体组件ConcreteComponent: 实现了Component接口的具体类，是被装饰的对象。 装饰类Decorator: 一个抽象类，给具体组件添加功能，但是具体的功能由其子类具体装饰者完成，持有一个指向Component对象的引用。 具体装饰类ConcreteDecorator: 扩展Decorator类，负责向Component对象添加新的行为，加牛奶的咖啡是一个具体装饰类，加糖的咖啡也是一个具体装饰类。 基本实现 link装饰模式的实现包括以下步骤：\n定义Component接口 // 组件接口 public interface Component { void operation(); } 实现 ConcreteComponent // 具体组件 public class ConcreteComponent implements Component { @Override public void operation() { System.out.println(\"ConcreteComponent operation\"); } } 定义Decorator装饰类，继承自Component // 定义一个抽象的装饰者类，继承自Component public abstract class Decorator implements Component { protected Component component; public Decorator(Component component) { this.component = component; } @Override public void operation() { component.operation(); } } 定义具体的装饰者实现，给具体组件对象添加功能。 // 具体的装饰者实现 public class ConcreteDecorator extends Decorator { public ConcreteDecorator(Component component) { super(component); } // 根据需要添加额外的方法 @Override public void operation() { // 可以在调用前后添加额外的行为 System.out.println(\"Before operation in ConcreteDecorator\"); super.operation(); System.out.println(\"After operation in ConcreteDecorator\"); } } 在客户端使用 public class Main { public static void main(String[] args) { // 创建具体组件 Component concreteComponent = new ConcreteComponent(); // 使用具体装饰者包装具体组件 Decorator decorator = new ConcreteDecorator(concreteComponent); // 调用操作 decorator.operation(); } } 应用场景 link装饰模式通常在以下几种情况使用：\n当需要给一个现有类添加附加功能，但由于某些原因不能使用继承来生成子类进行扩充时，可以使用装饰模式。\n动态的添加和覆盖功能：当对象的功能要求可以动态地添加，也可以再动态地撤销时可以使用装饰模式。\n在Java的I/O库中，装饰者模式被广泛用于增强I/O流的功能。例如，BufferedInputStream和BufferedOutputStream这两个类提供了缓冲区的支持，通过在底层的输入流和输出流上添加缓冲区，提高了读写的效率，它们都是InputStream和OutputStream的装饰器。BufferedReader和BufferedWriter这两个类与BufferedInputStream和BufferedOutputStream类似，提供了字符流的缓冲功能，是Reader和Writer的装饰者。\n本题代码 link import java.util.Scanner; // 咖啡接口 interface Coffee { void brew(); } // 具体的黑咖啡类 class BlackCoffee implements Coffee { @Override public void brew() { System.out.println(\"Brewing Black Coffee\"); } } // 具体的拿铁类 class Latte implements Coffee { @Override public void brew() { System.out.println(\"Brewing Latte\"); } } // 装饰者抽象类 abstract class Decorator implements Coffee { protected Coffee coffee; public Decorator(Coffee coffee) { this.coffee = coffee; } @Override public void brew() { coffee.brew(); } } // 具体的牛奶装饰者类 class MilkDecorator extends Decorator { public MilkDecorator(Coffee coffee) { super(coffee); } @Override public void brew() { super.brew(); System.out.println(\"Adding Milk\"); } } // 具体的糖装饰者类 class SugarDecorator extends Decorator { public SugarDecorator(Coffee coffee) { super(coffee); } @Override public void brew() { super.brew(); System.out.println(\"Adding Sugar\"); } } // 客户端代码 public class Main { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); while (scanner.hasNext()) { int coffeeType = scanner.nextInt(); int condimentType = scanner.nextInt(); // 根据输入制作咖啡 Coffee coffee; if (coffeeType == 1) { coffee = new BlackCoffee(); } else if (coffeeType == 2) { coffee = new Latte(); } else { System.out.println(\"Invalid coffee type\"); continue; } // 根据输入添加调料 if (condimentType == 1) { coffee = new MilkDecorator(coffee); } else if (condimentType == 2) { coffee = new SugarDecorator(coffee); } else { System.out.println(\"Invalid condiment type\"); continue; } // 输出制作过程 coffee.brew(); } } } 其他语言版本 linkJava link将处理输入和创建对象的逻辑分离到方法中。\nimport java.util.Scanner; // 定义咖啡接口 interface Coffee { void execute(); } // 黑咖啡类，实现咖啡接口 class BrewingBlackCoffee implements Coffee { @Override public void execute() { System.out.println(\"Brewing Black Coffee\"); } } // 拿铁类，实现咖啡接口 class BrewingLatte implements Coffee { @Override public void execute() { System.out.println(\"Brewing Latte\"); } } // 咖啡装饰器抽象类，实现咖啡接口 abstract class Decorator implements Coffee { private Coffee coffee; public Decorator(Coffee coffee) { this.coffee = coffee; } @Override public void execute() { coffee.execute(); } } // 牛奶装饰器类，继承自装饰器类 class MilkDecorator extends Decorator { public MilkDecorator(Coffee coffee) { super(coffee); } @Override public void execute() { super.execute(); System.out.println(\"Adding Milk\"); } } // 糖装饰器类，继承自装饰器类 class SugarDecorator extends Decorator { public SugarDecorator(Coffee coffee) { super(coffee); } @Override public void execute() { super.execute(); System.out.println(\"Adding Sugar\"); } } public class Main { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); try { String input; while (scanner.hasNextLine()) { input = scanner.nextLine(); if (input.equalsIgnoreCase(\"exit\")) { break; } processInput(input); } } catch (NumberFormatException e) { System.out.println(\"输入格式无效：\" + e.getMessage()); } finally { scanner.close(); } } // 处理输入的方法 private static void processInput(String input) { String[] parts = input.split(\" \"); if (parts.length != 2) { System.out.println(\"输入格式无效。请提供两个数字，中间用空格分隔。\"); return; } try { int type1 = Integer.parseInt(parts[0]); int type2 = Integer.parseInt(parts[1]); Coffee coffee = createCoffee(type1); if (coffee == null) { System.out.println(\"咖啡类型无效。请输入1（黑咖啡）或2（拿铁）。\"); return; } coffee = decorateCoffee(coffee, type2); if (coffee == null) { System.out.println(\"装饰类型无效。请输入1（牛奶）或2（糖）。\"); return; } coffee.execute(); } catch (NumberFormatException e) { System.out.println(\"输入格式无效：两个输入都必须是数字。\"); } } // 创建咖啡对象的方法 private static Coffee createCoffee(int type) { switch (type) { case 1: return new BrewingBlackCoffee(); case 2: return new BrewingLatte(); default: return null; } } // 添加装饰器的方法 private static Coffee decorateCoffee(Coffee coffee, int type) { switch (type) { case 1: return new MilkDecorator(coffee); case 2: return new SugarDecorator(coffee); default: return null; } } } C++ link #include #include // 咖啡接口 class Coffee { public: virtual ~Coffee() {} virtual void brew() = 0; }; // 具体的黑咖啡类 class BlackCoffee : public Coffee { public: void brew() override { std::cout \u003c\u003c \"Brewing Black Coffee\" \u003c\u003c std::endl; } }; // 具体的拿铁类 class Latte : public Coffee { public: void brew() override { std::cout \u003c\u003c \"Brewing Latte\" \u003c\u003c std::endl; } }; // 装饰者抽象类 class Decorator : public Coffee { protected: std::unique_ptr coffee; public: Decorator(std::unique_ptr coffee) : coffee(std::move(coffee)) {} void brew() override { if (coffee) { coffee-\u003ebrew(); } } }; // 具体的牛奶装饰者类 class MilkDecorator : public Decorator { public: MilkDecorator(std::unique_ptr coffee) : Decorator(std::move(coffee)) {} void brew() override { Decorator::brew(); std::cout \u003c\u003c \"Adding Milk\" \u003c\u003c std::endl; } }; // 具体的糖装饰者类 class SugarDecorator : public Decorator { public: SugarDecorator(std::unique_ptr coffee) : Decorator(std::move(coffee)) {} void brew() override { Decorator::brew(); std::cout \u003c\u003c \"Adding Sugar\" \u003c\u003c std::endl; } }; // 客户端代码 int main() { int coffeeType, condimentType; while (std::cin \u003e\u003e coffeeType \u003e\u003e condimentType) { // 根据输入制作咖啡 std::unique_ptr coffee; if (coffeeType == 1) { coffee = std::make_unique(); } else if (coffeeType == 2) { coffee = std::make_unique(); } else { std::cout \u003c\u003c \"Invalid coffee type\" \u003c\u003c std::endl; continue; } // 根据输入添加调料 if (condimentType == 1) { coffee = std::make_unique(std::move(coffee)); } else if (condimentType == 2) { coffee = std::make_unique(std::move(coffee)); } else { std::cout \u003c\u003c \"Invalid condiment type\" \u003c\u003c std::endl; continue; } // 输出制作过程 coffee-\u003ebrew(); } return 0; } Python link from abc import ABC, abstractmethod from typing import Type # 咖啡接口 class Coffee(ABC): @abstractmethod def brew(self): pass # 具体的黑咖啡类 class BlackCoffee(Coffee): def brew(self): print(\"Brewing Black Coffee\") # 具体的拿铁类 class Latte(Coffee): def brew(self): print(\"Brewing Latte\") # 装饰者抽象类 class Decorator(Coffee, ABC): def __init__(self, coffee: Type[Coffee]): self._coffee = coffee def brew(self): self._coffee.brew() # 具体的牛奶装饰者类 class MilkDecorator(Decorator): def brew(self): super().brew() print(\"Adding Milk\") # 具体的糖装饰者类 class SugarDecorator(Decorator): def brew(self): super().brew() print(\"Adding Sugar\") # 客户端代码 if __name__ == \"__main__\": try: while True: coffee_type, condiment_type = map(int, input().split()) # 根据输入制作咖啡 if coffee_type == 1: coffee = BlackCoffee() elif coffee_type == 2: coffee = Latte() else: print(\"Invalid coffee type\") continue # 根据输入添加调料 if condiment_type == 1: coffee = MilkDecorator(coffee) elif condiment_type == 2: coffee = SugarDecorator(coffee) else: print(\"Invalid condiment type\") continue # 输出制作过程 coffee.brew() except EOFError: pass Go link package main import \"fmt\" // 咖啡接口 type Coffee interface { brew() } // 具体的黑咖啡类 type BlackCoffee struct{} func (bc *BlackCoffee) brew() { fmt.Println(\"Brewing Black Coffee\") } // 具体的拿铁类 type Latte struct{} func (l *Latte) brew() { fmt.Println(\"Brewing Latte\") } // 装饰者抽象类 type Decorator struct { coffee Coffee } func (d *Decorator) brew() { d.coffee.brew() } // 具体的牛奶装饰者类 type MilkDecorator struct { Decorator } func (md *MilkDecorator) brew() { md.Decorator.brew() fmt.Println(\"Adding Milk\") } // 具体的糖装饰者类 type SugarDecorator struct { Decorator } func (sd *SugarDecorator) brew() { sd.Decorator.brew() fmt.Println(\"Adding Sugar\") } func main() { for { var coffeeType, condimentType int if _, err := fmt.Scan(\u0026coffeeType, \u0026condimentType); err != nil { break } // 根据输入制作咖啡 var coffee Coffee if coffeeType == 1 { coffee = \u0026BlackCoffee{} } else if coffeeType == 2 { coffee = \u0026Latte{} } else { fmt.Println(\"Invalid coffee type\") continue } // 根据输入添加调料 if condimentType == 1 { coffee = \u0026MilkDecorator{Decorator: Decorator{coffee: coffee}} } else if condimentType == 2 { coffee = \u0026SugarDecorator{Decorator: Decorator{coffee: coffee}} } else { fmt.Println(\"Invalid condiment type\") continue } // 输出制作过程 coffee.brew() } } "
            }
        );
    index.add(
            {
                id:  22 ,
                href: "\/docs\/dev\/23designpattern\/9.%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F\/",
                title: "9.外观模式",
                description: "外观模式`Facade Pattern`,  也被称为“门面模式”，是一种结构型设计模式，外观模式定义了一个高层接口，这个接口使得子系统更容易使用，同时也隐藏了子系统的复杂性。",
                content: "需求 link【设计模式专题之外观模式】9-电源开关\n题目描述\n小明家的电源总开关控制了家里的三个设备：空调、台灯和电视机。每个设备都有独立的开关密码，分别用数字1、2和3表示。即输入1时，空调关闭，输入2时，台灯关闭，输入3时，电视机关闭，当输入为4时，表示要关闭所有设备。请你使用外观模式编写程序来描述电源总开关的操作。 输入描述\n第一行是一个整数 N（1 \u003c= N \u003c= 100），表示后面有 N 行输入。 接下来的 N 行，每行包含一个数字，表示对应设备的开关操作（1表示关闭空调，2表示关闭台灯，3表示关闭电视机，4表示关闭所有设备）。 输出描述\n输出关闭所有设备后的状态，当输入的数字不在1-4范围内时，输出Invalid device code. 输入示例 4 1 2 3 4 输出示例 Air Conditioner is turned off. Desk Lamp is turned off. Television is turned off. All devices are off. 基本概念 link外观模式Facade Pattern, 也被称为“门面模式”，是一种结构型设计模式，外观模式定义了一个高层接口，这个接口使得子系统更容易使用，同时也隐藏了子系统的复杂性。\n门面模式可以将子系统关在“门里”隐藏起来，客户端只需要通过外观接口与外观对象进行交互，而不需要直接和多个子系统交互，无论子系统多么复杂，对于外部来说是隐藏的，这样可以降低系统的耦合度。\n举个例子，假设你正在编写的一个模块用来处理文件读取、解析、存储，我们可以将这个过程拆成三部分，然后创建一个外观类，将文件系统操作、数据解析和存储操作封装在外观类中，为客户端提供一个简化的接口，如果后续需要修改文件处理的流程或替换底层子系统，也只需在外观类中进行调整，不会影响客户端代码。\n基本结构 link外观模式的基本结构比较简单，只包括“外观”和“子系统类”\n外观类：对外提供一个统一的高层次接口，使复杂的子系统变得更易使用。 子系统类：实现子系统的功能，处理外观类指派的任务。 简易实现 link下面使用Java代码实现外观模式的通用结构\n// 子系统A class SubsystemA { public void operationA() { System.out.println(\"SubsystemA operation\"); } } // 子系统B class SubsystemB { public void operationB() { System.out.println(\"SubsystemB operation\"); } } // 子系统C class SubsystemC { public void operationC() { System.out.println(\"SubsystemC operation\"); } } // 外观类 class Facade { private SubsystemA subsystemA; private SubsystemB subsystemB; private SubsystemC subsystemC; public Facade() { this.subsystemA = new SubsystemA(); this.subsystemB = new SubsystemB(); this.subsystemC = new SubsystemC(); } // 外观方法，封装了对子系统的操作 public void facadeOperation() { subsystemA.operationA(); subsystemB.operationB(); subsystemC.operationC(); } } // 客户端 public class Main { public static void main(String[] args) { // 创建外观对象 Facade facade = new Facade(); // 客户端通过外观类调用子系统的操作 facade.facadeOperation(); } } 在上面的代码中，Facade 类是外观类，封装了对三个子系统SubSystem的操作。客户端通过调用外观类的方法来实现对子系统的访问，而不需要直接调用子系统的方法。\n优缺点和使用场景 link外观模式通过提供一个简化的接口，隐藏了系统的复杂性，降低了客户端和子系统之间的耦合度，客户端不需要了解系统的内部实现细节，也不需要直接和多个子系统交互，只需要通过外观接口与外观对象进行交互。\n但是如果需要添加新的子系统或修改子系统的行为，就可能需要修改外观类，这违背了“开闭原则”。\n外观模式的应用也十分普遍，下面几种情况都使用了外观模式来进行简化。\nSpring框架是一个广泛使用外观模式的例子。Spring框架提供了一个大量的功能，包括依赖注入、面向切面编程（AOP）、事务管理等。Spring的ApplicationContext可以看作是外观，隐藏了底层组件的复杂性，使得开发者可以更轻松地使用Spring的功能。 JDBC提供了一个用于与数据库交互的接口。DriverManager类可以看作是外观，它简化了数据库驱动的加载和连接的过程，隐藏了底层数据库连接的复杂性。 Android系统的API中也使用了外观模式。例如，Activity类提供了一个外观，使得开发者可以更容易地管理应用的生命周期，而无需关心底层的事件和状态管理。 本题代码 link import java.util.Scanner; class AirConditioner { public void turnOff() { System.out.println(\"Air Conditioner is turned off.\"); } } class DeskLamp { public void turnOff() { System.out.println(\"Desk Lamp is turned off.\"); } } class Television { public void turnOff() { System.out.println(\"Television is turned off.\"); } } class PowerSwitchFacade { private DeskLamp deskLamp; private AirConditioner airConditioner; private Television television; public PowerSwitchFacade() { this.deskLamp = new DeskLamp(); this.airConditioner = new AirConditioner(); this.television = new Television(); } public void turnOffDevice(int deviceCode) { switch (deviceCode) { case 1: airConditioner.turnOff(); break; case 2: deskLamp.turnOff(); break; case 3: television.turnOff(); break; case 4: System.out.println(\"All devices are off.\"); break; default: System.out.println(\"Invalid device code.\"); } } } public class Main { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); // 读取输入 int n = scanner.nextInt(); int[] input = new int[n]; for (int i = 0; i \u003c n; i++) { input[i] = scanner.nextInt(); } // 创建电源总开关外观 PowerSwitchFacade powerSwitch = new PowerSwitchFacade(); // 执行操作 for (int i = 0; i \u003c n; i++) { powerSwitch.turnOffDevice(input[i]); } } } 其他语言版本 linkC++ link #include #include class AirConditioner { public: void turnOff() { std::cout \u003c\u003c \"Air Conditioner is turned off.\" \u003c\u003c std::endl; } }; class DeskLamp { public: void turnOff() { std::cout \u003c\u003c \"Desk Lamp is turned off.\" \u003c\u003c std::endl; } }; class Television { public: void turnOff() { std::cout \u003c\u003c \"Television is turned off.\" \u003c\u003c std::endl; } }; class PowerSwitchFacade { private: DeskLamp deskLamp; AirConditioner airConditioner; Television television; public: PowerSwitchFacade() { } void turnOffDevice(int deviceCode) { switch (deviceCode) { case 1: airConditioner.turnOff(); break; case 2: deskLamp.turnOff(); break; case 3: television.turnOff(); break; case 4: std::cout \u003c\u003c \"All devices are off.\" \u003c\u003c std::endl; break; default: std::cout \u003c\u003c \"Invalid device code.\" \u003c\u003c std::endl; } } }; int main() { // 读取输入 int n; std::cin \u003e\u003e n; std::vector input(n); for (int i = 0; i \u003c n; i++) { std::cin \u003e\u003e input[i]; } // 创建电源总开关外观 PowerSwitchFacade powerSwitch; // 执行操作 for (int i = 0; i \u003c n; i++) { powerSwitch.turnOffDevice(input[i]); } return 0; } Python link class AirConditioner: def turn_off(self): print(\"Air Conditioner is turned off.\") class DeskLamp: def turn_off(self): print(\"Desk Lamp is turned off.\") class Television: def turn_off(self): print(\"Television is turned off.\") class PowerSwitchFacade: def __init__(self): self.desk_lamp = DeskLamp() self.air_conditioner = AirConditioner() self.television = Television() def turn_off_device(self, device_code): if device_code == 1: self.air_conditioner.turn_off() elif device_code == 2: self.desk_lamp.turn_off() elif device_code == 3: self.television.turn_off() elif device_code == 4: print(\"All devices are off.\") else: print(\"Invalid device code.\") if __name__ == \"__main__\": # 读取输入 n = int(input()) input_data = [int(input()) for _ in range(n)] # 创建电源总开关外观 power_switch = PowerSwitchFacade() # 执行操作 for device_code in input_data: power_switch.turn_off_device(device_code) Go link package main import \"fmt\" // AirConditioner 类 type AirConditioner struct{} func (ac *AirConditioner) turnOff() { fmt.Println(\"Air Conditioner is turned off.\") } // DeskLamp 类 type DeskLamp struct{} func (dl *DeskLamp) turnOff() { fmt.Println(\"Desk Lamp is turned off.\") } // Television 类 type Television struct{} func (tv *Television) turnOff() { fmt.Println(\"Television is turned off.\") } // PowerSwitchFacade 类 type PowerSwitchFacade struct { deskLamp DeskLamp airConditioner AirConditioner television Television } func (psf *PowerSwitchFacade) turnOffDevice(deviceCode int) { switch deviceCode { case 1: psf.airConditioner.turnOff() case 2: psf.deskLamp.turnOff() case 3: psf.television.turnOff() case 4: fmt.Println(\"All devices are off.\") default: fmt.Println(\"Invalid device code.\") } } func main() { var n int fmt.Scan(\u0026n) // 读取输入 input := make([]int, n) for i := 0; i \u003c n; i++ { fmt.Scan(\u0026input[i]) } // 创建电源总开关外观 powerSwitch := PowerSwitchFacade{} // 执行操作 for i := 0; i \u003c n; i++ { powerSwitch.turnOffDevice(input[i]) } } "
            }
        );
    index.add(
            {
                id:  23 ,
                href: "\/docs\/dev\/23designpattern\/10.%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F\/",
                title: "10.桥接模式",
                description: "桥接模式是一种结构型设计模式，它的UML图很像一座桥，它通过将【抽象部分】与【实现部分】分离，使它们可以独立变化，从而达到降低系统耦合度的目的。",
                content: "需求 link【设计模式专题之桥接模式】10-万能遥控器\n**题目描述\n小明家有一个万能遥控器，能够支持多个品牌的电视。每个电视可以执行开机、关机和切换频道的操作，请你使用桥接模式模拟这个操作。 **输入描述\n第一行是一个整数 N（1 \u003c= N \u003c= 100），表示后面有 N 行输入。 接下来的 N 行，每行包含两个数字。第一个数字表示创建某个品牌的遥控和电视，第二个数字表示执行的操作。 其中，0 表示创建 Sony 品牌的电视，1 表示创建 TCL 品牌的遥控和电视； 2 表示开启电视、3表示关闭电视，4表示切换频道。 输入示例 6 0 2 1 2 0 4 0 3 1 4 1 3 输出示例\nSony TV is ON TCL TV is ON Switching Sony TV channel Sony TV is OFF Switching TCL TV channel TCL TV is OFF 基本概念 link桥接模式（Bridge Pattern）是一种结构型设计模式，它的UML图很像一座桥，它通过将【抽象部分】与【实现部分】分离，使它们可以独立变化，从而达到降低系统耦合度的目的。桥接模式的主要目的是通过组合建立两个类之间的联系，而不是继承的方式。\n举个简单的例子，图形编辑器中，每一种图形都需要蓝色、红色、黄色不同的颜色，如果不使用桥接模式，可能需要为每一种图形类型和每一种颜色都创建一个具体的子类，而使用桥接模式可以将图形和颜色两个维度分离，两个维度都可以独立进行变化和扩展，如果要新增其他颜色，只需添加新的 Color 子类，不影响图形类；反之亦然。\n基本结构 link桥接模式的基本结构分为以下几个角色：\n抽象Abstraction：一般是抽象类，定义抽象部分的接口，维护一个对【实现】的引用。 修正抽象RefinedAbstaction：对抽象接口进行扩展，通常对抽象化的不同维度进行变化或定制。 实现Implementor： 定义实现部分的接口，提供具体的实现。这个接口通常是抽象化接口的实现。 具体实现ConcreteImplementor：实现实现化接口的具体类。这些类负责实现实现化接口定义的具体操作。 再举个例子，遥控器就是抽象接口，它具有开关电视的功能，修正抽象就是遥控器的实例，对遥控器的功能进行实现和扩展，而电视就是实现接口，具体品牌的电视机是具体实现，遥控器中包含一个对电视接口的引用，通过这种方式，遥控器和电视的实现被分离，我们可以创建多个遥控器，每个遥控器控制一个品牌的电视机，它们之间独立操作，不受电视品牌的影响，可以独立变化。\n简易实现 link下面是实现桥接模式的基本步骤：\n创建实现接口 interface Implementation { void operationImpl(); } 以电视举例, 具有开关和切换频道的功能。\ninterface TV { void on(); void off(); void tuneChannel(); } 创建具体实现类：实际提供服务的对象。 class ConcreteImplementationA implements Implementation { @Override public void operationImpl() { // 具体实现A } } class ConcreteImplementationB implements Implementation { @Override public void operationImpl() { // 具体实现B } } 以电视举例，创建具体实现类\nclass ATV implements TV { @Override public void on() { System.out.println(\"A TV is ON\"); } @Override public void off() { System.out.println(\"A TV is OFF\"); } @Override public void tuneChannel() { System.out.println(\"Tuning A TV channel\"); } } class BTV implements TV { @Override public void on() { System.out.println(\"B TV is ON\"); } @Override public void off() { System.out.println(\"B TV is OFF\"); } @Override public void tuneChannel() { System.out.println(\"Tuning B TV channel\"); } } 创建抽象接口：包含一个对实现化接口的引用。 public abstract class Abstraction { protected IImplementor mImplementor; public Abstraction(IImplementor implementor) { this.mImplementor = implementor; } public void operation() { this.mImplementor.operationImpl(); } } abstract class RemoteControl { // 持有一个实现化接口的引用 protected TV tv; public RemoteControl(TV tv) { this.tv = tv; } abstract void turnOn(); abstract void turnOff(); abstract void changeChannel(); } 实现抽象接口，创建RefinedAbstaction类 class RefinedAbstraction implements Abstraction { private Implementation implementation; public RefinedAbstraction(Implementation implementation) { this.implementation = implementation; } @Override public void operation() { // 委托给实现部分的具体类 implementation.operationImpl(); } } class BasicRemoteControl extends RemoteControl { public BasicRemoteControl(TV tv) { super(tv); } @Override void turnOn() { tv.on(); } @Override void turnOff() { tv.off(); } @Override void changeChannel() { tv.tuneChannel(); } } 客户端使用 // 客户端代码 public class Main { public static void main(String[] args) { // 创建具体实现化对象 Implementation implementationA = new ConcreteImplementationA(); Implementation implementationB = new ConcreteImplementationB(); // 使用扩充抽象化对象，将实现化对象传递进去 Abstraction abstractionA = new RefinedAbstraction(implementationA); Abstraction abstractionB = new RefinedAbstraction(implementationB); // 调用抽象化的操作 abstractionA.operation(); abstractionB.operation(); } } public class Main { public static void main(String[] args) { TV aTV = new ATV(); TV bTV = new BTV(); RemoteControl basicRemoteForA = new BasicRemoteControl(aTV); RemoteControl basicRemoteForB = new BasicRemoteControl(bTV); basicRemoteForA.turnOn(); // A TV is ON basicRemoteForA.changeChannel(); // Tuning A TV channel basicRemoteForA.turnOff(); // A TV is OFF basicRemoteForB.turnOn(); // B TV is ON basicRemoteForB.changeChannel(); // Tuning B TV channel basicRemoteForB.turnOff(); // B TV is OFF } } 使用场景 link桥接模式在日常开发中使用的并不是特别多，通常在以下情况下使用：\n当一个类存在两个独立变化的维度，而且这两个维度都需要进行扩展时，使用桥接模式可以使它们独立变化，减少耦合。\n不希望使用继承，或继承导致类爆炸性增长\n总体而言，桥接模式适用于那些有多个独立变化维度、需要灵活扩展的系统。\n本题代码 link import java.util.Scanner; // 步骤1: 创建实现化接口 interface TV { void turnOn(); void turnOff(); void switchChannel(); } // 步骤2: 创建具体实现化类 class SonyTV implements TV { @Override public void turnOn() { System.out.println(\"Sony TV is ON\"); } @Override public void turnOff() { System.out.println(\"Sony TV is OFF\"); } @Override public void switchChannel() { System.out.println(\"Switching Sony TV channel\"); } } class TCLTV implements TV { @Override public void turnOn() { System.out.println(\"TCL TV is ON\"); } @Override public void turnOff() { System.out.println(\"TCL TV is OFF\"); } @Override public void switchChannel() { System.out.println(\"Switching TCL TV channel\"); } } // 步骤3: 创建抽象化接口 abstract class RemoteControl { protected TV tv; public RemoteControl(TV tv) { this.tv = tv; } abstract void performOperation(); } // 步骤4: 创建扩充抽象化类 class PowerOperation extends RemoteControl { public PowerOperation(TV tv) { super(tv); } @Override void performOperation() { tv.turnOn(); } } class OffOperation extends RemoteControl { public OffOperation(TV tv) { super(tv); } @Override void performOperation() { tv.turnOff(); } } class ChannelSwitchOperation extends RemoteControl { public ChannelSwitchOperation(TV tv) { super(tv); } @Override void performOperation() { tv.switchChannel(); } } // 步骤5: 客户端代码 public class Main { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); int N = scanner.nextInt(); scanner.nextLine(); for (int i = 0; i \u003c N; i++) { String[] input = scanner.nextLine().split(\" \"); int brand = Integer.parseInt(input[0]); int operation = Integer.parseInt(input[1]); TV tv; if (brand == 0) { tv = new SonyTV(); } else { tv = new TCLTV(); } RemoteControl remoteControl; if (operation == 2) { remoteControl = new PowerOperation(tv); } else if (operation == 3) { remoteControl = new OffOperation(tv); } else { remoteControl = new ChannelSwitchOperation(tv); } remoteControl.performOperation(); } scanner.close(); } } 其他语言版本 linkC++ link #include #include #include // 步骤1: 创建实现化接口 class TV { public: virtual void turnOn() = 0; virtual void turnOff() = 0; virtual void switchChannel() = 0; }; // 步骤2: 创建具体实现化类 class SonyTV : public TV { public: void turnOn() override { std::cout \u003c\u003c \"Sony TV is ON\" \u003c\u003c std::endl; } void turnOff() override { std::cout \u003c\u003c \"Sony TV is OFF\" \u003c\u003c std::endl; } void switchChannel() override { std::cout \u003c\u003c \"Switching Sony TV channel\" \u003c\u003c std::endl; } }; class TCLTV : public TV { public: void turnOn() override { std::cout \u003c\u003c \"TCL TV is ON\" \u003c\u003c std::endl; } void turnOff() override { std::cout \u003c\u003c \"TCL TV is OFF\" \u003c\u003c std::endl; } void switchChannel() override { std::cout \u003c\u003c \"Switching TCL TV channel\" \u003c\u003c std::endl; } }; // 步骤3: 创建抽象化接口 class RemoteControl { protected: TV* tv; public: RemoteControl(TV* tv) : tv(tv) {} virtual void performOperation() = 0; }; // 步骤4: 创建扩充抽象化类 class PowerOperation : public RemoteControl { public: PowerOperation(TV* tv) : RemoteControl(tv) {} void performOperation() override { tv-\u003eturnOn(); } }; class OffOperation : public RemoteControl { public: OffOperation(TV* tv) : RemoteControl(tv) {} void performOperation() override { tv-\u003eturnOff(); } }; class ChannelSwitchOperation : public RemoteControl { public: ChannelSwitchOperation(TV* tv) : RemoteControl(tv) {} void performOperation() override { tv-\u003eswitchChannel(); } }; // 步骤5: 客户端代码 int main() { int N; std::cin \u003e\u003e N; std::cin.ignore(); for (int i = 0; i \u003c N; i++) { std::string input; std::getline(std::cin, input); std::istringstream iss(input); int brand, operation; iss \u003e\u003e brand \u003e\u003e operation; TV* tv; if (brand == 0) { tv = new SonyTV(); } else { tv = new TCLTV(); } RemoteControl* remoteControl; if (operation == 2) { remoteControl = new PowerOperation(tv); } else if (operation == 3) { remoteControl = new OffOperation(tv); } else { remoteControl = new ChannelSwitchOperation(tv); } remoteControl-\u003eperformOperation(); delete tv; delete remoteControl; } return 0; } Python link # 步骤1: 创建实现化接口 class TV: def turn_on(self): pass def turn_off(self): pass def switch_channel(self): pass # 步骤2: 创建具体实现化类 class SonyTV(TV): def turn_on(self): print(\"Sony TV is ON\") def turn_off(self): print(\"Sony TV is OFF\") def switch_channel(self): print(\"Switching Sony TV channel\") class TCLTV(TV): def turn_on(self): print(\"TCL TV is ON\") def turn_off(self): print(\"TCL TV is OFF\") def switch_channel(self): print(\"Switching TCL TV channel\") # 步骤3: 创建抽象化接口 class RemoteControl: def __init__(self, tv): self.tv = tv def perform_operation(self): pass # 步骤4: 创建扩充抽象化类 class PowerOperation(RemoteControl): def perform_operation(self): self.tv.turn_on() class OffOperation(RemoteControl): def perform_operation(self): self.tv.turn_off() class ChannelSwitchOperation(RemoteControl): def perform_operation(self): self.tv.switch_channel() # 步骤5: 客户端代码 if __name__ == \"__main__\": N = int(input()) for _ in range(N): input_data = input().split(\" \") brand = int(input_data[0]) operation = int(input_data[1]) if brand == 0: tv = SonyTV() else: tv = TCLTV() if operation == 2: remote_control = PowerOperation(tv) elif operation == 3: remote_control = OffOperation(tv) else: remote_control = ChannelSwitchOperation(tv) remote_control.perform_operation() Go link package main import \"fmt\" // 步骤1: 创建实现化接口 type TV interface { TurnOn() TurnOff() SwitchChannel() } // 步骤2: 创建具体实现化类 type SonyTV struct{} func (st *SonyTV) TurnOn() { fmt.Println(\"Sony TV is ON\") } func (st *SonyTV) TurnOff() { fmt.Println(\"Sony TV is OFF\") } func (st *SonyTV) SwitchChannel() { fmt.Println(\"Switching Sony TV channel\") } type TCLTV struct{} func (tt *TCLTV) TurnOn() { fmt.Println(\"TCL TV is ON\") } func (tt *TCLTV) TurnOff() { fmt.Println(\"TCL TV is OFF\") } func (tt *TCLTV) SwitchChannel() { fmt.Println(\"Switching TCL TV channel\") } // 步骤3: 创建抽象化接口 type RemoteControl interface { PerformOperation() } // 步骤4: 创建扩充抽象化类 type PowerOperation struct { tv TV } func (po *PowerOperation) PerformOperation() { po.tv.TurnOn() } type OffOperation struct { tv TV } func (oo *OffOperation) PerformOperation() { oo.tv.TurnOff() } type ChannelSwitchOperation struct { tv TV } func (cso *ChannelSwitchOperation) PerformOperation() { cso.tv.SwitchChannel() } // 步骤5: 客户端代码 func main() { var N int fmt.Scan(\u0026N) for i := 0; i \u003c N; i++ { var brand, operation int fmt.Scan(\u0026brand, \u0026operation) var tv TV if brand == 0 { tv = \u0026SonyTV{} } else { tv = \u0026TCLTV{} } var remoteControl RemoteControl switch operation { case 2: remoteControl = \u0026PowerOperation{tv: tv} case 3: remoteControl = \u0026OffOperation{tv: tv} case 4: remoteControl = \u0026ChannelSwitchOperation{tv: tv} } remoteControl.PerformOperation() } } "
            }
        );
    index.add(
            {
                id:  24 ,
                href: "\/docs\/dev\/23designpattern\/11.%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F\/",
                title: "11.组合模式",
                description: "组合模式是一种结构型设计模式，它**将对象组合成树状结构**来表示“部分-整体”的层次关系。组合模式使得客户端可以**统一处理单个对象和对象的组 合**，而无需区分它们的具体类型。",
                content: "需求 link【设计模式专题之组合模式】11-公司组织架构\n题目描述\n小明所在的公司内部有多个部门，每个部门下可能有不同的子部门或者员工。 请你设计一个组合模式来管理这些部门和员工，实现对公司组织结构的统一操作。部门和员工都具有一个通用的接口，可以获取他们的名称以及展示公司组织结构。 输入描述\n第一行是一个整数 N（1 \u003c= N \u003c= 100），表示后面有 N 行输入。 接下来的 N 行，每行描述一个部门或员工的信息。部门的信息格式为 D 部门名称，员工的信息格式为 E 员工名称，其中 D 或 E 表示部门或员工。 输出描述\n输出公司的组织结构，展示每个部门下的子部门和员工 输入示例 MyCompany 8 D HR E HRManager D Finance E AccountantA E AccountantB D IT E DeveloperA E DeveloperB 输出示例 Company Structure: MyCompany HR HRManager Finance AccountantA AccountantB IT DeveloperA DeveloperB 基本概念 link组合模式是一种结构型设计模式，它将对象组合成树状结构来表示“部分-整体”的层次关系。组合模式使得客户端可以统一处理单个对象和对象的组合，而无需区分它们的具体类型。\n基本结构 link组合模式包括下面几个角色：\n理解起来比较抽象，我们用“省份-城市”举个例子，省份中包含了多个城市，如果将之比喻成一个树形结构，城市就是叶子节点，它是省份的组成部分，而“省份”就是合成节点，可以包含其他城市，形成一个整体，省份和城市都是组件，它们都有一个共同的操作，比如获取信息。\nComponent组件： 组合模式的“根节点”，定义组合中所有对象的通用接口，可以是抽象类或接口。该类中定义了子类的共性内容。 Leaf叶子：实现了Component接口的叶子节点，表示组合中的叶子对象，叶子节点没有子节点。 Composite合成： 作用是存储子部件，并且在Composite中实现了对子部件的相关操作，比如添加、删除、获取子组件等。 通过组合模式，整个省份的获取信息操作可以一次性地执行，而无需关心省份中的具体城市。这样就实现了对国家省份和城市的管理和操作。\n简易实现 link // 组件接口 interface Component { void operation(); } // 叶子节点 class Leaf implements Component { @Override public void operation() { System.out.println(\"Leaf operation\"); } } // 组合节点：包含叶子节点的操作行为 class Composite implements Component { private List components = new ArrayList\u003c\u003e(); public void add(Component component) { components.add(component); } public void remove(Component component) { components.remove(component); } @Override public void operation() { System.out.println(\"Composite operation\"); for (Component component : components) { component.operation(); } } } // 客户端代码 public class Client { public static void main(String[] args) { // 创建叶子节点 Leaf leaf = new Leaf(); // 创建组合节点，并添加叶子节点 Composite composite = new Composite(); composite.add(leaf); composite.operation(); // 统一调用 } } 使用场景 link组合模式可以使得客户端可以统一处理单个对象和组合对象，无需区分它们之间的差异，比如在图形编辑器中，图形对象可以是简单的线、圆形，也可以是复杂的组合图形，这个时候可以对组合节点添加统一的操作。\n总的来说，组合模式适用于任何需要构建具有部分-整体层次结构的场景，比如组织架构管理、文件系统的文件和文件夹组织等。\n本题代码 link import java.util.ArrayList; import java.util.List; import java.util.Scanner; interface Component { void display(int depth); } class Department implements Component { private String name; private List children; public Department(String name) { this.name = name; this.children = new ArrayList\u003c\u003e(); } public void add(Component component) { children.add(component); } @Override public void display(int depth) { StringBuilder indent = new StringBuilder(); for (int i = 0; i \u003c depth; i++) { indent.append(\" \"); } System.out.println(indent + name); for (Component component : children) { component.display(depth + 1); } } } class Employee implements Component { private String name; public Employee(String name) { this.name = name; } @Override public void display(int depth) { StringBuilder indent = new StringBuilder(); for (int i = 0; i \u003c depth; i++) { indent.append(\" \"); } System.out.println(indent + \" \" + name); } } class Company { private String name; private Department root; public Company(String name) { this.name = name; this.root = new Department(name); } public void add(Component component) { root.add(component); } public void display() { System.out.println(\"Company Structure:\"); root.display(0); // 从 1 开始，以适配指定的缩进格式 } } public class Main { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); // 读取公司名称 String companyName = scanner.nextLine(); Company company = new Company(companyName); // 读取部门和员工数量 int n = scanner.nextInt(); scanner.nextLine(); // 读取部门和员工信息 for (int i = 0; i \u003c n; i++) { String type = scanner.next(); String name = scanner.nextLine().trim(); if (\"D\".equals(type)) { Department department = new Department(name); company.add(department); } else if (\"E\".equals(type)) { Employee employee = new Employee(name); company.add(employee); } } // 输出公司组织结构 company.display(); } } 其他语言版本 linkC++ link #include #include #include class Component { public: virtual void display(int depth) = 0; }; class Department : public Component { private: std::string name; std::vector children; public: Department(const std::string\u0026 name) : name(name) {} void add(Component* component) { children.push_back(component); } void display(int depth) override { std::string indent(depth * 2, ' '); std::cout \u003c\u003c indent \u003c\u003c name \u003c\u003c std::endl; for (Component* component : children) { component-\u003edisplay(depth + 1); } } }; class Employee : public Component { private: std::string name; public: Employee(const std::string\u0026 name) : name(name) {} void display(int depth) override { std::string indent((depth + 1) * 2, ' '); std::cout \u003c\u003c indent \u003c\u003c name \u003c\u003c std::endl; } }; class Company { private: std::string name; Department* root; public: Company(const std::string\u0026 name) : name(name), root(new Department(name)) {} void add(Component* component) { root-\u003eadd(component); } void display() { std::cout \u003c\u003c \"Company Structure:\" \u003c\u003c std::endl; root-\u003edisplay(0); } }; int main() { std::string companyName; std::getline(std::cin, companyName); Company company(companyName); int n; std::cin \u003e\u003e n; std::cin.ignore(); for (int i = 0; i \u003c n; i++) { std::string type, name; std::cin \u003e\u003e type; std::getline(std::cin \u003e\u003e std::ws, name); if (type == \"D\") { Department* department = new Department(name); company.add(department); } else if (type == \"E\") { Employee* employee = new Employee(name); company.add(employee); } } company.display(); return 0; } Python link from typing import List # 步骤1: 创建实现化接口 class Component: def display(self, depth: int): pass # 步骤2: 创建具体实现化类 class Department(Component): def __init__(self, name: str): self.name = name self.children: List[Component] = [] def add(self, component: Component): self.children.append(component) def display(self, depth: int): indent = \" \" * depth print(indent + self.name) for component in self.children: component.display(depth + 1) class Employee(Component): def __init__(self, name: str): self.name = name def display(self, depth: int): indent = \" \" * depth print(indent + \" \" + self.name) class Company: def __init__(self, name: str): self.name = name self.root = Department(name) def add(self, component: Component): self.root.add(component) def display(self): print(\"Company Structure:\") self.root.display(0) if __name__ == \"__main__\": # 读取公司名称 company_name = input() company = Company(company_name) # 读取部门和员工数量 n = int(input()) # 读取部门和员工信息 for _ in range(n): type_str, name = input().split(maxsplit=1) if type_str == \"D\": department = Department(name.strip()) company.add(department) elif type_str == \"E\": employee = Employee(name.strip()) company.add(employee) # 输出公司组织结构 company.display() Go link package main import ( \"bufio\" \"fmt\" \"os\" \"strings\" ) // 步骤1: 创建组件接口 type Component interface { display(depth int) } // 步骤2: 创建部门类实现组件接口 type Department struct { name string children []Component } func NewDepartment(name string) *Department { return \u0026Department{ name: name, children: make([]Component, 0), } } func (d *Department) add(component Component) { d.children = append(d.children, component) } func (d *Department) display(depth int) { indent := strings.Repeat(\" \", depth*2) fmt.Println(indent + d.name) for _, child := range d.children { child.display(depth + 1) } } // 步骤3: 创建员工类实现组件接口 type Employee struct { name string } func NewEmployee(name string) *Employee { return \u0026Employee{ name: name, } } func (e *Employee) display(depth int) { indent := strings.Repeat(\" \", depth*2) fmt.Println(indent + \" \" + e.name) } // 步骤4: 创建公司类 type Company struct { name string root *Department } func NewCompany(name string) *Company { return \u0026Company{ name: name, root: NewDepartment(name), } } func (c *Company) add(component Component) { c.root.add(component) } func (c *Company) display() { fmt.Println(\"Company Structure:\") c.root.display(0) // 从 0 开始，以适配指定的缩进格式 } func main() { scanner := bufio.NewScanner(os.Stdin) // 读取公司名称 scanner.Scan() companyName := scanner.Text() company := NewCompany(companyName) // 读取部门和员工数量 scanner.Scan() n := 0 fmt.Sscanf(scanner.Text(), \"%d\", \u0026n) // 读取部门和员工信息 var currentDepartment *Department for i := 0; i \u003c n; i++ { scanner.Scan() line := scanner.Text() fields := strings.Fields(line) if len(fields) \u003c 2 { continue } typeStr := fields[0] name := strings.Join(fields[1:], \" \") if typeStr == \"D\" { department := NewDepartment(name) company.add(department) currentDepartment = department } else if typeStr == \"E\" { employee := NewEmployee(name) currentDepartment.add(employee) } } // 输出公司组织结构 company.display() } "
            }
        );
    index.add(
            {
                id:  25 ,
                href: "\/docs\/dev\/23designpattern\/12.%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F\/",
                title: "12.享元模式",
                description: "享元模式是一种结构型设计模式，在享元模式中，对象被设计为可共享的，可以被多个上下文使用，而不必在每个上下文中都创建新的对象。",
                content: "需求 link【设计模式专题之享元模式】12-图形编辑器\n题目描述\n在一个图形编辑器中，用户可以绘制不同类型的图形，包括圆形（CIRCLE）、矩形（RECTANGLE）、三角形（TRIANGLE）等。现在，请你实现一个图形绘制程序，要求能够共享相同类型的图形对象，以减少内存占用。 输入描述 输入包含多行，每行表示一个绘制命令。每个命令包括两部分：\n图形类型（Circle、Rectangle 或 Triangle） 绘制的坐标位置（两个整数，分别表示 x 和 y） 输出描述\n对于每个绘制命令，输出相应图形被绘制的位置信息。如果图形是首次绘制，输出 “drawn at”，否则输出 “shared at”。 输入示例 CIRCLE 10 20 RECTANGLE 30 40 CIRCLE 15 25 TRIANGLE 5 15 CIRCLE 10 20 RECTANGLE 30 40 输出示例 CIRCLE drawn at (10, 20) RECTANGLE drawn at (30, 40) CIRCLE shared at (15, 25) TRIANGLE drawn at (5, 15) CIRCLE shared at (10, 20) RECTANGLE shared at (30, 40) 基础概念 link享元模式是一种结构型设计模式，在享元模式中，对象被设计为可共享的，可以被多个上下文使用，而不必在每个上下文中都创建新的对象。\n想要了解享元模式，就必须要区分什么是内部状态，什么是外部状态。\n内部状态是指那些可以被多个对象共享的状态，它存储在享元对象内部，并且对于所有享元对象都是相同的，这部分状态通常是不变的。\n而外部状态是享元对象依赖的、可能变化的部分。这部分状态不存储在享元对象内部，而是在使用享元对象时通过参数传递给对象。\n举个例子，图书馆中有很多相同的书籍，但每本书都可以被多个人借阅，图书馆里的书就是内部状态，人就是外部状态。\n再举个开发中的例子，假设我们在构建一个简单的图形编辑器，用户可以在画布上绘制不同类型的图形，而图形就是所有图形对象的内部状态（不变的），而图形的坐标位置就是图形对象的外部状态（变化的）。\n如果图形编辑器中有成千上万的图形对象，每个图形对象都独立创建并存储其内部状态，那么系统的内存占用可能会很大，在这种情况下，享元模式共享相同类型的图形对象，每种类型的图形对象只需创建一个共享实例，然后通过设置不同的坐标位置个性化每个对象，通过共享相同的内部状态，降低了对象的创建和内存占用成本。\n基本结构 link享元模式包括以下几个重要角色：\n享元接口Flyweight: 所有具体享元类的共享接口，通常包含对外部状态的操作。 具体享元类ConcreteFlyweight: 继承Flyweight类或实现享元接口，包含内部状态。 享元工厂类FlyweightFactory: 创建并管理享元对象，当用户请求时，提供已创建的实例或者创建一个。 客户端Client: 维护外部状态，在使用享元对象时，将外部状态传递给享元对象。 简易实现 link享元模式的实现通常涉及以下步骤：\n定义享元接口，接受外部状态作为参数并进行处理。 // 步骤 1: 定义享元接口 interface Flyweight { // 操作外部状态 void operation(String externalState); } 实现具体享元类, 存储内部状态。 // 步骤 2: 实现具体享元类 class ConcreteFlyweight implements Flyweight { private String intrinsicState; // 内部状态 public ConcreteFlyweight(String intrinsicState) { this.intrinsicState = intrinsicState; } @Override public void operation(String externalState) { System.out.println(\"Intrinsic State: \" + intrinsicState + \", External State: \" + externalState); } } 创建享元工厂类，创建并管理Flyweight对象，当用户请求一个Flyweight时，享元工厂会提供一个已经创建的实例或者创建一个。 class FlyweightFactory { private Map flyweights = new HashMap\u003c\u003e(); public Flyweight getFlyweight(String key) { if (!flyweights.containsKey(key)) { flyweights.put(key, new ConcreteFlyweight(key)); } return flyweights.get(key); } } 客户端使用享元模式 public class Main { public static void main(String[] args) { FlyweightFactory factory = new FlyweightFactory(); // 获取或创建享元对象，并传递外部状态 Flyweight flyweight1 = factory.getFlyweight(\"A\"); flyweight1.operation(\"External State 1\"); Flyweight flyweight2 = factory.getFlyweight(\"B\"); flyweight2.operation(\"External State 2\"); Flyweight flyweight3 = factory.getFlyweight(\"A\"); // 重复使用已存在的享元对象 flyweight3.operation(\"External State 3\"); } } 使用场景 link使用享元模式的关键在于包含大量相似对象，并且这些对象的内部状态可以共享。具体的应用场景包括文本编辑器，图形编辑器，游戏中的角色创建，这些对象的内部状态比较固定(外观，技能，形状)，但是外部状态变化比较大时，可以使用。\n本题代码 link import java.util.HashMap; import java.util.Map; import java.util.Scanner; enum ShapeType { CIRCLE, RECTANGLE, TRIANGLE } class Position { private int x; private int y; public Position(int x, int y) { this.x = x; this.y = y; } public int getX() { return x; } public int getY() { return y; } } interface Shape { void draw(Position position); } class ConcreteShape implements Shape { private ShapeType shapeType; public ConcreteShape(ShapeType shapeType) { this.shapeType = shapeType; } @Override public void draw(Position position) { System.out.println(shapeType + (isFirstTime ? \" drawn\" : \" shared\") + \" at (\" + position.getX() + \", \" + position.getY() + \")\"); } private boolean isFirstTime = true; public void setFirstTime(boolean firstTime) { isFirstTime = firstTime; } } class ShapeFactory { private Map shapes = new HashMap\u003c\u003e(); public Shape getShape(ShapeType type) { if (!shapes.containsKey(type)) { shapes.put(type, new ConcreteShape(type)); } return shapes.get(type); } } public class Main { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); ShapeFactory factory = new ShapeFactory(); while (scanner.hasNext()) { String command = scanner.nextLine(); processCommand(factory, command); } } private static void processCommand(ShapeFactory factory, String command) { String[] parts = command.split(\" \"); ShapeType type = ShapeType.valueOf(parts[0]); int x = Integer.parseInt(parts[1]); int y = Integer.parseInt(parts[2]); Shape shape = factory.getShape(type); shape.draw(new Position(x, y)); ((ConcreteShape) shape).setFirstTime(false); } } 其他语言版本 linkC++ link #include #include #include #include enum ShapeType { CIRCLE, RECTANGLE, TRIANGLE }; std::string shapeTypeToString(ShapeType type) { switch (type) { case CIRCLE: return \"CIRCLE\"; case RECTANGLE: return \"RECTANGLE\"; case TRIANGLE: return \"TRIANGLE\"; default: return \"UNKNOWN\"; } } class Position { private: int x; int y; public: Position(int x, int y) : x(x), y(y) {} int getX() const { return x; } int getY() const { return y; } }; class Shape { public: virtual void draw(const Position \u0026position) = 0; virtual ~Shape() {} }; class ConcreteShape : public Shape { private: ShapeType shapeType; bool isFirstTime; public: ConcreteShape(ShapeType shapeType) : shapeType(shapeType), isFirstTime(true) {} void draw(const Position \u0026position) override { std::cout \u003c\u003c shapeTypeToString(shapeType) \u003c\u003c (isFirstTime ? \" drawn\" : \" shared\") \u003c\u003c \" at (\" \u003c\u003c position.getX() \u003c\u003c \", \" \u003c\u003c position.getY() \u003c\u003c \")\\n\"; } void setFirstTime(bool firstTime) { isFirstTime = firstTime; } }; class ShapeFactory { private: std::unordered_map shapes; public: Shape *getShape(ShapeType type) { if (shapes.find(type) == shapes.end()) { shapes[type] = new ConcreteShape(type); } return shapes[type]; } ~ShapeFactory() { for (const auto \u0026entry : shapes) { delete entry.second; } } }; void processCommand(ShapeFactory \u0026factory, const std::string \u0026command); int main() { ShapeFactory factory; std::string command; while (std::getline(std::cin, command)) { processCommand(factory, command); } return 0; } void processCommand(ShapeFactory \u0026factory, const std::string \u0026command) { std::istringstream iss(command); std::string shapeTypeStr; int x, y; iss \u003e\u003e shapeTypeStr \u003e\u003e x \u003e\u003e y; ShapeType type; if (shapeTypeStr == \"CIRCLE\") { type = CIRCLE; } else if (shapeTypeStr == \"RECTANGLE\") { type = RECTANGLE; } else if (shapeTypeStr == \"TRIANGLE\") { type = TRIANGLE; } else { std::cerr \u003c\u003c \"Invalid shape type: \" \u003c\u003c shapeTypeStr \u003c\u003c std::endl; return; } Shape *shape = factory.getShape(type); shape-\u003edraw(Position(x, y)); dynamic_cast(shape)-\u003esetFirstTime(false); } Python link from enum import Enum from typing import Dict class ShapeType(Enum): CIRCLE = \"CIRCLE\" RECTANGLE = \"RECTANGLE\" TRIANGLE = \"TRIANGLE\" class Position: def __init__(self, x, y): self.x = x self.y = y class Shape: def draw(self, position: Position): pass class ConcreteShape(Shape): def __init__(self, shape_type: ShapeType): self.shape_type = shape_type self.is_first_time = True def draw(self, position: Position): print(f\"{self.shape_type.value}{' drawn' if self.is_first_time else ' shared'} at ({position.x}, {position.y})\") def set_first_time(self, first_time: bool): self.is_first_time = first_time class ShapeFactory: def __init__(self): self.shapes: Dict[ShapeType, Shape] = {} def get_shape(self, shape_type: ShapeType) -\u003e Shape: if shape_type not in self.shapes: self.shapes[shape_type] = ConcreteShape(shape_type) return self.shapes[shape_type] def process_command(factory: ShapeFactory, command: str): parts = command.split(\" \") shape_type = ShapeType(parts[0]) x = int(parts[1]) y = int(parts[2]) shape = factory.get_shape(shape_type) shape.draw(Position(x, y)) shape.set_first_time(False) if __name__ == \"__main__\": factory = ShapeFactory() while True: try: command = input() process_command(factory, command) except EOFError: break Go link package main import ( \"bufio\" \"fmt\" \"os\" \"strconv\" \"strings\" ) type ShapeType int const ( CIRCLE ShapeType = iota RECTANGLE TRIANGLE ) var shapeTypeStrings = [...]string{ \"CIRCLE\", \"RECTANGLE\", \"TRIANGLE\", } type Position struct { X, Y int } type Shape interface { Draw(Position) } type ConcreteShape struct { ShapeType ShapeType IsFirstTime bool } func NewConcreteShape(shapeType ShapeType) *ConcreteShape { return \u0026ConcreteShape{ ShapeType: shapeType, IsFirstTime: true, } } func (s *ConcreteShape) Draw(position Position) { fmt.Printf(\"%s %s at (%d, %d)\\n\", s.ShapeType.String(), s.getTimeDescription(), position.X, position.Y) } func (s *ConcreteShape) setFirstTime(firstTime bool) { s.IsFirstTime = firstTime } func (s *ConcreteShape) getTimeDescription() string { if s.IsFirstTime { return \"drawn\" } return \"shared\" } func (st ShapeType) String() string { if st \u003e= 0 \u0026\u0026 int(st) \u003c len(shapeTypeStrings) { return shapeTypeStrings[st] } return \"UNKNOWN\" } type ShapeFactory struct { shapes map[ShapeType]Shape } func NewShapeFactory() *ShapeFactory { return \u0026ShapeFactory{ shapes: make(map[ShapeType]Shape), } } func (f *ShapeFactory) getShape(shapeType ShapeType) Shape { if _, exists := f.shapes[shapeType]; !exists { f.shapes[shapeType] = NewConcreteShape(shapeType) } return f.shapes[shapeType] } func main() { var factory = NewShapeFactory() scanner := bufio.NewScanner(os.Stdin) for scanner.Scan() { command := scanner.Text() processCommand(factory, command) } if err := scanner.Err(); err != nil { fmt.Println(\"Error reading standard input:\", err) } } func processCommand(factory *ShapeFactory, command string) { parts := splitCommand(command) shapeType := ShapeTypeFromString(parts[0]) x, _ := strconv.Atoi(parts[1]) y, _ := strconv.Atoi(parts[2]) shape := factory.getShape(shapeType) shape.Draw(Position{X: x, Y: y}) concreteShape, ok := shape.(*ConcreteShape) if ok { concreteShape.setFirstTime(false) } } func splitCommand(command string) []string { return splitWithoutEmpty(command, ' ') } func splitWithoutEmpty(s string, sep byte) []string { parts := strings.FieldsFunc(s, func(r rune) bool { return r == rune(sep) }) return parts } func ShapeTypeFromString(s string) ShapeType { for i, str := range shapeTypeStrings { if str == s { return ShapeType(i) } } return CIRCLE } "
            }
        );
    index.add(
            {
                id:  26 ,
                href: "\/docs\/dev\/23designpattern\/13.%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F\/",
                title: "13.观察者模式",
                description: "观察者模式（发布-订阅模式）属于行为型模式，定义了一种一对多的依赖关系，让多个观察者对象同时监听一个主题对象，当主题对象的状态发生变化时，所有依赖于它的观察者都得到通知并被自动更新。",
                content: "需求 link【设计模式专题之观察者模式】13. 时间观察者\n题目描述\n小明所在的学校有一个时钟（主题），每到整点时，它就会通知所有的学生（观察者）当前的时间，请你使用观察者模式实现这个时钟通知系统。 注意点：时间从 0 开始，并每隔一个小时更新一次。 输入描述\n输入的第一行是一个整数 N（1 ≤ N ≤ 20），表示学生的数量。 接下来的 N 行，每行包含一个字符串，表示学生的姓名。 最后一行是一个整数，表示时钟更新的次数。 输出描述\n对于每一次时钟更新，输出每个学生的姓名和当前的时间。 输入示例 2 Alice Bob 3 输出示例 Alice 1 Bob 1 Alice 2 Bob 2 Alice 3 Bob 3 提示信息\n初始时钟时间为0（12:00 AM）。 第一次更新后，时钟变为1（1:00 AM），然后通知每个学生，输出学生名称和时钟点数。 第二次更新后，时钟变为2（2:00 AM），然后再次通知每个学生，输出学生名称和时钟点数 第三次更新后，时钟变为3（3:00 AM），然后再次通知每个学生，输出学生名称和时钟点数。 什么是观察者模式 link观察者模式（发布-订阅模式）属于行为型模式，定义了一种一对多的依赖关系，让多个观察者对象同时监听一个主题对象，当主题对象的状态发生变化时，所有依赖于它的观察者都得到通知并被自动更新。\n观察者模式依赖两个模块：\nSubject(主题)：也就是被观察的对象，它可以维护一组观察者，当主题本身发生改变时就会通知观察者。 Observer(观察者)：观察主题的对象，当“被观察”的主题发生变化时，观察者就会得到通知并执行相应的处理。 使用观察者模式有很多好处，比如说观察者模式将主题和观察者之间的关系解耦，主题只需要关注自己的状态变化，而观察者只需要关注在主题状态变化时需要执行的操作，两者互不干扰，并且由于观察者和主题是相互独立的，可以轻松的增加和删除观察者，这样实现的系统更容易扩展和维护。\n观察者模式的结构 link观察者模式依赖主题和观察者，但是一般有4个组成部分：\n主题Subject， 一般会定义成一个接口，提供方法用于注册、删除和通知观察者，通常也包含一个状态，当状态发生改变时，通知所有的观察者。 观察者Observer: 观察者也需要实现一个接口，包含一个更新方法，在接收主题通知时执行对应的操作。 具体主题ConcreteSubject: 主题的具体实现, 维护一个观察者列表，包含了观察者的注册、删除和通知方法。 具体观察者ConcreteObserver: 观察者接口的具体实现，每个具体观察者都注册到具体主题中，当主题状态变化并通知到具体观察者，具体观察者进行处理。 观察者模式的基本实现 link根据上面的类图，我们可以写出观察者模式的基本实现\n// 主题接口 （主题） interface Subject { // 注册观察者 void registerObserver(Observer observer); // 移除观察者 void removeObserver(Observer observer); // 通知观察者 void notifyObservers(); } // 观察者接口 (观察者) interface Observer { // 更新方法 void update(String message); } // 具体主题实现 class ConcreteSubject implements Subject { // 观察者列表 private List observers = new ArrayList\u003c\u003e(); // 状态 private String state; // 注册观察者 @Override public void registerObserver(Observer observer) { observers.add(observer); } // 移除观察者 @Override public void removeObserver(Observer observer) { observers.remove(observer); } // 通知观察者 @Override public void notifyObservers() { for (Observer observer : observers) { // 观察者根据传递的信息进行处理 observer.update(state); } } // 更新状态 public void setState(String state) { this.state = state; notifyObservers(); } } // 具体观察者实现 class ConcreteObserver implements Observer { // 更新方法 @Override public void update(String message) { } } 什么时候使用观察者模式 link观察者模式特别适用于一个对象的状态变化会影响到其他对象，并且希望这些对象在状态变化时能够自动更新的情况。 比如说在图形用户界面中，按钮、滑动条等组件的状态变化可能需要通知其他组件更新，这使得观察者模式被广泛应用于GUI框架，比如Java的Swing框架。\n此外，观察者模式在前端开发和分布式系统中也有应用，比较典型的例子是前端框架Vue, 当数据发生变化时，视图会自动更新。而在分布式系统中，观察者模式可以用于实现节点之间的消息通知机制，节点的状态变化将通知其他相关节点。\n本题代码 link import java.util.ArrayList; import java.util.List; import java.util.Scanner; // 观察者接口 interface Observer { void update(int hour); } // 主题接口 interface Subject { void registerObserver(Observer observer); void removeObserver(Observer observer); void notifyObservers(); } // 具体主题实现 class Clock implements Subject { private List observers = new ArrayList\u003c\u003e(); private int hour = 0; @Override public void registerObserver(Observer observer) { observers.add(observer); } @Override public void removeObserver(Observer observer) { observers.remove(observer); } @Override public void notifyObservers() { for (Observer observer : observers) { observer.update(hour); } } public void tick() { hour = (hour + 1) % 24; // 模拟时间的推移 notifyObservers(); } } // 具体观察者实现 class Student implements Observer { private String name; public Student(String name) { this.name = name; } @Override public void update(int hour) { System.out.println(name + \" \" + hour); } } public class Main { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); // 读取学生数量 int N = scanner.nextInt(); // 创建时钟 Clock clock = new Clock(); // 注册学生观察者 for (int i = 0; i \u003c N; i++) { String studentName = scanner.next(); clock.registerObserver(new Student(studentName)); } // 读取时钟更新次数 int updates = scanner.nextInt(); // 模拟时钟每隔一个小时更新一次 for (int i = 0; i \u003c updates; i++) { clock.tick(); } } } 其他语言版本 linkC++ link #include #include #include // 观察者接口 class Observer { public: virtual void update(int hour) = 0; virtual ~Observer() = default; // 添加虚析构函数 }; // 主题接口 class Subject { public: virtual void registerObserver(Observer* observer) = 0; virtual void removeObserver(Observer* observer) = 0; virtual void notifyObservers() = 0; virtual ~Subject() = default; // 添加虚析构函数 }; // 具体主题实现 class Clock : public Subject { private: std::vector observers; int hour; public: Clock() : hour(0) {} void registerObserver(Observer* observer) override { observers.push_back(observer); } void removeObserver(Observer* observer) override { auto it = std::find(observers.begin(), observers.end(), observer); if (it != observers.end()) { observers.erase(it); } } void notifyObservers() override { for (Observer* observer : observers) { observer-\u003eupdate(hour); } } // 添加获取观察者的函数 const std::vector\u0026 getObservers() const { return observers; } void tick() { hour = (hour + 1) % 24; // 模拟时间的推移 notifyObservers(); } }; // 具体观察者实现 class Student : public Observer { private: std::string name; public: Student(const std::string\u0026 name) : name(name) {} void update(int hour) override { std::cout \u003c\u003c name \u003c\u003c \" \" \u003c\u003c hour \u003c\u003c std::endl; } }; int main() { // 读取学生数量 int N; std::cin \u003e\u003e N; // 创建时钟 Clock clock; // 注册学生观察者 for (int i = 0; i \u003c N; i++) { std::string studentName; std::cin \u003e\u003e studentName; clock.registerObserver(new Student(studentName)); } // 读取时钟更新次数 int updates; std::cin \u003e\u003e updates; // 模拟时钟每隔一个小时更新一次 for (int i = 0; i \u003c updates; i++) { clock.tick(); } // 释放动态分配的观察者对象 for (Observer* observer : clock.getObservers()) { delete observer; } return 0; } Python link from typing import List # 观察者接口 class Observer: def update(self, hour: int): pass # 主题接口 class Subject: def register_observer(self, observer: Observer): pass def remove_observer(self, observer: Observer): pass def notify_observers(self): pass # 具体主题实现 class Clock(Subject): def __init__(self): self.observers: List[Observer] = [] self.hour = 0 def register_observer(self, observer: Observer): self.observers.append(observer) def remove_observer(self, observer: Observer): self.observers.remove(observer) def notify_observers(self): for observer in self.observers: observer.update(self.hour) def tick(self): self.hour = (self.hour + 1) % 24 # 模拟时间的推移 self.notify_observers() # 具体观察者实现 class Student(Observer): def __init__(self, name: str): self.name = name def update(self, hour: int): print(f\"{self.name} {hour}\") if __name__ == \"__main__\": # 读取学生数量 N = int(input()) # 创建时钟 clock = Clock() # 注册学生观察者 for _ in range(N): student_name = input() clock.register_observer(Student(student_name)) # 读取时钟更新次数 updates = int(input()) # 模拟时钟每隔一个小时更新一次 for _ in range(updates): clock.tick() GO link package main import ( \"fmt\" ) // 观察者接口 type Observer interface { Update(hour int) } // 主题接口 type Subject interface { RegisterObserver(observer Observer) RemoveObserver(observer Observer) NotifyObservers() } // 具体主题实现 type Clock struct { observers []Observer hour int } func (c *Clock) RegisterObserver(observer Observer) { c.observers = append(c.observers, observer) } func (c *Clock) RemoveObserver(observer Observer) { for i, obs := range c.observers { if obs == observer { c.observers = append(c.observers[:i], c.observers[i+1:]...) break } } } func (c *Clock) NotifyObservers() { for _, observer := range c.observers { observer.Update(c.hour) } } func (c *Clock) Tick() { c.hour = (c.hour + 1) % 24 // 模拟时间的推移 c.NotifyObservers() } // 具体观察者实现 type Student struct { name string } func NewStudent(name string) *Student { return \u0026Student{name: name} } func (s *Student) Update(hour int) { fmt.Println(s.name, hour) } func main() { // 读取学生数量 var N int fmt.Scan(\u0026N) // 创建时钟 clock := \u0026Clock{} // 注册学生观察者 for i := 0; i \u003c N; i++ { var studentName string fmt.Scan(\u0026studentName) clock.RegisterObserver(NewStudent(studentName)) } // 读取时钟更新次数 var updates int fmt.Scan(\u0026updates) // 模拟时钟每隔一个小时更新一次 for i := 0; i \u003c updates; i++ { clock.Tick() } } "
            }
        );
    index.add(
            {
                id:  27 ,
                href: "\/docs\/dev\/23designpattern\/14.%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F\/",
                title: "14.策略模式",
                description: "策略模式是一种行为型设计模式，它定义了一系列算法（这些算法完成的是相同的工作，只是实现不同），并将每个算法封装起来，使它们可以相互替换，而且算法的变化不会影响使用算法的客户。",
                content: "需求 link【设计模式专题之策略模式】14. 超市打折\n题目描述\n小明家的超市推出了不同的购物优惠策略，你可以根据自己的需求选择不同的优惠方式。其中，有两种主要的优惠策略： 九折优惠策略：原价的90%。 满减优惠策略：购物满一定金额时，可以享受相应的减免优惠。 具体的满减规则如下： 满100元减5元 满150元减15元 满200元减25元 满300元减40元 请你设计一个购物优惠系统，用户输入商品的原价和选择的优惠策略编号，系统输出计算后的价格。 输入描述\n输入的第一行是一个整数 N（1 ≤ N ≤ 20），表示需要计算优惠的次数。 接下来的 N 行，每行输入两个整数，第一个整数M( 0 \u003c M \u003c 400) 表示商品的价格, 第二个整数表示优惠策略，1表示九折优惠策略，2表示满减优惠策略 输入示例 4 100 1 200 2 300 1 300 2 输出示例 90 175 270 260 什么是策略模式 link策略模式是一种行为型设计模式，它定义了一系列算法（这些算法完成的是相同的工作，只是实现不同），并将每个算法封装起来，使它们可以相互替换，而且算法的变化不会影响使用算法的客户。\n举个例子，电商网站对于商品的折扣策略有不同的算法，比如新用户满减优惠，不同等级会员的打折情况不同，这种情况下会产生大量的if-else语句, 并且如果优惠政策修改时，还需要修改原来的代码，不符合开闭原则。\n这就可以将不同的优惠算法封装成独立的类来避免大量的条件语句，如果新增优惠算法，可以添加新的策略类来实现，客户端在运行时选择不同的具体策略，而不必修改客户端代码改变优惠策略。\n基本结构 link策略模式包含下面几个结构：\n策略类Strategy: 定义所有支持的算法的公共接口。 具体策略类ConcreteStrategy: 实现了策略接口，提供具体的算法实现。 上下文类Context: 包含一个策略实例，并在需要时调用策略对象的方法。 简单实现 link下面是一个简单的策略模式的基本实现:\n// 1. 抽象策略抽象类 abstract class Strategy { // 抽象方法 public abstract void algorithmInterface(); } // 2. 具体策略类1 class ConcreteStrategyA extends Strategy { @Override public void algorithmInterface() { System.out.println(\"Strategy A\"); // 具体的策略1执行逻辑 } } // 3. 具体策略类2 class ConcreteStrategyB extends Strategy { @Override public void algorithmInterface() { System.out.println(\"Strategy B\"); // 具体的策略2执行逻辑 } } // 4. 上下文类 class Context { private Strategy strategy; // 设置具体的策略 public Context(Strategy strategy) { this.strategy = strategy; } // 执行策略 public void contextInterface() { strategy.algorithmlnterface(); } } // 5. 客户端代码 public class Main{ public static void main(String[] args) { // 创建上下文对象，并设置具体的策略 Context contextA = new Context(new ConcreteStrategyA()); // 执行策略 contextA.contextInterface(); Context contextB = new Context(new ConcreteStrategyB()); contextB.contextInterface();u } } 使用场景 link那什么时候可以考虑使用策略模式呢？\n当一个系统根据业务场景需要动态地在几种算法中选择一种时，可以使用策略模式。例如，根据用户的行为选择不同的计费策略。\n当代码中存在大量条件判断，条件判断的区别仅仅在于行为，也可以通过策略模式来消除这些条件语句。\n在已有的工具库中，Java 标准库中的 Comparator 接口就使用了策略模式，通过实现这个接口，可以创建不同的比较器（指定不同的排序策略）来满足不同的排序需求。\n本题代码 link import java.util.Scanner; // 抽象购物优惠策略接口 interface DiscountStrategy { int applyDiscount(int originalPrice); } // 九折优惠策略 class DiscountStrategy1 implements DiscountStrategy { @Override public int applyDiscount(int originalPrice) { return (int) Math.round(originalPrice * 0.9); } } // 满减优惠策略 class DiscountStrategy2 implements DiscountStrategy { private int[] thresholds = {100, 150, 200, 300}; private int[] discounts = {5, 15, 25, 40}; @Override public int applyDiscount(int originalPrice) { for (int i = thresholds.length - 1; i \u003e= 0; i--) { if (originalPrice \u003e= thresholds[i]) { return originalPrice - discounts[i]; } } return originalPrice; } } // 上下文类 class DiscountContext { private DiscountStrategy discountStrategy; public void setDiscountStrategy(DiscountStrategy discountStrategy) { this.discountStrategy = discountStrategy; } public int applyDiscount(int originalPrice) { return discountStrategy.applyDiscount(originalPrice); } } public class Main { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); // 读取需要计算优惠的次数 int N = Integer.parseInt(scanner.nextLine()); for (int i = 0; i \u003c N; i++) { // 读取商品价格和优惠策略 String[] input = scanner.nextLine().split(\" \"); int M = Integer.parseInt(input[0]); int strategyType = Integer.parseInt(input[1]); // 根据优惠策略设置相应的打折策略 DiscountStrategy discountStrategy; switch (strategyType) { case 1: discountStrategy = new DiscountStrategy1(); break; case 2: discountStrategy = new DiscountStrategy2(); break; default: // 处理未知策略类型 System.out.println(\"Unknown strategy type\"); return; } // 设置打折策略 DiscountContext context = new DiscountContext(); context.setDiscountStrategy(discountStrategy); // 应用打折策略并输出优惠后的价格 int discountedPrice = context.applyDiscount(M); System.out.println(discountedPrice); } } } 其他语言版本 linkJava link使用策略枚举类实现 import java.util.Scanner; interface Strategy { void preferentialMethod(int price); } //策略枚举类 enum DiscountStrategy implements Strategy { STRATEGY1 { @Override public void preferentialMethod(int price) { double discountedPrice = 0.9 * price; System.out.println((int) discountedPrice); } }, STRATEGY2 { @Override public void preferentialMethod(int price) { int[][] discountRules = { {300, 40}, {200, 25}, {150, 15}, {100, 5} }; for (int[] rule : discountRules) { if (price \u003e= rule[0]) { price -= rule[1]; break; } } System.out.println(price); } }; public static DiscountStrategy fromType(int type) { switch (type) { case 1: return STRATEGY1; case 2: return STRATEGY2; default: throw new IllegalArgumentException(\"无效选择，请输入1或2\"); } } } class Context { private Strategy strategy; public Context(Strategy strategy) { this.strategy = strategy; } public void executeStrategy(int price) { strategy.preferentialMethod(price); } } public class Main { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); try { int num = scanner.nextInt(); scanner.nextLine(); for (int i = 0; i \u003c num; i++) { try { String input = scanner.nextLine(); String[] parts = input.split(\" \"); if (parts.length != 2) { System.out.println(\"输入错误！\"); continue; } int price = Integer.parseInt(parts[0]); int type = Integer.parseInt(parts[1]); DiscountStrategy strategy = DiscountStrategy.fromType(type); Context context = new Context(strategy); context.executeStrategy(price); } catch (NumberFormatException e) { System.out.println(\"输入格式错误，请输入有效的价格和类型！\"); } catch (IllegalArgumentException e) { System.out.println(e.getMessage()); } } } catch (Exception e) { System.out.println(\"An error occurred: \" + e.getMessage()); } finally { scanner.close(); } } } C++ link #include #include #include // 抽象购物优惠策略接口 class DiscountStrategy { public: virtual int applyDiscount(int originalPrice) = 0; virtual ~DiscountStrategy() = default; // 添加虚析构函数 }; // 九折优惠策略 class DiscountStrategy1 : public DiscountStrategy { public: int applyDiscount(int originalPrice) override { return static_cast(std::round(originalPrice * 0.9)); } }; // 满减优惠策略 class DiscountStrategy2 : public DiscountStrategy { private: int thresholds[4] = {100, 150, 200, 300}; int discounts[4] = {5, 15, 25, 40}; public: int applyDiscount(int originalPrice) override { for (int i = sizeof(thresholds) / sizeof(thresholds[0]) - 1; i \u003e= 0; i--) { if (originalPrice \u003e= thresholds[i]) { return originalPrice - discounts[i]; } } return originalPrice; } }; // 上下文类 class DiscountContext { private: DiscountStrategy* discountStrategy; public: void setDiscountStrategy(DiscountStrategy* discountStrategy) { this-\u003ediscountStrategy = discountStrategy; } int applyDiscount(int originalPrice) { return discountStrategy-\u003eapplyDiscount(originalPrice); } }; int main() { // 读取需要计算优惠的次数 int N; std::cin \u003e\u003e N; std::cin.ignore(); // 忽略换行符 for (int i = 0; i \u003c N; i++) { // 读取商品价格和优惠策略 int M, strategyType; std::cin \u003e\u003e M \u003e\u003e strategyType; // 根据优惠策略设置相应的打折策略 DiscountStrategy* discountStrategy; switch (strategyType) { case 1: discountStrategy = new DiscountStrategy1(); break; case 2: discountStrategy = new DiscountStrategy2(); break; default: // 处理未知策略类型 std::cout \u003c\u003c \"Unknown strategy type\" \u003c\u003c std::endl; return 1; } // 设置打折策略 DiscountContext context; context.setDiscountStrategy(discountStrategy); // 应用打折策略并输出优惠后的价格 int discountedPrice = context.applyDiscount(M); std::cout \u003c\u003c discountedPrice \u003c\u003c std::endl; // 释放动态分配的打折策略对象 delete discountStrategy; } return 0; } Python link class DiscountStrategy: def apply_discount(self, original_price): pass class DiscountStrategy1(DiscountStrategy): def apply_discount(self, original_price): return round(original_price * 0.9) class DiscountStrategy2(DiscountStrategy): def __init__(self): self.thresholds = [100, 150, 200, 300] self.discounts = [5, 15, 25, 40] def apply_discount(self, original_price): for threshold, discount in zip(reversed(self.thresholds), reversed(self.discounts)): if original_price \u003e= threshold: return original_price - discount return original_price class DiscountContext: def __init__(self): self.discount_strategy = None def set_discount_strategy(self, discount_strategy): self.discount_strategy = discount_strategy def apply_discount(self, original_price): return self.discount_strategy.apply_discount(original_price) if __name__ == \"__main__\": # 读取需要计算优惠的次数 N = int(input()) for _ in range(N): # 读取商品价格和优惠策略 input_data = input().split(\" \") M = int(input_data[0]) strategy_type = int(input_data[1]) # 根据优惠策略设置相应的打折策略 if strategy_type == 1: discount_strategy = DiscountStrategy1() elif strategy_type == 2: discount_strategy = DiscountStrategy2() else: # 处理未知策略类型 print(\"Unknown strategy type\") break # 设置打折策略 context = DiscountContext() context.set_discount_strategy(discount_strategy) # 应用打折策略并输出优惠后的价格 discounted_price = context.apply_discount(M) print(discounted_price) Go link package main import \"fmt\" // 抽象购物优惠策略接口 type DiscountStrategy interface { applyDiscount(originalPrice int) int } // 九折优惠策略 type DiscountStrategy1 struct{} func (d *DiscountStrategy1) applyDiscount(originalPrice int) int { return int(float64(originalPrice) * 0.9) } // 满减优惠策略 type DiscountStrategy2 struct { thresholds []int discounts []int } func (d *DiscountStrategy2) applyDiscount(originalPrice int) int { for i := len(d.thresholds) - 1; i \u003e= 0; i-- { if originalPrice \u003e= d.thresholds[i] { return originalPrice - d.discounts[i] } } return originalPrice } // 上下文类 type DiscountContext struct { discountStrategy DiscountStrategy } func (d *DiscountContext) setDiscountStrategy(discountStrategy DiscountStrategy) { d.discountStrategy = discountStrategy } func (d *DiscountContext) applyDiscount(originalPrice int) int { return d.discountStrategy.applyDiscount(originalPrice) } func main() { // 读取需要计算优惠的次数 var N int fmt.Scan(\u0026N) for i := 0; i \u003c N; i++ { // 读取商品价格和优惠策略 var M, strategyType int fmt.Scan(\u0026M, \u0026strategyType) // 根据优惠策略设置相应的打折策略 var discountStrategy DiscountStrategy switch strategyType { case 1: discountStrategy = \u0026DiscountStrategy1{} case 2: discountStrategy = \u0026DiscountStrategy2{ thresholds: []int{100, 150, 200, 300}, discounts: []int{5, 15, 25, 40}, } default: // 处理未知策略类型 fmt.Println(\"Unknown strategy type\") return } // 设置打折策略 context := \u0026DiscountContext{} context.setDiscountStrategy(discountStrategy) // 应用打折策略并输出优惠后的价格 discountedPrice := context.applyDiscount(M) fmt.Println(discountedPrice) } } "
            }
        );
    index.add(
            {
                id:  28 ,
                href: "\/docs\/dev\/23designpattern\/15.%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F\/",
                title: "15.命令模式",
                description: "命令模式是一种行为型设计模式，其允许**将请求封装成一个对象**(命令对象，包含执行操作所需的所有信息)，**并将命令对象按照一定的顺序存储在队列中，然后再逐一调用执行，这些命令也可以支持反向操作，进行撤销和重做。**",
                content: "需求 link【设计模式专题之命令模式】15-自助点餐机\n题目描述\n小明去奶茶店买奶茶，他可以通过在自助点餐机上来点不同的饮品，请你使用命令模式设计一个程序，模拟这个自助点餐系统的功能。 输入描述\n第一行是一个整数 n（1 ≤ n ≤ 100），表示点单的数量。 接下来的 n 行，每行包含一个字符串，表示点餐的饮品名称。 输出描述\n输出执行完所有点单后的制作情况，每行输出一种饮品的制作情况。如果制作完成，输出 “XXX is ready!\"，其中 XXX 表示饮品名称。 输入示例 4 MilkTea Coffee Cola MilkTea 输出示例 MilkTea is ready! Coffee is ready! Cola is ready! MilkTea is ready! 基本概念 link命令模式是一种行为型设计模式，其允许将请求封装成一个对象(命令对象，包含执行操作所需的所有信息)，并将命令对象按照一定的顺序存储在队列中，然后再逐一调用执行，这些命令也可以支持反向操作，进行撤销和重做。\n这样一来，发送者只需要触发命令就可以完成操作，不需要知道接受者的具体操作，从而实现两者间的解耦。\n举个现实中的应用场景，遥控器可以控制不同的设备，在命令模式中，可以假定每个按钮都是一个命令对象，包含执行特定操作的命令，不同设备对同一命令的具体操作也不同，这样就可以方便的添加设备和命令对象。\n基本结构 link命令模式包含以下几个基本角色：\n命令接口Command：接口或者抽象类，定义执行操作的接口。 具体命令类ConcreteCommand: 实现命令接口，执行具体操作，在调用execute方法时使“接收者对象”根据命令完成具体的任务，比如遥控器中的“开机”，“关机”命令。 接收者类Receiver: 接受并执行命令的对象，可以是任何对象，遥控器可以控制空调，也可以控制电视机，电视机和空调负责执行具体操作，是接收者。 调用者类Invoker: 发起请求的对象，有一个将命令作为参数传递的方法。它不关心命令的具体实现，只负责调用命令对象的 execute() 方法来传递请求，在本例中，控制遥控器的“人”就是调用者。 客户端：创建具体的命令对象和接收者对象，然后将它们组装起来。 简易实现 link 定义执行操作的接口：包含一个execute方法。有的时候还会包括unExecute方法，表示撤销命令。 public interface Command { void execute(); } 实现命令接口，执行具体的操作。 public class ConcreteCommand implements Command { // 接收者对象 private Receiver receiver; public ConcreteCommand(Receiver receiver) { this.receiver = receiver; } @Override public void execute() { // 调用接收者相应的操作 receiver.action(); } } 定义接受者类，知道如何实施与执行一个请求相关的操作。 public class Receiver { public void action() { // 执行操作 } } 定义调用者类，调用命令对象执行请求。 public class Invoker { private Command command; public Invoker(Command command) { this.command = command; } public void executeCommand() { command.execute(); } } 调用者类中可以维护一个命令队列或者“撤销栈”，以支持批处理和撤销命令。\nimport java.util.LinkedList; import java.util.Queue; import java.util.Stack; // 调用者类：命令队列和撤销请求 class Invoker { private Queue commandQueue; // 命令队列 private Stack undoStack; // 撤销栈 public Invoker() { this.commandQueue = new LinkedList\u003c\u003e(); this.undoStack = new Stack\u003c\u003e(); } // 设置命令并执行 public void setAndExecuteCommand(Command command) { command.execute(); commandQueue.offer(command); undoStack.push(command); } // 撤销上一个命令 public void undoLastCommand() { if (!undoStack.isEmpty()) { Command lastCommand = undoStack.pop(); lastCommand.undo(); // 需要命令类实现 undo 方法 commandQueue.remove(lastCommand); } else { System.out.println(\"No command to undo.\"); } } // 执行命令队列中的所有命令 public void executeCommandsInQueue() { for (Command command : commandQueue) { command.execute(); } } } 客户端使用，创建具体的命令对象和接收者对象，然后进行组装。 public class Main { public static void main(String[] args) { Receiver receiver = new Receiver(); Command command = new ConcreteCommand(receiver); Invoker invoker = new Invoker(command); invoker.executeCommand(); } } 优缺点和使用场景 link命令模式在需要将请求封装成对象、支持撤销和重做、设计命令队列等情况下，都是一个有效的设计模式。\n撤销操作： 需要支持撤销操作，命令模式可以存储历史命令，轻松实现撤销功能。 队列请求： 命令模式可以将请求排队，形成一个命令队列，依次执行命令。 可扩展性： 可以很容易地添加新的命令类和接收者类，而不影响现有的代码。新增命令不需要修改现有代码，符合开闭原则。 但是对于每个命令，都会有一个具体命令类，这可能导致类的数量急剧增加，增加了系统的复杂性。\n命令模式同样有着很多现实场景的应用，比如Git中的很多操作，如提交（commit）、合并（merge）等，都可以看作是命令模式的应用，用户通过执行相应的命令来操作版本库。Java的GUI编程中，很多事件处理机制也都使用了命令模式。例如，每个按钮都有一个关联的 Action，它代表一个命令，按钮的点击触发 Action 的执行。\n本题代码 link import java.util.Scanner; // 命令接口 interface Command { void execute(); } // 具体命令类 - 点餐命令 class OrderCommand implements Command { private String drinkName; private DrinkMaker receiver; public OrderCommand(String drinkName, DrinkMaker receiver) { this.drinkName = drinkName; this.receiver = receiver; } @Override public void execute() { receiver.makeDrink(drinkName); } } // 接收者类 - 制作饮品 class DrinkMaker { public void makeDrink(String drinkName) { System.out.println(drinkName + \" is ready!\"); } } // 调用者类 - 点餐机 class OrderMachine { private Command command; public void setCommand(Command command) { this.command = command; } public void executeOrder() { command.execute(); } } public class Main { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); // 创建接收者和命令对象 DrinkMaker drinkMaker = new DrinkMaker(); // 读取命令数量 int n = scanner.nextInt(); scanner.nextLine(); while (n-- \u003e 0) { // 读取命令 String drinkName = scanner.next(); // 创建命令对象 Command command = new OrderCommand(drinkName, drinkMaker); // 执行命令 OrderMachine orderMachine = new OrderMachine(); orderMachine.setCommand(command); orderMachine.executeOrder(); } scanner.close(); } } 其他语言版本 linkJava link使用命令模式+工厂模式，进一步将程序进行解耦，主程序不需要知道具体命令类的实现细节，后续增加新命令或饮料类型时，只需修改工厂类，不会影响主程序的结构。\nimport java.util.Scanner; // 命令接口 interface Command { void execute(); } // 具体命令类 - 点餐命令 class OrderCommand implements Command { private String drinkName; private DrinkMaker receiver; public OrderCommand(String drinkName, DrinkMaker receiver) { this.drinkName = drinkName; this.receiver = receiver; } @Override public void execute() { receiver.makeDrink(drinkName); } } // 接收者类 - 制作饮品 class DrinkMaker { public void makeDrink(String drinkName) { System.out.println(drinkName + \" is ready!\"); } } // 调用者类 - 点餐机 class OrderMachine { private Command command; public void setCommand(Command command) { this.command = command; } public void executeOrder() { if (command != null) { command.execute(); } else { System.out.println(\"未设置命令.\"); } } } // 命令工厂类 class CommandFactory { private DrinkMaker drinkMaker; public CommandFactory(DrinkMaker drinkMaker) { this.drinkMaker = drinkMaker; } public Command createCommand(String drinkName) { return new OrderCommand(drinkName, drinkMaker); } } // 主类 public class Main { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); // 创建接收者和工厂对象 DrinkMaker drinkMaker = new DrinkMaker(); CommandFactory commandFactory = new CommandFactory(drinkMaker); OrderMachine orderMachine = new OrderMachine(); // 读取命令数量 int n = scanner.nextInt(); scanner.nextLine(); while (n-- \u003e 0) { // 读取命令 String drinkName = scanner.nextLine().trim(); if (drinkName.isEmpty()) { System.out.println(\"无效输入，请输入饮品名.\"); continue; } // 使用工厂创建命令对象 Command command = commandFactory.createCommand(drinkName); // 设置命令并执行 orderMachine.setCommand(command); orderMachine.executeOrder(); } scanner.close(); } } C++ link #include #include #include class DrinkMaker; // 前向声明 // 命令接口 class Command { public: virtual void execute() = 0; virtual ~Command() = default; // 添加虚析构函数 }; // 具体命令类 - 点餐命令 class OrderCommand : public Command { private: std::string drinkName; DrinkMaker* receiver; // 使用前向声明 public: OrderCommand(const std::string\u0026 drinkName, DrinkMaker* receiver); void execute() override; }; // 接收者类 - 制作饮品 class DrinkMaker { public: void makeDrink(const std::string\u0026 drinkName) { std::cout \u003c\u003c drinkName \u003c\u003c \" is ready!\" \u003c\u003c std::endl; } }; // 实现 OrderCommand 的构造函数和 execute 函数 OrderCommand::OrderCommand(const std::string\u0026 drinkName, DrinkMaker* receiver) : drinkName(drinkName), receiver(receiver) {} void OrderCommand::execute() { receiver-\u003emakeDrink(drinkName); } // 调用者类 - 点餐机 class OrderMachine { private: Command* command; public: void setCommand(Command* command) { this-\u003ecommand = command; } void executeOrder() { command-\u003eexecute(); } }; int main() { // 创建接收者和命令对象 DrinkMaker drinkMaker; // 读取命令数量 int n; std::cin \u003e\u003e n; std::cin.ignore(); // 消耗掉换行符 while (n-- \u003e 0) { // 读取命令 std::string drinkName; std::cin \u003e\u003e drinkName; // 创建命令对象 Command* command = new OrderCommand(drinkName, \u0026drinkMaker); // 执行命令 OrderMachine orderMachine; orderMachine.setCommand(command); orderMachine.executeOrder(); // 释放动态分配的命令对象 delete command; } return 0; } Python link from abc import ABC, abstractmethod # 命令接口 class Command(ABC): @abstractmethod def execute(self): pass # 具体命令类 - 点餐命令 class OrderCommand(Command): def __init__(self, drink_name, receiver): self.drink_name = drink_name self.receiver = receiver def execute(self): self.receiver.make_drink(self.drink_name) # 接收者类 - 制作饮品 class DrinkMaker: def make_drink(self, drink_name): print(f\"{drink_name} is ready!\") # 调用者类 - 点餐机 class OrderMachine: def __init__(self): self.command = None def set_command(self, command): self.command = command def execute_order(self): self.command.execute() if __name__ == \"__main__\": # 创建接收者和命令对象 drink_maker = DrinkMaker() # 读取命令数量 n = int(input()) for _ in range(n): # 读取命令 drink_name = input() # 创建命令对象 command = OrderCommand(drink_name, drink_maker) # 执行命令 order_machine = OrderMachine() order_machine.set_command(command) order_machine.execute_order() Go link package main import \"fmt\" // Command 接口 type Command interface { Execute() } // OrderCommand 具体命令类 - 点餐命令 type OrderCommand struct { DrinkName string Receiver *DrinkMaker } func (oc *OrderCommand) Execute() { oc.Receiver.MakeDrink(oc.DrinkName) } // DrinkMaker 接收者类 - 制作饮品 type DrinkMaker struct{} func (dm *DrinkMaker) MakeDrink(drinkName string) { fmt.Println(drinkName + \" is ready!\") } // OrderMachine 调用者类 - 点餐机 type OrderMachine struct { Command Command } func (om *OrderMachine) SetCommand(command Command) { om.Command = command } func (om *OrderMachine) ExecuteOrder() { om.Command.Execute() } func main() { // 创建接收者和命令对象 drinkMaker := \u0026DrinkMaker{} // 读取命令数量 var n int fmt.Scan(\u0026n) for i := 0; i \u003c n; i++ { // 读取命令 var drinkName string fmt.Scan(\u0026drinkName) // 创建命令对象 command := \u0026OrderCommand{DrinkName: drinkName, Receiver: drinkMaker} // 执行命令 orderMachine := \u0026OrderMachine{} orderMachine.SetCommand(command) orderMachine.ExecuteOrder() } } "
            }
        );
    index.add(
            {
                id:  29 ,
                href: "\/docs\/dev\/23designpattern\/16.%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F\/",
                title: "16.中介者模式",
                description: "中介者模式（Mediator Pattern）也被称为调停者模式，是一种行为型设计模式，它通过一个中介对象来封装一组对象之间的交互，从而使这些对象不需要直接相互引用。这样可以降低对象之间的耦合度，使系统更容易维护和扩展。",
                content: "需求 link【设计模式专题之中介者模式】16-简易聊天室\n题目描述\n小明正在设计一个简单的多人聊天室系统，有多个用户和一个聊天室中介者，用户通过中介者进行聊天，请你帮他完成这个系统的设计。 输入描述\n第一行包括一个整数N,表示用户的数量（1 \u003c= N \u003c= 100) 第二行是N个用户，比如User1 User2 User3，用空格分隔。第三行开始，每行包含两个字符串，表示消息的发出者和消息内容，用空格分隔 输出描述 对于每个用户，输出一行，包含该用户收到的所有消息内容。\n输入示例 3 User1 User2 User3 User1 Hello_All! User2 Hi_User1! User3 How_is_everyone? 输出示例 User2 received: Hello_All! User3 received: Hello_All! User1 received: Hi_User1! User3 received: Hi_User1! User1 received: How_is_everyone? User2 received: How_is_everyone? 基本概念 link中介者模式（Mediator Pattern）也被称为调停者模式，是一种行为型设计模式，它通过一个中介对象来封装一组对象之间的交互，从而使这些对象不需要直接相互引用。这样可以降低对象之间的耦合度，使系统更容易维护和扩展。\n当一个系统中的对象有很多且多个对象之间有复杂的相互依赖关系时，其结构图可能是下面这样的。\n这种依赖关系很难理清，这时我们可以引入一个中介者对象来进行协调和交互。中介者模式可以使得系统的网状结构变成以中介者为中心的星形结构，每个具体对象不再通过直接的联系与另一个对象发生相互作用，而是通过“中介者”对象与另一个对象发生相互作用。\n基本结构 link中介者模式包括以下几个重要角色：\n抽象中介者（Mediator）： 定义中介者的接口，用于各个具体同事对象之间的通信。\n具体中介者（Concrete Mediator）： 实现抽象中介者接口，负责协调各个具体同事对象的交互关系，它需要知道所有具体同事类，并从具体同事接收消息，向具体同事对象发出命令。\n抽象同事类（Colleague）： 定义同事类的接口，维护一个对中介者对象的引用，用于通信。\n具体同事类（Concrete Colleague）： 实现抽象同事类接口，每个具体同事类只知道自己的行为，而不了解其他同事类的情况，因为它们都需要与中介者通信，通过中介者协调与其他同事对象的交互。\n简易实现 link // 抽象中介者 public abstract class Mediator { void register(Colleague colleague); // 定义一个抽象的发送消息方法 public abstract void send(String message, Player player); } // 具体中介者 public class ConcreteMediator extends Mediator { private List colleagues = new ArrayList\u003c\u003e(); public void register((Colleague colleague) { colleagues.add(colleague); } @Override public void send(String message, Colleague colleague) { for (Colleague c : colleagues) { // 排除发送消息的同事对象 if (c != colleague) { c.receive(message); } } } } // 同事对象 abstract class Colleague { protected Mediator mediator; public Colleague(Mediator mediator) { this.mediator = mediator; } // 发送消息 public abstract void send(String message); // 接收消息 public abstract void receive(String message); } // 具体同事对象1 class ConcreteColleague1 extends Colleague { public ConcreteColleague1(Mediator mediator) { super(mediator); } @Override public void send(String message) { mediator.send(message, this); } @Override public void receive(String message) { System.out.println(\"ConcreteColleague1 received: \" + message); } } // 具体同事对象2 class ConcreteColleague2 extends Colleague { public ConcreteColleague2(Mediator mediator) { super(mediator); } @Override public void send(String message) { mediator.send(message, this); } @Override public void receive(String message) { System.out.println(\"ConcreteColleague2 received: \" + message); } } // 客户端 public class Main{ public static void main(String[] args) { // 创建中介者 Mediator mediator = new ConcreteMediator(); // 创建同事对象 Colleague colleague1 = new ConcreteColleague1(mediator); Colleague colleague2 = new ConcreteColleague2(mediator); // 注册同事对象到中介者 mediator.register(colleague1); mediator.register(colleague2); // 同事对象之间发送消息 colleague1.send(\"Hello from Colleague1!\"); colleague2.send(\"Hi from Colleague2!\"); } } 使用场景 link中介者模式使得同事对象不需要知道彼此的细节，只需要与中介者进行通信，简化了系统的复杂度，也降低了各对象之间的耦合度，但是这也会使得中介者对象变得过于庞大和复杂，如果中介者对象出现问题，整个系统可能会受到影响。\n中介者模式适用于当系统对象之间存在复杂的交互关系或者系统需要在不同对象之间进行灵活的通信时使用，可以使得问题简化，\n本题代码 link import java.util.*; // 抽象中介者 interface ChatRoomMediator { void sendMessage(String sender, String message); void addUser(ChatUser user); Map getUsers(); } // 具体中介者 class ChatRoomMediatorImpl implements ChatRoomMediator { private Map users = new LinkedHashMap\u003c\u003e(); @Override public void sendMessage(String sender, String message) { for (ChatUser user : users.values()) { if (!user.getName().equals(sender)) { user.receiveMessage(sender, message); } } } @Override public void addUser(ChatUser user) { users.put(user.getName(), user); } @Override public Map getUsers() { return users; } } // 抽象同事类 abstract class ChatUser { private String name; private ChatRoomMediator mediator; private List receivedMessages = new ArrayList\u003c\u003e(); public ChatUser(String name, ChatRoomMediator mediator) { this.name = name; this.mediator = mediator; mediator.addUser(this); } public String getName() { return name; } public void sendMessage(String message) { mediator.sendMessage(name, message); } public abstract void receiveMessage(String sender, String message); public List getReceivedMessages() { return receivedMessages; } protected void addReceivedMessage(String message) { receivedMessages.add(message); } } // 具体同事类 class ConcreteChatUser extends ChatUser { public ConcreteChatUser(String name, ChatRoomMediator mediator) { super(name, mediator); } @Override public void receiveMessage(String sender, String message) { String receivedMessage = getName() + \" received: \" + message; addReceivedMessage(receivedMessage); System.out.println(receivedMessage); } } // 客户端 public class Main { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); int N = scanner.nextInt(); List userNames = new ArrayList\u003c\u003e(); for (int i = 0; i \u003c N; i++) { userNames.add(scanner.next()); } ChatRoomMediator mediator = new ChatRoomMediatorImpl(); // 创建用户对象 for (String userName : userNames) { new ConcreteChatUser(userName, mediator); } // 发送消息并输出 while (scanner.hasNext()) { String sender = scanner.next(); String message = scanner.next(); ChatUser user = mediator.getUsers().get(sender); if (user != null) { user.sendMessage(message); } } scanner.close(); } } 扩展：和代理模式的区别 link中介者模式（Mediator Pattern）和代理模式（Proxy Pattern) 在某些表述上有些类似，但是他们是完全不同的两个设计模式，中介者模式的目的是降低系统中各个对象之间的直接耦合，通过引入一个中介者对象，使对象之间的通信集中在中介者上。而在代理模式中，客户端通过代理与目标对象进行通信。代理可以在调用目标对象的方法前后进行一些额外的操作，其目的是控制对对象的访问，它们分别解决了不同类型的问题。\n其他语言版本 linkC++ link #include #include #include #include // 抽象中介者 class ChatRoomMediator; // 抽象同事类 class ChatUser { private: std::string name; ChatRoomMediator* mediator; std::list receivedMessages; public: ChatUser(const std::string\u0026 name, ChatRoomMediator* mediator); std::string getName() const { return name; } void sendMessage(const std::string\u0026 message); virtual void receiveMessage(const std::string\u0026 sender, const std::string\u0026 message) = 0; std::list getReceivedMessages() const { return receivedMessages; } protected: void addReceivedMessage(const std::string\u0026 message) { receivedMessages.push_back(message); } }; // 具体同事类 class ConcreteChatUser : public ChatUser { public: ConcreteChatUser(const std::string\u0026 name, ChatRoomMediator* mediator); void receiveMessage(const std::string\u0026 sender, const std::string\u0026 message) override; }; // 抽象中介者 class ChatRoomMediator { public: virtual void sendMessage(const std::string\u0026 sender, const std::string\u0026 message) = 0; virtual void addUser(ChatUser* user) = 0; virtual std::map getUsers() = 0; virtual ~ChatRoomMediator() = default; }; // 具体中介者 class ChatRoomMediatorImpl : public ChatRoomMediator { private: std::map users; public: void sendMessage(const std::string\u0026 sender, const std::string\u0026 message) override { for (const auto\u0026 userPair : users) { if (userPair.first != sender) { userPair.second-\u003ereceiveMessage(sender, message); } } } void addUser(ChatUser* user) override { users[user-\u003egetName()] = user; } std::map getUsers() override { return users; } }; // 实现 ChatUser 类的成员函数 ChatUser::ChatUser(const std::string\u0026 name, ChatRoomMediator* mediator) : name(name), mediator(mediator) { mediator-\u003eaddUser(this); } void ChatUser::sendMessage(const std::string\u0026 message) { mediator-\u003esendMessage(name, message); } // 实现 ConcreteChatUser 类的成员函数 ConcreteChatUser::ConcreteChatUser(const std::string\u0026 name, ChatRoomMediator* mediator) : ChatUser(name, mediator) {} void ConcreteChatUser::receiveMessage(const std::string\u0026 sender, const std::string\u0026 message) { std::string receivedMessage = getName() + \" received: \" + message; addReceivedMessage(receivedMessage); std::cout \u003c\u003c receivedMessage \u003c\u003c std::endl; } int main() { std::vector userNames; int N; std::cin \u003e\u003e N; for (int i = 0; i \u003c N; i++) { std::string userName; std::cin \u003e\u003e userName; userNames.push_back(userName); } ChatRoomMediator* mediator = new ChatRoomMediatorImpl(); // 创建用户对象 for (const auto\u0026 userName : userNames) { new ConcreteChatUser(userName, mediator); } // 发送消息并输出 std::string sender, message; while (std::cin \u003e\u003e sender \u003e\u003e message) { ChatUser* user = mediator-\u003egetUsers()[sender]; if (user != nullptr) { user-\u003esendMessage(message); } } delete mediator; // 释放中介者对象 return 0; } Python link class ChatRoomMediator: def __init__(self): self.users = {} def send_message(self, sender, message): for user in self.users.values(): if user.name != sender: user.receive_message(sender, message) def add_user(self, user): self.users[user.name] = user class ChatUser: def __init__(self, name, mediator): self.name = name self.mediator = mediator self.received_messages = [] def send_message(self, message): self.mediator.send_message(self.name, message) def receive_message(self, sender, message): received_message = f\"{self.name} received: {message}\" self.received_messages.append(received_message) print(received_message) if __name__ == \"__main__\": # 读取用户数量 N = int(input()) # 读取用户列表 user_names = input().split() # 创建中介者 mediator = ChatRoomMediator() # 创建用户对象并注册到中介者 for user_name in user_names: user = ChatUser(user_name, mediator) mediator.add_user(user) # 处理消息输入 while True: try: sender, message = input().split() user = mediator.users.get(sender) if user: user.send_message(message) except EOFError: break Go link package main import \"fmt\" type ChatRoomMediator struct { users map[string]*ChatUser } func NewChatRoomMediator() *ChatRoomMediator { return \u0026ChatRoomMediator{ users: make(map[string]*ChatUser), } } func (m *ChatRoomMediator) SendMessage(sender, message string) { for _, user := range m.users { if user.name != sender { user.ReceiveMessage(sender, message) } } } func (m *ChatRoomMediator) AddUser(user *ChatUser) { m.users[user.name] = user } type ChatUser struct { name string mediator *ChatRoomMediator receivedMessages []string } func NewChatUser(name string, mediator *ChatRoomMediator) *ChatUser { return \u0026ChatUser{ name: name, mediator: mediator, receivedMessages: make([]string, 0), } } func (u *ChatUser) SendMessage(message string) { u.mediator.SendMessage(u.name, message) } func (u *ChatUser) ReceiveMessage(sender, message string) { receivedMessage := fmt.Sprintf(\"%s received: %s\", u.name, message) u.receivedMessages = append(u.receivedMessages, receivedMessage) fmt.Println(receivedMessage) } func main() { var N int fmt.Scan(\u0026N) userNames := make([]string, N) for i := 0; i \u003c N; i++ { fmt.Scan(\u0026userNames[i]) } mediator := NewChatRoomMediator() for _, userName := range userNames { user := NewChatUser(userName, mediator) mediator.AddUser(user) } for { var sender, message string _, err := fmt.Scan(\u0026sender, \u0026message) if err != nil { break } user, ok := mediator.users[sender] if ok { user.SendMessage(message) } } } "
            }
        );
    index.add(
            {
                id:  30 ,
                href: "\/docs\/dev\/23designpattern\/17.%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F\/",
                title: "17.备忘录模式",
                description: "备忘录模式（Memento Pattern）是一种行为型设计模式，它允许在**不暴露对象实现的情况下捕获对象的内部状态**并**在对象之外保存这个状态**，以 便稍后可以将其还原到先前的状态。",
                content: "需求 link【设计模式专题之备忘录模式】17-redo计数器应用\n题目描述 小明正在设计一个简单的计数器应用，支持增加（Increment）和减少（Decrement）操作，以及撤销（Undo）和重做（Redo）操作，请你使用备忘录模式帮他实现。\n输入描述\n输入包含若干行，每行包含一个字符串，表示计数器应用的操作，操作包括 “Increment”、“Decrement”、“Undo” 和 “Redo”。 输出描述\n对于每个 “Increment” 和 “Decrement” 操作，输出当前计数器的值，计数器数值从0开始 对于每个 “Undo” 操作，输出撤销后的计数器值。 对于每个 “Redo” 操作，输出重做后的计数器值。 输入示例 Increment Increment Decrement Undo Redo Increment 输出示例 1 2 1 2 1 2 基本概念 link备忘录模式（Memento Pattern）是一种行为型设计模式，它允许在不暴露对象实现的情况下捕获对象的内部状态并在对象之外保存这个状态，以便稍后可以将其还原到先前的状态。\n基本结构 link备忘录模式包括以下几个重要角色：\n发起人Originator： 需要还原状态的那个对象，负责创建一个【备忘录】，并使用备忘录记录当前时刻的内部状态。\n备忘录Memento: 存储发起人对象的内部状态，它可以包含发起人的部分或全部状态信息，但是对外部是不可见的，只有发起人能够访问备忘录对象的状态。\n备忘录有两个接口，发起人能够通过宽接口访问数据，管理者只能看到窄接口，并将备忘录传递给其他对象。\n管理者Caretaker: 负责存储备忘录对象，但并不了解其内部结构，管理者可以存储多个备忘录对象。\n客户端：在需要恢复状态时，客户端可以从管理者那里获取备忘录对象，并将其传递给发起人进行状态的恢复。\n基本实现 link 创建发起人类：可以创建备忘录对象 class Originator { private String state; public void setState(String state) { this.state = state; } public String getState() { return state; } // 创建备忘录对象 public Memento createMemento() { return new Memento(state); } // 通过备忘录对象恢复状态 public void restoreFromMemento(Memento memento) { state = memento.getState(); } } 创建备忘录类：保存发起人对象的状态 class Memento { private String state; // 保存发起人的状态 public Memento(String state) { this.state = state; } public String getState() { return state; } } 创建管理者：维护一组备忘录对象 class Caretaker { private List mementos = new ArrayList\u003c\u003e(); public void addMemento(Memento memento) { mementos.add(memento); } public Memento getMemento(int index) { return mementos.get(index); } } 客户端使用备忘录模式 public class Main { public static void main(String[] args) { // 创建发起人对象 Originator originator = new Originator(); originator.setState(\"State 1\"); // 创建管理者对象 Caretaker caretaker = new Caretaker(); // 保存当前状态 caretaker.addMemento(originator.createMemento()); // 修改状态 originator.setState(\"State 2\"); // 再次保存当前状态 caretaker.addMemento(originator.createMemento()); // 恢复到先前状态 originator.restoreFromMemento(caretaker.getMemento(0)); System.out.println(\"Current State: \" + originator.getState()); } } 使用场景 link备忘录模式在保证了对象内部状态的封装和私有性前提下可以轻松地添加新的备忘录和发起人，实现“备份”，不过 备份对象往往会消耗较多的内存，资源消耗增加。\n备忘录模式常常用来实现撤销和重做功能，比如在Java Swing GUI编程中，javax.swing.undo包中的撤销（undo）和重做（redo）机制使用了备忘录模式。UndoManager和UndoableEdit接口是与备忘录模式相关的主要类和接口。\n本题代码 link import java.util.Scanner; import java.util.Stack; // 备忘录 class Memento { private int value; public Memento(int value) { this.value = value; } public int getValue() { return value; } } // 发起人（Originator） class Counter { private int value; private Stack undoStack = new Stack\u003c\u003e(); private Stack redoStack = new Stack\u003c\u003e(); public void increment() { redoStack.clear(); undoStack.push(new Memento(value)); value++; } public void decrement() { redoStack.clear(); undoStack.push(new Memento(value)); value--; } public void undo() { if (!undoStack.isEmpty()) { redoStack.push(new Memento(value)); value = undoStack.pop().getValue(); } } public void redo() { if (!redoStack.isEmpty()) { undoStack.push(new Memento(value)); value = redoStack.pop().getValue(); } } public int getValue() { return value; } } // 客户端 public class Main { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); Counter counter = new Counter(); // 处理计数器应用的输入 while (scanner.hasNext()) { String operation = scanner.next(); switch (operation) { case \"Increment\": counter.increment(); break; case \"Decrement\": counter.decrement(); break; case \"Undo\": counter.undo(); break; case \"Redo\": counter.redo(); break; } // 输出当前计数器的值 System.out.println(counter.getValue()); } scanner.close(); } } 其他语言版本 linkC++ link #include #include // 备忘录 class Memento { private: int value; public: Memento(int val) : value(val) {} int getValue() const { return value; } }; // 发起人（Originator） class Counter { private: int value; std::stack undoStack; std::stack redoStack; public: void increment() { redoStack = std::stack(); // 清空 redoStack undoStack.push(Memento(value)); value++; } void decrement() { redoStack = std::stack(); // 清空 redoStack undoStack.push(Memento(value)); value--; } void undo() { if (!undoStack.empty()) { redoStack.push(Memento(value)); value = undoStack.top().getValue(); undoStack.pop(); } } void redo() { if (!redoStack.empty()) { undoStack.push(Memento(value)); value = redoStack.top().getValue(); redoStack.pop(); } } int getValue() const { return value; } }; int main() { Counter counter; // 处理计数器应用的输入 std::string operation; while (std::cin \u003e\u003e operation) { if (operation == \"Increment\") { counter.increment(); } else if (operation == \"Decrement\") { counter.decrement(); } else if (operation == \"Undo\") { counter.undo(); } else if (operation == \"Redo\") { counter.redo(); } // 输出当前计数器的值 std::cout \u003c\u003c counter.getValue() \u003c\u003c std::endl; } return 0; } Python link import sys class Memento: def __init__(self, value): self.value = value def get_value(self): return self.value class Counter: def __init__(self): self.value = 0 self.undo_stack = [] self.redo_stack = [] def increment(self): self.redo_stack = [] # 清空 redo_stack self.undo_stack.append(Memento(self.value)) self.value += 1 def decrement(self): self.redo_stack = [] # 清空 redo_stack self.undo_stack.append(Memento(self.value)) self.value -= 1 def undo(self): if self.undo_stack: self.redo_stack.append(Memento(self.value)) self.value = self.undo_stack.pop().get_value() def redo(self): if self.redo_stack: self.undo_stack.append(Memento(self.value)) self.value = self.redo_stack.pop().get_value() def get_value(self): return self.value # 客户端 counter = Counter() # 处理计数器应用的输入 for line in sys.stdin: operation = line.strip() if operation == \"Increment\": counter.increment() elif operation == \"Decrement\": counter.decrement() elif operation == \"Undo\": counter.undo() elif operation == \"Redo\": counter.redo() # 输出当前计数器的值 print(counter.get_value()) Go link package main import ( \"bufio\" \"fmt\" \"os\" ) // 备忘录 type Memento struct { value int } // 发起人（Originator） type Counter struct { value int undoStack []*Memento redoStack []*Memento } func (c *Counter) increment() { c.redoStack = nil c.undoStack = append(c.undoStack, \u0026Memento{value: c.value}) c.value++ } func (c *Counter) decrement() { c.redoStack = nil c.undoStack = append(c.undoStack, \u0026Memento{value: c.value}) c.value-- } func (c *Counter) undo() { if len(c.undoStack) \u003e 0 { c.redoStack = append(c.redoStack, \u0026Memento{value: c.value}) c.value = c.undoStack[len(c.undoStack)-1].value c.undoStack = c.undoStack[:len(c.undoStack)-1] } } func (c *Counter) redo() { if len(c.redoStack) \u003e 0 { c.undoStack = append(c.undoStack, \u0026Memento{value: c.value}) c.value = c.redoStack[len(c.redoStack)-1].value c.redoStack = c.redoStack[:len(c.redoStack)-1] } } func (c *Counter) getValue() int { return c.value } // 客户端 func main() { scanner := bufio.NewScanner(os.Stdin) counter := \u0026Counter{} // 处理计数器应用的输入 for scanner.Scan() { operation := scanner.Text() switch operation { case \"Increment\": counter.increment() case \"Decrement\": counter.decrement() case \"Undo\": counter.undo() case \"Redo\": counter.redo() } // 输出当前计数器的值 fmt.Println(counter.getValue()) } if err := scanner.Err(); err != nil { fmt.Fprintln(os.Stderr, \"reading standard input:\", err) } } "
            }
        );
    index.add(
            {
                id:  31 ,
                href: "\/docs\/dev\/23designpattern\/18.%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F\/",
                title: "18.模板方法模式",
                description: "模板方法模式（Template Method Pattern）是一种行为型设计模式, 它定义了一个算法的骨架，将**一些步骤的实现延迟到子类。**模板方法模式使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤。",
                content: "需求 link【设计模式专题之模板方法模式】18-咖啡馆\n题目描述\n小明喜欢品尝不同类型的咖啡，她发现每种咖啡的制作过程有一些相同的步骤，他决定设计一个简单的咖啡制作系统，使用模板方法模式定义咖啡的制作过程。系统支持两种咖啡类型：美式咖啡（American Coffee）和拿铁（Latte）。\n咖啡制作过程包括以下步骤：\n研磨咖啡豆 Grinding coffee beans 冲泡咖啡 Brewing coffee 添加调料 Adding condiments 其中，美式咖啡和拿铁的调料添加方式略有不同, 拿铁在添加调料时需要添加牛奶Adding milk\n输入描述\n多行输入，每行包含一个数字，表示咖啡的选择（1 表示美式咖啡，2 表示拿铁）。 输出描述\n根据每行输入，输出制作咖啡的过程，包括咖啡类型和各个制作步骤，末尾有一个空行。 输入示例 1 2 输出示例\nMaking American Coffee: Grinding coffee beans Brewing coffee Adding condiments Making Latte: Grinding coffee beans Brewing coffee Adding milk Adding condiments 基本概念 link模板方法模式（Template Method Pattern）是一种行为型设计模式, 它定义了一个算法的骨架，将**一些步骤的实现延迟到子类。**模板方法模式使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤。【引用自大话设计第10章】\n举个简单的例子，做一道菜通常都需要包含至少三步：\n准备食材 亨饪过程 上菜 不同菜品的亨饪过程是不一样的，但是我们可以先定义一个”骨架”，包含这三个步骤，亨饪过程的过程放到具体的炒菜类中去实现，这样，无论炒什么菜，都可以沿用相同的炒菜算法，只需在子类中实现具体的炒菜步骤，从而提高了代码的复用性。\n基本结构 link模板方法模式的基本结构包含以下两个角色：\n模板类AbstractClass：由一个模板方法和若干个基本方法构成，模板方法定义了逻辑的骨架，按照顺序调用包含的基本方法，基本方法通常是一些抽象方法，这些方法由子类去实现。基本方法还包含一些具体方法，它们是算法的一部分但已经有默认实现，在具体子类中可以继承或者重写。 具体类ConcreteClass：继承自模板类，实现了在模板类中定义的抽象方法，以完成算法中特定步骤的具体实现。 简易实现 link模板方法模式的简单示例如下：\n定义模板类，包含模板方法，定义了算法的骨架, 一般都加上final关键字，避免子类重写。 // 模板类 abstract class AbstractClass { // 模板方法，定义了算法的骨架 public final void templateMethod() { step1(); step2(); step3(); } // 抽象方法，由子类实现 protected abstract void step1(); protected abstract void step2(); protected abstract void step3(); } 定义具体类, 实现模板类中的抽象方法 // 具体类 class ConcreteClass extends AbstractClass { @Override protected void step1() { System.out.println(\"Step 1 \"); } @Override protected void step2() { System.out.println(\"Step 2 \"); } @Override protected void step3() { System.out.println(\"Step 3\"); } } 客户端实现 public class Main { public static void main(String[] args) { AbstractClass concreteTemplate = new ConcreteClass(); // 触发整个算法的执行 concreteTemplate.templateMethod(); } } 应用场景 link模板方法模式将算法的不变部分被封装在模板方法中，而可变部分算法由子类继承实现，这样做可以很好的提高代码的复用性，但是当算法的框架发生变化时，可能需要修改模板类，这也会影响到所有的子类。\n总体来说，当算法的整体步骤很固定，但是个别步骤在更详细的层次上的实现可能不同时，通常考虑模板方法模式来处理。在已有的工具和库中， Spring框架中的JdbcTemplate类使用了模板方法模式，其中定义了一些执行数据库操作的模板方法，具体的数据库操作由回调函数提供。而在Java的JDK源码中，AbstractList 类也使用了模板方法模式，它提供了一些通用的方法，其中包括一些模板方法。具体的列表操作由子类实现。\n本题代码 link import java.util.Scanner; // 抽象类 abstract class CoffeeMakerTemplate { private String coffeeName; // 添加咖啡名称字段 // 构造函数，接受咖啡名称参数 public CoffeeMakerTemplate(String coffeeName) { this.coffeeName = coffeeName; } // 模板方法定义咖啡制作过程 final void makeCoffee() { System.out.println(\"Making \" + coffeeName + \":\"); grindCoffeeBeans(); brewCoffee(); addCondiments(); System.out.println(); } // 具体步骤的具体实现由子类提供 abstract void grindCoffeeBeans(); abstract void brewCoffee(); // 添加调料的默认实现 void addCondiments() { System.out.println(\"Adding condiments\"); } } // 具体的美式咖啡类 class AmericanCoffeeMaker extends CoffeeMakerTemplate { // 构造函数传递咖啡名称 public AmericanCoffeeMaker() { super(\"American Coffee\"); } @Override void grindCoffeeBeans() { System.out.println(\"Grinding coffee beans\"); } @Override void brewCoffee() { System.out.println(\"Brewing coffee\"); } } // 具体的拿铁咖啡类 class LatteCoffeeMaker extends CoffeeMakerTemplate { // 构造函数传递咖啡名称 public LatteCoffeeMaker() { super(\"Latte\"); } @Override void grindCoffeeBeans() { System.out.println(\"Grinding coffee beans\"); } @Override void brewCoffee() { System.out.println(\"Brewing coffee\"); } // 添加调料的特定实现 @Override void addCondiments() { System.out.println(\"Adding milk\"); System.out.println(\"Adding condiments\"); } } // 客户端代码 public class Main { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); while (scanner.hasNext()) { int coffeeType = scanner.nextInt(); CoffeeMakerTemplate coffeeMaker = null; if (coffeeType == 1) { coffeeMaker = new AmericanCoffeeMaker(); } else if (coffeeType == 2) { coffeeMaker = new LatteCoffeeMaker(); } else { System.out.println(\"Invalid coffee type\"); continue; } // 制作咖啡 coffeeMaker.makeCoffee(); } } } 其他语言版本 linkJava link添加钩子函数，也可由用户来确定是否添加牛奶或其它配料。\nimport java.util.Scanner; // 抽象类，定义咖啡制作的基本步骤 abstract class CoffeeModel { private String coffeeName; // 构造函数，接受咖啡名称参数 public CoffeeModel(String coffeeName) { this.coffeeName = coffeeName; } protected abstract void grind(); protected abstract void brew(); protected abstract void addCondiments(); // 添加其他调料可使用该类 public void addThings(){}; // 模板方法，定义咖啡制作的流程 public final void createCoffeeTemplate() { System.out.println(\"Making \" + coffeeName + \":\"); grind(); brew(); //根据情况，是否调用添加更多调料 if (isAddThings()) { addThings(); } addCondiments(); System.out.println(); } // 默认不添加其他调料。如牛奶等 public boolean isAddThings() { return false; } } //美式咖啡类实现 class CreateAmericanCoffee extends CoffeeModel { public CreateAmericanCoffee() { super(\"American Coffee\"); } @Override protected void grind() { System.out.println(\"Grinding coffee beans\"); } @Override protected void brew() { System.out.println(\"Brewing coffee\"); } @Override protected void addCondiments() { System.out.println(\"Adding condiments\"); } // 美式咖啡默认不添加其他调料，如牛奶等 @Override public boolean isAddThings() { return false; } } //拿铁类实现 class CreateLatte extends CoffeeModel { private boolean addThingsFlag = true; public CreateLatte() { super(\"Latte\"); } @Override protected void grind() { System.out.println(\"Grinding coffee beans\"); } @Override protected void brew() { System.out.println(\"Brewing coffee\"); } @Override protected void addCondiments() { System.out.println(\"Adding condiments\"); } //需要添加调料，牛奶 @Override public void addThings(){ System.out.println(\"Adding milk\"); } // 拿铁默认添加牛奶 @Override public boolean isAddThings() { return this.addThingsFlag; } // 外部调用以改变是否添加牛奶的状态，钩子函数 public void setAddThingsFlag(boolean flag) { this.addThingsFlag = flag; } } //客户端 public class Main { public static void main(String[] args) { try (Scanner scanner = new Scanner(System.in)) { while (scanner.hasNextInt()) { int input = scanner.nextInt(); CoffeeModel coffee; switch (input) { case 1: coffee = new CreateAmericanCoffee(); break; case 2: coffee = new CreateLatte(); break; default: System.out.println(\"无效选择，请输入1或2\"); continue; } coffee.createCoffeeTemplate(); } } } } C++ link #include #include #include // 抽象类 class CoffeeMakerTemplate { private: std::string coffeeName; public: // 构造函数，接受咖啡名称参数 CoffeeMakerTemplate(const std::string\u0026 coffeeName) : coffeeName(coffeeName) {} // 模板方法定义咖啡制作过程 virtual void makeCoffee() { std::cout \u003c\u003c \"Making \" \u003c\u003c coffeeName \u003c\u003c \":\\n\"; grindCoffeeBeans(); brewCoffee(); addCondiments(); std::cout \u003c\u003c '\\n'; } // 具体步骤的具体实现由子类提供 virtual void grindCoffeeBeans() = 0; virtual void brewCoffee() = 0; // 添加调料的默认实现 virtual void addCondiments() { std::cout \u003c\u003c \"Adding condiments\\n\"; } }; // 具体的美式咖啡类 class AmericanCoffeeMaker : public CoffeeMakerTemplate { public: // 构造函数传递咖啡名称 AmericanCoffeeMaker() : CoffeeMakerTemplate(\"American Coffee\") {} void grindCoffeeBeans() override { std::cout \u003c\u003c \"Grinding coffee beans\\n\"; } void brewCoffee() override { std::cout \u003c\u003c \"Brewing coffee\\n\"; } }; // 具体的拿铁咖啡类 class LatteCoffeeMaker : public CoffeeMakerTemplate { public: // 构造函数传递咖啡名称 LatteCoffeeMaker() : CoffeeMakerTemplate(\"Latte\") {} void grindCoffeeBeans() override { std::cout \u003c\u003c \"Grinding coffee beans\\n\"; } void brewCoffee() override { std::cout \u003c\u003c \"Brewing coffee\\n\"; } // 添加调料的特定实现 void addCondiments() override { std::cout \u003c\u003c \"Adding milk\\n\"; std::cout \u003c\u003c \"Adding condiments\\n\"; } }; int main() { std::unique_ptr coffeeMaker; int coffeeType; while (std::cin \u003e\u003e coffeeType) { if (coffeeType == 1) { coffeeMaker = std::make_unique(); } else if (coffeeType == 2) { coffeeMaker = std::make_unique(); } else { std::cout \u003c\u003c \"Invalid coffee type\\n\"; continue; } // 制作咖啡 coffeeMaker-\u003emakeCoffee(); } return 0; } Python link from abc import ABC, abstractmethod # 抽象类 class CoffeeMakerTemplate(ABC): # 构造函数，接受咖啡名称参数 def __init__(self, coffee_name): self.coffee_name = coffee_name # 模板方法定义咖啡制作过程 def make_coffee(self): print(f\"Making {self.coffee_name}:\") self.grind_coffee_beans() self.brew_coffee() self.add_condiments() print() # 具体步骤的具体实现由子类提供 @abstractmethod def grind_coffee_beans(self): pass @abstractmethod def brew_coffee(self): pass # 添加调料的默认实现 def add_condiments(self): print(\"Adding condiments\") # 具体的美式咖啡类 class AmericanCoffeeMaker(CoffeeMakerTemplate): # 构造函数传递咖啡名称 def __init__(self): super().__init__(\"American Coffee\") def grind_coffee_beans(self): print(\"Grinding coffee beans\") def brew_coffee(self): print(\"Brewing coffee\") # 具体的拿铁咖啡类 class LatteCoffeeMaker(CoffeeMakerTemplate): # 构造函数传递咖啡名称 def __init__(self): super().__init__(\"Latte\") def grind_coffee_beans(self): print(\"Grinding coffee beans\") def brew_coffee(self): print(\"Brewing coffee\") # 添加调料的特定实现 def add_condiments(self): print(\"Adding milk\") print(\"Adding condiments\") # 客户端代码 if __name__ == \"__main__\": while True: try: coffee_type = int(input()) coffee_maker = None if coffee_type == 1: coffee_maker = AmericanCoffeeMaker() elif coffee_type == 2: coffee_maker = LatteCoffeeMaker() else: print(\"Invalid coffee type\") continue # 制作咖啡 coffee_maker.make_coffee() except EOFError: break Go link package main import ( \"fmt\" \"os\" ) // 抽象类接口 type CoffeeMakerTemplate interface { MakeCoffee() GrindCoffeeBeans() BrewCoffee() AddCondiments() } // 具体的美式咖啡类 type AmericanCoffeeMaker struct { coffeeName string } // 构造函数传递咖啡名称 func NewAmericanCoffeeMaker() *AmericanCoffeeMaker { return \u0026AmericanCoffeeMaker{coffeeName: \"American Coffee\"} } // 实现接口 func (a *AmericanCoffeeMaker) MakeCoffee() { fmt.Printf(\"Making %s:\\n\", a.coffeeName) a.GrindCoffeeBeans() a.BrewCoffee() a.AddCondiments() fmt.Println() } func (a *AmericanCoffeeMaker) GrindCoffeeBeans() { fmt.Println(\"Grinding coffee beans\") } func (a *AmericanCoffeeMaker) BrewCoffee() { fmt.Println(\"Brewing coffee\") } func (a *AmericanCoffeeMaker) AddCondiments() { fmt.Println(\"Adding condiments\") } // 具体的拿铁咖啡类 type LatteCoffeeMaker struct { coffeeName string } // 构造函数传递咖啡名称 func NewLatteCoffeeMaker() *LatteCoffeeMaker { return \u0026LatteCoffeeMaker{coffeeName: \"Latte\"} } // 实现接口 func (l *LatteCoffeeMaker) MakeCoffee() { fmt.Printf(\"Making %s:\\n\", l.coffeeName) l.GrindCoffeeBeans() l.BrewCoffee() l.AddCondiments() fmt.Println() } func (l *LatteCoffeeMaker) GrindCoffeeBeans() { fmt.Println(\"Grinding coffee beans\") } func (l *LatteCoffeeMaker) BrewCoffee() { fmt.Println(\"Brewing coffee\") } func (l *LatteCoffeeMaker) AddCondiments() { fmt.Println(\"Adding milk\") fmt.Println(\"Adding condiments\") } func main() { for { var coffeeType int if _, err := fmt.Scan(\u0026coffeeType); err != nil { if err.Error() == \"expected integer\" || err.Error() == \"EOF\" { break } fmt.Println(err) os.Exit(1) } var coffeeMaker CoffeeMakerTemplate switch coffeeType { case 1: coffeeMaker = NewAmericanCoffeeMaker() case 2: coffeeMaker = NewLatteCoffeeMaker() default: fmt.Println(\"Invalid coffee type\") continue } // 制作咖啡 coffeeMaker.MakeCoffee() } } "
            }
        );
    index.add(
            {
                id:  32 ,
                href: "\/docs\/dev\/23designpattern\/19.%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F\/",
                title: "19.迭代器模式",
                description: "迭代器模式是一种行为设计模式，是一种使用频率非常高的设计模式，在各个语言中都有应用，其主要目的是**提供一种统一的方式来访问一个聚合对象中的各个元素，**而不需要暴露该对象的内部表示。通过迭代器，客户端可以顺序访问聚合对象的元素，而无需了解底层数据结构。",
                content: "需求 link【设计模式专题之迭代器模式】19-学生名单\n题目描述\n小明是一位老师，在进行班级点名时，希望有一个学生名单系统，请你实现迭代器模式提供一个迭代器使得可以按顺序遍历学生列表。 输入描述\n第一行是一个整数 N （1 \u003c= N \u003c= 100), 表示学生的数量。 接下来的 N 行，每行包含一个学生的信息，格式为 姓名 学号 输出描述\n输出班级点名的结果，即按顺序遍历学生列表，输出学生的姓名和学号 输入示例 3 Alice 1001 Bob 1002 Charlie 1003 输出示例 Alice 1001 Bob 1002 Charlie 1003 基本概念 link迭代器模式是一种行为设计模式，是一种使用频率非常高的设计模式，在各个语言中都有应用，其主要目的是**提供一种统一的方式来访问一个聚合对象中的各个元素，**而不需要暴露该对象的内部表示。通过迭代器，客户端可以顺序访问聚合对象的元素，而无需了解底层数据结构。\n迭代器模式应用广泛，但是大多数语言都已经内置了迭代器接口，不需要自己实现。\n基本结构 link迭代器模式包括以下几个重要角色\n迭代器接口Iterator：定义访问和遍历元素的接口, 通常会包括hasNext()方法用于检查是否还有下一个元素，以及next()方法用于获取下一个元素。有的还会实现获取第一个元素以及获取当前元素的方法。 具体迭代器ConcreateIterator：实现迭代器接口，实现遍历逻辑对聚合对象进行遍历。 抽象聚合类：定义了创建迭代器的接口，包括一个createIterator方法用于创建一个迭代器对象。 具体聚合类：实现在抽象聚合类中声明的createIterator() 方法，返回一个与具体聚合对应的具体迭代器 简易实现 link 定义迭代器接口：通常会有检查是否还有下一个元素以及获取下一个元素的方法。 // 迭代器接口 public interface Iterator{ // 检查是否还会有下一个元素 boolean hasNext(); // 获取下一个元素 Object next(); } 定义具体迭代器：实现迭代器接口，遍历集合。 public class ConcreteIterator implements Iterator { private int index; private List elements; // 构造函数初始化迭代器 public ConcreteIterator(List elements) { this.elements = elements; this.index = 0; } @Override public boolean hasNext() { return index \u003c elements.size(); } @Override public Object next() { if (hasNext()) { return elements.get(index++); } return null; } } 定义聚合接口：通常包括createIterator()方法，用于创建迭代器 public interface Iterable { Iterator createIterator(); } 实现具体聚合：创建具体的迭代器 // 具体聚合 public class ConcreteIterable implements Iterable { private List elements; // 构造函数初始化可迭代对象 public ConcreteIterable(List elements) { this.elements = elements; } @Override public Iterator createIterator() { return new ConcreteIterator(elements); } } 客户端使用 import java.util.ArrayList; import java.util.List; public class IteratorPatternExample { public static void main(String[] args) { List elements = new ArrayList\u003c\u003e(); elements.add(\"Element 1\"); elements.add(\"Element 2\"); elements.add(\"Element 3\"); Iterable iterable = new ConcreteIterable(elements); Iterator iterator = iterable.createIterator(); while (iterator.hasNext()) { System.out.println(iterator.next()); } } } 使用场景 link迭代器模式是一种通用的设计模式，其封装性强，简化了客户端代码，客户端不需要知道集合的内部结构，只需要关心迭代器和迭代接口就可以完成元素的访问。但是引入迭代器模式会增加额外的类，每增加一个集合类，都需要增加该集合对应的迭代器，这也会使得代码结构变得更加复杂。\n许多编程语言和框架都使用了这个模式提供一致的遍历和访问集合元素的机制。下面是几种常见语言迭代器模式的实现。\nJava语言：集合类（如ArrayList、LinkedList), 通过Iterator接口，可以遍历集合中的元素。 List list = new ArrayList\u003c\u003e(); list.add(\"Item 1\"); list.add(\"Item 2\"); list.add(\"Item 3\"); Iterator iterator = list.iterator(); while (iterator.hasNext()) { System.out.println(iterator.next()); } Python语言：使用迭代器和生成器来实现迭代模式，iter()和next()函数可以用于创建和访问迭代器。 elements = [\"Element 1\", \"Element 2\", \"Element 3\"] iterator = iter(elements) while True: try: element = next(iterator) print(element) except StopIteration: break C++语言：C++中的STL提供了迭代器的支持，begin()和end()函数可以用于获取容器的起始和结束迭代器。 #include #include int main() { std::vector elements = {\"Element 1\", \"Element 2\", \"Element 3\"}; for (auto it = elements.begin(); it != elements.end(); ++it) { std::cout \u003c\u003c *it \u003c\u003c std::endl; } return 0; } JavaScript语言：ES6中新增了迭代器协议，使得遍历和访问集合元素变得更加方便。 script // 可迭代对象实现可迭代协议 class IterableObject { constructor() { this.elements = []; } addElement(element) { this.elements.push(element); } [Symbol.iterator]() { let index = 0; // 迭代器对象实现迭代器协议 return { next: () =\u003e { if (index \u003c this.elements.length) { return { value: this.elements[index++], done: false }; } else { return { done: true }; } } }; } } // 使用迭代器遍历可迭代对象 const iterableObject = new IterableObject(); iterableObject.addElement(\"Element 1\"); iterableObject.addElement(\"Element 2\"); iterableObject.addElement(\"Element 3\"); for (const element of iterableObject) { console.log(element); } 本题代码 link import java.util.ArrayList; import java.util.List; import java.util.Scanner; // 可迭代对象接口 interface StudentCollection { java.util.Iterator iterator(); } // 具体可迭代对象 class ConcreteStudentCollection implements StudentCollection { private List students = new ArrayList\u003c\u003e(); public void addStudent(Student student) { students.add(student); } @Override public java.util.Iterator iterator() { return new ConcreteStudentIterator(students); } } // 迭代器接口 interface Iterator { boolean hasNext(); T next(); } // 具体迭代器 class ConcreteStudentIterator implements java.util.Iterator { private List students; private int currentIndex = 0; public ConcreteStudentIterator(List students) { this.students = students; } @Override public boolean hasNext() { return currentIndex \u003c students.size(); } @Override public Student next() { if (hasNext()) { Student student = students.get(currentIndex); currentIndex++; return student; } return null; } } // 学生类 class Student { private String name; private String studentId; public Student(String name, String studentId) { this.name = name; this.studentId = studentId; } public String getName() { return name; } public String getStudentId() { return studentId; } } public class Main { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); // 读取学生数量 int n = scanner.nextInt(); scanner.nextLine(); // 读取换行符 // 创建具体可迭代对象 ConcreteStudentCollection studentCollection = new ConcreteStudentCollection(); // 读取学生信息并添加到集合 for (int i = 0; i \u003c n; i++) { String[] input = scanner.nextLine().split(\" \"); if (input.length == 2) { String name = input[0]; String studentId = input[1]; Student student = new Student(name, studentId); studentCollection.addStudent(student); } else { System.out.println(\"Invalid input\"); return; } } // 使用迭代器遍历学生集合 java.util.Iterator iterator = studentCollection.iterator(); while (iterator.hasNext()) { Student student = iterator.next(); System.out.println(student.getName() + \" \" + student.getStudentId()); } } } 其他版本代码 linkJava linkJava 内置的 List 接口的 iterator() 方法实现。 import java.util.*; // 学生类 class Student { String name; String id; Student(String name, String id) { this.name = name; this.id = id; } String getInfo() { return name + \" \" + id; } } // 学生列表系统 class StudentListSystem { private List students = new ArrayList\u003c\u003e(); void addStudent(String name, String id) { students.add(new Student(name, id)); } Iterator iterator() { return students.iterator(); } } public class Main { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); StudentListSystem studentList = new StudentListSystem(); int n = scanner.nextInt(); scanner.nextLine(); for (int i = 0; i \u003c n; i++) { String[] s = scanner.nextLine().split(\" \"); studentList.addStudent(s[0], s[1]); } Iterator iterator = studentList.iterator(); while (iterator.hasNext()) { Student student = iterator.next(); System.out.println(student.getInfo()); } scanner.close(); } } C++ link #include #include // 学生类 class Student { public: Student(const std::string\u0026 name, const std::string\u0026 studentId) : name(name), studentId(studentId) {} std::string getName() const { return name; } std::string getStudentId() const { return studentId; } private: std::string name; std::string studentId; }; // 可迭代对象接口 class StudentCollection { public: virtual ~StudentCollection() = default; virtual std::vector::iterator begin() = 0; virtual std::vector::iterator end() = 0; }; // 具体可迭代对象 class ConcreteStudentCollection : public StudentCollection { public: void addStudent(const Student\u0026 student) { students.push_back(student); } std::vector::iterator begin() override { return students.begin(); } std::vector::iterator end() override { return students.end(); } private: std::vector students; }; int main() { int n; std::cin \u003e\u003e n; std::cin.ignore(); // 忽略换行符 ConcreteStudentCollection studentCollection; for (int i = 0; i \u003c n; ++i) { std::string name, studentId; std::cin \u003e\u003e name \u003e\u003e studentId; studentCollection.addStudent(Student(name, studentId)); } // 使用迭代器遍历学生集合 for (auto it = studentCollection.begin(); it != studentCollection.end(); ++it) { const Student\u0026 student = *it; std::cout \u003c\u003c student.getName() \u003c\u003c \" \" \u003c\u003c student.getStudentId() \u003c\u003c std::endl; } return 0; } Python link class Student: def __init__(self, name, student_id): self.name = name self.student_id = student_id def get_name(self): return self.name def get_student_id(self): return self.student_id class StudentCollection: def __init__(self): self.students = [] def add_student(self, student): self.students.append(student) def __iter__(self): return iter(self.students) def main(): n = int(input()) student_collection = StudentCollection() for _ in range(n): inputs = input().split() if len(inputs) == 2: name, student_id = inputs student = Student(name, student_id) student_collection.add_student(student) else: print(\"Invalid input\") return # 使用迭代器遍历学生集合 for student in student_collection: print(student.get_name(), student.get_student_id()) if __name__ == \"__main__\": main() Go link package main import ( \"fmt\" \"bufio\" \"os\" \"strings\" ) // 可迭代对象接口 type StudentCollection interface { Iterator() Iterator } // 具体可迭代对象 type ConcreteStudentCollection struct { students []Student } func NewConcreteStudentCollection() *ConcreteStudentCollection { return \u0026ConcreteStudentCollection{ students: make([]Student, 0), } } func (c *ConcreteStudentCollection) AddStudent(student Student) { c.students = append(c.students, student) } func (c *ConcreteStudentCollection) Iterator() Iterator { return NewConcreteStudentIterator(c.students) } // 迭代器接口 type Iterator interface { HasNext() bool Next() Student } // 具体迭代器 type ConcreteStudentIterator struct { students []Student currentIndex int } func NewConcreteStudentIterator(students []Student) *ConcreteStudentIterator { return \u0026ConcreteStudentIterator{ students: students, currentIndex: 0, } } func (i *ConcreteStudentIterator) HasNext() bool { return i.currentIndex \u003c len(i.students) } func (i *ConcreteStudentIterator) Next() Student { if i.HasNext() { student := i.students[i.currentIndex] i.currentIndex++ return student } return Student{} } // 学生类 type Student struct { Name string StudentID string } // 主函数 func main() { scanner := bufio.NewScanner(os.Stdin) // 读取学生数量 scanner.Scan() n := 0 fmt.Sscanf(scanner.Text(), \"%d\", \u0026n) // 创建具体可迭代对象 studentCollection := NewConcreteStudentCollection() // 读取学生信息并添加到集合 for i := 0; i \u003c n; i++ { scanner.Scan() input := strings.Fields(scanner.Text()) if len(input) == 2 { name := input[0] studentID := input[1] student := Student{Name: name, StudentID: studentID} studentCollection.AddStudent(student) } else { fmt.Println(\"Invalid input\") return } } // 使用迭代器遍历学生集合 iterator := studentCollection.Iterator() for iterator.HasNext() { student := iterator.Next() fmt.Printf(\"%s %s\\n\", student.Name, student.StudentID) } } "
            }
        );
    index.add(
            {
                id:  33 ,
                href: "\/docs\/dev\/23designpattern\/20.%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F\/",
                title: "20.状态模式",
                description: "状态模式（State Pattern）是一种行为型设计模式，它适用于一个对象在在不同的状态下有不同的行为时，比如说电灯的开、关、闪烁是不停的状态，状态不同时，对应的行为也不同，在没有状态模式的情况下，为了添加新的状态或修改现有的状态，往往**需要修改已有的代码**，这违背了开闭原则，而且如果对象的状态切换逻辑和各个状态的行为都在同一个类中实现，就可能导致该类的职责过重，不符合单一职责原则。",
                content: "需求 link【设计模式专题之状态模式】20-开关台灯\n题目描述\n小明家有一个灯泡，刚开始为关闭状态（OffState）。台灯可以接收一系列的指令，包括打开（“ON”）、关闭（“OFF”）和闪烁（“blink”）。每次接收到一个指令后，台灯会执行相应的操作，并输出当前灯泡的状态。请设计一个程序模拟这个灯泡系统。 输入描述\n第一行是一个整数 n（1 \u003c= n \u003c= 1000），表示接收的命令数量。 接下来的 n 行，每行包含一个字符串 s，表示一个命令（“ON”、“OFF\"或\"blink”）。 输出描述\n对于每个命令，输出一行，表示执行该命令后灯泡的状态。 输入示例 5 ON OFF BLINK OFF ON 输出示例 Light is ON Light is OFF Light is Blinking Light is OFF Light is ON 基本结构 link状态模式（State Pattern）是一种行为型设计模式，它适用于一个对象在在不同的状态下有不同的行为时，比如说电灯的开、关、闪烁是不停的状态，状态不同时，对应的行为也不同，在没有状态模式的情况下，为了添加新的状态或修改现有的状态，往往需要修改已有的代码，这违背了开闭原则，而且如果对象的状态切换逻辑和各个状态的行为都在同一个类中实现，就可能导致该类的职责过重，不符合单一职责原则。\n而状态模式将每个状态的行为封装在一个具体状态类中，使得每个状态类相对独立，并将对象在不同状态下的行为进行委托，从而使得对象的状态可以在运行时动态改变，每个状态的实现也不会影响其他状态。\n基本结构： link状态模式包括以下几个重要角色：\nState（状态）： 定义一个接口，用于封装与Context的一个特定状态相关的行为。\nConcreteState（具体状态）： 负责处理Context在状态改变时的行为, 每一个具体状态子类实现一个与Context的一个状态相关的行为。\nContext（上下文）: 维护一个具体状态子类的实例，这个实例定义当前的状态。\n基本使用 link 定义状态接口：创建一个状态接口，该接口声明了对象可能的各种状态对应的方法。 // 状态接口 public interface State { void handle(); } 实现具体状态类： 为对象可能的每种状态创建具体的状态类，实现状态接口中定义的方法。 // 具体状态类1 public class ConcreteState1 implements State { @Override public void handle() { // 执行在状态1下的操作 } } // 具体状态类2 public class ConcreteState2 implements State { @Override public void handle() { // 执行在状态2下的操作 } } 创建上下文类：该类包含对状态的引用，并在需要时调用当前状态的方法。 // 上下文类 public class Context { private State currentState; public void setState(State state) { this.currentState = state; } public void request() { currentState.handle(); } } 客户端使用：创建具体的状态对象和上下文对象，并通过上下文对象调用相应的方法。通过改变状态，可以改变上下文对象的行为 public class Client { public static void main(String[] args) { Context context = new Context(); State state1 = new ConcreteState1(); State state2 = new ConcreteState2(); context.setState(state1); context.request(); // 执行在状态1下的操作 context.setState(state2); context.request(); // 执行在状态2下的操作 } } 使用场景 link状态模式将每个状态的实现都封装在一个类中，每个状态类的实现相对独立，使得添加新状态或修改现有状态变得更加容易，避免了使用大量的条件语句来控制对象的行为。但是如果状态过多，会导致类的数量增加，可能会使得代码结构复杂。\n总的来说，状态模式适用于有限状态机的场景，其中对象的行为在运行时可以根据内部状态的改变而改变，在游戏开发中，Unity3D 的 Animator 控制器就是一个状态机。它允许开发人员定义不同的状态（动画状态），并通过状态转换来实现角色的动画控制和行为切换。\n本题代码 link import java.util.Scanner; // 状态接口 interface State { String handle(); // // 处理状态的方法 } // 具体状态类 class OnState implements State { @Override public String handle() { return \"Light is ON\"; } } class OffState implements State { @Override public String handle() { return \"Light is OFF\"; } } class BlinkState implements State { @Override public String handle() { return \"Light is Blinking\"; } } // 上下文类 class Light { private State state; // 当前状态 public Light() { this.state = new OffState(); // 初始状态为关闭 } public void setState(State state) { // 设置新的状态 this.state = state; } public String performOperation() { // 执行当前状态的操作 return state.handle(); } } public class Main { public static void main(String[] args) { // 创建一个Scanner对象以读取用户输入 Scanner scanner = new Scanner(System.in); int n = scanner.nextInt(); scanner.nextLine(); Light light = new Light(); // 处理用户输入 for (int i = 0; i \u003c n; i++) { String command = scanner.nextLine().trim(); // 根据输入修改灯的状态 switch (command) { case \"ON\": light.setState(new OnState()); break; case \"OFF\": light.setState(new OffState()); break; case \"BLINK\": light.setState(new BlinkState()); break; default: System.out.println(\"Invalid command: \" + command); break; } // 显示灯的当前状态 System.out.println(light.performOperation()); } } } 其他语言版本 linkC++ link #include #include #include // 状态接口 class State { public: virtual std::string handle() = 0; // 处理状态的方法 }; // 具体状态类 class OnState : public State { public: std::string handle() override { return \"Light is ON\"; } }; class OffState : public State { public: std::string handle() override { return \"Light is OFF\"; } }; class BlinkState : public State { public: std::string handle() override { return \"Light is Blinking\"; } }; // 上下文类 class Light { private: State* state; // 当前状态 public: Light() : state(new OffState()) {} // 初始状态为关闭 void setState(State* newState) { // 设置新的状态 delete state; // 释放之前的状态对象 state = newState; } std::string performOperation() { // 执行当前状态的操作 return state-\u003ehandle(); } ~Light() { delete state; // 释放内存 } }; int main() { // 读取要输入的命令数量 int n; std::cin \u003e\u003e n; std::cin.ignore(); // 消耗掉整数后的换行符 // 创建一个Light对象 Light light; // 处理用户输入的每个命令 for (int i = 0; i \u003c n; i++) { // 读取命令并去掉首尾空白字符 std::string command; std::getline(std::cin, command); // 根据命令执行相应的操作 if (command == \"ON\") { light.setState(new OnState()); } else if (command == \"OFF\") { light.setState(new OffState()); } else if (command == \"BLINK\") { light.setState(new BlinkState()); } else { // 处理无效命令 std::cout \u003c\u003c \"Invalid command: \" \u003c\u003c command \u003c\u003c std::endl; } // 在每个命令后显示灯的当前状态 std::cout \u003c\u003c light.performOperation() \u003c\u003c std::endl; } return 0; } Python link # 状态接口 class State: def handle(self): pass # 具体状态类 class OnState(State): def handle(self): return \"Light is ON\" class OffState(State): def handle(self): return \"Light is OFF\" class BlinkState(State): def handle(self): return \"Light is Blinking\" # 上下文类 class Light: def __init__(self): self.state = OffState() # 初始状态为关闭 def set_state(self, new_state): self.state = new_state # 设置新的状态 def perform_operation(self): return self.state.handle() # 执行当前状态的操作 # 处理用户输入 def main(): # 读取要输入的命令数量 n = int(input().strip()) # 创建一个Light对象 light = Light() # 处理用户输入的每个命令 for _ in range(n): # 读取命令并去掉首尾空白字符 command = input().strip() # 根据命令执行相应的操作 if command == \"ON\": light.set_state(OnState()) elif command == \"OFF\": light.set_state(OffState()) elif command == \"BLINK\": light.set_state(BlinkState()) else: # 处理无效命令 print(\"Invalid command:\", command) # 在每个命令后显示灯的当前状态 print(light.perform_operation()) if __name__ == \"__main__\": main() Go link package main import ( \"fmt\" \"bufio\" \"os\" \"strings\" ) // 状态接口 type State interface { Handle() string // 处理状态的方法 } // 具体状态类 type OnState struct{} func (s *OnState) Handle() string { return \"Light is ON\" } type OffState struct{} func (s *OffState) Handle() string { return \"Light is OFF\" } type BlinkState struct{} func (s *BlinkState) Handle() string { return \"Light is Blinking\" } // 上下文类 type Light struct { state State // 当前状态 } func NewLight() *Light { return \u0026Light{state: \u0026OffState{}} // 初始状态为关闭 } func (l *Light) SetState(state State) { // 设置新的状态 l.state = state } func (l *Light) PerformOperation() string { // 执行当前状态的操作 return l.state.Handle() } // 主函数 func main() { scanner := bufio.NewScanner(os.Stdin) // 读取用户输入 scanner.Scan() var n int fmt.Sscanf(scanner.Text(), \"%d\", \u0026n) light := NewLight() // 处理用户输入 for i := 0; i \u003c n; i++ { scanner.Scan() command := strings.TrimSpace(scanner.Text()) // 根据输入修改灯的状态 switch command { case \"ON\": light.SetState(\u0026OnState{}) case \"OFF\": light.SetState(\u0026OffState{}) case \"BLINK\": light.SetState(\u0026BlinkState{}) default: fmt.Println(\"Invalid command:\", command) continue } // 显示灯的当前状态 fmt.Println(light.PerformOperation()) } } "
            }
        );
    index.add(
            {
                id:  34 ,
                href: "\/docs\/dev\/23designpattern\/21.%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F\/",
                title: "21.责任链模式",
                description: "责任链模式是一种行为型设计模式，它允许你构建一个对象链，让请求从链的一端进入，然后沿着链上的对象依次处理，直到链上的某个对象能够处理该请求为止。",
                content: "需求 link【设计模式专题之责任链模式】21-请假审批\n题目描述\n小明所在的公司请假需要在OA系统上发布申请，整个请求流程包括多个处理者，每个处理者负责处理不同范围的请假天数，如果一个处理者不能处理请求，就会将请求传递给下一个处理者，请你实现责任链模式，可以根据请求天数找到对应的处理者。 审批责任链由主管(Supervisor), 经理(Manager)和董事（Director)组成，他们分别能够处理3天、7天和10天的请假天数。如果超过10天，则进行否决。 输入描述\n第一行是一个整数N（1 \u003c= N \u003c= 100), 表示请求申请的数量。 接下来的N行，每行包括一个请求申请的信息，格式为\"姓名 请假天数\" 输出描述\n对于每个请假请求，输出一行，表示该请求是否被批准。如果被批准/否决，输出被哪一个职级的人批准/否决。 输入示例 4 Alice 2 Bob 5 Tom 10 Jerry 12 输出示例 Alice Approved by Supervisor. Bob Approved by Manager. Tom Approved by Director. Jerry Denied by Director. 基本概念 link责任链模式是一种行为型设计模式，它允许你构建一个对象链，让请求从链的一端进入，然后沿着链上的对象依次处理，直到链上的某个对象能够处理该请求为止。\n职责链上的处理者就是一个对象，可以对请求进行处理或者将请求转发给下一个节点，这个场景在生活中很常见，就是一个逐层向上递交的过程，最终的请求要么被处理者所处理，要么处理不了，这也因此可能导致请求无法被处理。\n组成结构 link责任链模式包括以下几个基本结构：\n处理者Handler ：定义一个处理请求的接口，包含一个处理请求的抽象方法和一个指向下一个处理者的链接。 具体处理者ConcreteHandler: 实现处理请求的方法，并判断能否处理请求，如果能够处理请求则进行处理，否则将请求传递给下一个处理者。 客户端：创建并组装处理者对象链，并将请求发送到链上的第一个处理者。 简易实现 link 处理者：定义处理请求的接口 interface Handler { // 处理请求的方法 void handleRequest(double amount); // 设置下一个处理者的方法 void setNextHandler(Handler nextHandler); } 具体处理者：实现处理请求 class ConcreteHandler implements Handler { private Handler nextHandler; @Override public void handleRequest(Request request) { // 根据具体情况处理请求，如果无法处理则交给下一个处理者 if (canHandle(request)) { // 处理请求的逻辑 } else if (nextHandler != null) { // 交给下一个处理者处理 nextHandler.handleRequest(request); } else { // 无法处理请求的逻辑 } } @Override public void setNextHandler(Handler nextHandler) { this.nextHandler = nextHandler; } // 具体处理者自己的判断条件 private boolean canHandle(Request request) { // 根据具体情况判断是否能够处理请求 return /* 判断条件 */; } } 客户端创建并组装处理者对象链，将请求发送给链上第一个处理者 public class Main { public static void main(String[] args) { // 创建处理者实例 Handler handler1 = new ConcreteHandler(); Handler handler2 = new ConcreteHandler(); // ... // 构建责任链 handler1.setNextHandler(handler2); // ... // 发送请求 Request request = new Request(/* 请求参数 */); handler1.handleRequest(request); } } 使用场景 link责任链模式具有下面几个优点：\n降低耦合度：将请求的发送者和接收者解耦，每个具体处理者都只负责处理与自己相关的请求，客户端不需要知道具体是哪个处理者处理请求。 增强灵活性：可以动态地添加或删除处理者，改变处理者之间的顺序以满足不同需求。 但是由于一个请求可能会经过多个处理者，这可能会导致一些性能问题，并且如果整个链上也没有合适的处理者来处理请求，就会导致请求无法被处理。\n责任链模式是设计模式中简单且常见的设计模式，在日常中也会经常使用到，比如Java开发中过滤器的链式处理，以及Spring框架中的拦截器，都组装成一个处理链对请求、响应进行处理。\n本题代码 link import java.util.Scanner; // 处理者：定义接口 interface LeaveHandler { void handleRequest(LeaveRequest request); } // 具体处理者：可以有多个，负责具体处理，这里分为 Supervisor、Manager、Director class Supervisor implements LeaveHandler { private static final int MAX_DAYS_SUPERVISOR_CAN_APPROVE = 3; private LeaveHandler nextHandler; public Supervisor(LeaveHandler nextHandler) { this.nextHandler = nextHandler; } @Override public void handleRequest(LeaveRequest request) { if (request.getDays() \u003c= MAX_DAYS_SUPERVISOR_CAN_APPROVE) { System.out.println(request.getName() + \" Approved by Supervisor.\"); } else if (nextHandler != null) { nextHandler.handleRequest(request); } else { System.out.println(request.getName() + \" Denied by Supervisor.\"); } } } class Manager implements LeaveHandler { private static final int MAX_DAYS_MANAGER_CAN_APPROVE = 7; private LeaveHandler nextHandler; public Manager(LeaveHandler nextHandler) { this.nextHandler = nextHandler; } @Override public void handleRequest(LeaveRequest request) { if (request.getDays() \u003c= MAX_DAYS_MANAGER_CAN_APPROVE) { System.out.println(request.getName() + \" Approved by Manager.\"); } else if (nextHandler != null) { nextHandler.handleRequest(request); } else { System.out.println(request.getName() + \" Denied by Manager.\"); } } } class Director implements LeaveHandler { private static final int MAX_DAYS_DIRECTOR_CAN_APPROVE = 10; @Override public void handleRequest(LeaveRequest request) { if (request.getDays() \u003c= MAX_DAYS_DIRECTOR_CAN_APPROVE) { System.out.println(request.getName() + \" Approved by Director.\"); } else { System.out.println(request.getName() + \" Denied by Director.\"); } } } // 请求类 class LeaveRequest { private String name; private int days; public LeaveRequest(String name, int days) { this.name = name; this.days = days; } public String getName() { return name; } public int getDays() { return days; } } public class Main { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); int n = scanner.nextInt(); scanner.nextLine(); // 组装职责链 LeaveHandler director = new Director(); LeaveHandler manager = new Manager(director); LeaveHandler supervisor = new Supervisor(manager); for (int i = 0; i \u003c n; i++) { String[] input = scanner.nextLine().split(\" \"); if (input.length == 2) { String name = input[0]; int days = Integer.parseInt(input[1]); LeaveRequest request = new LeaveRequest(name, days); supervisor.handleRequest(request); } else { System.out.println(\"Invalid input\"); return; } } } } 其他语言版本 linkJava link使用枚举封装了请求级别的逻辑，方便未来的修改和扩展。\nimport java.util.Scanner; // 抽象处理器类，定义了责任链的基本结构 abstract class Handler { public final static int SUPERVISOR_LEVEL_REQUEST = 1; public final static int MANAGER_LEVEL_REQUEST = 2; public final static int DIRECTOR_LEVEL_REQUEST = 3; private Handler nextHandler; private int level = 0; // 构造函数，设置处理器的级别 public Handler(int _level) { this.level = _level; } // 处理请求的方法 public final Response handleMessage(Request request) { if (this.level == request.getRequestLevel()) { return this.response(request); } else { if (this.nextHandler != null) { return this.nextHandler.handleMessage(request); } else { return new Response(\"Request denied\"); } } } // 设置下一个处理器 public void setNext(Handler _handler) { this.nextHandler = _handler; } protected abstract Response response(Request request); } // 主管处理 class SupervisorHandler extends Handler { public SupervisorHandler() { super(Handler.SUPERVISOR_LEVEL_REQUEST); } @Override protected Response response(Request request) { System.out.println(request.getName() + \" Approved by Supervisor.\"); return new Response(\"Approved by Supervisor\"); } } // 经理处理 class ManagerHandler extends Handler { public ManagerHandler() { super(Handler.MANAGER_LEVEL_REQUEST); } @Override protected Response response(Request request) { System.out.println(request.getName() + \" Approved by Manager.\"); return new Response(\"Approved by Manager\"); } } // 董事处理 class DirectorHandler extends Handler { public DirectorHandler() { super(Handler.DIRECTOR_LEVEL_REQUEST); } @Override protected Response response(Request request) { System.out.println(request.getName() + \" Approved by Director.\"); return new Response(\"Approved by Director\"); } } // 请求级别的枚举，定义了不同级别的请假天数范围 enum RequestLevel { SUPERVISOR(1, 3), MANAGER(4, 5), DIRECTOR(6, 10); private final int minDays; private final int maxDays; RequestLevel(int minDays, int maxDays) { this.minDays = minDays; this.maxDays = maxDays; } // 根据天数确定请求级别 public static RequestLevel fromDays(int days) { for (RequestLevel level : values()) { if (days \u003e= level.minDays \u0026\u0026 days \u003c= level.maxDays) { return level; } } return null; } public int getValue() { return ordinal() + 1; } } // 请求类，包含请求的详细信息 class Request { private String name; private int level; private int nums; public Request(String name, int nums) { this.name = name; this.nums = nums; RequestLevel requestLevel = RequestLevel.fromDays(nums); this.level = (requestLevel != null) ? requestLevel.getValue() : -1; } public int getRequestLevel() { return this.level; } public String getName() { return this.name; } public int getNums() { return this.nums; } } // 响应类，包含处理结果 class Response { private String message; public Response(String message) { this.message = message; } public String getMessage() { return this.message; } } // 主类 public class Main { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); // 创建处理器链 SupervisorHandler supervisorHandler = new SupervisorHandler(); ManagerHandler managerHandler = new ManagerHandler(); DirectorHandler directorHandler = new DirectorHandler(); // 设置处理器链的顺序 supervisorHandler.setNext(managerHandler); managerHandler.setNext(directorHandler); int n = scanner.nextInt(); scanner.nextLine(); // 处理每个请求 while (n-- \u003e 0) { String[] s = scanner.nextLine().split(\" \"); Request request = new Request(s[0], Integer.parseInt(s[1])); Response response = supervisorHandler.handleMessage(request); if (request.getRequestLevel() == -1) { System.out.println(request.getName() + \" Denied by Director.\"); } } scanner.close(); } } C++ link #include #include class LeaveHandler { public: virtual void handleRequest(const std::string\u0026 name, int days) = 0; }; class Supervisor : public LeaveHandler { private: static const int MAX_DAYS_SUPERVISOR_CAN_APPROVE = 3; LeaveHandler* nextHandler; public: Supervisor(LeaveHandler* nextHandler) : nextHandler(nextHandler) {} void handleRequest(const std::string\u0026 name, int days) override { if (days \u003c= MAX_DAYS_SUPERVISOR_CAN_APPROVE) { std::cout \u003c\u003c name \u003c\u003c \" Approved by Supervisor.\" \u003c\u003c std::endl; } else if (nextHandler != nullptr) { nextHandler-\u003ehandleRequest(name, days); } else { std::cout \u003c\u003c name \u003c\u003c \" Denied by Supervisor.\" \u003c\u003c std::endl; } } }; class Manager : public LeaveHandler { private: static const int MAX_DAYS_MANAGER_CAN_APPROVE = 7; LeaveHandler* nextHandler; public: Manager(LeaveHandler* nextHandler) : nextHandler(nextHandler) {} void handleRequest(const std::string\u0026 name, int days) override { if (days \u003c= MAX_DAYS_MANAGER_CAN_APPROVE) { std::cout \u003c\u003c name \u003c\u003c \" Approved by Manager.\" \u003c\u003c std::endl; } else if (nextHandler != nullptr) { nextHandler-\u003ehandleRequest(name, days); } else { std::cout \u003c\u003c name \u003c\u003c \" Denied by Manager.\" \u003c\u003c std::endl; } } }; class Director : public LeaveHandler { private: static const int MAX_DAYS_DIRECTOR_CAN_APPROVE = 10; public: void handleRequest(const std::string\u0026 name, int days) override { if (days \u003c= MAX_DAYS_DIRECTOR_CAN_APPROVE) { std::cout \u003c\u003c name \u003c\u003c \" Approved by Director.\" \u003c\u003c std::endl; } else { std::cout \u003c\u003c name \u003c\u003c \" Denied by Director.\" \u003c\u003c std::endl; } } }; class LeaveRequest { private: std::string name; int days; public: LeaveRequest(const std::string\u0026 name, int days) : name(name), days(days) {} std::string getName() const { return name; } int getDays() const { return days; } }; int main() { int n; std::cin \u003e\u003e n; std::cin.ignore(); LeaveHandler* director = new Director(); LeaveHandler* manager = new Manager(director); LeaveHandler* supervisor = new Supervisor(manager); for (int i = 0; i \u003c n; i++) { std::string input; std::getline(std::cin, input); std::istringstream iss(input); std::string name; int days; if (iss \u003e\u003e name \u003e\u003e days) { LeaveRequest request(name, days); supervisor-\u003ehandleRequest(name, days); } else { std::cout \u003c\u003c \"Invalid input\" \u003c\u003c std::endl; return 1; } } delete supervisor; delete manager; delete director; return 0; } Python link class LeaveHandler: def handle_request(self, name, days): pass class Supervisor(LeaveHandler): MAX_DAYS_SUPERVISOR_CAN_APPROVE = 3 def __init__(self, next_handler=None): self.next_handler = next_handler def handle_request(self, name, days): if days \u003c= self.MAX_DAYS_SUPERVISOR_CAN_APPROVE: print(f\"{name} Approved by Supervisor.\") elif self.next_handler: self.next_handler.handle_request(name, days) else: print(f\"{name} Denied by Supervisor.\") class Manager(LeaveHandler): MAX_DAYS_MANAGER_CAN_APPROVE = 7 def __init__(self, next_handler=None): self.next_handler = next_handler def handle_request(self, name, days): if days \u003c= self.MAX_DAYS_MANAGER_CAN_APPROVE: print(f\"{name} Approved by Manager.\") elif self.next_handler: self.next_handler.handle_request(name, days) else: print(f\"{name} Denied by Manager.\") class Director(LeaveHandler): MAX_DAYS_DIRECTOR_CAN_APPROVE = 10 def handle_request(self, name, days): if days \u003c= self.MAX_DAYS_DIRECTOR_CAN_APPROVE: print(f\"{name} Approved by Director.\") else: print(f\"{name} Denied by Director.\") class LeaveRequest: def __init__(self, name, days): self.name = name self.days = days def get_name(self): return self.name def get_days(self): return self.days if __name__ == \"__main__\": n = int(input()) director = Director() manager = Manager(director) supervisor = Supervisor(manager) for _ in range(n): input_data = input().split() if len(input_data) == 2: name, days = input_data days = int(days) request = LeaveRequest(name, days) supervisor.handle_request(name, days) else: print(\"Invalid input\") exit(1) Go link package main import ( \"fmt\" \"bufio\" \"os\" \"strconv\" \"strings\" ) // 处理者：定义接口 type LeaveHandler interface { HandleRequest(request LeaveRequest) } // 具体处理者：可以有多个，负责具体处理，这里分为 Supervisor、Manager、Director type Supervisor struct { nextHandler LeaveHandler } const maxDaysSupervisorCanApprove = 3 func NewSupervisor(nextHandler LeaveHandler) *Supervisor { return \u0026Supervisor{nextHandler: nextHandler} } func (s *Supervisor) HandleRequest(request LeaveRequest) { if request.Days \u003c= maxDaysSupervisorCanApprove { fmt.Println(request.Name + \" Approved by Supervisor.\") } else if s.nextHandler != nil { s.nextHandler.HandleRequest(request) } else { fmt.Println(request.Name + \" Denied by Supervisor.\") } } type Manager struct { nextHandler LeaveHandler } const maxDaysManagerCanApprove = 7 func NewManager(nextHandler LeaveHandler) *Manager { return \u0026Manager{nextHandler: nextHandler} } func (m *Manager) HandleRequest(request LeaveRequest) { if request.Days \u003c= maxDaysManagerCanApprove { fmt.Println(request.Name + \" Approved by Manager.\") } else if m.nextHandler != nil { m.nextHandler.HandleRequest(request) } else { fmt.Println(request.Name + \" Denied by Manager.\") } } type Director struct{} const maxDaysDirectorCanApprove = 10 func (d *Director) HandleRequest(request LeaveRequest) { if request.Days \u003c= maxDaysDirectorCanApprove { fmt.Println(request.Name + \" Approved by Director.\") } else { fmt.Println(request.Name + \" Denied by Director.\") } } // 请求类 type LeaveRequest struct { Name string Days int } // 主函数 func main() { scanner := bufio.NewScanner(os.Stdin) // 读取用户输入 scanner.Scan() var n int fmt.Sscanf(scanner.Text(), \"%d\", \u0026n) // 组装职责链 director := \u0026Director{} manager := NewManager(director) supervisor := NewSupervisor(manager) for i := 0; i \u003c n; i++ { scanner.Scan() input := strings.Fields(scanner.Text()) if len(input) == 2 { name := input[0] days, err := strconv.Atoi(input[1]) if err != nil { fmt.Println(\"Invalid input\") return } request := LeaveRequest{Name: name, Days: days} supervisor.HandleRequest(request) } else { fmt.Println(\"Invalid input\") return } } } "
            }
        );
    index.add(
            {
                id:  35 ,
                href: "\/docs\/dev\/23designpattern\/22.%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F\/",
                title: "22.解释器模式",
                description: "解释器模式（Interpreter Pattern）是一种行为型设计模式，它定义了一个语言的文法，并且建立一个【解释器】来解释该语言中的句子。",
                content: "需求 link【设计模式专题之解释器模式】22-数学表达式\n题目描述\n小明正在设计一个计算器，用于解释用户输入的简单数学表达式，每个表达式都是由整数、加法操作符+、乘法操作符组成的，表达式中的元素之间用空格分隔，请你使用解释器模式帮他实现这个系统。 输入描述\n每行包含一个数学表达式，表达式中包含整数、加法操作符（+）和乘法操作符（*）。 表达式中的元素之间用空格分隔。 输出描述\n对于每个输入的数学表达式，每行输出一个整数，表示对应表达式的计算结果。 输入示例 2 + 3 5 * 2 3 + 4 * 2 输出示例 5 10 11 基本概念 link解释器模式（Interpreter Pattern）是一种行为型设计模式，它定义了一个语言的文法，并且建立一个【解释器】来解释该语言中的句子。\n比如说SQL语法、正则表达式，这些内容比较简短，但是表达的内容可不仅仅是字面上的那些符号，计算机想要理解这些语法，就需要解释这个语法规则，因此解释器模式常用于实现编程语言解释器、正则表达式处理等场景。\n组成结构 link解释器模式主要包含以下几个角色：\n抽象表达式（Abstract Expression）： 定义了解释器的接口，包含了解释器的方法 interpret。 终结符表达式（Terminal Expression）： 在语法中不能再分解为更小单元的符号。 非终结符表达式（Non-terminal Expression）： 文法中的复杂表达式，它由终结符和其他非终结符组成。 上下文（Context）： 包含解释器之外的一些全局信息，可以存储解释器中间结果，也可以用于向解释器传递信息。 举例来说，表达式 “3 + 5 * 2”，数字 “3” 和 “5”， “2” 是终结符，而运算符 “+”, “*“都需要两个操作数, 属于非终结符。\n简易实现 link 创建抽象表达式接口： 定义解释器的接口，声明一个 interpret 方法，用于解释语言中的表达式。 // 抽象表达式接口 public interface Expression { int interpret(); } 创建具体的表达式类： 实现抽象表达式接口，用于表示语言中的具体表达式。 public class TerminalExpression implements Expression { private int value; public TerminalExpression(int value) { this.value = value; } @Override public int interpret() { return value; } } 非终结符表达式：抽象表达式的一种，用于表示语言中的非终结符表达式，通常包含其他表达式。 public class AddExpression implements Expression { private Expression left; private Expression right; public AddExpression(Expression left, Expression right) { this.left = left; this.right = right; } @Override public int interpret() { return left.interpret() + right.interpret(); } } 上下文：包含解释器需要的一些全局信息或状态。 public class Context { // 可以在上下文中存储一些全局信息或状态 } 客户端：构建并组合表达式，然后解释表达式。 public class Main { public static void main(String[] args) { Context context = new Context(); Expression expression = new AddExpression( new TerminalExpression(1), new TerminalExpression(2) ); int result = expression.interpret(); System.out.println(\"Result: \" + result); } } 使用场景 link当需要解释和执行特定领域或业务规则的语言时，可以使用解释器模式。例如，SQL解释器、正则表达式解释器等。但是需要注意的是解释器模式可能会导致类的层次结构较为复杂，同时也可能不够灵活，使用要慎重。\n本题代码 link import java.util.Scanner; import java.util.Stack; // 抽象表达式接口 interface Expression { int interpret(); } // 终结符表达式类 - 数字 class NumberExpression implements Expression { private int number; public NumberExpression(int number) { this.number = number; } @Override public int interpret() { return number; } } // 非终结符表达式类 - 加法 class AddExpression implements Expression { private Expression left; private Expression right; public AddExpression(Expression left, Expression right) { this.left = left; this.right = right; } @Override public int interpret() { return left.interpret() + right.interpret(); } } // 非终结符表达式类 - 乘法 class MultiplyExpression implements Expression { private Expression left; private Expression right; public MultiplyExpression(Expression left, Expression right) { this.left = left; this.right = right; } @Override public int interpret() { return left.interpret() * right.interpret(); } } // 上下文类 class Context { private Stack expressionStack = new Stack\u003c\u003e(); public void pushExpression(Expression expression) { expressionStack.push(expression); } public Expression popExpression() { return expressionStack.pop(); } } public class Main{ public static void main(String[] args) { Scanner scanner = new Scanner(System.in); Context context = new Context(); // 处理用户输入的数学表达式 while (scanner.hasNextLine()) { String userInput = scanner.nextLine(); Expression expression = parseExpression(userInput); if (expression != null) { context.pushExpression(expression); System.out.println(expression.interpret()); } else { System.out.println(\"Invalid expression.\"); } } scanner.close(); } // 解析用户输入的数学表达式并返回相应的抽象表达式类 private static Expression parseExpression(String userInput) { try { Stack expressionStack = new Stack\u003c\u003e(); char[] tokens = userInput.toCharArray(); for (int i = 0; i \u003c tokens.length; i++) { char token = tokens[i]; if (Character.isDigit(token)) { expressionStack.push(new NumberExpression(Character.getNumericValue(token))); // 如果下一个字符不是数字，且栈中有两个以上的元素，说明可以进行运算 if (i + 1 \u003c tokens.length \u0026\u0026 !Character.isDigit(tokens[i + 1]) \u0026\u0026 expressionStack.size() \u003e= 2) { Expression right = expressionStack.pop(); Expression left = expressionStack.pop(); char operator = tokens[i + 1]; if (operator == '+') { expressionStack.push(new AddExpression(left, right)); } else if (operator == '*') { expressionStack.push(new MultiplyExpression(left, right)); } i++; // 跳过下一个字符，因为已经处理过了 } } else { return null; } } return expressionStack.pop(); } catch (Exception e) { return null; } } } 其他语言版本 linkC++ link #include #include #include #include #include #include #include // 抽象表达式类 class Expression { public: virtual int interpret() = 0; virtual ~Expression() {} }; // 终结符表达式类 - 数字 class NumberExpression : public Expression { private: int value; public: NumberExpression(int val) : value(val) {} int interpret() override { return value; } }; // 非终结符表达式类 - 加法操作 class AddExpression : public Expression { private: Expression* left; Expression* right; public: AddExpression(Expression* l, Expression* r) : left(l), right(r) {} int interpret() override { return left-\u003einterpret() + right-\u003einterpret(); } }; // 非终结符表达式类 - 乘法操作 class MultiplyExpression : public Expression { private: Expression* left; Expression* right; public: MultiplyExpression(Expression* l, Expression* r) : left(l), right(r) {} int interpret() override { return left-\u003einterpret() * right-\u003einterpret(); } }; // 非终结符表达式类 - 操作符 class OperatorExpression : public Expression { private: std::string oper; public: OperatorExpression(const std::string\u0026 op) : oper(op) {} int interpret() override { throw std::runtime_error(\"OperatorExpression does not support interpretation\"); } std::string getOperator() const { return oper; } }; // 解析表达式字符串 int parseExpression(const std::string\u0026 expressionStr) { std::istringstream iss(expressionStr); std::vector elements(std::istream_iterator{iss}, std::istream_iterator()); std::stack stack; for (const auto\u0026 element : elements) { if (std::regex_match(element, std::regex(\"\\\\d+\"))) { stack.push(new NumberExpression(std::stoi(element))); } else if (element == \"+\" || element == \"*\") { stack.push(new OperatorExpression(element)); } else { throw std::invalid_argument(\"Invalid element in expression: \" + element); } } while (stack.size() \u003e 1) { Expression* right = stack.top(); stack.pop(); Expression* operatorExp = stack.top(); stack.pop(); Expression* left = stack.top(); stack.pop(); if (auto* opExp = dynamic_cast(operatorExp)) { std::string op = opExp-\u003egetOperator(); if (op == \"+\") { stack.push(new AddExpression(left, right)); } else if (op == \"*\") { stack.push(new MultiplyExpression(left, right)); } } else { throw std::invalid_argument(\"Invalid operator type in expression\"); } } int result = stack.top()-\u003einterpret(); delete stack.top(); return result; } int main() { std::vector input_lines; std::string line; while (std::getline(std::cin, line) \u0026\u0026 !line.empty()) { input_lines.push_back(line); } for (size_t i = 0; i \u003c input_lines.size(); ++i) { try { int result = parseExpression(input_lines[i]); std::cout \u003c\u003c result \u003c\u003c std::endl; } catch (const std::exception\u0026 e) { std::cout \u003c\u003c \"Error - \" \u003c\u003c e.what() \u003c\u003c std::endl; } } return 0; } Python link # 抽象表达式类 class Expression: def interpret(self): pass # 终结符表达式类 - 数字 class NumberExpression(Expression): def __init__(self, value): self.value = int(value) def interpret(self): return self.value # 非终结符表达式类 - 加法操作 class AddExpression(Expression): def __init__(self, left, right): self.left = left self.right = right def interpret(self): return self.left.interpret() + self.right.interpret() # 非终结符表达式类 - 乘法操作 class MultiplyExpression(Expression): def __init__(self, left, right): self.left = left self.right = right def interpret(self): return self.left.interpret() * self.right.interpret() # 客户端代码 def parse_expression(expression_str): elements = expression_str.split() stack = [] for element in elements: if element.isdigit(): stack.append(NumberExpression(element)) elif element == '+': if len(stack) \u003c 2: raise ValueError(\"Invalid expression format\") right = stack.pop() left = stack.pop() stack.append(AddExpression(left, right)) elif element == '*': if len(stack) \u003c 2: raise ValueError(\"Invalid expression format\") right = stack.pop() left = stack.pop() stack.append(MultiplyExpression(left, right)) else: raise ValueError(f\"Invalid element in expression: {element}\") if len(stack) != 1: raise ValueError(\"Invalid expression format\") return str(stack.pop().interpret()) # 从标准输入读取输入 input_lines = [] while True: try: line = input().strip() if not line: break input_lines.append(line) except EOFError: break # 输出计算结果到标准输出 for i, input_line in enumerate(input_lines, start=1): try: result = parse_expression(input_line) print(f\"Case {i}: {result}\") except ValueError as e: print(f\"Case {i}: Error - {e}\") Go link package main import ( \"bufio\" \"fmt\" \"os\" \"regexp\" \"strconv\" \"strings\" ) // 抽象表达式类 type Expression interface { interpret() int } // 终结符表达式类 - 数字 type NumberExpression struct { value int } func NewNumberExpression(val int) *NumberExpression { return \u0026NumberExpression{value: val} } func (n *NumberExpression) interpret() int { return n.value } // 非终结符表达式类 - 加法操作 type AddExpression struct { left Expression right Expression } func NewAddExpression(left, right Expression) *AddExpression { return \u0026AddExpression{left, right} } func (a *AddExpression) interpret() int { return a.left.interpret() + a.right.interpret() } // 非终结符表达式类 - 乘法操作 type MultiplyExpression struct { left Expression right Expression } func NewMultiplyExpression(left, right Expression) *MultiplyExpression { return \u0026MultiplyExpression{left, right} } func (m *MultiplyExpression) interpret() int { return m.left.interpret() * m.right.interpret() } // 非终结符表达式类 - 操作符 type OperatorExpression struct { oper string } func NewOperatorExpression(op string) *OperatorExpression { return \u0026OperatorExpression{oper: op} } func (o *OperatorExpression) interpret() int { panic(\"OperatorExpression does not support interpretation\") } func (o *OperatorExpression) getOperator() string { return o.oper } // 解析表达式字符串 func parseExpression(expressionStr string) (int, error) { elements := strings.Fields(expressionStr) stack := make([]Expression, 0) for _, element := range elements { if regexp.MustCompile(`^\\d+$`).MatchString(element) { val, _ := strconv.Atoi(element) stack = append(stack, NewNumberExpression(val)) } else if element == \"+\" || element == \"*\" { stack = append(stack, NewOperatorExpression(element)) } else { return 0, fmt.Errorf(\"Invalid element in expression: %s\", element) } } for len(stack) \u003e 1 { right := stack[len(stack)-1] stack = stack[:len(stack)-1] operatorExp := stack[len(stack)-1] stack = stack[:len(stack)-1] left := stack[len(stack)-1] stack = stack[:len(stack)-1] if opExp, ok := operatorExp.(*OperatorExpression); ok { op := opExp.getOperator() if op == \"+\" { stack = append(stack, NewAddExpression(left, right)) } else if op == \"*\" { stack = append(stack, NewMultiplyExpression(left, right)) } } else { return 0, fmt.Errorf(\"Invalid operator type in expression\") } } result := stack[0].interpret() return result, nil } func main() { scanner := bufio.NewScanner(os.Stdin) for scanner.Scan() { expression := scanner.Text() if expression == \"\" { continue } result, err := parseExpression(expression) if err != nil { fmt.Printf(\"Error - %s\\n\", err) } else { fmt.Println(result) } } if err := scanner.Err(); err != nil { fmt.Println(\"Error reading standard input:\", err) } } "
            }
        );
    index.add(
            {
                id:  36 ,
                href: "\/docs\/dev\/23designpattern\/23.%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F\/",
                title: "23.访问者模式",
                description: "访问者模式（Visitor Pattern）是一种行为型设计模式，可以在不改变对象结构的前提下，对对象中的元素进行新的操作。",
                content: "需求 link【设计模式专题之访问者模式】23-图形的面积\n题目描述\n小明家有一些圆形和长方形面积的土地，请你帮他实现一个访问者模式，使得可以通过访问者计算每块土地的面积。 图形的面积计算规则如下： 圆形的面积计算公式为：3.14 * 半径 * 半径 矩形的面积计算公式为：长 * 宽 输入描述\n第一行是一个整数 n（1 \u003c= n \u003c= 1000），表示图形的数量。 接下来的 n 行，每行描述一个图形，格式为 “Circle r” 或 “Rectangle width height”，其中 r、width、height 是正整数。 输出描述\n对于每个图形，输出一行，表示该图形的面积。 输入示例 3 Circle 5 Rectangle 3 4 Circle 2 输出示例 78.5 12 12.56 基本概念 link访问者模式（Visitor Pattern）是一种行为型设计模式，可以在不改变对象结构的前提下，对对象中的元素进行新的操作。\n举个例子，假设有一个动物园，里面有不同种类的动物，比如狮子、大象、猴子等。每个动物都会被医生检查身体，被管理员投喂，被游客观看，医生，游客，管理员都属于访问者。\n// 定义动物接口 interface Animal { void accept(Visitor visitor); } // 具体元素类：狮子 class Lion implements Element { @Override public void accept(Visitor visitor) { visitor.visit(this); } } // 具体元素类：大象 class Elephant implements Element { @Override public void accept(Visitor visitor) { visitor.visit(this); } } // 具体元素类：猴子 class Monkey implements Element { @Override public void accept(Visitor visitor) { visitor.visit(this); } } 如果你想对动物园中的每个动物执行一些操作，比如医生健康检查、管理员喂食、游客观赏等。就可以使用访问者模式来实现这些操作。\n// 定义访问者接口 interface Visitor { void visit(Animal animal); } // 具体访问者类：医生 class Vet implements Visitor { @Override public void visit(Animal animal) { } } // 具体访问者类：管理员 class Zookeeper implements Visitor { @Override public void visit(Animal animal) { } } // 具体访问者类：游客 class VisitorPerson implements Visitor { @Override public void visit(Animal animal) { } } 将这些访问者应用到动物园的每个动物上\npublic class Main { public static void main(String[] args) { Animal lion = new Lion(); Animal elephant = new Elephant(); Animal monkey = new Monkey(); Visitor vet = new Vet(); Visitor zookeeper = new Zookeeper(); Visitor visitorPerson = new VisitorPerson(); // 动物接受访问者的访问 lion.accept(vet); elephant.accept(zookeeper); monkey.accept(visitorPerson); } } 基本结构： link访问者模式包括以下几个基本角色：\n抽象访问者（Visitor）： 声明了访问者可以访问哪些元素，以及如何访问它们的方法visit。\n具体访问者（ConcreteVisitor）： 实现了抽象访问者定义的方法，不同的元素类型可能有不同的访问行为。医生、管理员、游客都属于具体的访问者，它们的访问行为不同。\n抽象元素（Element）： 定义了一个accept方法，用于接受访问者的访问。\n具体元素（ConcreteElement）： 实现了accept方法，是访问者访问的目标。\n对象结构（Object Structure）： 包含元素的集合，可以是一个列表、一个集合或者其他数据结构。负责遍历元素，并调用元素的接受方法。\n简易实现： link 定义抽象访问者: 声明那些元素可以访问 // 抽象访问者 interface Visitor { void visit(ConcreteElementA element); void visit(ConcreteElementB element); } 实现具体访问者：实现具体的访问逻辑 // 具体访问者A class ConcreteVisitorA implements Visitor { @Override public void visit(ConcreteElementA element) { System.out.println(\"ConcreteVisitorA Visit ConcreteElementA\"); } @Override public void visit(ConcreteElementB element) { System.out.println(\"ConcreteVisitorA Visit ConcreteElementB\"); } } // 具体访问者B class ConcreteVisitorB implements Visitor { @Override public void visit(ConcreteElementA element) { System.out.println(\"ConcreteVisitorB Visit ConcreteElementA\"); } @Override public void visit(ConcreteElementB element) { System.out.println(\"ConcreteVisitorB Visit ConcreteElementB\"); } } 定义元素接口：声明接收访问者的方法。 // 抽象元素 interface Element { void accept(Visitor visitor); } 实现具体元素：实现接受访问者的方法 // 具体元素A class ConcreteElementA implements Element { @Override public void accept(Visitor visitor) { visitor.visit(this); } } // 具体元素B class ConcreteElementB implements Element { @Override public void accept(Visitor visitor) { visitor.visit(this); } } 创建对象结构：提供一个接口让访问者访问它的元素。 // 对象结构 class ObjectStructure { private List elements = new ArrayList\u003c\u003e(); public void attach(Element element) { elements.add(element); } public void detach(Element element) { elements.remove(element); } public void accept(Visitor visitor) { for (Element element : elements) { element.accept(visitor); } } } 客户端调用 public class Main { public static void main(String[] args) { ObjectStructure objectStructure = new ObjectStructure(); objectStructure.attach(new ConcreteElementA()); objectStructure.attach(new ConcreteElementB()); Visitor visitorA = new ConcreteVisitorA(); Visitor visitorB = new ConcreteVisitorB(); objectStructure.accept(visitorA); objectStructure.accept(visitorB); } } 使用场景 link访问者模式结构较为复杂，但是访问者模式将同一类操作封装在一个访问者中，使得相关的操作彼此集中，提高了代码的可读性和维护性。它常用于对象结构比较稳定，但经常需要在此对象结构上定义新的操作，这样就无需修改现有的元素类，只需要定义新的访问者来添加新的操作。\n本题代码 link import java.util.Scanner; // 元素接口 interface Shape { void accept(Visitor visitor); } // 具体元素类 class Circle implements Shape { private int radius; public Circle(int radius) { this.radius = radius; } public int getRadius() { return radius; } @Override public void accept(Visitor visitor) { visitor.visit(this); } } class Rectangle implements Shape { private int width; private int height; public Rectangle(int width, int height) { this.width = width; this.height = height; } public int getWidth() { return width; } public int getHeight() { return height; } @Override public void accept(Visitor visitor) { visitor.visit(this); } } // 访问者接口 interface Visitor { void visit(Circle circle); void visit(Rectangle rectangle); } // 具体访问者类 class AreaCalculator implements Visitor { @Override public void visit(Circle circle) { double area = 3.14 * Math.pow(circle.getRadius(), 2); System.out.println(area); } @Override public void visit(Rectangle rectangle) { int area = rectangle.getWidth() * rectangle.getHeight(); System.out.println(area); } } // 对象结构类 class Drawing { private Shape[] shapes; public Drawing(Shape[] shapes) { this.shapes = shapes; } public void accept(Visitor visitor) { for (Shape shape : shapes) { shape.accept(visitor); } } } public class Main { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); int n = scanner.nextInt(); scanner.nextLine(); // 创建一个数组来存储图形对象 Shape[] shapes = new Shape[n]; // 根据用户输入创建不同类型的图形对象 for (int i = 0; i \u003c n; i++) { String[] input = scanner.nextLine().split(\" \"); if (input[0].equals(\"Circle\")) { int radius = Integer.parseInt(input[1]); shapes[i] = new Circle(radius); } else if (input[0].equals(\"Rectangle\")) { int width = Integer.parseInt(input[1]); int height = Integer.parseInt(input[2]); shapes[i] = new Rectangle(width, height); } else { System.out.println(\"Invalid input\"); return; } } // 创建一个图形集合 Drawing drawing = new Drawing(shapes); // 创建一个面积计算访问者 Visitor areaCalculator = new AreaCalculator(); // 访问图形集合并计算面积 drawing.accept(areaCalculator); } } 其他语言版本 linkC++ link #include #include #include class Shape; // 访问者接口 class Visitor { public: virtual void visit(class Circle\u0026 circle) = 0; virtual void visit(class Rectangle\u0026 rectangle) = 0; }; // 元素接口 class Shape { public: virtual ~Shape() {} // 添加虚析构函数 virtual void accept(Visitor\u0026 visitor) = 0; }; // 具体元素类 class Circle : public Shape { private: int radius; public: Circle(int radius) : radius(radius) {} int getRadius() const { return radius; } void accept(Visitor\u0026 visitor) override; }; // 具体元素类 class Rectangle : public Shape { private: int width; int height; public: Rectangle(int width, int height) : width(width), height(height) {} int getWidth() const { return width; } int getHeight() const { return height; } void accept(Visitor\u0026 visitor) override; }; // 具体访问者类 class AreaCalculator : public Visitor { public: void visit(Circle\u0026 circle) override; void visit(Rectangle\u0026 rectangle) override; }; // 对象结构类 class Drawing { private: std::vector shapes; public: Drawing(const std::vector\u0026 shapes) : shapes(shapes) {} void accept(Visitor\u0026 visitor) { for (Shape* shape : shapes) { shape-\u003eaccept(visitor); } } }; // 实现 accept 函数 void Circle::accept(Visitor\u0026 visitor) { visitor.visit(*this); } void Rectangle::accept(Visitor\u0026 visitor) { visitor.visit(*this); } // 实现 visit 函数 void AreaCalculator::visit(Circle\u0026 circle) { double area = 3.14 * std::pow(circle.getRadius(), 2); std::cout \u003c\u003c area \u003c\u003c std::endl; } void AreaCalculator::visit(Rectangle\u0026 rectangle) { int area = rectangle.getWidth() * rectangle.getHeight(); std::cout \u003c\u003c area \u003c\u003c std::endl; } int main() { int n; std::cin \u003e\u003e n; std::vector shapes; for (int i = 0; i \u003c n; i++) { std::string type; std::cin \u003e\u003e type; if (type == \"Circle\") { int radius; std::cin \u003e\u003e radius; shapes.push_back(new Circle(radius)); } else if (type == \"Rectangle\") { int width, height; std::cin \u003e\u003e width \u003e\u003e height; shapes.push_back(new Rectangle(width, height)); } else { // 处理无效输入 std::cout \u003c\u003c \"Invalid input\" \u003c\u003c std::endl; return 1; } } Drawing drawing(shapes); AreaCalculator areaCalculator; drawing.accept(areaCalculator); // 释放动态分配的内存 for (Shape* shape : shapes) { delete shape; } return 0; } Python link from abc import ABC, abstractmethod # 访问者接口 class Visitor(ABC): @abstractmethod def visit_circle(self, circle): pass @abstractmethod def visit_rectangle(self, rectangle): pass # 元素接口 class Shape(ABC): @abstractmethod def accept(self, visitor): pass # 具体元素类 class Circle(Shape): def __init__(self, radius): self.radius = radius def get_radius(self): return self.radius def accept(self, visitor): visitor.visit_circle(self) # 具体元素类 class Rectangle(Shape): def __init__(self, width, height): self.width = width self.height = height def get_width(self): return self.width def get_height(self): return self.height def accept(self, visitor): visitor.visit_rectangle(self) # 具体访问者类 class AreaCalculator(Visitor): def visit_circle(self, circle): area = 3.14 * circle.get_radius()**2 print(area) def visit_rectangle(self, rectangle): area = rectangle.get_width() * rectangle.get_height() print(area) # 对象结构类 class Drawing: def __init__(self, shapes): self.shapes = shapes def accept(self, visitor): for shape in self.shapes: shape.accept(visitor) # 示例用法 if __name__ == \"__main__\": n = int(input()) shapes = [] for _ in range(n): shape_type, *params = input().split() if shape_type == \"Circle\": radius = int(params[0]) shapes.append(Circle(radius)) elif shape_type == \"Rectangle\": width, height = map(int, params) shapes.append(Rectangle(width, height)) else: print(\"invalid input\") exit(1) drawing = Drawing(shapes) area_calculator = AreaCalculator() drawing.accept(area_calculator) Go link package main import ( \"bufio\" \"fmt\" \"os\" \"math\" \"strconv\" \"strings\" ) // 元素接口 type Shape interface { accept(Visitor) } // 具体元素类 type Circle struct { radius int } func NewCircle(radius int) *Circle { return \u0026Circle{radius} } func (c *Circle) getRadius() int { return c.radius } func (c *Circle) accept(visitor Visitor) { visitor.visit(c) } type Rectangle struct { width, height int } func NewRectangle(width, height int) *Rectangle { return \u0026Rectangle{width, height} } func (r *Rectangle) getWidth() int { return r.width } func (r *Rectangle) getHeight() int { return r.height } func (r *Rectangle) accept(visitor Visitor) { visitor.visit(r) } // 访问者接口 type Visitor interface { visit(shape Shape) } // 具体访问者类 type AreaCalculator struct{} func (ac *AreaCalculator) visit(shape Shape) { switch concreteShape := shape.(type) { case *Circle: area := 3.14 * math.Pow(float64(concreteShape.getRadius()), 2) fmt.Println(area) case *Rectangle: area := concreteShape.getWidth() * concreteShape.getHeight() fmt.Println(area) } } // 对象结构类 type Drawing struct { shapes []Shape } func NewDrawing(shapes []Shape) *Drawing { return \u0026Drawing{shapes} } func (d *Drawing) accept(visitor Visitor) { for _, shape := range d.shapes { shape.accept(visitor) } } func main() { var n int fmt.Scan(\u0026n) shapes := make([]Shape, n) scanner := bufio.NewScanner(os.Stdin) for i := 0; i \u003c n; i++ { scanner.Scan() input := strings.Split(scanner.Text(), \" \") if input[0] == \"Circle\" { radius, _ := strconv.Atoi(input[1]) shapes[i] = NewCircle(radius) } else if input[0] == \"Rectangle\" { width, _ := strconv.Atoi(input[1]) height, _ := strconv.Atoi(input[2]) shapes[i] = NewRectangle(width, height) } else { fmt.Println(\"Invalid input\") return } } drawing := NewDrawing(shapes) areaCalculator := \u0026AreaCalculator{} drawing.accept(areaCalculator) } "
            }
        );
    index.add(
            {
                id:  37 ,
                href: "\/docs\/dev\/golang\/fyne\/1.%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%AD%A6%E4%B9%A0fyne\/",
                title: "1.为什么要学习Fyne？",
                description: "Fyne 是一个纯Golang 的跨平台GUI 库..",
                content: "GUI Application 的定义 linkGUI(Graphical User Interface/图形用户界面)程序是指使用图形界面与用户进行交互的软件应用程序。图形界面通常包括窗口、图标、按钮、文本框、菜单等可视化元素, 使用户可以通过直观的操作(如点击、拖动, 输入内容)与程序进行交互, 而不需要通过如命令行进行操作。\n例子: 好比 VS Code 就是。\n使用 Fyne 开发 GUI(图形用户界面)程序有许多优势, 我们简单地和 Electron 比较一下。\n1. 轻量 link Fyne：Fyne 是一个轻量级的 GUI 框架, 应用程序的体积相对较小, 占用的系统资源也较少。 Electron：Electron 打包了整个 Chromium 和 Node.js, 导致应用程序的体积较大, 并且在运行时占用不少内存。 2. 性能 link Fyne：Fyne 应用是用 Go 语言编写的, Go 语言本身以其高效和快速的性能而闻名。Fyne 应用在启动和运行时的性能通常优于 Electron 应用。 Electron：由于 Electron 依赖于 Chromium 和 Node.js, 其性能受限于这些底层技术的性能。Electron 应用启动较慢, 运行时占用较多的内存和 CPU 资源。 3. 资源消耗 link Fyne：Fyne 应用程序消耗的系统资源较少, 特别是在内存和 CPU 使用方面。这使得 Fyne 应用在低配置的系统上也能顺畅运行。 Electron：Electron 应用通常消耗更多的内存和 CPU 资源, 特别是在打开多个窗口或运行复杂的应用时, 这在低配置系统上可能会导致性能问题。 4. 开发语言 link Fyne：Fyne 使用 Go 语言开发。Go 语言以其简洁、高效和强大的并发支持而著称, 非常适合开发高性能的服务器和桌面应用。 Electron：Electron对于 Web 开发者而言则非常熟悉。 5. 其它优势 link Fyne 提供了一套统一的、现代的用户界面, 能够在各个平台上看起来一致。其设计风格和用户体验都非常优雅。而得益于 Go 语言的编译特性，Fyne 应用在编译成二进制文件后，更难被逆向工程破解，从而在一定程度上增强了应用的安全性。 6. Fyne 也有一些问题 link Fyne 是一个相对较新的框架,虽然社区也在飞速发展, 但是肯定不能和 Electron 比, Electron 早已有了一个成熟的生态系统。 适用场景 link Fyne：适合开发轻量级、高性能、跨平台的桌面应用，尤其是在对资源消耗和性能要求较高的场景下。\nElectron：适合快速开发跨平台的桌面应用，尤其是已经有 Web 应用或有大量现成 Web 组件的场景。\n对于本教程 link本频道一直对于 Go 很重视, 有很多朋友对于 Go 的 Fyne 学习很有兴趣, 同时, Fyne 也很适合 Go 语言新手上手, 开发出一个不错的 GUI 程序。\n关于热重载(Hot Reload) link定义: Hot Reload 允许开发者在不重新启动整个应用程序的情况下立即看到代码更改的效果。\n通过热重载, 开发者可以大大提高效率。而 Fyne 框架本身不直接内置热重载功能\n快速理解例子:\n如 Vue.js 中，运行 npm run dev, 此命令启动了一个开发服务器, 监视项目中的文件变化, 并在检测到变化时自动重新编译, 而无需重新启动服务器。\n配置基本环境 link略\n项目代码: https://github.com/haveflychi/Fyne-study\n"
            }
        );
    index.add(
            {
                id:  38 ,
                href: "\/docs\/dev\/golang\/fyne\/2.%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%B0%8F%E9%A1%B9%E7%9B%AE\/",
                title: "2.第一个小项目",
                description: "fyne编写第一个小项目",
                content: "基本命令\ngo mod init fyneTest01 fyneTest01可以随便写。\ngo get fyne.io/fyne/v2 GOPATH 介绍说明\n$GOPATH 是一个环境变量，它指定了你的 Go 工作空间的位置。工作空间中往往包含编译后的包文件和可执行文件。\n如何找到它?\ngo env GOPATH 即可。\n成品代码\npackage main import ( \"fmt\" \"fyne.io/fyne/v2/app\" \"fyne.io/fyne/v2/widget\" ) func main() { a:= app.New() w:= a.NewWindow(\"Gofer gogogo\") w.SetContent(widget.NewLabel(\"Gofer gogogo\")) w.ShowAndRun() fmt.Println(\"close!\") } Go 要点: go mod tidy linkgo mod tidy 命令会清理 go.mod 文件，移除不再需要的依赖，并确保所有实际使用的依赖都在文件中声明。同时，它还会更新 go.sum 文件，确保其中的记录是最新的和完整的。\ngo mod tidy 运行程序\ngo run . 即可\nGo 要点: go run . link参考文档 https://shellytw.medium.com/golang-learning-journey-from-an-ex-javascript-developer-1-go-run-and-packages-d107fdff147\n这里的解释简单但是到位。 本教程将都使用这个命令。\nFyne 要点: w.ShowAndRun() linkSyntactic Sugar, 亦可以写成\nw.Show() a.Run() a.run将开启事件循环(Eventloop)\n测试代码\nfmt.Println(\"close!\") Fyne, 你不能同时有两个事件循环, 这是因为事件循环负责处理所有的事件(如用户输入)并协调应用程序中的所有组件和窗口。如果你尝试在同一个应用程序中运行多个事件循环,会导致不一致的状态 只能有一个事件循环。\n"
            }
        );
    index.add(
            {
                id:  39 ,
                href: "\/docs\/dev\/golang\/fyne\/3.%E5%A4%84%E7%90%86%E5%A4%9A%E7%AA%97%E5%8F%A3\/",
                title: "3.处理多窗口问题",
                description: "Fyne支持单个事件循环中管理多个窗口",
                content: "代码案例 link package main import ( \"fyne.io/fyne/v2/app\" \"fyne.io/fyne/v2/container\" \"fyne.io/fyne/v2/widget\" ) func main() { a := app.New() w1 := a.NewWindow(\"Window 1\") w1.SetContent(container.NewVBox( widget.NewLabel(\"Test01\"), )) w2 := a.NewWindow(\"Window 2\") w2.SetContent(container.NewVBox( widget.NewLabel(\"Test02\"), )) w1.Show() w2.Show() a.Run() } "
            }
        );
    index.add(
            {
                id:  40 ,
                href: "\/docs\/dev\/golang\/fyne\/4.go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%BF%AB%E9%80%9F%E9%80%9A%E5%85%B3\/",
                title: "4.Go基础速通",
                description: "有Go基础的同学可以跳过",
                content: "代码案例 01 link type Person struct{ Name string Age int Email string } func main() { p := Person{ Name: \"Inkka\", Age: 17, Email: \"inkkaplumbilibili@example.com\", } // 访问结构体字段 fmt.Println(\"Name:\", p.Name) fmt.Println(\"Age:\", p.Age) fmt.Println(\"Email:\", p.Email) // 修改结构体字段 p.Age = 18 fmt.Println(\"Updated Age:\", p.Age) } 代码案例 02 link package main import \"fmt\" func main() { // 初始化一个整数变量 i i := 114514 // 将 i 的值赋给 j j := i // 修改 j 的值 j = 1919810 // 打印 i 和 j 的值 fmt.Println(\"i:\", i) // 输出: i: 114514 fmt.Println(\"j:\", j) // 输出: j: 1919810 } Go 没有引用类型\nhttps://github.com/golang/go/commit/b34f0551387fcf043d65cd7d96a0214956578f94\n代码案例 03 link package main import \"fmt\" func main(){ a := 12 b := \u0026a *b = 13 fmt.Println(a, *b) } 代码案例 04 link type MyStruct struct { Name string age int } func NewMyStruct(name string, age int) *MyStruct { return \u0026MyStruct{ Name: name, age: age, } } 公式\nfunc (接收者变量 接收者类型) 方法名(参数列表) 返回类型 { 函数体 } 代码案例 05 link package main import \"fmt\" type Person struct { name string age int } func main() { p := NewPerson(\"Gopher\", 17) p.Activity() } func NewPerson(name string, age int) *Person { return \u0026Person{ name: name, age: age, } } func (p Person) Activity() { fmt.Println(p.name, p.age) } 代码案例 06 link package main import \"fmt\" type Person struct { name string } func main() { person1 := Person{name: \"Gopher\"} person1.SetName() person1.Activity() } func (p *Person) SetName() { p.name = \"Inkka\" } func (p Person) Activity() { fmt.Println(p.name + \"在写代码\") } TypeScript 参考例:\nsetName(newName: string) { this.name = newName; // 实例属性赋值 } 参考图(图源 Yandex)\n代码案例 07 link package main import \"fmt\" // 定义一个函数，接受一个 int 类型指针参数并修改它 func incrementByReference(val *int) { fmt.Println(1, val) *val++ fmt.Println(\"Inside incrementByReference:\", *val) // 输出: 11 } func main() { num := 10 fmt.Println(2, \u0026num) incrementByReference(\u0026num) fmt.Println(\"Outside incrementByReference:\", num) // 输出: 11 } 代码案例 08 link package main import \"fmt\" // 定义一个函数，接受一个 int 类型参数并试图修改它 func incrementByValue(val int) { val++ fmt.Println(\"Inside incrementByValue:\", val) // 输出: 11 } func main() { num := 10 incrementByValue(num) fmt.Println(\"Outside incrementByValue:\", num) // 输出: 10 } 代码案例 09 link type Animal interface { Speak() string } type Animal interface { Speak(string) string } //补充: 这也可以 type Animal interface { Speak(s string) string } 代码案例 10 link package main import \"fmt\" // 定义 Animal 接口 type Animal interface { Speak() string } // 定义 Dog 结构体 type Dog struct { name string } // 定义 Cat 结构体 type Cat struct { name string } // Dog 实现 Animal 接口的 Speak 方法 func (d Dog) Speak() string { return \"Woof!\" } // Cat 实现 Animal 接口的 Speak 方法 func (c Cat) Speak() string { return \"Nya!\" } // 一个函数，接受 Animal 类型的参数 func MakeAnimalSpeak(a Animal) { fmt.Println(a.Speak()) } func main() { dog := Dog{name: \"Inu\"} cat := Cat{name: \"Neko\"} // Dog 和 Cat 类型都实现了 Animal 接口 MakeAnimalSpeak(dog) // 输出: Woof! MakeAnimalSpeak(cat) // 输出: Nya! } "
            }
        );
    index.add(
            {
                id:  41 ,
                href: "\/docs\/dev\/golang\/fyne\/5.%E6%9B%B4%E5%A4%8D%E6%9D%82%E7%9A%84%E9%A1%B9%E7%9B%AE\/",
                title: "5.更复杂的项目",
                description: "再一次体验 Container, 点击按钮能够实现对应的效果。",
                content: "要求和最终效果 link参考任意一篇 Fyne 官方文档, 可以看到写法:\nfunc makeUI() (*widget.Label, *widget.Entry) { return widget.NewLabel(\"Hello world!\"), widget.NewEntry() } func main() { a := app.New() w := a.NewWindow(\"Hello Person\") w.SetContent(container.NewVBox(makeUI())) w.ShowAndRun() } 所以, 我们也会写makeUI()。\n优势 link 逻辑清晰 便于测试 读法的小提示 link*... 可以读成Pointer to ...。\n成品代码 link package main import ( \"fmt\" \"fyne.io/fyne/v2\" \"fyne.io/fyne/v2/app\" \"fyne.io/fyne/v2/container\" \"fyne.io/fyne/v2/widget\" ) type App struct{ output *widget.Label } var myApp App func (app *App) makeUI()(*widget.Label, *widget.Entry, *widget.Button, *widget.Label, *widget.Button ){ output := widget.NewLabel(\"Gopher Go go go\") entry:= widget.NewEntry() btn := widget.NewButton(\"Click!\", func() { output.SetText(entry.Text) }) app.output = output btn.Importance = widget.HighImportance number := 0 count := widget.NewLabel(fmt.Sprintf(\"Current Number: %d\", number)) incrementbtn := widget.NewButton(\"Click again!\", func() { number++ count.SetText(fmt.Sprintf(\"Current Number: %d\", number)) }) incrementbtn.Importance = widget.DangerImportance return output, entry, btn, count, incrementbtn } func main() { a := app.New() w := a.NewWindow(\"Gopher Go go go!02\") output, entry, btn, count, incrementbtn := myApp.makeUI() w.SetContent(container.NewVBox(output, entry, btn, count, incrementbtn)) w.Resize(fyne.Size{Width: 1600, Height: 1000}) w.ShowAndRun() } "
            }
        );
    index.add(
            {
                id:  42 ,
                href: "\/docs\/dev\/golang\/fyne\/project\/1.markdown%E7%BC%96%E8%BE%91%E5%99%A8\/",
                title: "Fyne-Markdown编辑器",
                description: "Markdown 编辑器\n此项目的要求和最终效果 link能够支持中文, 程序窗口左半边写 markdown, 右边则显示富文本, 也就是现在我们 Vs code 里面的 Preview(プレビュー)\n解决语言问题 linkFyne 默认字体不支持中文, 我们可以复制一下下面的测试文本, 基于我们第一个案例, 会发现是乱码。\npackage main import ( \"fmt\" \"fyne.io/fyne/v2/app\" \"fyne.io/fyne/v2/widget\" ) func main() { a:= app.New() w:= a.NewWindow(\"让我们一起来学习Go语言吧!\") w.SetContent(widget.NewLabel(\"让我们一起来学习Go语言吧!\")) w.ShowAndRun() fmt.Println(\"close!\") } 在项目文件夹中(必要文件), 找到字体文件(NotoSansHans-Regular.ttf)或者亦可以用你喜好的字体。将项目文件夹中的theme.go和util.go复制到项目目录下。\n然后, 在项目中添加如下代码:\ncustomFont := fyne.NewStaticResource(\"NotoSansHans.ttf\", loadFont(\"NotoSansHans-Regular.ttf\")) a.Settings().SetTheme(\u0026myTheme{font: customFont}) 只需要改loadFont内的内容即可。\n实战 Struct 和 Receiver link package main import ( \"fyne.io/fyne/v2\" \"fyne.io/fyne/v2/app\" \"fyne.io/fyne/v2/container\" \"fyne.io/fyne/v2/widget\" ) type config struct { EditWidget *widget.Entry PreviewWidget *widget.RichText CurrentFile fyne.",
                content: "Markdown 编辑器\n此项目的要求和最终效果 link能够支持中文, 程序窗口左半边写 markdown, 右边则显示富文本, 也就是现在我们 Vs code 里面的 Preview(プレビュー)\n解决语言问题 linkFyne 默认字体不支持中文, 我们可以复制一下下面的测试文本, 基于我们第一个案例, 会发现是乱码。\npackage main import ( \"fmt\" \"fyne.io/fyne/v2/app\" \"fyne.io/fyne/v2/widget\" ) func main() { a:= app.New() w:= a.NewWindow(\"让我们一起来学习Go语言吧!\") w.SetContent(widget.NewLabel(\"让我们一起来学习Go语言吧!\")) w.ShowAndRun() fmt.Println(\"close!\") } 在项目文件夹中(必要文件), 找到字体文件(NotoSansHans-Regular.ttf)或者亦可以用你喜好的字体。将项目文件夹中的theme.go和util.go复制到项目目录下。\n然后, 在项目中添加如下代码:\ncustomFont := fyne.NewStaticResource(\"NotoSansHans.ttf\", loadFont(\"NotoSansHans-Regular.ttf\")) a.Settings().SetTheme(\u0026myTheme{font: customFont}) 只需要改loadFont内的内容即可。\n实战 Struct 和 Receiver link package main import ( \"fyne.io/fyne/v2\" \"fyne.io/fyne/v2/app\" \"fyne.io/fyne/v2/container\" \"fyne.io/fyne/v2/widget\" ) type config struct { EditWidget *widget.Entry PreviewWidget *widget.RichText CurrentFile fyne.URI MenuItem *fyne.MenuItem } 正式写代码 linkcontainer.NewHSplit对应的文档: https://docs.fyne.io/api/v2.4/container/split.html\nURI URL 辨析 link URI 是一个用于标识资源的字符串, 它可以是资源的名称、位置或两者的结合。URI 的概念是一个广义的概念, 包含了两类子集：URL 和 URN。\nURL(统一资源定位符) URL 是 URI 的一个子集, 用于指定资源的位置。URL 不仅标识资源, 还提供了定位资源的方法。URL 通常包括以下部分：\n方案(Scheme): 例如 http、https、ftp 等，表示访问资源的协议。 主机(Host): 资源所在的主机名或 IP 地址。 路径(Path): 资源在主机上的具体位置。 查询参数(Query Param): 附加的参数信息，用于传递额外的数据。 片段(Fragment): 资源的一部分，例如网页中的一个锚点。\n举一个例子(锚点): https://ja.wikipedia.org/wiki/Go_(プログラミング言語)#interface\n案例\nhttps://example.com/path/to/resource?query=param#fragment URI例子\nfile:///Users/username/Documents/example.md 代码是最终成品\nFilter(筛选器) link代码\nvar filter = storage.NewExtensionFileFilter([]string{\".md\", \".MD\"}) 提示:\nfunc HasSuffix(s, suffix string) bool { return len(s) \u003e= len(suffix) \u0026\u0026 s[len(s)-len(suffix):] == suffix } 表示方法\ns[len(s)-len(suffix):] 假设 s 为example.md\n放在不同的文件中 link目录说明 link myapp/ |-- main.go |-- test.go main.go及test.go第一行\npackage main main.go更多代码\nfunc main() { ... ... } 附注: 只要在同一个包, 顶层变量和函数就可以互相自由访问。\n生成一个图标 link随意地找一个生成器即可, 格式要求 Icon.png\n最终目录 link myapp/ |-- main.go |-- ui.go |-- config.go 这里只有 Import 相关的内容\nconfig.go\nimport ( \"io\" \"strings\" \"fyne.io/fyne/v2\" \"fyne.io/fyne/v2/dialog\" \"fyne.io/fyne/v2/storage\" ) ui.go\nimport ( \"fyne.io/fyne/v2\" \"fyne.io/fyne/v2/widget\" ) main.go\nimport ( \"fyne.io/fyne/v2\" \"fyne.io/fyne/v2/app\" \"fyne.io/fyne/v2/container\" \"fyne.io/fyne/v2/widget\" ) 综合代码 linkmain.go\ntype config struct { EditWidget *widget.Entry PreviewWidget *widget.RichText CurrentFile fyne.URI MenuItem *fyne.MenuItem BaseTitle string } var cfg config var filter = storage.NewExtensionFileFilter([]string{\".md\", \".MD\"}) func main() { a := app.New() customFont := fyne.NewStaticResource(\"NotoSansHans.ttf\", loadFont(\"NotoSansHans-Regular.ttf\")) a.Settings().SetTheme(\u0026myTheme{font: customFont}) w := a.NewWindow(\"Markdown编辑器\") cfg.BaseTitle = \"Markdown编辑器\" edit, preview := cfg.makeUI() cfg.createMenu(w) w.SetContent(container.NewHSplit(edit, preview)) w.Resize(fyne.Size{Width: 800, Height: 600}) w.CenterOnScreen() w.ShowAndRun() } ui.go\npackage main import ( \"fyne.io/fyne/v2\" \"fyne.io/fyne/v2/widget\" ) func (cfg *config) makeUI() (*widget.Entry, *widget.RichText){ edit := widget.NewMultiLineEntry() preview := widget.NewRichTextFromMarkdown(\"\") cfg.EditWidget = edit cfg.PreviewWidget = preview edit.OnChanged = preview.ParseMarkdown return edit, preview } func (cfg *config) createMenu(win fyne.Window){ open := fyne.NewMenuItem(\"打开...\", cfg.openFunc(win)) save := fyne.NewMenuItem(\"保存\", cfg.saveFunc(win)) cfg.MenuItem = save cfg.MenuItem.Disabled = true saveAs := fyne.NewMenuItem(\"另存为...\", cfg.saveAsFunc(win)) fileMenu := fyne.NewMenu(\"文件\", open, save, saveAs) menu := fyne.NewMainMenu(fileMenu) win.SetMainMenu(menu) } config.go\npackage main import ( \"io/ioutil\" \"strings\" \"fyne.io/fyne/v2\" \"fyne.io/fyne/v2/dialog\" \"fyne.io/fyne/v2/storage\" ) func (cfg *config) saveAsFunc(win fyne.Window) func(){ return func(){ saveDialog := dialog.NewFileSave(func(write fyne.URIWriteCloser, err error){ if err != nil{ dialog.ShowError(err, win) return } if write == nil{ return } if !strings.HasSuffix(strings.ToLower(write.URI().String()),\".md\"){ dialog.ShowInformation(\"错误\", \"必须是.md扩展名\", win) return } write.Write([]uint8(cfg.EditWidget.Text)) cfg.CurrentFile = write.URI() defer write.Close() win.SetTitle(cfg.BaseTitle + \"-\" + write.URI().Name()) cfg.MenuItem.Disabled = false },win) saveDialog.SetFileName(\"未命名.md\") saveDialog.SetFilter(filter) saveDialog.Show() } } func (cfg *config) openFunc(win fyne.Window) func() { return func(){ openDialog := dialog.NewFileOpen(func(read fyne.URIReadCloser, err error){ if err!=nil{ dialog.ShowError(err,win) return } if read == nil{ return } data, err := io.ReadAll(read) if err!=nil{ dialog.ShowError(err,win) return } defer read.Close() cfg.EditWidget.SetText(string(data)) cfg.CurrentFile = read.URI() win.SetTitle(cfg.BaseTitle + \"-\" + read.URI().Name()) cfg.MenuItem.Disabled = false },win) openDialog.SetFilter(filter) openDialog.Show() } } func (cfg *config) saveFunc(win fyne.Window) func() { return func(){ if cfg.CurrentFile != nil{ write, err := storage.Writer(cfg.CurrentFile) if err != nil{ dialog.ShowError(err, win) return } write.Write([]byte(cfg.EditWidget.Text)) defer write.Close() } } } 测试文件 link对应成品代码 link package main import ( \"testing\" \"fyne.io/fyne/v2/container\" \"fyne.io/fyne/v2/test\" ) func Test_makeUI(t *testing.T){ var testCfg config edit, preview := testCfg.makeUI() test.Type(edit, \"Gofjer\") if preview.String() != \"Gofjer\"{ t.Error(\"Failed!!!!\") } } 打包项目 link参考此文档即可: https://docs.fyne.io/started/packaging.html\n"
            }
        );
    index.add(
            {
                id:  43 ,
                href: "\/docs\/dev\/golang\/fyne\/project\/2.%E8%B6%A3%E5%91%B3%E6%95%B4%E6%B4%BB%E9%A1%B9%E7%9B%AE\/",
                title: "Fyne-趣味整活项目",
                description: "全部代码 link package main import ( \"time\" \"fyne.io/fyne/v2\" \"fyne.io/fyne/v2/app\" \"fyne.io/fyne/v2/container\" \"fyne.io/fyne/v2/dialog\" \"fyne.io/fyne/v2/widget\" ) func main() { // 创建一个 Fyne 应用 a := app.New() // 创建一个窗口 customFont := fyne.NewStaticResource(\"NotoSansHans.ttf\", loadFont(\"NotoSansHans-Regular.ttf\")) a.Settings().SetTheme(\u0026myTheme{font: customFont}) win := a.NewWindow(\"高端检测器\") // 创建一个按钮 btn := widget.NewButton(\"检测是否开机\", func() { // 创建一个进度条 progress := widget.NewProgressBarInfinite() progressContainer := container.NewVBox(progress) // 显示加载动画 loadingDialog := dialog.NewCustom(\"正在检测...\", \"取消\", progressContainer, win) loadingDialog.Show() // 模拟加载时间 go func(){ time.Sleep(10 * time.Second) // 10 秒模拟加载时间 // 关闭加载动画并弹出结果窗口 loadingDialog.",
                content: "全部代码 link package main import ( \"time\" \"fyne.io/fyne/v2\" \"fyne.io/fyne/v2/app\" \"fyne.io/fyne/v2/container\" \"fyne.io/fyne/v2/dialog\" \"fyne.io/fyne/v2/widget\" ) func main() { // 创建一个 Fyne 应用 a := app.New() // 创建一个窗口 customFont := fyne.NewStaticResource(\"NotoSansHans.ttf\", loadFont(\"NotoSansHans-Regular.ttf\")) a.Settings().SetTheme(\u0026myTheme{font: customFont}) win := a.NewWindow(\"高端检测器\") // 创建一个按钮 btn := widget.NewButton(\"检测是否开机\", func() { // 创建一个进度条 progress := widget.NewProgressBarInfinite() progressContainer := container.NewVBox(progress) // 显示加载动画 loadingDialog := dialog.NewCustom(\"正在检测...\", \"取消\", progressContainer, win) loadingDialog.Show() // 模拟加载时间 go func(){ time.Sleep(10 * time.Second) // 10 秒模拟加载时间 // 关闭加载动画并弹出结果窗口 loadingDialog.Hide() dialog.ShowInformation(\"结果\", \"电脑是开机的\", win) }() }) // 设置窗口内容 win.SetContent(container.NewVBox(btn)) win.Resize(fyne.Size{Width: 400, Height: 200}) win.CenterOnScreen() win.ShowAndRun() } Go goroutine 简单概念 linkGoroutine 是 Go 语言中的一种轻量级线程, 由 Go 运行时管理。Goroutine 使得并发编程变得更加简单和高效，可以通过关键字 go 启动。\n当然, 每一个并发执行的活动称为goroutine。当一个程序启动时, 只有一个goroutine来调用main函数, 称之为主goroutine。\n特点 link 轻量级：\nGoroutine 非常轻量级, 可以在同一个程序中启动成千上万个 Goroutine, 而不会造成过多的内存开销。 易于使用：\n只需在函数调用前加上 go 关键字, 即可启动一个新的 Goroutine。 并发执行：\nGoroutine 可以并发执行, 不同的 Goroutine 之间可以独立运行, 互不干扰。 调度器管理：\nGo 运行时会自动管理 Goroutine 的调度, 充分利用多核处理器的优势。 Goroutine 示例 link以下是一个简单的 Goroutine 示例：\npackage main import ( \"fmt\" \"time\" ) func sayHello() { for i := 0; i \u003c 5; i++ { fmt.Println(\"Hello\") time.Sleep(1 * time.Second) } } func main() { go sayHello() // 启动一个新的 Goroutine 执行 sayHello 函数 // 主 Goroutine 继续执行其他代码 for i := 0; i \u003c 5; i++ { fmt.Println(\"World\") time.Sleep(1 * time.Second) } // 等待 sayHello 函数执行完成 time.Sleep(6 * time.Second) } 输出情况:\n由于 sayHello 函数在一个新的 goroutine 中执行, 而 main 函数继续执行, 两个函数的输出将会交错在一起。具体的输出可能会有所不同, 有可能是如下面这样\nWorld Hello World Hello ... 而Up主的案例是这样。\nWorld Hello Hello World World Hello Hello World World Hello 上文这就是 Goroutine 的一个非常好的案例\n"
            }
        );
    index.add(
            {
                id:  44 ,
                href: "\/docs\/dev\/golang\/1.go%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1\/",
                title: "1.Go的面向对象",
                description: "简单介绍一下封装、继承、多态、空接口、类型断言",
                content: "封装 - 工厂模式 link golang的结构体没有构造函数，通常可以使用工厂模式来解决这个问题。 如果包里面的结构体变量首字母小写，引入后，不能直接使用，可以工厂模式解决。 只关心结果，不关心实现过程，因为过程是由封闭的工厂来实现的。 package demo //定义一个结构体 type student struct{ Name string score float64 } // *student返回结构体的指针 func NewStudent(name string, score float64) *student { //外包引用不了，但本包是可以引用的 stu := student{ Name : name, score : score, } return \u0026stu } // 结构体中的score字段也是小写所以需要写一个方法返回 func (s *student) GetScore() float64 { return s.score } func (s *student) SetScore(score float64) { s.score = score } package main import ( \"fmt\" \"go-demo/demo\" ) func main() { s := demo.NewStudent(\"Tony\", 60.5) fmt.Println(s) fmt.Println(s.GetScore()) s.SetScore(80) fmt.Println(s) // \u0026{Tony 60.5} // 60.5 // \u0026{Tony 80} } 继承 - struct嵌套 link 在golang中，采用匿名结构体字段来模拟继承关系。 这个时候，可以说Student是继承自Person。 package main import ( \"fmt\" ) type Person struct { name string age int sex string } func (Person) SayHello(){ fmt.Println(\"this is from Person\") } type Student struct { Person school string } func main() { stu := Student{school:\"middle\"} stu.name = \"leo\" stu.age = 30 fmt.Println(stu.name) stu.SayHello() } 多态 - Golang接口的定义 link1. Golang中的接口 link 在Go语言中接口（interface）是一种类型，一种抽象的类型。\n接口（interface）定义了一个对象的行为规范，只定义规范不实现，由具体的对象来实现规范的细节。\n实现接口的条件：\n一个对象只要全部实现了接口中的方法，那么就实现了这个接口。 换句话说，接口就是一个需要实现的方法列表。 2. 为什么要使用接口 link 下面的代码中定义了猫和狗，然后它们都会叫，你会发现main函数中明显有重复的代码。 如果我们后续再加上猪、青蛙等动物的话，我们的代码还会一直重复下去。 那我们能不能把它们当成“能叫的动物”来处理呢？ package main import ( \"fmt\" ) type Cat struct { Name string } func (c Cat) Say() string { return c.Name + \"：喵喵喵\" } type Dog struct { Name string } func (d Dog) Say() string { return d.Name + \": 汪汪汪\" } func main() { c := Cat{Name: \"小白猫\"} fmt.Println(c.Say()) d := Dog{\"阿黄\"} fmt.Println(d.Say()) } // 小白猫：喵喵喵 // 阿黄: 汪汪汪 3. 定义一个Usber接口 link 定义一个 Usber 接口让 Phone 和 Computer 结构体实现这个接口 package main import \"fmt\" // 1.接口是一个规范 type Usber interface { getName() string } // 2.如果接口里面有方法的话，必须要通过结构体或者通过自定义类型实现这个接口 type Phone struct { Name string } type Computer struct { Brand string } func (c *Computer) getName() string { return c.Brand } // 3.手机要实现usb接口的话必须得实现usb接口中的所有方法 func (p *Phone) getName() string { return p.Name } func main() { p := \u0026Phone{ Name: \"华为手机\", } c := \u0026Computer{ Brand: \"联想电脑\", } var p1 Usber // golang中接口就是一个数据类型 p1 = p // 表示手机实现Usb接口 fmt.Println(p1.getName()) // 接口使用场景，处理相同类型的数据 newName := transData(p) newName1 := transData(c) fmt.Println(newName, newName1) } func transData(usber Usber) string { name := usber.getName() return fmt.Sprintf(\"%s%s\", name, \"处理后\") } 空接口 link1. 空接口说明 link Golang中空接口也可以直接当做类型来使用，可以表示任意类型（泛型概念）。 Golang 中的接口可以不定义任何方法，没有定义任何方法的接口就是空接口。 空接口表示没有任何约束，因此任何类型变量都可以实现空接口。 空接口在实际项目中用得非常多，用空接口可以表示任意数据类型。 2. 空接口作为函数的参数 link package main import \"fmt\" // 空接口作为函数的参数 func show(a interface{}) { fmt.Printf(\"值:%v 类型:%T\\n\", a, a) } func main() { show(20) // 值:20 类型:int show(\"你好golang\") // 值:你好golang 类型:string slice := []int{1, 2, 34, 4} show(slice) // 值:[1 2 34 4] 类型:[]int } 3. 切片实现空接口 link package main import \"fmt\" func main() { var slice = []interface{}{\"张三\", 20, true, 32.2} fmt.Println(slice) // [张三 20 true 32.2] } 4. map 的值实现空接口 link package main import \"fmt\" func main() { // 空接口作为 map 值 var studentInfo = make(map[string]interface{}) studentInfo[\"name\"] = \"张三\" studentInfo[\"age\"] = 18 studentInfo[\"married\"] = false fmt.Println(studentInfo) // map[age:18 married:false name:张三] } 类型断言 link 一个接口的值（简称接口值）是由一个具体类型和具体类型的值两部分组成的。\n这两部分分别称为接口的动态类型和动态值。\n如果我们想要判断空接口中值的类型，那么这个时候就可以使用类型断言。\n其语法格式： x.(T)\nx : 表示类型为 interface{}的变量 T : 表示断言 x 可能是的类型 package main import \"fmt\" func main() { var x interface{} x = \"Hello golang\" v, ok := x.(string) if ok { fmt.Println(v) } else { fmt.Println(\"非字符串类型\") } } 值接收者和指针接收者 link1. 值接收者 link 当方法作用于值类型接收者时，Go语言会在代码运行时将接收者的值复制一份。 在值类型接收者的方法中可以获取接收者的成员值，但修改操作只是针对副本，无法修改接收者变量本身。 package main import \"fmt\" type Usb interface { Start() Stop() } type Phone struct { Name string } func (p Phone) Start() { fmt.Println(p.Name, \"开始工作\") } func (p Phone) Stop() { fmt.Println(p.Name, \"停止工作\") } func main() { phone1 := Phone{ Name: \"小米手机\", } var p1 Usb = phone1 // phone1 实现了 Usb 接口 p1.Start() // 输出: 小米手机 开始工作 phone2 := \u0026Phone{ Name: \"苹果手机\", } var p2 Usb = phone2 // phone2 实现了 Usb 接口 p2.Start() // 输出: 苹果手机 开始工作 } 2. 指针接收者 link 指针类型的接收者由一个结构体的指针组成。 由于指针的特性，调用方法时修改接收者指针的任意成员变量，在方法结束后，修改都是有效的。 这种方式就十分接近于其他语言中面向对象中的 this 或者 self。 例如我们为 Person 添加一个 SetAge 方法，来修改实例变量的年龄。 3. 指针类型接收者 使用时机 link 并不是所有情况下都希望修改数据： 需要修改接收者中的值 接收者是拷贝代价比较大的大对象 保证一致性，如果有某个方法使用了指针接收者，那么其他的方法也应该使用指针接收者。 "
            }
        );
    index.add(
            {
                id:  45 ,
                href: "\/docs\/dev\/golang\/2.go%E7%9A%84%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B\/",
                title: "2.Go的并发编程",
                description: "简单介绍一下并发协程、管道、并发锁等",
                content: "并发介绍 link 并发和并行 并发：本质还是串行 食堂窗口一个大妈（同一时间类只能给一个人打饭） Python 本质没有并行的线程 并行：任务分布在不同 CPU 上，同一时间点同时执行 并行就是有多个食堂大妈，同时给不同人打饭 协程和线程 协程：独立的栈空间，共享堆空间，调度由用户自己控制，本质上有点类似于用户级线程，这些用户级线程的调度也是自己实现的 线程：一个线程上可以跑多个协程，协程是轻量级的线程。 线程和协程最大的区别： 开启一个线程需要大概 2M 空间，而且需要 CPU 调度才能执行，线程会强占 CPU 开启一个协程大概只需要 2K 的空间，而且是由 Go 解释器自己实现的 GPM 调度，主动退出 可以同时启动成千上万个 goroutine 而不会过度占用内存 如果开启成千上万个线程，不仅会大量占用内存，甚至导致机器崩溃；操作系统调度线程也需要耗费大量时间 协程如果需要用 CPU 才会去使用 CPU，如果没有使用 CPU 的需求，它就会主动把 CPU 让给其他协程执行 线程在时间片内，即使不使用 CPU，比如当前正在从磁盘读数据，它也不会让出 CPU goroutine link 多线程编程缺点\n在 Java/C++ 中我们要实现并发编程时，通常需要自己维护一个线程池，并且需要自己去包装一个又一个的任务，同时需要自己去调度线程执行任务并维护上下文切换 goroutine\nGo 语言中的 goroutine 是由 Go 的运行时（runtime）调度和管理的。 Go 程序会智能地将 goroutine 中的任务合理地分配给每个 CPU。 Go 语言之所以被称为现代化的编程语言，就是因为它在语言层面已经内置了调度和上下文切换的机制。 在 Go 语言编程中，你不需要自己写进程、线程、协程，你的技能包里只有一个技能 —— goroutine 当你需要让某个任务并发执行时，只需将该任务包装成一个函数，并开启一个 goroutine 去执行该函数即可。 协程基本使用 link 启动一个协程\n主线程中每 100 毫秒打印一次，总共打印 2 次，同时开启一个协程打印 10 次 package main import ( \"fmt\" \"time\" ) func test() { for i := 0; i \u003c 10; i++ { fmt.Println(\"test() 你好golang\") time.Sleep(time.Millisecond * 100) } } func main() { go test() // 表示开启一个协程 for i := 0; i \u003c 2; i++ { fmt.Println(\"main() 你好golang\") time.Sleep(time.Millisecond * 100) } } WaitGroup\n主线程退出后所有的协程无论有没有执行完毕都会退出。所以我们在主进程中可以通过 WaitGroup 等待协程执行完毕。\nsync.WaitGroup 内部维护着一个计数器，计数器的值可以增加和减少。\n例如当我们启动了 N 个并发任务时，就将计数器值增加 N。\n每个任务完成时通过调用 Done() 方法将计数器减 1。\n通过调用 Wait() 来等待并发任务执行完，当计数器值为 0 时，表示所有并发任务已经完成。\nvar wg sync.WaitGroup // 第一步：定义一个计数器 wg.Add(1) // 第二步：开启一个协程计数器+1 wg.Done() // 第三步：协程执行完毕，计数器-1 wg.Wait() // 第四步：计数器为0时退出 package main import ( \"fmt\" \"sync\" \"time\" ) var wg sync.WaitGroup // 第一步：定义一个计数器 func test1() { for i := 0; i \u003c 10; i++ { fmt.Println(\"test1() 你好golang-\", i) time.Sleep(time.Millisecond * 100) } wg.Done() //协程计数器-1 // 第三步：协程执行完毕，计数器-1 } func test2() { for i := 0; i \u003c 2; i++ { fmt.Println(\"test2() 你好golang-\", i) time.Sleep(time.Millisecond * 100) } wg.Done() //协程计数器-1 } func main() { wg.Add(1) //协程计数器+1 第二步：开启一个协程计数器+1 go test1() // 表示开启一个协程 wg.Add(1) //协程计数器+1 go test2() // 表示开启一个协程 wg.Wait() //等待协程执行完毕 // 第四步：计数器为0时退出 fmt.Println(\"主线程退出\") } 开启多个协程\n在 Go 语言中实现并发非常简单，可以轻松启动多个 goroutine，并使用 sync.WaitGroup 等待它们执行完毕。多次执行上面的代码，会发现每次打印的数字顺序都不一致。这是因为 10 个 goroutine 是并发执行的，而 goroutine 的调度是随机的。 package main import ( \"fmt\" \"sync\" ) var wg sync.WaitGroup func hello(i int) { defer wg.Done() // goroutine结束就登记-1 fmt.Println(\"Hello Goroutine!\", i) } func main() { for i := 0; i \u003c 10; i++ { wg.Add(1) // 启动一个goroutine就登记+1 go hello(i) } wg.Wait() // 等待所有登记的goroutine都结束 } channel link Channel说明\n共享内存交互数据弊端\n单纯地将函数并发执行是没有意义的。函数与函数间需要交换数据才能体现并发执行的意义。 虽然可以使用共享内存进行数据交换，但是共享内存在不同的 goroutine 中容易发生竞态问题。 为了保证数据交换的正确性，必须使用互斥量对内存进行加锁，这种做法势必造成性能问题。 Channel好处\nGo 语言中的通道（channel）是一种特殊的类型。 通道像一个传送带或者队列，总是遵循先入先出（FIFO）的规则，保证收发数据的顺序。 每一个通道都是一个具体类型的导管，也就是声明 channel 的时候需要为其指定元素类型。 如果说 goroutine 是 Go 程序并发的执行体，channel 就是它们之间的连接。 Channel 是可以让一个 goroutine 发送特定值到另一个 goroutine 的通信机制。 Channel类型\nChannel 是一种类型，一种引用类型。声明管道类型的格式如下: var 变量 chan 元素类型 var ch1 chan int // 声明一个传递整型的管道 var ch2 chan bool // 声明一个传递布尔型的管道 var ch3 chan []int // 声明一个传递 int 切片的管道 创建channel\n声明的管道后需要使用 make 函数初始化之后才能使用。创建 channel 的格式如下： make(chan 元素类型, 容量) // 创建一个能存储 10 个 int 类型数据的管道 ch1 := make(chan int, 10) // 创建一个能存储 4 个 bool 类型数据的管道 ch2 := make(chan bool, 4) // 创建一个能存储 3 个[]int 切片类型数据的管道 ch3 := make(chan []int, 3) Channel操作 package main import \"fmt\" func main() { // 1、创建channel ch := make(chan int, 5) // 2、向channel放入数据 ch \u003c- 10 ch \u003c- 12 fmt.Println(\"发送成功\", ch) // 3、向channel取值 v1 := \u003c-ch fmt.Println(v1) v2 := \u003c-ch fmt.Println(v2) // 4、空channel取值报错 v3 := \u003c-ch fmt.Println(\"v3\", v3) } 优雅的从Channel取值\n当通过通道发送有限的数据时，可以通过 close 函数关闭通道来告知从该通道接收值的 goroutine 停止等待。当通道被关闭时，往该通道发送值会引发 panic，从该通道里接收的值一直都是类型零值。可以通过 for range 的方式判断通道是否关闭。 package main import \"fmt\" func main() { ch := make(chan int, 5) ch \u003c- 10 ch \u003c- 12 ch \u003c- 14 ch \u003c- 16 ch \u003c- 18 close(ch) for i := range ch { // 通道关闭后会退出for range循环 fmt.Println(i) } } Goroutine和Channel小案例\n请完成 goroutine 和 channel 协同工作的案例，具体要求： 开启一个 writeData 协程，向管道 intChan 中写入 50 个整数。 开启一个 readData 协程，从管道 intChan 中读取 writeData 写入的数据。 注意：writeData 和 readDate 操作的是同一个管道。 主线程需要等待 writeData 和 readData 协程都完成工作才能退出。 package main import ( \"fmt\" ) //write Data func writeData(intChan chan int) { for i := 1; i \u003c= 50; i++ { //放入数据 intChan \u003c- i fmt.Println(\"writeData \", i) } close(intChan) //关闭 } //read data func readData(intChan chan int, exitChan chan bool) { for { v, ok := \u003c-intChan if !ok { break } fmt.Printf(\"readData 读到数据=%v\\n\", v) } //readData 读取完数据后，即任务完成 exitChan \u003c- true close(exitChan) } func main() { //创建两个管道 intChan := make(chan int, 10) exitChan := make(chan bool, 1) go writeData(intChan) go readData(intChan, exitChan) for { _, ok := \u003c-exitChan if !ok { break } } } Select 多路复用 link Select说明\n传统的方法在遍历管道时，如果不关闭会阻塞而导致 deadlock，在实际开发中，可能我们不好确定什么时候关闭该管道。这种 for range 方式虽然可以实现从多个管道接收值的需求，但是运行性能会差很多。为了应对这种场景，Go 内置了 select 关键字，可以同时响应多个管道的操作。 select 的使用类似于 switch 语句，它有一系列 case 分支和一个默认的分支。每个 case 会对应一个管道的通信（接收或发送）过程。select 会一直等待，直到某个 case 的通信操作完成时，就会执行 case 分支对应的语句。 具体格式如下： select { case v := \u003c-chan1: // 如果chan1成功读到数据，则进行该case处理语句 case chan2 \u003c- 1: // 如果成功向chan2写入数据，则进行该case处理语句 default: // 如果上面都没有成功，则进入default处理流程 } Select的使用\n使用 select 语句能提高代码的可读性。可处理一个或多个 channel 的发送/接收操作。如果多个 case 同时满足，select 会随机选择一个。对于没有 case 的 select{} 会一直等待，可用于阻塞 main 函数。 package main import ( \"fmt\" ) func main() { // 在某些场景下我们需要同时从多个通道接收数据,这个时候就可以用到golang中给我们提供的select多路复用 //1.定义一个管道 10个数据int intChan := make(chan int, 10) for i := 0; i \u003c 10; i++ { intChan \u003c- i } //2.定义一个管道 5个数据string stringChan := make(chan string, 5) for i := 0; i \u003c 5; i++ { stringChan \u003c- \"hello\" + fmt.Sprintf(\"%d\", i) } // 使用select来获取channel里面的数据的时候不需要关闭channel for { select { case v := \u003c-intChan: fmt.Printf(\"从 intChan 读取的数据%d\\n\", v) case v := \u003c-stringChan: fmt.Printf(\"从 stringChan 读取的数据%v\\n\", v) default: fmt.Printf(\"数据获取完毕\") return // 注意退出 } } } 互斥锁 link 互斥锁是一种常用的控制共享资源访问的方法，它能够保证同时只有一个 goroutine 可以访问共享资源。 Go 语言中使用 sync 包的 Mutex 类型来实现互斥锁。 在多核的系统中，这 1000 个协程被分配到多个线程里面运行，那么就有可能是并行运行的。 比如当前的 num=987，后面两个线程同时执行，那么结果就是 988，但是这不是我们想要的结果，我们想要的是 999。 如何解决？其实可以通过互斥锁来保证代码在并发运行时，只有一个线程可以修改 num 的值。 package main import ( \"fmt\" \"sync\" ) var num int var mtx sync.Mutex var wg sync.WaitGroup func add() { defer wg.Done() mtx.Lock() num += 1 mtx.Unlock() } func main() { for i := 0; i \u003c 1000; i++ { wg.Add(1) go add() } wg.Wait() fmt.Println(\"num:\", num) } Semaphore信号量 link 含义 Semaphore是用来控制多个goroutine同时访问多个资源的并发原语 包含2个操作： P 操作 (decrease, wait, acquire) 是减少信号量的计数值 V 操作 (increase, signal, release) 是增加信号量的计数值 补充说明 P/V 的含义： P —— passeren，中文译为“通过” V —— vrijgeven，中文译为“释放”（因为作者是荷兰人，上面单词为荷兰语） 实现 类型名叫Weighted Acquire 方法：相当于P操作，你可以一次获取多个资源，如果没有足够的资源，那么调用者就会被阻塞 Release 方法：相当于V操作，可以将多个资源释放，放宽信号量 TryAcquire 方法：尝试获取N个资源，但是它不会阻塞，返回true，要么什么也不获取，返回false 使用场景 常用于控制并发 常见错误 请求了资源，但是忘记释放它 积放了从未请求的资源 长时间持有一个资源，即使不需要它 不持有一个资源，想直接使用它 避免误用 请求多少资源，就释放多少资源 package main import ( \"context\" \"fmt\" \"log\" \"runtime\" \"time\" \"golang.org/x/sync/semaphore\" ) var ( maxWorkers = runtime.GOMAXPROCS(0) //设置信号量总数 当前应为4 sema = semaphore.NewWeighted(int64(maxWorkers)) //设置需要完成的任务数 当前应为16 task = make([]int, maxWorkers*4) ) func main() { ctx := context.Background() for i := range task { //获取信号量，如果没有则阻塞。 log.Printf(\"阻塞中任务id: %v\", i) //P操作 将sema信号量减1 if err := sema.Acquire(ctx, 1); err != nil { log.Panicf(\"减少信号量报错：%v\", err) } log.Printf(\"阻塞结束任务id: %v\", i) go func(i int) { //V操作 将sema信号量释放 加1 defer sema.Release(1) time.Sleep(10000 * time.Millisecond) task[i] = i + 1 }(i) } if err := sema.Acquire(ctx, int64(maxWorkers)); err != nil { log.Printf(\"获取所有的worker失败： %v\", err) } fmt.Println(task) } /* 输出 2024/08/29 11:41:40 阻塞中任务id: 0 2024/08/29 11:41:40 阻塞结束任务id: 0 2024/08/29 11:41:40 阻塞中任务id: 1 2024/08/29 11:41:40 阻塞结束任务id: 1 2024/08/29 11:41:40 阻塞中任务id: 2 2024/08/29 11:41:40 阻塞结束任务id: 2 2024/08/29 11:41:40 阻塞中任务id: 3 2024/08/29 11:41:40 阻塞结束任务id: 3 2024/08/29 11:41:40 阻塞中任务id: 4 2024/08/29 11:41:50 阻塞结束任务id: 4 2024/08/29 11:41:50 阻塞中任务id: 5 2024/08/29 11:41:50 阻塞结束任务id: 5 2024/08/29 11:41:50 阻塞中任务id: 6 2024/08/29 11:41:50 阻塞结束任务id: 6 2024/08/29 11:41:50 阻塞中任务id: 7 2024/08/29 11:41:50 阻塞结束任务id: 7 2024/08/29 11:41:50 阻塞中任务id: 8 2024/08/29 11:42:00 阻塞结束任务id: 8 2024/08/29 11:42:00 阻塞中任务id: 9 2024/08/29 11:42:00 阻塞结束任务id: 9 2024/08/29 11:42:00 阻塞中任务id: 10 2024/08/29 11:42:00 阻塞结束任务id: 10 2024/08/29 11:42:00 阻塞中任务id: 11 2024/08/29 11:42:00 阻塞结束任务id: 11 2024/08/29 11:42:00 阻塞中任务id: 12 2024/08/29 11:42:10 阻塞结束任务id: 12 2024/08/29 11:42:10 阻塞中任务id: 13 2024/08/29 11:42:10 阻塞结束任务id: 13 2024/08/29 11:42:10 阻塞中任务id: 14 2024/08/29 11:42:10 阻塞结束任务id: 14 2024/08/29 11:42:10 阻塞中任务id: 15 2024/08/29 11:42:10 阻塞结束任务id: 15 [1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16] */ 上面的demo中通过日志时间可以看到，每次只并发了4个协程\n"
            }
        );
    index.add(
            {
                id:  46 ,
                href: "\/docs\/dev\/golang\/3.go%E5%B8%B8%E7%94%A8%E5%BA%93\/",
                title: "3.Go常用库",
                description: "Go常用基础库",
                content: "时间库time link package main import ( \"fmt\" \"time\" ) func main() { now := time.Now() fmt.Printf(\"原始时间对象：%s\\n\", now) //格式化时间 timePrf := now.Format(\"2006-01-02 15:04:05\") fmt.Printf(\"格式化时间戳：%s\\n\", timePrf) /* output: 原始时间对象：2024-09-26 23:49:32.920331 +0800 CST m=+0.000064395 格式化时间戳：2024-09-26 23:49:32 */ //时间戳 fmt.Printf(\"秒时间戳：%v\\n\", now.Unix()) fmt.Printf(\"毫秒时间戳：%v\\n\", now.UnixMilli()) fmt.Printf(\"微秒时间戳：%v\\n\", now.UnixMicro()) fmt.Printf(\"纳秒时间戳：%v\\n\", now.UnixNano()) /* output: 秒时间戳：1727365772 毫秒时间戳：1727365772920 微秒时间戳：1727365772920331 纳秒时间戳：1727365772920331000 */ //格式化后的时间（string）转时间对象 loc, _ := time.LoadLocation(\"Asia/Shanghai\") inLocation, _ := time.ParseInLocation(\"2006-01-02 15:04:05\", timePrf, loc) fmt.Printf(\"格式化后的时间字符串转时间对象：%s\\n\", inLocation) /* output: 格式化后的时间字符串转时间对象：2024-09-26 23:49:32 +0800 CST */ //获取年月日、时分秒 year := now.Year() month := now.Month() day := now.Day() hour := now.Hour() minute := now.Minute() second := now.Second() fmt.Printf(\"获取年月日，时分秒：%d/%02d/%02d %02d:%02d:%02d\\n\", year, month, day, hour, minute, second) /* output: 获取年月日，时分秒：2024/09/26 23:49:32 */ //秒时间戳转时间类型,0代表指定这一秒内的偏移量以纳秒为单位 unixObj := time.Unix(now.Unix(), 0) fmt.Printf(\"Unix时间戳转时间对象：%s\\n\", unixObj) /* output: Unix时间戳转时间对象：2024-09-26 23:49:32 +0800 CST */ //时间计算 //add fmt.Printf(\"当前时间：%s\\n\", now) duration, _ := time.ParseDuration(\"1m\") addTime := now.Add(duration) fmt.Printf(\"加计算后的时间：%s\\n\", addTime) /* output: 当前时间：2024-09-26 23:49:32.920331 +0800 CST m=+0.000064395 加计算后的时间：2024-09-26 23:50:32.920331 +0800 CST m=+60.000064395 */ //sub fmt.Printf(\"计算时间差：%s\\n\", now.Sub(addTime)) /* output: 计算时间差：-1m0s */ } os库 link package main import ( \"fmt\" \"os\" ) func main() { /* output: */ //获取当前目录 fmt.Println(os.Getwd()) /* output: /Volumes/data/go/src/test */ //cd到某个目录 dir, _ := os.Getwd() os.Chdir(\"../\") fmt.Println(os.Getwd()) os.Chdir(dir) /* output: /Volumes/data/go/src */ //创建文件夹 os.Mkdir(\"go_fly\", 0777) //删除文件夹 os.Remove(\"go_fly\") //修改文件名称 os.Mkdir(\"go_fly\", 0777) os.Rename(\"go_fly\", \"go_flyxx\") //创建文件 os.Create(\"./go_flyxx/feichi.txt\") //打开文件 file, _ := os.OpenFile(\"./go_flyxx/feichi.txt\", os.O_RDWR|os.O_APPEND, 0666) /* O_RDONLY 打开只读文件 O_WRONLY 打开只写文件 O_RDWR 打开既可以读取又可以写入文件 O_APPEND 写入文件时将数据追加到文件尾部 O_CREATE 如果文件不存在，则创建一个新的文件 */ file.WriteString(\"你好小飞\") } 文件操作 link package main import ( \"fmt\" \"io\" \"os\" \"strings\" ) func main() { //读文件数据 fileName := \"file.txt\" file, _ := os.ReadFile(fileName) fmt.Printf(\"读数据：%s\\n\", string(file)) /* output: 读数据：你好👋 */ //写数据 fileName2 := \"hello.txt\" str1 := \"虞锋是笨蛋\" _ = os.WriteFile(fileName2, []byte(str1), 0777) //读取Reader类型的数据，常用于http response的读取 str2 := \"虞锋是笨蛋吗？\" reader1 := strings.NewReader(str2) allData, _ := io.ReadAll(reader1) fmt.Printf(\"读取Reader类型的数据：%s\\n\", string(allData)) /* output: 读取Reader类型的数据：虞锋是笨蛋吗？ */ //读取当前目录下所有文件和文件夹，遍历一层 dir, _ := os.Getwd() readDir, _ := os.ReadDir(dir) fmt.Println(\"读取当前文件下所有文件或文件夹\") for index, mydir := range readDir { fmt.Printf(\"第%v个：%s，是目录吗：%v\\n\", index, mydir.Name(), mydir.IsDir()) } /* output: 读取当前文件下所有文件或文件夹 第0个：.idea，是目录吗：true 第1个：file.txt，是目录吗：false 第2个：go.mod，是目录吗：false 第3个：go.sum，是目录吗：false 第4个：hello.txt，是目录吗：false 第5个：main.go，是目录吗：false */ } flag包 link package main import ( \"flag\" \"fmt\" \"time\" ) func main() { //定义命令行参数 var ( name string age int marride bool delay time.Duration ) //传参：绑定的变量名，传参的参数名，传参的默认值，传参的备注 flag.StringVar(\u0026name, \"name\", \"张三\", \"姓名\") flag.IntVar(\u0026age, \"age\", 18, \"年龄\") flag.BoolVar(\u0026marride, \"marride\", false, \"婚否\") flag.DurationVar(\u0026delay, \"delay\", 0, \"延迟的间隔时间\") //解命令行参数 flag.Parse() fmt.Println(name, age, marride, delay) fmt.Printf(\"未解析的参数值：%s, 未解析的参数个数：%v, 使用的参数：%v\\n\", flag.Args(), flag.NArg(), flag.NFlag()) } fei@feideMBP test % go run main.go -name feic -age 20 -marride=false -delay 1m a1 b1 c1 feic 20 false 1m0s 未解析的参数值：[a1 b1 c1], 未解析的参数个数：3, 使用的参数：4 实现hostnamectl命令 link package main import ( \"flag\" \"syscall\" ) func main() { var hostname string flag.StringVar(\u0026hostname, \"set-hostname\", \"feichi-server01\", \"主机名\") flag.Parse() syscall.Sethostname([]byte(hostname)) } fei@feideMBP test % CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build main.go [root@yu123 ~]# ./hostname -h Usage of ./hostname: -set-hostname string 主机名 (default \"feichi-server01\") [root@yu123 ~]# ./hostname -set-hostname yu1234 [root@yu123 ~]# bash [root@yu1234 ~]# ./hostname [root@yu1234 ~]# bash [root@feichi-server01 ~]# # 在mac版本的go中会没有这个方法：syscall.Sethostname，但是交叉编译成linux后可以运行: https://github.com/golang/go/issues/46166 "
            }
        );
    index.add(
            {
                id:  47 ,
                href: "\/docs\/dev\/golang\/4.go-net-http\/",
                title: "4.Go-net-http",
                description: "Go net-http包介绍",
                content: "net-http介绍 link . ├─ ClientGet │ └── main.go // 发送get请求 ├─ ClientPost │ └── main.go // 发送post请求 ├─ Server │ └── main.go // web服务 Go语言内置的net/http包十分的优秀，提供了HTTP客户端和服务端的实现。\n1.Server/main.go link 客户端 请求信息 封装在http.Request对象中 服务端返回的 响应报文 会被保存在http.Response结构体中 发送给客户端响应的并不是http.Response，而是通过http.ResponseWriter接口来实现的 方法签名 描述 Header() 用户设置或获取响应头信息 Write() 用于写入数据到响应体 WriteHeader() 用于设置响应状态码，若不调用则默认状态码为200 OK。 package main import ( \"encoding/json\" \"io\" \"log\" \"net/http\" ) // 定义入参结构体 type Data struct { Speak string `json:\"speak\"` } // 处理get请求 func dealGetReqHandler(w http.ResponseWriter, r *http.Request) { query := r.URL.Query() //获取请求参数两种方法 if len(query[\"name\"]) \u003e 0 { name := query[\"name\"][0] log.Printf(\"1.通过map中切片的下标获取：%s\\n\", name) } name2 := query.Get(\"name\") //没有的话就会返回空值 log.Printf(\"2.通过Get方法获取：%s\\n\", name2) data := \u0026Data{ name2 + \"是笨蛋\", } //响应json数据:序列化了一下data对象，并写入响应体w中 json.NewEncoder(w).Encode(data) //也可以w.Write([]byte(··json数据··)) } // 处理post请求 func dealPostReqHandler(w http.ResponseWriter, r *http.Request) { //获取请求体数据 bodyByte, err := io.ReadAll(r.Body) if err != nil { w.Write([]byte(err.Error())) } //转成结构体示范，为了可以更好的处理数据，而不是必须转结构体才能json返回 bodyStr := string(bodyByte) data := \u0026Data{} json.Unmarshal([]byte(bodyStr), \u0026data) log.Printf(\"从post请求体中获取到的数据：%s\\n\", data.Speak) //返回响应内容 data.Speak = data.Speak + \"是笨蛋\" //返回响应体内容 json.NewEncoder(w).Encode(data) } // 启动http服务 func main() { //注册全局路由 http.HandleFunc(\"/req/post\", dealPostReqHandler) http.HandleFunc(\"/req/get\", dealGetReqHandler) http.ListenAndServe(\":8000\", nil) } 一个路由对应一个handler:/api/xxx对应的是一个处理方法 http.ResponseWriter用来响应内容 *http.Request用来拿到请求头或者请求参数 测试 link fei@feideMBP Server % go run main.go 2024/10/02 02:43:58 1.通过map中切片的下标获取：虞锋 2024/10/02 02:43:58 2.通过Get方法获取：虞锋 2024/10/02 02:44:04 从post请求体中获取到的数据：虞锋 fei@feideMBP ~ % curl http://127.0.0.1:8000/req/get?name=虞锋 {\"speak\":\"虞锋是笨蛋\"} fei@feideMBP ~ % curl -X POST http://127.0.0.1:8000/req/post \\ -H 'Content-Type: application/json' \\ -d '{\"speak\":\"虞锋\"}' {\"speak\":\"虞锋是笨蛋\"} 2.ClientGet/main.go link package main import ( \"io\" \"log\" \"net/http\" \"net/url\" ) func main() { apiUrl := \"http://localhost:8000/req/get\" //定义url参数 data := url.Values{} data.Set(\"name\", \"httpGet-root\") //组装url u, err := url.ParseRequestURI(apiUrl) if err != nil { panic(err) } u.RawQuery = data.Encode() log.Printf(\"请求路由为：%s\\n\", u.String()) //发起请求 resp, err := http.Get(u.String()) if err != nil { panic(err) } defer resp.Body.Close() //读取 byteBody, _ := io.ReadAll(resp.Body) log.Printf(\"返回数据为：%s\\n\", string(byteBody)) } 测试 link # 启动server fei@feideMBP Server % go run main.go 2024/10/02 03:39:08 1.通过map中切片的下标获取：httpGet-root 2024/10/02 03:39:08 2.通过Get方法获取：httpGet-root # 启动getclient fei@feideMBP ClientGet % go run main.go 2024/10/02 03:39:08 请求路由为：http://localhost:8000/req/get?name=httpGet-root 2024/10/02 03:39:08 返回数据为：{\"speak\":\"httpGet-root是笨蛋\"} 3.ClientPost/main.go link package main import ( \"io\" \"log\" \"net/http\" \"strings\" ) func main() { apiUrl := \"http://localhost:8000/req/post\" //定义请求体及header contentType := \"application/json\" data := `{\"speak\":\"httpPost\"}` resp, err := http.Post(apiUrl, contentType, strings.NewReader(data)) if err != nil { panic(err) } defer resp.Body.Close() //读取 byteBody, _ := io.ReadAll(resp.Body) log.Printf(\"返回数据为：%s\\n\", string(byteBody)) } 测试 link # 启动server fei@feideMBP Server % go run main.go 2024/10/02 03:51:39 从post请求体中获取到的数据：httpPost # 启动postclient fei@feideMBP ClientPost % go run main.go 2024/10/02 03:51:39 返回数据为：{\"speak\":\"httpPost是笨蛋\"} "
            }
        );
    index.add(
            {
                id:  48 ,
                href: "\/docs\/dev\/golang\/5.go-grpc\/",
                title: "5.Go-gRPC",
                description: "Go-gRPC介绍",
                content: "1.gRPC 是什么 linkgRPC是google开源的一个RPC框架和库，支持多语言之间的通信。底层通信采用的是 HTTP2 协议。gRPC在设计上使用了 ProtoBuf 这种接口描述语言。这种IDL语言可以定义各种服务，google还提供了一种工具 protoc 来编译这种IDL语言，生成各种各样的语言来操作服务。\n2.gRPC特点 link 定义服务简单，可以很快的搭建出一个RPC调度的服务 gRPC是与语言无关，平台无关的。你定义好了一个protobuf协议，就可以用protoc生成不同语言的协议框架 使用HTTP2协议，支持双向流。客户端和服务端可以双向通信 3.RPC与RESTful区别是什么 link 在客户端和服务端通信还有一种基于http协议的 RESTful 架构模式，RESTful一般是对于资源的操作，它是名词（资源地址），然后添加一些动作对这些资源进行操作。而RPC是基于函数，它是动词。 RPC一般基于TCP协议，当然gRPC是基于HTTP2，但它也是比HTTP协议更加有效率和更多特性。RESTful一般都是基于HTTP协议。 传输方面：自定义的TCP协议或者使用HTTP2协议，报文体积更小，所以传输效率更高，RESTful一般基于http协议，报文体积大。 gRPC用的是protobuf的IDL语言，会编码为二进制协议的数据，而RESTful一般是用json的数据格式，所以json格式的编解码更耗时。 4.gRPC通信流程 link 客户端(gRPC Stub)调用A方法，发起RPC调用 对请求信息使用Protobuf进行对象序列化压缩（IDL） 服务端（gPRC Server)接收到请求后，解码请求体，进行业务逻辑处理并返回。 对响应结果使用Protobuf进行对象序列化压缩（IDL） 客户端接受到服务端响应，解码请求体。回调被调用的A方法，唤醒正在等待响应（阻塞）的客户端调用并返回响应结果 5.gRPC环境安装 link5.1安装 protobuf link从官方仓库：https://github.com/google/protobuf/releases 下载适合你平台的预编译好的二进制文件（protoc--.zip）。\n适用Windows 64位protoc-3.20.1-win64.zip 适用于Mac Intel 64位protoc-3.20.1-osx-x86_64.zip 适用于Mac ARM 64位protoc-3.20.1-osx-aarch_64.zip 适用于Linux 64位protoc-3.20.1-linux-x86_64.zip 将下载的zip解压到指定位置，这里以mac系统为例 fei@feideMBP protoc % pwd /usr/local/protoc fei@feideMBP protoc % tree -L 2 ./ ./ ├── bin │ └── protoc └── include ├── github.com └── google 5 directories, 1 file fei@feideMBP protoc % protoc --version libprotoc 3.20.3 fei@feideMBP protoc % head -n1 ~/.zshrc export PATH=$PATH:/Volumes/data/go/bin:/usr/local/protoc/bin:/Volumes/data/go/pkg/bin 还需要安装protobuf的golang编译器插件protoc-gen-go，用于生成go文件安装protoc-gen-go-grpc和protoc-gen-go，因为protoc没有内置go生成器，想实现.proto→.go的转换的话 go install google.golang.org/protobuf/cmd/protoc-gen-go@latest go install google.golang.org/grpc/cmd/protoc-gen-go-grpc@latest 验证安装 fei@feideMBP protoc % protoc-gen-go-grpc --version protoc-gen-go-grpc 1.2.0 fei@feideMBP protoc % protoc-gen-go --version protoc-gen-go v1.28.1 6.使用protoc示例 link6.1目录结构 link ./ ├── client │ └── main.go //客户端代码 ├── go.mod ├── go.sum ├── pb //pb生成的文件 │ ├── message.pb.go │ └── message_grpc.pb.go ├── proto //proto文件 │ └── message.proto ├── server //服务端入口 │ └── main.go └── serverImpl //服务端业务逻辑 └── MassageSendServerImpl.go 6.2proto文件定义 link // 定义proto的版本 syntax = \"proto3\"; // ../pb定义了生成的go文件的位置，pb是go文件的包名 option go_package = \"../pb;pb\"; // 定义响应数据 message MessageReply { string response_something = 1; } // 定义请求数据 message MessageReq { string say_something = 1; } //定义了一个service，有一个rpc方法 service MessageSender { rpc Send(MessageReq) returns (MessageReply){} } 6.3pb文件生成 link //生成数据结构相关pb文件 req resp fei@feideMBP proto % protoc --go_out=. message.proto //生成方法相关pb文件 fei@feideMBP proto % protoc --go-grpc_out=. message.proto fei@feideMBP proto % ls -l ../pb total 24 -rw-r--r-- 1 fei admin 6540 Oct 3 01:10 message.pb.go -rw-r--r-- 1 fei admin 3614 Oct 3 01:16 message_grpc.pb.go 6.4逻辑实现 linkserverImpl/MassageSendServerImpl.go package serverImpl import ( \"context\" \"log\" \"test/pb\" ) // 定义结构体: MessageSenderServerImpl 结构体嵌入了 pb.UnimplementedMessageSenderServer。这是 gRPC 自动生成的类型，用于提供默认的未实现方法，便于后续实现。 type MessageSenderServerImpl struct { *pb.UnimplementedMessageSenderServer } func (MessageSenderServerImpl) Send(ctx context.Context, req *pb.MessageReq) (*pb.MessageReply, error) { log.Printf(\"Receive Message:%s\", req.GetSaySomething()) return \u0026pb.MessageReply{ ResponseSomething: req.GetSaySomething() + \"是笨蛋\", }, nil } pb.UnimplementedMessageSenderServer\n自动生成: pb.UnimplementedMessageSenderServer 是由 Protocol Buffers (protobuf) 工具自动生成的 gRPC 服务器类型。当定义 gRPC 服务时，protobuf 会根据服务定义生成相应的代码。 它包含了所有 gRPC 方法的默认实现，这些方法通常返回错误，表示未实现。 目的: 嵌入这个类型可以让自定义的 gRPC 服务器（如 MessageSenderServerImpl）继承默认的方法实现。这意味着你不需要手动实现所有的方法，只需实现你需要的方法即可。 结构体嵌入的好处\n简化代码: 通过嵌入，避免了重复编写所有 gRPC 接口的方法。只需实现特定的方法（如 Send），其余未实现的方法将保留原有的默认行为。 保持一致性: 使用生成的未实现类型确保遵循 protobuf 定义的一致性。这降低了因手动实现而引起的不一致风险。 便于扩展: 如果将来需要添加更多的 gRPC 方法，只需在 pb 文件中定义新方法并重新生成代码，无需修改现有的实现。 server/main.go package main import ( \"google.golang.org/grpc\" \"net\" \"test/pb\" \"test/serverImpl\" ) func main() { //new一个grpc服务 gser := grpc.NewServer() //注册服务 pb.RegisterMessageSenderServer(gser, serverImpl.MessageSenderServerImpl{}) //启动gRPC tcplis, err := net.Listen(\"tcp\", \":8001\") if err != nil { panic(\"tcp启动失败:\" + err.Error()) } err = gser.Serve(tcplis) if err != nil { panic(\"grpc启动失败:\" + err.Error()) } } pb.RegisterMessageSenderServer(gser, serverImpl.MessageSenderServerImpl{}) 注册服务:\npb.RegisterMessageSenderServer是由protobuf自动生成的函数，用于将实现的服务注册到 gRPC 服务器中。 第一个参数是 gser，表示要注册服务的 gRPC 服务器实例。 第二个参数是一个具体的服务实现实例，这里使用的是serverImpl.MessageSenderServerImpl{}，它实现了 gRPC 服务的相关方法（如前面提到的 Send 方法）。 测试 link fei@feideMBP server % go run main.go 2024/10/03 03:33:52 Receive Message:虞锋 6.5客户端实现 link package main import ( \"context\" \"google.golang.org/grpc\" \"google.golang.org/grpc/credentials/insecure\" \"log\" \"test/pb\" ) func main() { //此行尝试连接运行在 localhost 上的 gRPC 服务器，端口为 8001，并使用不安全凭据。 dial, err := grpc.Dial(\"localhost:8001\", grpc.WithTransportCredentials(insecure.NewCredentials())) if err != nil { panic(\"gRPC连接失败\" + err.Error()) } log.Printf(\"gRPC建联成功\") defer dial.Close() //New一个gRPC Client对象 msc := pb.NewMessageSenderClient(dial) send, err := msc.Send(context.Background(), \u0026pb.MessageReq{ SaySomething: \"虞锋\", }) if err != nil { panic(\"gRPC请求失败\" + err.Error()) } log.Printf(\"gRPC reply:%s\", send.ResponseSomething) } 测试 link //启动服务端 fei@feideMBP server % go run main.go 2024/10/03 03:59:09 Receive Message:虞锋 //启动客户端 fei@feideMBP client % go run main.go 2024/10/03 04:00:04 gRPC建联成功 2024/10/03 04:00:04 gRPC reply:虞锋是笨蛋 "
            }
        );
    index.add(
            {
                id:  49 ,
                href: "\/docs\/dev\/golang\/6.go-gin\/",
                title: "6.Go-Gin",
                description: "Go-Gin介绍",
                content: "1.Gin介绍 link Gin 是一个高性能的Go语言Web框架，封装比较优雅，API友好，源代码比较明确。具有快速灵活，容错方便等特点。 其实对于golang而言，web框架的依赖远比Python，Java之类的要小。自身的net/http足够简单，性能也非常不错。 框架更像是一个常用函数或者工具的集合。借助框架开发，不仅可以省去很多常用的封装带来的时间，也有助于团队的编码风格和形成规范。 Gin官网:Gin Github\n2.Gin第一个应用 link package main import ( \"github.com/gin-gonic/gin\" \"net/http\" ) func main() { //实例化gin对象 ginSer := gin.Default() //定义路由：当使用 GET 方法访问路径为 /api/gin-test 时，执行回调函数 ginSer.GET(\"/api/gin-test\", func(c *gin.Context) { //在回调函数中，返回一个字符串 \"hello, go\" 并设置HTTP状态码为200 OK c.String(http.StatusOK, \"Hello Gin\") }) ginSer.Run(\":8000\") } 2.1测试 link //启动服务端 fei@feideMBP test % go run main.go [GIN-debug] [WARNING] Creating an Engine instance with the Logger and Recovery middleware already attached. [GIN-debug] [WARNING] Running in \"debug\" mode. Switch to \"release\" mode in production. - using env: export GIN_MODE=release - using code: gin.SetMode(gin.ReleaseMode) [GIN-debug] GET /api/gin-test --\u003e main.main.func1 (3 handlers) [GIN-debug] [WARNING] You trusted all proxies, this is NOT safe. We recommend you to set a value. Please check https://pkg.go.dev/github.com/gin-gonic/gin#readme-don-t-trust-all-proxies for details. [GIN-debug] Listening and serving HTTP on :8000 [GIN] 2024/10/03 - 22:34:40 | 200 | 26.316µs | 127.0.0.1 | GET \"/api/gin-test\" //测试 fei@feideMBP ~ % curl 127.0.0.1:8000/api/gin-test Hello Gin 3.Gin工作流程 link Engine容器对象,整个框架的基础 Engine.trees负责存储路由和handle方法的映射,采用类似字典树的结构 Engine.RouterGroup其中的Handlers存储着所有中间件 Context 上下文对象负责处理请求和回应,其中的handlers是存储处理请求时中间件和处理方法的 请求处理流程\n4.Gin源码分析 link4.1gin.Default() link // Default和New几乎是一模一样的，就是调用了Go泪痣的Logger，Recovery中间件 func Default() *Engine { debugPrintWARNINGDefault() engine := New() // 默认实例 // 注册中间件，中间件是一个函数，最终只要返回一个type HandlerFunc func (*Context) 就可以 engine.Use(Logger(), Recovery()) return engine } 4.2engine:=New()初始化 link通过调用gin.New()方法来实例化 Engine容器 .\n初始化Engine 将RouterGroup的Handlers(数组)设置成nil, basePath设置成/ 为了使用方便, RouteGroup里面也有一个Engine指针, 这里将刚刚初始化的engine赋值给了RouterGroup的engine指针 为了防止频繁的context GC造成效率的降低, 在Engine里使用了sync.Pool, 专门存储gin的Context func New() *Engine { debugPrintWARNINGNew() // Engine 容器对象,整个框架的基础 engine := \u0026Engine{ // 初始化语句 // Handlers 全局中间件组在注册路由时使用 RouterGroup: RouterGroup{ // Engine.RouterGroup,其中的Handlers存储着所有中间件 Handlers: nil, basePath: \"/\", root: true, }, // 树结构,保存路由和处理方法的映射 trees: make(methodTrees, 0, 9), } engine.RouterGroup.engine = engine return engine } 4.3engine.Use()注册中间件 link gin框架中的中间件设计很巧妙，可以首先从最常用的 r := gin.Default()的Default 函数开始看 它内部构造一个新的engine之后就通过Use()函数注册了Logger中间件和Recovery中间件 Use()就是gin的引入中间件的入口了 仔细分析这个函数, 不难发现Use()其实是在给RouteGroup引入中间件的. func Default() *Engine { debugPrintWARNINGDefault() engine := New() engine.Use(Logger(), Recovery()) // 默认注册的两个中间件 return engine } gin.use()调用RouterGroup.Use()往RouterGroup.Handlers写入记录 func (engine *Engine) Use(middleware ...HandlerFunc) IRoutes { engine.RouterGroup.Use(middleware...) engine.rebuild404Handlers() //注册404处理方法 engine.rebuild405Handlers() //注册405处理方法 return engine } // 其中`Handlers`字段就是一个数组,用来存储中间件 func (group *RouterGroup) Use(middleware ...HandlerFunc) IRoutes { group.Handlers = append(group.Handlers, middleware...) return group.returnObj() } 组成一条处理函数链条HandlersChain\n也就是说，我们会将一个路由的中间件函数和处理函数结合到一起组成一条处理函数链条HandlersChain 而它本质上就是一个由HandlerFunc组成的切片type HandlersChain []HandlerFunc 中间件的执行\n其中c.Next()就是很关键的一步，它的代码很简单\n从下面的代码可以看到，这里通过索引遍历HandlersChain链条，从而实现依次调用该路由的每一个函数（中间件或处理请求的函数），我们可以在中间件函数中通过再次调用c.Next()实现嵌套调用（func1中调用func2；func2中调用func3） func (c *Context) Next() { c.index++ for c.index \u003c int8(len(c.handlers)) { c.handlers[c.index](c) c.index++ } } 4.4r.GET()注册路由 link r.GET(\"/\", func(c *gin.Context) { c.String(http.StatusOK, \"hello World!\") }) 通过Get方法将路由和处理视图函数注册 func (group *RouterGroup) GET(relativePath string, handlers ...HandlerFunc) IRoutes { return group.handle(http.MethodGet, relativePath, handlers) } func (group *RouterGroup) handle(httpMethod, relativePath string, handlers HandlersChain) IRoutes { absolutePath := group.calculateAbsolutePath(relativePath) handlers = group.combineHandlers(handlers) // 将处理请求的函数与中间件函数结合 group.engine.addRoute(httpMethod, absolutePath, handlers) // 调用addRoute方法注册路由 return group.returnObj() } 这段代码就是利用method, path, 将handlers注册到engine的trees中. 注意这里为什么是HandlersChain呢, 可以简单说一下, 就是将中间件和处理函数都注册到method, path的tree中了. // tree.go // addRoute 将具有给定句柄的节点添加到路径中。 // 不是并发安全的 func (n *node) addRoute(path string, handlers HandlersChain) { fullPath := path n.priority++ numParams := countParams(path) // 数一下参数个数 // 空树就直接插入当前节点 if len(n.path) == 0 \u0026\u0026 len(n.children) == 0 { n.insertChild(numParams, path, fullPath, handlers) n.nType = root return } parentFullPathIndex := 0 walk: for { // 更新当前节点的最大参数个数 if numParams \u003e n.maxParams { n.maxParams = numParams } // 找到最长的通用前缀 // 这也意味着公共前缀不包含“:”\"或“*” / // 因为现有键不能包含这些字符。 i := longestCommonPrefix(path, n.path) // 分裂边缘（此处分裂的是当前树节点） // 例如一开始path是search，新加入support，s是他们通用的最长前缀部分 // 那么会将s拿出来作为parent节点，增加earch和upport作为child节点 if i \u003c len(n.path) { child := node{ path: n.path[i:], // 公共前缀后的部分作为子节点 wildChild: n.wildChild, indices: n.indices, children: n.children, handlers: n.handlers, priority: n.priority - 1, //子节点优先级-1 fullPath: n.fullPath, } // Update maxParams (max of all children) for _, v := range child.children { if v.maxParams \u003e child.maxParams { child.maxParams = v.maxParams } } n.children = []*node{\u0026child} // []byte for proper unicode char conversion, see #65 n.indices = string([]byte{n.path[i]}) n.path = path[:i] n.handlers = nil n.wildChild = false n.fullPath = fullPath[:parentFullPathIndex+i] } // 将新来的节点插入新的parent节点作为子节点 if i \u003c len(path) { path = path[i:] if n.wildChild { // 如果是参数节点 parentFullPathIndex += len(n.path) n = n.children[0] n.priority++ // Update maxParams of the child node if numParams \u003e n.maxParams { n.maxParams = numParams } numParams-- // 检查通配符是否匹配 if len(path) \u003e= len(n.path) \u0026\u0026 n.path == path[:len(n.path)] { // 检查更长的通配符, 例如 :name and :names if len(n.path) \u003e= len(path) || path[len(n.path)] == '/' { continue walk } } pathSeg := path if n.nType != catchAll { pathSeg = strings.SplitN(path, \"/\", 2)[0] } prefix := fullPath[:strings.Index(fullPath, pathSeg)] + n.path panic(\"'\" + pathSeg + \"' in new path '\" + fullPath + \"' conflicts with existing wildcard '\" + n.path + \"' in existing prefix '\" + prefix + \"'\") } // 取path首字母，用来与indices做比较 c := path[0] // 处理参数后加斜线情况 if n.nType == param \u0026\u0026 c == '/' \u0026\u0026 len(n.children) == 1 { parentFullPathIndex += len(n.path) n = n.children[0] n.priority++ continue walk } // 检查路path下一个字节的子节点是否存在 // 比如s的子节点现在是earch和upport，indices为eu // 如果新加一个路由为super，那么就是和upport有匹配的部分u，将继续分列现在的upport节点 for i, max := 0, len(n.indices); i \u003c max; i++ { if c == n.indices[i] { parentFullPathIndex += len(n.path) i = n.incrementChildPrio(i) n = n.children[i] continue walk } } // 否则就插入 if c != ':' \u0026\u0026 c != '*' { // []byte for proper unicode char conversion, see #65 // 注意这里是直接拼接第一个字符到n.indices n.indices += string([]byte{c}) child := \u0026node{ maxParams: numParams, fullPath: fullPath, } // 追加子节点 n.children = append(n.children, child) n.incrementChildPrio(len(n.indices) - 1) n = child } n.insertChild(numParams, path, fullPath, handlers) return } // 已经注册过的节点 if n.handlers != nil { panic(\"handlers are already registered for path '\" + fullPath + \"'\") } n.handlers = handlers return } } 4.5r.run()启动服务 link 通过调用net/http来启动服务,由于engine实现了ServeHTTP方法 只需要直接传engine对象就可以完成初始化并启动 //r.Run() func (engine *Engine) Run(addr ...string) (err error) { defer func() { debugPrintError(err) }() address := resolveAddress(addr) debugPrint(\"Listening and serving HTTP on %s\\n\", address) err = http.ListenAndServe(address, engine) // gin使用net/http模块 return } func ListenAndServe(addr string, handler Handler) error { server := \u0026Server{Addr: addr, Handler: handler} return server.ListenAndServe() } //来自 net/http 定义的接口,只要实现了这个接口就可以作为处理请求的函数 type Handler interface { ServeHTTP(ResponseWriter, *Request) } //实现了ServeHTTP方法 func (engine *Engine) ServeHTTP(w http.ResponseWriter, req *http.Request) { c := engine.pool.Get().(*Context) c.writermem.reset(w) c.Request = req c.reset() engine.handleHTTPRequest(c) engine.pool.Put(c) } 5.Gin路由与传参 link5.1无参路由 link package main import ( \"github.com/gin-gonic/gin\" \"log\" \"net/http\" ) func HelloGinHandler(c *gin.Context) { // gin.Context，封装了request和response c.String(http.StatusOK, \"Hello Gin\") } func main() { //实例化gin对象 ginSer := gin.Default() // 基本路由 /hello/ ginSer.GET(\"/hello\", HelloGinHandler) log.Printf(\"PATH: %s\", \"http://127.0.0.1:8000\") ginSer.Run(\":8000\") } 5.2api参数 link package main import ( \"fmt\" \"github.com/gin-gonic/gin\" \"log\" \"net/http\" ) // uri路径传参 func GetBookDetailHandler(c *gin.Context) { bookId := c.Param(\"id\") c.String(http.StatusOK, fmt.Sprintf(\"成功获取书籍详情：%s\", bookId)) } // ?号传参 func GetUserDetailHandler(c *gin.Context) { username := c.Query(\"name\") // gin.Context，封装了request和response c.String(http.StatusOK, fmt.Sprintf(\"成功获取用户详情：%s\", username)) } // 组合使用 func GetFoodDetailHandler(c *gin.Context) { Food := c.Param(\"name\") Weight := c.Query(\"weight\") c.String(http.StatusOK, fmt.Sprintf(\"成功获取食物：%s，重%v斤\", Food, Weight)) } func main() { //实例化gin对象 ginSer := gin.Default() //注册路由 ginSer.GET(\"/book/:id\", GetBookDetailHandler) ginSer.GET(\"/user\", GetUserDetailHandler) ginSer.GET(\"/food/:name\", GetFoodDetailHandler) log.Printf(\"PATH: %s\", \"http://127.0.0.1:8000\") ginSer.Run(\":8000\") } 测试 fei@feideMBP ~ % curl 127.0.0.1:8000/book/9623503 成功获取书籍详情：9623503 fei@feideMBP ~ % curl 127.0.0.1:8000/user?name=虞锋 成功获取用户详情：虞锋 fei@feideMBP ~ % curl 127.0.0.1:8000/food/cake?weight=256 成功获取食物：cake，重256斤 5.3ShouldBind参数绑定 linkGin提供了一个更加便捷、开发效率更高的方法获取参数，也就是参数绑定。\n我们可以基于请求的Content-Type识别请求数据类型并利用反射机制 自动提取请求中QueryString、form表单、JSON、XML等参数到结构体中。 下面的示例代码将演示.ShouldBind()强大的功能，它能够自动提取基于querystring、form、json、path的参数，并把值绑定到指定的结构体对象。 package main import ( \"github.com/gin-gonic/gin\" \"log\" \"net/http\" ) /* binding 用于必填参数校验、 json 用于将application/json请求绑定到结构体、 form 用于将multipart/form-data请求绑定到结构体 */ type Login struct { Username string `form:\"username\" json:\"username\" binding:\"required\"` Password string `form:\"password\" json:\"password\" binding:\"required\"` } func LoginHandler(c *gin.Context) { login := \u0026Login{} //GET请求一般使用form标签 //application/json一般是POST、PUT、DELETE if err := c.ShouldBind(\u0026login); err != nil { //gin.H 为一个map c.JSON(http.StatusOK, gin.H{ \"msg\": \"绑定参数失败\" + err.Error(), \"data\": nil, \"code\": 90400, }) return } c.JSON(http.StatusOK, gin.H{ \"msg\": \"绑定参数成功\", \"data\": login, \"code\": 90200, }) } func main() { //实例化gin对象 ginSer := gin.Default() //注册路由 ginSer.POST(\"/login\", LoginHandler) ginSer.GET(\"/login\", LoginHandler) log.Printf(\"PATH: %s\", \"http://127.0.0.1:8000\") ginSer.Run(\":8000\") } 测试 POST json测试 fei@feideMBP ~ % curl --location 'http://127.0.0.1:8000/login' \\ --header 'Content-Type: application/json' \\ --data '{ \"username\": \"fei\", \"password\": \"123456\" }' {\"code\":90200,\"data\":{\"username\":\"fei\",\"password\":\"123456\"},\"msg\":\"绑定参数成功\"} fei@feideMBP ~ % curl --location 'http://127.0.0.1:8000/login' \\ --header 'Content-Type: application/json' \\ --data '{ \"username\": \"fei\" }' {\"code\":90400,\"data\":null,\"msg\":\"绑定参数失败Key: 'Login.Password' Error:Field validation for 'Password' failed on the 'required' tag\"} GET form测试 fei@feideMBP ~ % curl --location --request GET 'http://127.0.0.1:8000/login' \\ --form 'username=\"fly\"' \\ --form 'password=\"123456\"' {\"code\":90200,\"data\":{\"username\":\"fly\",\"password\":\"123456\"},\"msg\":\"绑定参数成功\"} fei@feideMBP ~ % curl --location --request GET 'http://127.0.0.1:8000/login' \\ --form 'username=\"fly\"' {\"code\":90400,\"data\":null,\"msg\":\"绑定参数失败Key: 'Login.Password' Error:Field validation for 'Password' failed on the 'required' tag\"} 5.4重定向 link package main import ( \"github.com/gin-gonic/gin\" \"log\" \"net/http\" ) func main() { //实例化gin对象 ginSer := gin.Default() //重定向 ginSer.GET(\"/remove\", func(context *gin.Context) { context.Redirect(http.StatusMovedPermanently, \"https://cakepanit.com\") }) log.Printf(\"PATH: %s\", \"http://127.0.0.1:8000\") ginSer.Run(\":8000\") } 测试 fei@feideMBP ~ % curl -i http://127.0.0.1:8000/remove HTTP/1.1 301 Moved Permanently Content-Type: text/html; charset=utf-8 Location: https://cakepanit.com Date: Fri, 04 Oct 2024 16:17:13 GMT Content-Length: 56 Moved Permanently. 5.5路由分发 link目录结构 fei@feideMBP test % tree ./ ./ ├── go.mod ├── go.sum ├── main.go └── routers ├── book.go └── user.go router1 package routers import ( \"github.com/gin-gonic/gin\" \"net/http\" ) func UserHandler(c *gin.Context) { c.JSON(http.StatusOK, gin.H{ \"msg\": \"User Router\", \"data\": nil, \"code\": \"90200\", }) } // 在main中初始化gin对象之后，调用此方法传入gin对象，就注册了这个路由 func LoadUsers(r *gin.Engine) { r.GET(\"/users\", UserHandler) } router2 package routers import ( \"github.com/gin-gonic/gin\" \"net/http\" ) func BookHandler(c *gin.Context) { c.JSON(http.StatusOK, gin.H{ \"msg\": \"Book Router\", \"data\": nil, \"code\": \"90200\", }) } // 在main中初始化gin对象之后，调用此方法传入gin对象，就注册了这个路由 func LoadBooks(r *gin.Engine) { r.GET(\"/books\", BookHandler) } main package main import ( \"github.com/gin-gonic/gin\" \"log\" \"test/routers\" ) func main() { //实例化gin对象 ginSer := gin.Default() //注册路由 routers.LoadUsers(ginSer) routers.LoadBooks(ginSer) log.Printf(\"PATH: %s\", \"http://127.0.0.1:8000\") ginSer.Run(\":8000\") } 测试 fei@feideMBP ~ % curl http://127.0.0.1:8000/users {\"code\":\"90200\",\"data\":null,\"msg\":\"User Router\"} fei@feideMBP ~ % curl http://127.0.0.1:8000/books {\"code\":\"90200\",\"data\":null,\"msg\":\"Book Router\"} 5.6routes group link routes group是为了管理一些相同的URL package main import ( \"github.com/gin-gonic/gin\" \"fmt\" ) // gin的helloWorld func main() { // 1.创建路由 // 默认使用了2个中间件Logger(), Recovery() r := gin.Default() // 路由组1 ，处理GET请求 v1 := r.Group(\"/v1\") // {} 是书写规范 { v1.GET(\"/login\", login) v1.GET(\"submit\", submit) } v2 := r.Group(\"/v2\") { v2.POST(\"/login\", login) v2.POST(\"/submit\", submit) } r.Run(\":8000\") } func login(c *gin.Context) { name := c.DefaultQuery(\"name\", \"jack\") c.String(200, fmt.Sprintf(\"hello %s\\n\", name)) } func submit(c *gin.Context) { name := c.DefaultQuery(\"name\", \"lily\") c.String(200, fmt.Sprintf(\"hello %s\\n\", name)) } 6.Gin中间件 link Gin框架允许开发者在处理请求的过程中，加入用户自己的钩子（Hook）函数。 这个钩子函数就叫中间件，中间件适合处理一些公共的业务逻辑 比如登录认证、权限校验、数据分页、记录日志、耗时统计等。 6.1全局中间件 link 所有请求都经过此中间件 中间件中没有调用next方法，先走完中间件才会执行视图函数 package main import ( \"github.com/gin-gonic/gin\" \"log\" \"time\" ) // 定义中间件 func MiddleWare() gin.HandlerFunc { return func(c *gin.Context) { nowTime := time.Now() log.Printf(\"中间件开始执行,%v\", nowTime) //设置变了到Context的key中，可以通过Get()取 c.Set(\"middle\", \"全局中间件\") status := c.Writer.Status() //获取状态码 sinceTime := time.Since(nowTime) log.Printf(\"中间件执行完毕,%v,%v\", sinceTime, status) } } func main() { //实例化gin对象 ginSer := gin.Default() //注册全局中间件 ginSer.Use(MiddleWare()) { ginSer.GET(\"/Global\", func(c *gin.Context) { //取中间件set的值 middleValue, _ := c.Get(\"middle\") c.JSON(200, gin.H{ \"msg\": \"执行成功\", \"data\": middleValue, \"code\": \"90200\", }) }) } log.Printf(\"PATH: %s\", \"http://127.0.0.1:8000\") ginSer.Run(\":8000\") } 测试 fei@feideMBP test % go run main.go [GIN-debug] [WARNING] Creating an Engine instance with the Logger and Recovery middleware already attached. [GIN-debug] [WARNING] Running in \"debug\" mode. Switch to \"release\" mode in production. - using env: export GIN_MODE=release - using code: gin.SetMode(gin.ReleaseMode) [GIN-debug] GET /Global --\u003e main.main.func1 (4 handlers) 2024/10/05 01:23:11 PATH: http://127.0.0.1:8000 [GIN-debug] [WARNING] You trusted all proxies, this is NOT safe. We recommend you to set a value. Please check https://pkg.go.dev/github.com/gin-gonic/gin#readme-don-t-trust-all-proxies for details. [GIN-debug] Listening and serving HTTP on :8000 2024/10/05 01:23:30 中间件开始执行,2024-10-05 01:23:30.308065 +0800 CST m=+18.718944754 2024/10/05 01:23:30 中间件执行完毕,29.735µs,200 [GIN] 2024/10/05 - 01:23:30 | 200 | 71.342µs | 127.0.0.1 | GET \"/Global\" fei@feideMBP ~ % curl http://127.0.0.1:8000/Global {\"code\":\"90200\",\"data\":\"全局中间件\",\"msg\":\"执行成功\"} 6.2局部中间件 link 局部中间件只会在局部执行 package main import ( \"github.com/gin-gonic/gin\" \"log\" \"time\" ) // 定义中间件 func MiddleWare() gin.HandlerFunc { return func(c *gin.Context) { nowTime := time.Now() log.Printf(\"中间件开始执行,%v\", nowTime) //设置变了到Context的key中，可以通过Get()取 c.Set(\"middle\", \"局部中间件\") status := c.Writer.Status() //获取状态码 sinceTime := time.Since(nowTime) log.Printf(\"中间件执行完毕,%v,%v\", sinceTime, status) } } func main() { //实例化gin对象 ginSer := gin.Default() //注册局部中间件，只对当前方法生效 ginSer.GET(\"/Global\", MiddleWare(), func(c *gin.Context) { //取中间件set的值 middleValue, _ := c.Get(\"middle\") c.JSON(200, gin.H{ \"msg\": \"执行成功\", \"data\": middleValue, \"code\": \"90200\", }) }) log.Printf(\"PATH: %s\", \"http://127.0.0.1:8000\") ginSer.Run(\":8000\") } 测试 fei@feideMBP test % go run main.go [GIN-debug] [WARNING] Creating an Engine instance with the Logger and Recovery middleware already attached. [GIN-debug] [WARNING] Running in \"debug\" mode. Switch to \"release\" mode in production. - using env: export GIN_MODE=release - using code: gin.SetMode(gin.ReleaseMode) [GIN-debug] GET /Global --\u003e main.main.func1 (4 handlers) 2024/10/05 01:27:47 PATH: http://127.0.0.1:8000 [GIN-debug] [WARNING] You trusted all proxies, this is NOT safe. We recommend you to set a value. Please check https://pkg.go.dev/github.com/gin-gonic/gin#readme-don-t-trust-all-proxies for details. [GIN-debug] Listening and serving HTTP on :8000 2024/10/05 01:27:50 中间件开始执行,2024-10-05 01:27:50.421581 +0800 CST m=+3.358432915 2024/10/05 01:27:50 中间件执行完毕,50.829µs,200 [GIN] 2024/10/05 - 01:27:50 | 200 | 90.149µs | 127.0.0.1 | GET \"/Global\" fei@feideMBP ~ % curl http://127.0.0.1:8000/Global {\"code\":\"90200\",\"data\":\"局部中间件\",\"msg\":\"执行成功\"} 6.3Next()方法 link 在中间件中调用next()方法，会从next()方法调用的地方跳转到下一个视图函数（可能是中间件也可能是业务方法） 中间件代码最后即使没有调用Next()方法，后续中间件及handlers也会执行； 如果在中间件函数的非结尾调用Next()方法当前中间件剩余代码会被暂停执行，会先去执行后续中间件及handlers，等这些handlers全部执行完以后程序控制权会回到当前中间件继续执行剩余代码； package main import ( \"github.com/gin-gonic/gin\" \"log\" \"time\" ) // 定义中间件 func MiddleWare1() gin.HandlerFunc { return func(c *gin.Context) { nowTime := time.Now() log.Printf(\"中间件1开始执行,%v\", nowTime) c.Next() sinceTime := time.Since(nowTime) log.Printf(\"中间件1执行完毕,%v\", sinceTime) } } func MiddleWare2() gin.HandlerFunc { return func(c *gin.Context) { nowTime := time.Now() log.Printf(\"中间件2开始执行,%v\", nowTime) c.Next() sinceTime := time.Since(nowTime) log.Printf(\"中间件2执行完毕,%v\", sinceTime) } } func main() { //实例化gin对象 ginSer := gin.Default() //注册局部中间件，只对当前方法生效 ginSer.GET(\"/Global\", MiddleWare1(), MiddleWare2(), func(c *gin.Context) { c.JSON(200, gin.H{ \"msg\": \"执行成功\", \"data\": \"Next测试\", \"code\": \"90200\", }) log.Printf(\"业务视图执行完成\") }) log.Printf(\"PATH: %s\", \"http://127.0.0.1:8000\") ginSer.Run(\":8000\") } 测试 fei@feideMBP test % go run main.go [GIN-debug] [WARNING] Creating an Engine instance with the Logger and Recovery middleware already attached. [GIN-debug] [WARNING] Running in \"debug\" mode. Switch to \"release\" mode in production. - using env: export GIN_MODE=release - using code: gin.SetMode(gin.ReleaseMode) [GIN-debug] GET /Global --\u003e main.main.func1 (5 handlers) 2024/10/05 02:16:33 PATH: http://127.0.0.1:8000 [GIN-debug] [WARNING] You trusted all proxies, this is NOT safe. We recommend you to set a value. Please check https://pkg.go.dev/github.com/gin-gonic/gin#readme-don-t-trust-all-proxies for details. [GIN-debug] Listening and serving HTTP on :8000 2024/10/05 02:16:37 中间件1开始执行,2024-10-05 02:16:37.29812 +0800 CST m=+3.993203377 2024/10/05 02:16:37 中间件2开始执行,2024-10-05 02:16:37.298147 +0800 CST m=+3.993230463 2024/10/05 02:16:37 业务视图执行完成 2024/10/05 02:16:37 中间件2执行完毕,71.999µs 2024/10/05 02:16:37 中间件1执行完毕,102.562µs [GIN] 2024/10/05 - 02:16:37 | 200 | 106.552µs | 127.0.0.1 | GET \"/Global\" fei@feideMBP ~ % curl http://127.0.0.1:8000/Global {\"code\":\"90200\",\"data\":\"Next测试\",\"msg\":\"执行成功\"} 6.5Abort()方法 link 如果想中断剩余中间件及handlers应该使用Abort方法，但需要注意当前中间件的剩余代码会继续执行。 package main import ( \"github.com/gin-gonic/gin\" \"log\" \"time\" ) // 定义中间件 func MiddleWare1() gin.HandlerFunc { return func(c *gin.Context) { nowTime := time.Now() log.Printf(\"中间件1开始执行,%v\", nowTime) //中断后续Handler执行 c.Abort() sinceTime := time.Since(nowTime) log.Printf(\"中间件1执行完毕,%v\", sinceTime) } } func MiddleWare2() gin.HandlerFunc { return func(c *gin.Context) { nowTime := time.Now() log.Printf(\"中间件2开始执行,%v\", nowTime) c.Next() sinceTime := time.Since(nowTime) log.Printf(\"中间件2执行完毕,%v\", sinceTime) } } func main() { //实例化gin对象 ginSer := gin.Default() //注册局部中间件，只对当前方法生效 ginSer.GET(\"/Global\", MiddleWare1(), MiddleWare2(), func(c *gin.Context) { c.JSON(200, gin.H{ \"msg\": \"执行成功\", \"data\": \"Next测试\", \"code\": \"90200\", }) log.Printf(\"业务视图执行完成\") }) log.Printf(\"PATH: %s\", \"http://127.0.0.1:8000\") ginSer.Run(\":8000\") } 测试 fei@feideMBP test % go run main.go [GIN-debug] [WARNING] Creating an Engine instance with the Logger and Recovery middleware already attached. [GIN-debug] [WARNING] Running in \"debug\" mode. Switch to \"release\" mode in production. - using env: export GIN_MODE=release - using code: gin.SetMode(gin.ReleaseMode) [GIN-debug] GET /Global --\u003e main.main.func1 (5 handlers) 2024/10/05 02:27:05 PATH: http://127.0.0.1:8000 [GIN-debug] [WARNING] You trusted all proxies, this is NOT safe. We recommend you to set a value. Please check https://pkg.go.dev/github.com/gin-gonic/gin#readme-don-t-trust-all-proxies for details. [GIN-debug] Listening and serving HTTP on :8000 2024/10/05 02:27:14 中间件1开始执行,2024-10-05 02:27:14.554943 +0800 CST m=+9.109470469 2024/10/05 02:27:14 中间件1执行完毕,54.262µs [GIN] 2024/10/05 - 02:27:14 | 200 | 58.93µs | 127.0.0.1 | GET \"/Global\" fei@feideMBP ~ % curl http://127.0.0.1:8000/Global fei@feideMBP ~ % 7.Gin-AuthDemo link 用Gin实现一个简单的鉴权 package main import ( \"github.com/gin-gonic/gin\" \"log\" \"net/http\" ) // 定义中间件 func AuthMiddleWare() gin.HandlerFunc { return func(c *gin.Context) { if Token := c.Request.Header.Get(\"token\"); Token == \"\" { c.JSON(http.StatusForbidden, gin.H{ \"msg\": \"鉴权失败\", }) log.Printf(\"鉴权失败\") c.Abort() } } } func main() { //实例化gin对象 ginSer := gin.Default() //注册局部中间件，只对当前方法生效 ginSer.GET(\"/index\", AuthMiddleWare(), func(c *gin.Context) { c.JSON(http.StatusOK, gin.H{ \"msg\": \"鉴权成功\", \"data\": \"Welcome to my homepage\", \"code\": \"90200\", }) log.Printf(\"业务视图执行完成\") }) log.Printf(\"PATH: %s\", \"http://127.0.0.1:8000\") ginSer.Run(\":8000\") } 测试 fei@feideMBP test % go run main.go [GIN-debug] [WARNING] Creating an Engine instance with the Logger and Recovery middleware already attached. [GIN-debug] [WARNING] Running in \"debug\" mode. Switch to \"release\" mode in production. - using env: export GIN_MODE=release - using code: gin.SetMode(gin.ReleaseMode) [GIN-debug] GET /index --\u003e main.main.func1 (4 handlers) 2024/10/05 02:47:52 PATH: http://127.0.0.1:8000 [GIN-debug] [WARNING] You trusted all proxies, this is NOT safe. We recommend you to set a value. Please check https://pkg.go.dev/github.com/gin-gonic/gin#readme-don-t-trust-all-proxies for details. [GIN-debug] Listening and serving HTTP on :8000 2024/10/05 02:48:01 鉴权失败 [GIN] 2024/10/05 - 02:48:01 | 403 | 224.271µs | 127.0.0.1 | GET \"/index\" 2024/10/05 02:48:10 业务视图执行完成 [GIN] 2024/10/05 - 02:48:10 | 200 | 66.163µs | 127.0.0.1 | GET \"/index\" fei@feideMBP ~ % curl --location 'http://127.0.0.1:8000/index' {\"msg\":\"鉴权失败\"} fei@feideMBP ~ % curl --location 'http://127.0.0.1:8000/index' \\ --header 'token: 123456' {\"code\":\"90200\",\"data\":\"Welcome to my homepage\",\"msg\":\"鉴权成功\"} "
            }
        );
    index.add(
            {
                id:  50 ,
                href: "\/docs\/dev\/golang\/7.go-gorm\/",
                title: "7.Go-GORM",
                description: "Go-GORM介绍",
                content: "1.什么是ORM？ linkorm是一种术语而不是软件\norm英文全称object relational mapping,就是 ==对象映射关系== 程序； 简单来说类似python这种面向对象的程序来说一切皆对象，但是我们使用的数据库却都是关系型的； 为了保证一致的使用习惯，通过 orm将编程语言的对象模型和数据库的关系模型建立映射关系； 这样我们直接 使用编程语言的对象模型进行操作数据库 就可以了，而不用直接使用sql语言； 2.什么是GORM？ linkGORM 官方文档\n全功能 ORM (无限接近) 关联 (Has One, Has Many, Belongs To, Many To Many, 多态) 钩子 (在创建/保存/更新/删除/查找之前或之后) 预加载 事务 复合主键 SQL 生成器 数据库自动迁移 自定义日志 可扩展性, 可基于 GORM 回调编写插件 所有功能都被测试覆盖 开发者友好 3.GORM(v2)基本使用 link3.1安装 link go get -u gorm.io/gorm 4.准备MySQL环境 link4.1docker拉起一个mysql link docker run --name fly-mysql -e MYSQL_ROOT_PASSWORD=123456 -p 3306:3306 -d mysql:8.0 4.2创建数据库 link create database test_db charset utf8mb4; use test_db; show tables; 4.3连接数据库 link package main import ( \"gorm.io/driver/mysql\" \"gorm.io/gorm\" ) // 数据库初始化 func main() { //定义db连接串 //parseTime=True\u0026loc=Local //parseTime查询结果示范自带解析为时间。查询数据时将mysql_datetime字段字段转成go_time.time //loc是mysql的时区设置 dsn := \"root:123456@tcp(127.0.0.1:3306)/test_db?charset=utf8mb4\u0026parseTime=True\u0026loc=Local\" //建立连接 mdb, err := gorm.Open(mysql.Open(dsn), \u0026gorm.Config{}) if err != nil { panic(err) } } 4.4自动迁移表 link package main import ( \"gorm.io/driver/mysql\" \"gorm.io/gorm\" ) // 1.表对应的struct type User struct { ID int64 `gorm:\"primary_key\"` Username string Password string } // 2.自定义表名 func (*User) TableName() string { return \"user_t\" } // 数据库初始化 func main() { dsn := \"root:123456@tcp(127.0.0.1:3306)/test_db?charset=utf8mb4\u0026parseTime=True\u0026loc=Local\" //0.建立连接 mdb, err := gorm.Open(mysql.Open(dsn), \u0026gorm.Config{}) if err != nil { panic(err) } //3.自带创建表，AutoMigrate没有建立映射关系 // 用于项目初始化自动创建表 mdb.AutoMigrate(User{}) } 5.增删改查 link 增 package main import ( \"gorm.io/driver/mysql\" \"gorm.io/gorm\" ) // 1.表对应的struct type User struct { ID int64 `gorm:\"primary_key\"` Username string Password string } // 2.自定义表名 func (*User) TableName() string { return \"user\" } // 数据库初始化 func main() { dsn := \"root:123456@tcp(127.0.0.1:3306)/test_db?charset=utf8mb4\u0026parseTime=True\u0026loc=Local\" //0.建立连接 mdb, err := gorm.Open(mysql.Open(dsn), \u0026gorm.Config{}) if err != nil { panic(err) } //3.自带创建表，AutoMigrate没有建立映射关系 // 用于项目初始化自动创建表，已存在不会重复创建 mdb.AutoMigrate(User{}) //新增 mdb.Create(\u0026User{ //ID: 0, 自增属性不需要控制，所以注释掉 Username: \"sky\", Password: \"123456\", }) } 测试 fei@feideMBP 03crud % go run main.go fei@feideMBP 03crud % mysql\u003e select * from user; +----+----------+----------+ | id | username | password | +----+----------+----------+ | 1 | sky | 123456 | +----+----------+----------+ 1 row in set (0.00 sec) 改 package main import ( \"gorm.io/driver/mysql\" \"gorm.io/gorm\" ) // 1.表对应的struct type User struct { ID int64 `gorm:\"primary_key\"` Username string Password string } // 2.自定义表名 func (*User) TableName() string { return \"user\" } // 数据库初始化 func main() { dsn := \"root:123456@tcp(127.0.0.1:3306)/test_db?charset=utf8mb4\u0026parseTime=True\u0026loc=Local\" //0.建立连接 mdb, err := gorm.Open(mysql.Open(dsn), \u0026gorm.Config{}) if err != nil { panic(err) } //3.自带创建表，AutoMigrate没有建立映射关系 // 用于项目初始化自动创建表，已存在不会重复创建 mdb.AutoMigrate(User{}) //新增 (必须接收指针类型) mdb.Create(\u0026User{ //ID: 0, 自增属性不需要控制，所以注释掉 Username: \"sky02\", Password: \"123456\", }) //修改 id := 1 //where 里面是原生的查询条件 mdb.Model(User{}).Where(\"id = ?\", id).Update(\"username\", \"fei\") /* 等价于： UPDATE user SET username='fei' WHERE id=1; Model()传入User结构体，自动去找该结构体小写复数即users，如果指定了func (*User) TableName() string 方法则找方法中对应的表名。 其他写法 mdb.Model(User{ID: 1,}).Update(\"username\", \"fei\") mdb.Table(\"user\").Where(\"id = ?\", id).Update(\"username\", \"fei\") */ } 测试 fei@feideMBP 03crud % go run main.go fei@feideMBP 03crud % mysql\u003e select * from user; +----+----------+----------+ | id | username | password | +----+----------+----------+ | 1 | fei | 123456 | | 2 | sky02 | 123456 | +----+----------+----------+ 2 rows in set (0.00 sec) //将第一次加的sky改名成了fei //第二次运行的create 又插入了一条数据 查 package main import ( \"gorm.io/driver/mysql\" \"gorm.io/gorm\" \"log\" ) // 1.表对应的struct type User struct { ID int64 `gorm:\"primary_key\"` Username string Password string } // 2.自定义表名 func (*User) TableName() string { return \"user\" } // 数据库初始化 func main() { dsn := \"root:123456@tcp(127.0.0.1:3306)/test_db?charset=utf8mb4\u0026parseTime=True\u0026loc=Local\" //0.建立连接 mdb, err := gorm.Open(mysql.Open(dsn), \u0026gorm.Config{}) if err != nil { panic(err) } //3.自带创建表，AutoMigrate没有建立映射关系 // 用于项目初始化自动创建表，已存在不会重复创建 mdb.AutoMigrate(User{}) //查询 第一种 u := \u0026User{ID: 1} mdb.First(u) log.Printf(\"第一种查询写法：%v\", u) //查询 第二种 u2 := \u0026User{} mdb.Where(\"id = ?\", 2).First(u2) log.Printf(\"第二种查询写法：%v\", u2) //查询所有数据 users := []User{} mdb.Find(\u0026users) log.Printf(\"查询全部：%v\", users) } 测试 fei@feideMBP 03crud % go run main.go 2024/10/05 22:47:25 第一种查询写法：\u0026{1 fei 123456} 2024/10/05 22:47:25 第二种查询写法：\u0026{2 sky02 123456} 2024/10/05 22:47:25 查询全部：[{1 fei 123456} {2 sky02 123456}] 删 package main import ( \"gorm.io/driver/mysql\" \"gorm.io/gorm\" \"log\" ) // 1.表对应的struct type User struct { ID int64 `gorm:\"primary_key\"` Username string Password string } // 2.自定义表名 func (*User) TableName() string { return \"user\" } // 数据库初始化 func main() { dsn := \"root:123456@tcp(127.0.0.1:3306)/test_db?charset=utf8mb4\u0026parseTime=True\u0026loc=Local\" //0.建立连接 mdb, err := gorm.Open(mysql.Open(dsn), \u0026gorm.Config{}) if err != nil { panic(err) } //3.自带创建表，AutoMigrate没有建立映射关系 // 用于项目初始化自动创建表，已存在不会重复创建 mdb.AutoMigrate(User{}) users := []User{} mdb.Find(\u0026users) log.Printf(\"删除前查询全部：%v\", users) //删除，传入结构体表示在哪张表中删除 mdb.Where(\"id = ?\", 1).Delete(\u0026User{}) log.Printf(\"删除完成\") //查询所有数据 mdb.Find(\u0026users) log.Printf(\"删除后查询全部：%v\", users) } 测试 fei@feideMBP 03crud % go run main.go 2024/10/05 22:53:38 删除前查询全部：[{1 fei 123456} {2 sky02 123456}] 2024/10/05 22:53:38 删除完成 2024/10/05 22:53:38 删除后查询全部：[{2 sky02 123456}] 5.1错误处理 link package main import ( \"gorm.io/driver/mysql\" \"gorm.io/gorm\" \"log\" ) // 1.表对应的struct type User struct { ID int64 `gorm:\"primary_key\"` Username string Password string } // 2.自定义表名 func (*User) TableName() string { return \"user\" } // 数据库初始化 func main() { dsn := \"root:123456@tcp(127.0.0.1:3306)/test_db?charset=utf8mb4\u0026parseTime=True\u0026loc=Local\" //0.建立连接 mdb, err := gorm.Open(mysql.Open(dsn), \u0026gorm.Config{}) if err != nil { panic(err) } //3.自带创建表，AutoMigrate没有建立映射关系 // 用于项目初始化自动创建表，已存在不会重复创建 mdb.AutoMigrate(User{}) users := []User{} mdb.Find(\u0026users) log.Printf(\"查询全部：%v\", users) //错误处理演示 u2 := \u0026User{} tx := mdb.Where(\"id = ?\", 1).First(u2) //注意，tx.Error。查询出的数据为空也会算成err \"record not found\" if tx.Error != nil { log.Printf(\"查询报错\") } //处理方式 if tx.Error != nil \u0026\u0026 tx.Error != gorm.ErrRecordNotFound { log.Printf(\"查询报错2\") } } 测试 fei@feideMBP 03crud % go run main.go 2024/10/05 23:03:24 查询全部：[{2 sky02 123456}] 2024/10/05 23:03:24 /Volumes/data/go/src/test/03crud/main.go:41 record not found [1.660ms] [rows:0] SELECT * FROM `user` WHERE id = 1 ORDER BY `user`.`id` LIMIT 1 2024/10/05 23:03:24 查询报错 6.模型定义 link文档参考\n6.1模型定义 link 模型一般都是普通的 Golang 的结构体，Go的基本数据类型，或者指针。 package main import ( \"gorm.io/driver/mysql\" \"gorm.io/gorm\" \"time\" ) // 不建议将字段属性放到结构体中定义 type User struct { Id int64 `gorm:\"primary_key\" json:\"id\"` Name string CreatedAt *time.Time `json:\"createdAt\" gorm:\"column:create_at\"` //定义字段名 Email string `gorm:\"type:varchar(100);unique_index\"` // 唯一索引 Role string `gorm:\"size:255\"` //设置字段的大小为255个字节 MemberNumber *string `gorm:\"unique;not null\"` // 设置字段唯一，且不为空 Num int `gorm:\"AUTO_INCREMENT\"` // 设置 Num字段自增 Address string `gorm:\"index:addr\"` // 给Address 创建一个名字是 `addr`的索引 IgnoreMe int `gorm:\"-\"` //忽略这个字段 } func main() { dsn := \"root:123456@tcp(127.0.0.1:3306)/test_db?charset=utf8mb4\u0026parseTime=True\u0026loc=Local\" //0.建立连接 mdb, err := gorm.Open(mysql.Open(dsn), \u0026gorm.Config{}) if err != nil { panic(err) } //3.自带创建表，AutoMigrate没有建立映射关系 // 用于项目初始化自动创建表，已存在不会重复创建 mdb.AutoMigrate(User{}) } 测试 fei@feideMBP 04mode % go run main.go fei@feideMBP 04mode % mysql\u003e desc users; +---------------+--------------+------+-----+---------+----------------+ | Field | Type | Null | Key | Default | Extra | +---------------+--------------+------+-----+---------+----------------+ | id | bigint | NO | PRI | NULL | auto_increment | | name | longtext | YES | | NULL | | | create_at | datetime(3) | YES | | NULL | | | email | varchar(100) | YES | | NULL | | | role | varchar(255) | YES | | NULL | | | member_number | varchar(191) | NO | UNI | NULL | | | num | bigint | YES | | NULL | | | address | varchar(191) | YES | MUL | NULL | | +---------------+--------------+------+-----+---------+----------------+ 8 rows in set (0.01 sec) 6.2支持结构标签\n标签是声明模型时可选的标记。 标签 说明 Column 指定列的名称 Type 指定列的类型 Size 指定列的大小，默认是 255 PRIMARY_KEY 指定一个列作为主键 UNIQUE 指定一个唯一的列 DEFAULT 指定一个列的默认值 PRECISION 指定列的数据的精度 NOT NULL 指定列的数据不为空 AUTO_INCREMENT 指定一个列的数据是否自增 INDEX 创建带或不带名称的索引，同名创建复合索引 UNIQUE_INDEX 类似 索引 ，创建一个唯一的索引 EMBEDDED 将 struct 设置为 embedded EMBEDDED_PREFIX 设置嵌入式结构的前缀名称 - 忽略这些字段 7.一对多 link7.1has many介绍 linkhttps://gorm.io/zh_CN/docs/has_many.html\nhas many关联就是创建和另一个模型的一对多关系。不同于has one，拥有者可以有零或多个关联模型。 例如，例如每一个用户都拥有多张信用卡，这样就是生活中一个简单的一对多关系。 // 用户有多张信用卡，UserID 是外键 type User struct { gorm.Model CreditCards []*CreditCard } // 必须要写UserID这个外键属性 type CreditCard struct { gorm.Model Number string UserID uint // 默认会在 CreditCard 表中生成 UserID 字段作为 与User表关联的外键ID } // mdb.AutoMigrate(User{}, CreditCard{}) 7.2外键 link 为了定义一对多关系， 外键是必须存在的，默认外键的名字是所有者类型的名字加上它的主键(UserId) 。 就像上面的例子，为了定义一个属于 User 的模型，外键就应该为 UserID。 使用其他的字段名作为外键， 可以通过foreignkey来定制它。 type User struct { gorm.Model // foreignkey:UserRefer 可以自己指定外键关联字段名为：UserRefer // 默认外键字段名是 UserId，你也可以自己修改 CreditCards []CreditCard `gorm:\"foreignkey:UserRefer\"` } type CreditCard struct { gorm.Model Number string UserRefer uint } // mdb.AutoMigrate(User{}, CreditCard{}) 7.3外键关联 link GORM通常使用所有者的主键作为外键的值,例如, User的ID, 当您将信用卡分配给用户时,GORM将保存用户的信用卡 ID 放入信用卡’ UserID 字段中。 您可以使用标签进行更改 references type User struct { ID uint `gorm:\"primarykey\"` MemberNumber string `gorm:\"type:varchar(255);unique\"` //一对多关联需要唯一所以这里设置unique约束，否则mysql创建报错 // 默认CreditCard会使用User表的Id作为外键，references:MemberNumber 指定使用 MemberNumber 作为外键关联 CreditCards []CreditCard `gorm:\"foreignkey:UserMember;references:MemberNumber\"` } type CreditCard struct { ID uint `gorm:\"primarykey\"` Number string UserMember string } // mdb.AutoMigrate(User{}, CreditCard{}) 7.4一对多查询DEMO link package main import ( \"gorm.io/driver/mysql\" \"gorm.io/gorm\" ) /* constraint:OnUpdate:CASCADE 【当User表更新，也会同步给CreditCards】 // 外键约束 OnDelete:SET NULL 【当User中数据被删除时，CreditCard关联设置为 NULL，不删除记录】 */ type User struct { gorm.Model Username string `json:\"username\" gorm:\"column:username\"` CreditCards []CreditCard `gorm:\"constraint:OnUpdate:CASCADE,OnDelete:SET NULL;\"` } type CreditCard struct { gorm.Model Number string UserID uint } func main() { dsn := \"root:123456@tcp(127.0.0.1:3306)/test_db?charset=utf8mb4\u0026parseTime=True\u0026loc=Local\" //0.建立连接 mdb, err := gorm.Open(mysql.Open(dsn), \u0026gorm.Config{}) if err != nil { panic(err) } //3.自带创建表，AutoMigrate没有建立映射关系 // 用于项目初始化自动创建表，已存在不会重复创建 mdb.AutoMigrate(User{}, CreditCard{}) // 1、创建一对多 user := User{ Username: \"zhangsan\", CreditCards: []CreditCard{ {Number: \"0001\"}, {Number: \"0002\"}, }, } mdb.Create(\u0026user) // 2、为已存在用户添加信用卡 u := User{Username: \"zhangsan\"} mdb.First(\u0026u) //fmt.Println(u.Username) mdb.Model(\u0026u).Association(\"CreditCards\").Append([]CreditCard{ {Number: \"0003\"}, }) } mysql\u003e select * from users; +----+-------------------------+-------------------------+------------+----------+ | id | created_at | updated_at | deleted_at | username | +----+-------------------------+-------------------------+------------+----------+ | 1 | 2024-10-06 04:43:29.747 | 2024-10-06 04:43:29.758 | NULL | zhangsan | +----+-------------------------+-------------------------+------------+----------+ 1 row in set (0.00 sec) mysql\u003e select * from credit_cards; +----+-------------------------+-------------------------+------------+--------+---------+ | id | created_at | updated_at | deleted_at | number | user_id | +----+-------------------------+-------------------------+------------+--------+---------+ | 1 | 2024-10-06 04:43:29.749 | 2024-10-06 04:43:29.749 | NULL | 0001 | 1 | | 2 | 2024-10-06 04:43:29.749 | 2024-10-06 04:43:29.749 | NULL | 0002 | 1 | | 3 | 2024-10-06 04:43:29.760 | 2024-10-06 04:43:29.760 | NULL | 0003 | 1 | +----+-------------------------+-------------------------+------------+--------+---------+ 3 rows in set (0.00 sec) 一对多 Association(不推荐) https://gorm.io/zh_CN/docs/associations.html\n使用 Association 方法, 需要把 User 查询好, 然后根据 User 定义中指定的 AssociationForeignKey 去查找 CreditCard。 package main import ( \"encoding/json\" \"fmt\" \"gorm.io/driver/mysql\" \"gorm.io/gorm\" ) /* constraint:OnUpdate:CASCADE 【当User表更新，也会同步给CreditCards】 // 外键约束 OnDelete:SET NULL 【当User中数据被删除时，CreditCard关联设置为 NULL，不删除记录】 */ type User struct { gorm.Model Username string `json:\"username\" gorm:\"column:username\"` CreditCards []CreditCard `gorm:\"constraint:OnUpdate:CASCADE,OnDelete:SET NULL;\"` } type CreditCard struct { gorm.Model Number string UserID uint } func main() { dsn := \"root:123456@tcp(127.0.0.1:3306)/test_db?charset=utf8mb4\u0026parseTime=True\u0026loc=Local\" //0.建立连接 mdb, err := gorm.Open(mysql.Open(dsn), \u0026gorm.Config{}) if err != nil { panic(err) } //3.自带创建表，AutoMigrate没有建立映射关系 // 用于项目初始化自动创建表，已存在不会重复创建 mdb.AutoMigrate(User{}, CreditCard{}) // 1、查找 用户名为 zhangsan 的所有信用卡信息 u := User{Username: \"zhangsan\"} // Association必须要先查出User才能关联查询对应的CreditCard mdb.First(\u0026u) err = mdb.Model(\u0026u).Association(\"CreditCards\").Find(\u0026u.CreditCards) if err != nil { fmt.Println(err) } strUser, _ := json.Marshal(\u0026u) fmt.Println(string(strUser)) } fei@feideMBP 04mode % go run main.go { \"ID\": 1, \"CreatedAt\": \"2024-10-06T04:43:29.747+08:00\", \"UpdatedAt\": \"2024-10-06T04:43:29.758+08:00\", \"DeletedAt\": null, \"username\": \"zhangsan\", \"CreditCards\": [{ \"ID\": 1, \"CreatedAt\": \"2024-10-06T04:43:29.749+08:00\", \"UpdatedAt\": \"2024-10-06T04:43:29.749+08:00\", \"DeletedAt\": null, \"Number\": \"0001\", \"UserID\": 1 } ... ] } 一对多 Preload https://gorm.io/zh_CN/docs/preload.html\n使用 Preload 方法, 在查询 User 时先去获取 CreditCard 的记录。 package main import ( \"encoding/json\" \"fmt\" \"gorm.io/driver/mysql\" \"gorm.io/gorm\" ) /* constraint:OnUpdate:CASCADE 【当User表更新，也会同步给CreditCards】 // 外键约束 OnDelete:SET NULL 【当User中数据被删除时，CreditCard关联设置为 NULL，不删除记录】 */ type User struct { gorm.Model Username string `json:\"username\" gorm:\"column:username\"` CreditCards []CreditCard `gorm:\"constraint:OnUpdate:CASCADE,OnDelete:SET NULL;\"` } type CreditCard struct { gorm.Model Number string UserID uint } func main() { dsn := \"root:123456@tcp(127.0.0.1:3306)/test_db?charset=utf8mb4\u0026parseTime=True\u0026loc=Local\" //0.建立连接 mdb, err := gorm.Open(mysql.Open(dsn), \u0026gorm.Config{}) if err != nil { panic(err) } //3.自带创建表，AutoMigrate没有建立映射关系 // 用于项目初始化自动创建表，已存在不会重复创建 mdb.AutoMigrate(User{}, CreditCard{}) // 1、预加载: 查找 user 时预加载相关 CreditCards users := []User{} mdb.Preload(\"CreditCards\").Find(\u0026users) strUser, _ := json.Marshal(\u0026users) fmt.Println(string(strUser)) } [{ \"ID\": 1, \"CreatedAt\": \"2024-10-06T04:43:29.747+08:00\", \"UpdatedAt\": \"2024-10-06T04:43:29.758+08:00\", \"DeletedAt\": null, \"username\": \"zhangsan\", \"CreditCards\": [{ \"ID\": 1, \"CreatedAt\": \"2024-10-06T04:43:29.749+08:00\", \"UpdatedAt\": \"2024-10-06T04:43:29.749+08:00\", \"DeletedAt\": null, \"Number\": \"0001\", \"UserID\": 1 }, ... ] }] 目的:\nPreload: 用于预加载关联数据，通常在查询时使用。 Association: 用于管理已经加载模型的关联数据，包括增删改查。 使用场景:\n当你需要一次性加载主模型及其关联数据时，使用 Preload。 当你需要对已经加载的模型的关联进行进一步操作时，使用 Association。 8.多对多 link8.1many to many介绍 linkhttps://gorm.io/zh_CN/docs/many_to_many.html\nMany to Many 会在两个 model 中添加一张连接表。 例如，您的应用包含了 user 和 language，且一个 user 可以说多种 language，多个 user 也可以说一种 language。 当使用 GORM 的 AutoMigrate 为 User 创建表时，GORM 会自动创建第三张连接表 // User 拥有并属于多种 language，`user_languages` 是连接表 type User struct { gorm.Model Languages []Language `gorm:\"many2many:user_languages;\"` } type Language struct { gorm.Model Name string } 8.2反向连接 link // User 拥有并属于多种 language，`user_languages` 是连接表 /* gorm:\"many2many:user_languages; 用于声明多对多关系，以及中间表的名称 */ type User struct { gorm.Model Languages []*Language `gorm:\"many2many:user_languages;\"` } type Language struct { gorm.Model Name string Users []*User `gorm:\"many2many:user_languages;\"` } 8.3重写外键 link 对于 many2many 关系，连接表会同时拥有两个模型的外键 type User struct { gorm.Model Languages []Language `gorm:\"many2many:user_languages;\"` } type Language struct { gorm.Model Name string } // 连接表：user_languages // 外键字段user_id，引用了users表的id字段 // foreign key: user_id, reference: users.id // foreign key: language_id, reference: languages.id 若要重写它们，可以使用标签 foreignKey、references、joinforeignKey、joinReferences。 当然，您不需要使用全部的标签，你可以仅使用其中的一个重写部分的外键、引用。 type User struct { gorm.Model //foreignKey:Refer 指定本地表字段名，joinForeignKey:UserReferID 指定关联表字段名 Profiles []Profile `gorm:\"many2many:user_profiles;foreignKey:Refer;joinForeignKey:UserReferID;References:UserRefer;joinReferences:ProfileRefer\"` Refer uint `gorm:\"index:,unique\"` } type Profile struct { gorm.Model Name string UserRefer uint `gorm:\"index:,unique\"` } // 会创建连接表：user_profiles // foreign key: user_refer_id, reference: users.refer // foreign key: profile_refer, reference: profiles.user_refer 8.4自定义第三张表 linkhttps://gorm.io/zh_CN/docs/many_to_many.html#自定义连接表 type User struct { gorm.Model Languages []*Language `gorm:\"many2many:user_languages\"` } type Language struct { gorm.Model Name string Users []*User `gorm:\"many2many:user_languages\"` } type UserLanguage struct { UserID int `gorm:\"primaryKey;\"` LanguageID int `gorm:\"primaryKey;\"` CreatedAt time.Time DeletedAt gorm.DeletedAt } //mdb.AutoMigrate(User{}, Language{}, UserLanguage{}) 此时创建出的表经过测试没有外键约束 debug 2024/10/06 17:51:36 /Volumes/data/go/src/test/many2many/main.go:43 [37.939ms] [rows:0] CREATE TABLE `users` (`id` bigint unsigned AUTO_INCREMENT,`created_at` datetime(3) NULL,`updated_at` datetime(3) NULL,`deleted_at` datetime(3) NULL,PRIMARY KEY (`id`),INDEX `idx_users_deleted_at` (`deleted_at`)) 2024/10/06 17:51:36 /Volumes/data/go/src/test/many2many/main.go:43 [35.273ms] [rows:0] CREATE TABLE `user_languages` (`user_id` bigint,`language_id` bigint,`created_at` datetime(3) NULL,`deleted_at` datetime(3) NULL,PRIMARY KEY (`user_id`,`language_id`)) 2024/10/06 17:51:37 /Volumes/data/go/src/test/many2many/main.go:43 [37.921ms] [rows:0] CREATE TABLE `languages` (`id` bigint unsigned AUTO_INCREMENT,`created_at` datetime(3) NULL,`updated_at` datetime(3) NULL,`deleted_at` datetime(3) NULL,`name` longtext,PRIMARY KEY (`id`),INDEX `idx_languages_deleted_at` (`deleted_at`)) 8.5多对多查询DEMO link package main import ( \"encoding/json\" \"fmt\" \"gorm.io/driver/mysql\" \"gorm.io/gorm\" \"gorm.io/gorm/logger\" \"time\" ) type User struct { gorm.Model Languages []*Language `gorm:\"many2many:user_languages\"` } type Language struct { gorm.Model Name string Users []*User `gorm:\"many2many:user_languages\"` } type UserLanguage struct { UserID int `gorm:\"primaryKey;\"` LanguageID int `gorm:\"primaryKey;\"` CreatedAt time.Time DeletedAt gorm.DeletedAt } func main() { dsn := \"root:123456@tcp(127.0.0.1:3306)/test_db?charset=utf8mb4\u0026parseTime=True\u0026loc=Local\" gormConfig := \u0026gorm.Config{ Logger: logger.Default.LogMode(logger.Info), // 启用详细日志 } //0.建立连接 mdb, err := gorm.Open(mysql.Open(dsn), gormConfig) if err != nil { panic(err) } //3.自带创建表，AutoMigrate没有建立映射关系 // 用于项目初始化自动创建表，已存在不会重复创建 mdb.AutoMigrate(User{}, Language{}, UserLanguage{}) //添加数据 user := \u0026User{ Model: gorm.Model{}, Languages: []*Language{ {Name: \"vue\"}, {Name: \"golang\"}, }, } mdb.Create(user) /* INSERT INTO `languages` (`created_at`,`updated_at`,`deleted_at`,`name`) VALUES ('2024-10-06 18:07:06.874','2024-10-06 18:07:06.874',NULL,'vue'),('2024-10-06 18:07:06.874','2024-10-06 18:07:06.874',NULL,'golang') ON DUPLICATE KEY UPDATE `id`=`id` */ //Preload获取数据 users := []*User{} mdb.Preload(\"Languages\").Find(\u0026users) userBytes, _ := json.Marshal(users) fmt.Println(string(userBytes)) /* input: SELECT * FROM `users` WHERE `users`.`deleted_at` IS NULL output: [{\"ID\":1,\"CreatedAt\":\"2024-10-06T18:07:06.871+08:00\",\"UpdatedAt\":\"2024-10-06T18:07:06.871+08:00\",\"DeletedAt\":null,\"Languages\":[{\"ID\":1,\"CreatedAt\":\"2024-10-06T18:07:06.874+08:00\",\"UpdatedAt\":\"2024-10-06T18:07:06.874+08:00\",\"DeletedAt\":null,\"Name\":\"vue\",\"Users\":null},{\"ID\":2,\"CreatedAt\":\"2024-10-06T18:07:06.874+08:00\",\"UpdatedAt\":\"2024-10-06T18:07:06.874+08:00\",\"DeletedAt\":null,\"Name\":\"golang\",\"Users\":null}]}] */ //Preload获取单条数据 user = \u0026User{ Model: gorm.Model{ ID: 1, }, } mdb.Preload(\"Languages\").Find(\u0026user) userByte, _ := json.Marshal(user) fmt.Println(string(userByte)) /* input: SELECT * FROM `users` WHERE `users`.`deleted_at` IS NULL AND `users`.`id` = 1 output: {\"ID\":1,\"CreatedAt\":\"2024-10-06T18:07:06.871+08:00\",\"UpdatedAt\":\"2024-10-06T18:07:06.871+08:00\",\"DeletedAt\":null,\"Languages\":[{\"ID\":1,\"CreatedAt\":\"2024-10-06T18:07:06.874+08:00\",\"UpdatedAt\":\"2024-10-06T18:07:06.874+08:00\",\"DeletedAt\":null,\"Name\":\"vue\",\"Users\":null},{\"ID\":2,\"CreatedAt\":\"2024-10-06T18:07:06.874+08:00\",\"UpdatedAt\":\"2024-10-06T18:07:06.874+08:00\",\"DeletedAt\":null,\"Name\":\"golang\",\"Users\":null}]} */ user = \u0026User{ Model: gorm.Model{ ID: 1, }, } mdb.Model(\u0026user).Association(\"Languages\").Find(\u0026user.Languages) userAssByte, _ := json.Marshal(user) fmt.Println(string(userAssByte)) /* input: SELECT `languages`.`id`,`languages`.`created_at`,`languages`.`updated_at`,`languages`.`deleted_at`,`languages`.`name` FROM `languages` JOIN `user_languages` ON `user_languages`.`language_id` = `languages`.`id` AND `user_languages`.`user_id` = 1 WHERE `languages`.`deleted_at` IS NULL output: {\"ID\":1,\"CreatedAt\":\"0001-01-01T00:00:00Z\",\"UpdatedAt\":\"0001-01-01T00:00:00Z\",\"DeletedAt\":null,\"Languages\":[{\"ID\":1,\"CreatedAt\":\"2024-10-06T18:07:06.874+08:00\",\"UpdatedAt\":\"2024-10-06T18:07:06.874+08:00\",\"DeletedAt\":null,\"Name\":\"vue\",\"Users\":null},{\"ID\":2,\"CreatedAt\":\"2024-10-06T18:07:06.874+08:00\",\"UpdatedAt\":\"2024-10-06T18:07:06.874+08:00\",\"DeletedAt\":null,\"Name\":\"golang\",\"Users\":null}]} */ /* 解析： Preload： mdb.Preload(\"Languages\"): 此方法用于指定在查找用户时，同时加载与用户相关联的 Languages 数据。 .Find(\u0026user): 此方法从数据库中检索用户记录，并将结果填充到 user 变量中。 Association： mdb.Model(\u0026user): 这里的 mdb 表示 GORM 数据库连接实例，而 Model(\u0026user) 指定了要操作的模型，即 user。 .Association(\"Languages\"): 此方法用于访问与 user 关联的 Languages 集合。GORM 会根据模型中的定义自动处理这种关系。 .Find(\u0026user.Languages): 这个调用会将与该用户相关的所有语言记录加载到 user.Languages 切片中。 */ } "
            }
        );
    index.add(
            {
                id:  51 ,
                href: "\/docs\/dev\/front-end\/1.html\/",
                title: "1.HTML",
                description: "HTML是用来描述网页的一种语言，全称超文本标记语言(Hyper Text Markup Language)，它是一种标记语言，使用标记标签来描述网页，它的语法规则可以定义图片、表格、链接等。",
                content: "1.1 一个基础例子 link一个基础的HTML例子：\n\u003c!DOCTYPE html\u003e page name title 1 sub title paragraph text\ntitle 2 paragraph text\n整个文件由html标签包着，其中由分为首部和主体两部分，分别用head标签和body标签包裹。\n首部告诉浏览器关于网页的信息，如页面标题，首部包括和之间的所有内容。其中的title标签定义了网页的标题，meta标签指定了字符编码。\n主体包含网页的所有内容和结构，也就是在浏览器直接看到的部分，主体包括和之间的所有内容。其中的h1标签和h2标签分别是一级标题和二级标题，p标签则是段落。\n保存为HTML文件，在浏览器打开后，页面效果如下：\n此外，还可以在HTML的首部里增加一些样式，就是style标签。style标签有一个可选的属性type，一般指定为\"text/css\"。\n\u003c!DOCTYPE html\u003e page name title 1 sub title paragraph text\ntitle 2 paragraph text\nstyle标签中的body表示这段配置应用于主体中的body标签。\n保存刷新后看到页面效果：\n可以看到通过增加style标签，给页面加了背景颜色、边框、字体。\n1.2 标签 linkHTML标签是由尖括号包围、成对出现的关键词，如 和 ，分别为开始标签和结束标签。HTML标签大小写不敏感，但推荐使用小写。\n1.3 元素 linkHTML元素是开始标签到对应的结束标签的所有代码，HTML元素可以嵌套包含其他HTML元素。\nhtml元素定义整个HTML文档，head元素定义文档的首部，body元素定义文档的主体。空元素没有内容，在开始标签中关闭，如br元素应当在开始标签添加斜杠：\n。\n1.4 属性 linkHTML属性在开始标签中设置，以名称/值对name=“value\"的形式出现。属性和属性值大小写不敏感，但推荐小写。\n以下是大多数HTML元素的属性：\nclass：规定元素的类名（classname），不同的元素可以有相同的类名 id：规定元素的id，元素的id在HTML文档中是唯一的，其他a标签可以通过href=\"url#label\"定位到此网页的该元素处 style：规定元素的行内样式（inline style） title：规定元素的额外信息 以下是几个属性的实例：\nHTML链接的地址：\nThis is a link HTML标题的对齐方式：\nHTML表格的边框信息：\n1.5 字符实体 link若要在HTML文本中展示\u003c和\u003e，又不想和标签区分开，可以转化为字符实体，用来表示特殊字符。\n特殊字符 字符实体 说明 空格 \u0026nbsp; \u003c \u0026lt; \u003e \u0026gt; \u0026 \u0026amp; 在\u0026用于实体字符时转化，一般可直接用\u0026 \" \u0026quot; ' \u0026apos; 1.6 标准 link现在最新的标准是HTML5，可以通过 The W3C Markup Validation Service 检查网页是否符合HTML标准。\n2. 标签 link2.1 首部 linkhtml标签包裹整个HTML文件，其中又分为head元素和body元素表示首部和主体。\n以下是几个专门用于首部的标签。\n标题\ntitle标签指定网页标题。\npage name 默认链接\nbase标签为所有链接规定默认地址。\n外部资源\nlink标签定义外部资源。\n样式\nstyle标签定了HTML文档的样式信息。\n数据\nmeta标签定义元数据，如页面描述、修改时间、字符编码等。\n2.2 基础标签 link注释\n标题\n通过 h1 - h6 标签进行定义不同等级的标题，h1最大，h6最小。\nThis is a heading This is a heading This is a heading 段落\n浏览器会忽略HTML文档中的制表符、回车和大部分空格，根据标记来确定换行或分段。\nThis is a paragraph.\n换行\n显示页面时，浏览器会移除源代码多余的空格和空行，连续的空格或空行会被算作一个空格，因此需要用此标签来换行。\n水平线\n创建水平线用于分割内容。\n链接\nhref属性指定链接地址，标签中间为显示的文本。\ntarget属性定义链接文档的显示位置，默认在当前窗口打开，target=\"_blank\"表示在新窗口打开。\nid属性或name属性定义锚（anchor），id=“label”，在同一文档创建链接，或者其他页面创建链接，点击后直接跳转到该锚。\n将显示文本替换为img元素，可以展示一个可以点击的图像。\ntext 图像\n属性指定了图像的名称和尺寸。\nsrc属性指定图片地址，可以是本地图片地址或网络图片地址。\nwidth、height属性指定图片宽高，默认为按实际图片大小显示，可以为具体像素值也可以为百分比，如width=\"300\"、width=\"300px\"、width=\"50%\"。\nalt属性定义替换的文本，无法载入图片时显示。\n2.3 文本格式 link粗体文本\ntext 斜体字\ntext 强调\ntext 大号字\ntext 小号字\ntext 下标字\ntext 上标字\ntext 删除线\ntext 下划线\ntext 代码格式\na = 1; 2.4 引用 link短引用\n单行的引用，会用引号包围。\ntext 长引用\n会对整个元素进行缩进。\n五十年来，WWF 一直致力于保护自然界的未来。 WWF 工作于 100 个国家，并得到美国一百二十万会员及全球近五百万会员的支持。 缩略词\n对缩写进行标记，为浏览器、搜索引擎提供信息。\nWHO 联系信息\n定义文档或文章的联系信息（作者/拥有者）。\nWritten by Donald Duck.\nVisit us at:\nExample.com\nBox 564, Disneyland\nUSA 著作标题\nThe Scream 2.5 表格 link一个表格用table标签定义，每一行用tr标签定义，行的每个单元格用td标签定义。第一行表头可用th标签定义，显示为粗体居中。\n数据单元格可以包含文本、图片、列表、段落、表单、水平线、表格等等。\ntable标签的border属性定义边框。\n一个表格的例子：\nHeading Another Heading row 1, cell 1 row 1, cell 2 row 2, cell 1 row 2, cell 2 2.6 列表 link不同的列表可以嵌套使用，即在li元素中定义新的列表。\nli = list item\nul = unordered list\nol = ordered list\n无序列表\n用圆点列出每个项目。\nCoffee Milk 也可以直接用li标签包裹每个元素：\nCoffee Milk 有序列表\n用数字列出每个项目。\nCoffee Milk 定义列表\n用给定文本列出每个项目，列表的每一项都有dt标签和dd标签。\nCoffee Black hot drink Milk White cold drink 2.7 块 link使用div元素定义块，用于组合其它HTML元素，以对文档布局，将文档分割为独立的分区或节。\n用id或class属性标记div元素，和css一起使用，用于对内容块设置样式。\nThis is a header This is a paragraph.\n用span元素来组合行内的文本，再通过样式来格式化它们。span标签本身没有固定的格式表现，需要对它应用样式。\nsome text.some other text.\n2.8 内联框架 linkiframe元素用于在网页内显示网页。\n属性width和height规定框架的宽度和高度，默认单位为像素，也可以是百分比。\n2.9 JavaScript link在head元素或body元素内，使用script标签定义JavaScript脚本。\n也可以通过src属性，使用外部脚本文件。\n2.10 表单 link使用form标签定义HTML表单，收集用户输入。\n表单元素内，input标签定义输入，其中是输入文本框，*是单选按钮，是提交按钮。\n如下例子：\ninput 1:\ninput 2:\nMale\nFemale\n在网页中显示如下：\n点击提交按钮，会讲上面文本框和单选按钮输入的key=value对，传给网页参数发送请求，例如会发送一个请求a.html?input+1=val1\u0026input+2=val2\u0026sex=male。\nform标签的action属性定义提交表单时执行的动作，如将会指定某个服务器脚本来处理被提交的表单，不指定action属性则设置为当前网页处理表单。\nform标签的method属性规定提交表单用的HTTP方法为GET或POST，如指定为GET方法。\n2.11 画布 linkcanvas元素使用JavaScript在网页上绘制图像。\n3. HTML5 link3.1 语义元素 link非语义元素div和span，无法提供关于内容的信息，通过id和class包含信息，如和。\nHTML5提供的语义元素能清楚地描述意义，明确表示网页的不同部分，可以将上面的换为和。\nHTML5语义元素对应的网页结构：\nheader\n文档的页眉。\nnav\n定义导航链接集合。\nmain\n定义文档的主内容。\nsection\n文档中的节，是有主题的内容组，通常具有标题。\narticle\n独立的自包含的内容，常用于论坛、博客、新闻。\nsection元素和article元素是可以包含对方或者自包含的。\naside\n除了页面主内容外的内容，与周围内容相关，如侧栏。\nfooter\n文档或节的页脚，通常包含作者、版权信息、联系信息等。\n4. 样式 link可以通过首部的style标签，将样式添加到HTML元素中，或者通过CSS进行定义。\n4.1 内部样式表 link在HTML首部添加style标签，给指定元素定义样式。以下例子分别给HTML主体中的body元素和p元素指定了样式。\n4.2 外部样式表 link当同一个样式需要被应用到很多页面的时候，可以选择外部样式表，定义一个公共的css文件来杯多个HTML文件引用，在每个HTML文件首部引用该css文件。\n4.3 内联样式 link当特殊的样式需要应用到个别元素时，就可以使用内联样式，为对应的元素添加style属性，只应用于该元素。\nThis is a paragraph.\n4.4 指定元素使用样式 linkstyle标签指定对特定类型标签应用样式：\ntitle paragraph text\nparagraph text\nparagraph text\nstyle元素内的css分为选择器和声明块两部分，如p {background-color: #a0a0a0;}中p为选择器，指定HTML文档主体中特定的元素，{}中的部分为声明块，为若干个设置。\ncss写成p {}表示对所有p元素设置样式。css还可以写成.text {}指定对所有类text设置样式，或者用p.text {}对p元素的类text设置样式。写成#t1 {}指定对特定id t1设置样式。\n参考 link 《Head First HTML与CSS（第2版）》 W3school - HTML 教程 The W3C Markup Validation Service "
            }
        );
    index.add(
            {
                id:  52 ,
                href: "\/docs\/dev\/front-end\/2.css\/",
                title: "2.CSS",
                description: "让网页元素的样式更加丰富，也为了让网页的内容和样式能拆分开",
                content: "1.CSS样式语言 link 为了让网页元素的样式更加丰富，也为了让网页的内容和样式能拆分开，CSS由此思想而诞生。 CSS是 Cascading Style Sheets 的首字母缩写，意思是层叠样式表。 有了CSS，html中大部分表现样式的标签就废弃不用了，html只负责文档的结构和内容，表现形式完全交给CSS，html文档变得更加简洁。 2.CSS使用方式 link 内联方式（行内样式） 直接在html内使用样式\n内部方式（内嵌方式）在head标签中使用 Title 外部导入式（推荐）在head标签中使用 3.CSS选择器 link 选择器：需要改变样式的HTML元素 格式：选择器（属性:值;属性:值;属性:值;…..） 常见选择器：标签(元素)选择器、类型选择器、ID选择器、派生选择器 3.1元素选择器 link 使用html标签作为选择器，为指定标签设置样式 示例1：h1元素设置样式 h1 { color: darkcyan; font-size: 14; } 示例2：为多个元素设置样式 h2,h3 { color: chartreuse; } 示例3：子元素会继承最高级元素所有属性 如果子元素有自己的样式优先用自己，如果没有则用父元素样式 body { color: darkcyan; font-family: Verdana, sarif; /*字体*/ } h1 { color: brown; font-size: 14; } 3.2ID选择器 link ID选择器：使用id作为选择器，为指定的id设置样式 使用格式：#id{样式;} 特点：每个ID名称只能在html中出现一次（也就是唯一的），在实际开发中id一般预留在javascript使用 使用方式： /* 为id设置样式 */ #mff { color: blue; } /* 给指定的标签设置id mff */ Hello HTML 3.3类选择器 link 类选择器：使用\"类名\"作为选择器，为指定类设置样式。 使用格式：.类名{样式….} 特点：class一般用于多个不同标签，但是有相同css属性的绑定 使用方式 /* 为类设置样式 */ .mff { color: red; } /* 给指定的标签设置类 mff */ Hello css Hello css 3.4派生选择器 link 依据元素在其位置的上下文关系来定义样式 使用方式 /* 定义标签内容 */ 1号标题 这是一个段落\n/* 设置局部样式，只给mff类中的p标签加个样式 */ .mff p { color: dodgerblue; } 4.CSS常用属性 link4.1盒模型 link padding（内边距）：钻戒到盒子内边框的距离 margin（外边距）：钻戒盒子距离坐姿边缘的距离 border：钻戒盒子边框宽度 内边距：\n属性 描述 padding 设置四边的内边距 padding-top 上内边距 padding-right 右内边距 padding-bottom 下内边距 padding-left 左内边距 A B C D 外边距：\n属性 描述 margin 设置四边的外边距 margin-top 上外边距 margin-right 右外边距 margin-bottom 下外边距 margin-left 左外边距 A 4.2字体 link 属性 描述 值 font-size 设置字体尺寸 - xx-small、x-small、small、medium、large、x-large、xx-large（从小到大），默认是：medium\n- length（固定长度，例如12px） - 浏览器解析字体大小最小是12px font-family 字体系列，可以写多个如果第一个不支持，便使用下一个 示例：Microsoft YaHei font-weight 设置字体的粗细 - normal（默认值）\n- bold（粗体）\n- bolder（更粗）\n- lighter（更细） font-style 字体样式 - normal（正常）\n- italic（斜体）\n- oblique（倾斜的字体） \u003c!DOCTYPE html\u003e 首页 这是a1 这是a2 这是a3 这是a4 4.3文本 link 属性 描述 值 color 字体颜色 颜色名称，如 red\n十六进制值，如 #ff0000\nrgb 代码，如 rgb(255,0,0) text-align 文本对齐方式 left：左边\nright：右边\ncenter：中间\njustify：两端对齐文本效果 text-decoration 文本修饰 none：默认，定义标准文本，例如去掉超链接下划线\nline-through：删除线\nunderline：文本加一条线 text-overflow 文本溢出后显示效果 clip：修剪文本\nellipsis：显示省略号来代表被修剪的文本\nstring：使用给定的字符串来代表被修剪的文本 letter-spacing 字符间的距离 normal：默认\nlength：定义间距 line-height 行间的距离（行高） normal：默认\nlength：设置固定值 \u003c!DOCTYPE html\u003e 首页 这是p1\n这是p2\n这是p3\n这是p4\n这是p5\n这是p6\n4.4边框 link 属性 描述 值 border 所有边框样式的缩写 示例：border: 1px solid blue;（宽度 样式 颜色） border-radius 圆角边框 直接写像素 box-shadow 给元素添加阴影 格式：box-shadow: h-shadow v-shadow blur spread color inset;\n- h-shadow：必选，水平阴影的位置\n- v-shadow：必选，垂直阴影的位置\n- blur：可选，模糊程度\n- spread：可选，阴影的大小\n- color：可选，阴影的颜色\n- inset：可选，从外层的阴影（开始时）改变阴影内侧阴影\n示例1：box-shadow: 1px 2px 3px 1px #c2c2c2;\n示例2：box-shadow: 0.5px 20px 0 #e8e8e8; \u003c!DOCTYPE html\u003e 首页 4.5背景 link 属性 描述 值 background-color 背景颜色 颜色名称：如 red\n十六进制值：如 #ff0000 rgb代码：如 rgb(255,0,0) background-image 背景图片 URL：url(\"url\") 图片路径\nnone：不显示背景图片 background-repeat 设置是否及如何重复背景图像 repeat：默认，背景图像将在垂直和水平方向重复\nrepeat-x：背景图像将在水平方向重复 repeat-y：背景图像将在垂直方向重复\nno-repeat：背景图像将仅显示一次 background-position 背景图片的位置 left、top、top right、center left、center center、center right、bottom left、bottom center、bottom right x% y%：水平位置和垂直位置 background-size 背景图片尺寸 length：背景图片的高度和宽度，如 80px 60px\npercentage：以父元素的百分比设置背景图像的高度和宽度，如 50% 50% \u003c!DOCTYPE html\u003e 首页 4.6flex弹性布局 link 在之前要控制HTML的元素布局，会用到padding、margin、position、float等方法，经过反复调试才可以实现效果。自从有了Flex弹性布局的出现，一切似乎都简单了许多。 启用Flex布局，只需要在外部元素设置display: flex属性。 Flex有一个隐式的坐标空间，水平方向有一条主轴，垂直方向有一条交叉轴 属性 描述 值 justify-content 改变主轴（横向）的布局 flex-end右对齐 center居中对齐 space-evenly平分空间 space-between两端对齐 align-items 改变交差轴（竖向）的布局 flex-end靠下对齐 center居中对齐 flex-direction 设置主轴的方向 row水平排列 column垂直排列 row-reverse反向水平排列 column-reverse反向垂直排列 flex-wrap 此属性定义，如果一条轴线上排列补下，换行的方式 nowrap不换行 wrap换行 wrap-reverse反向换行 从下到上 \u003c!DOCTYPE html\u003e 首页 1 2 3 4 5 "
            }
        );
    index.add(
            {
                id:  53 ,
                href: "\/docs\/dev\/front-end\/3.js\/",
                title: "3.JavaScript",
                description: "使网页具有交互性，例如响应用户点击，给用户提供更好的体验",
                content: "1.JavaScript发展史 link JavaScript(简称JS):是一种轻量级客户端脚本语言，通常被嵌入HTML页面，在浏览器上执行。 JavaScript的主要用途： 使网页具有交互性，例如响应客户点击，给用户提供更好的体验。 处理表单，检测用户输入，并及时反馈提醒。 浏览器与服务端之间数据通信，主要通过Ajax异步传输。 在网页中添加标签，添加样式，改变标签的属性等。对Dom节定进行操作 2.HelloWorld link \u003c!DOCTYPE html\u003e 首页 Hello Js\n3.事件 link 事件 描述 onclick 点击 HTML 元素时触发 onmouseover 鼠标移动到元素上时触发 onkeydown 按下键盘按键时触发 onchange HTML 元素发生变化时触发 onmouseout 鼠标移开 HTML 元素时触发 onload 页面加载完成时触发 \u003c!DOCTYPE html\u003e 首页 onclick onmouseenter onmouseout 输入你的名字： 第一个点击触发，第二个鼠标移动上去触发，第三个鼠标移出时触发。输入框焦点改变时触发\n4.选择器 link JS选择器主要用来获取HTHL页面中的元素,将页面中的元素保存到一个对象中,然后就可以对这些对象的属性值进行相应操作，以实现一些动态效果，以达到页面的生动，易用。 需要注意的一点是操作的一定是对象，直接将元素当做对象使用是不行的。 常见选择器:标签选择器、类选择器、ID选择器 Document 点我 p1\n我是p2下的a标签 p3\n5.JS操作html link 插入内容 document.write(\"这是JS写入的段落\n\");//向文档写入HTML内容 x = document.getElementById('demo'); //获取id为demo的元素 x.innerHTML=\"Hello\"\" //向元素插入HTML内容 改变标签属性 document.getElementById(\"image\").src=\"b.jpg\" //修改img标签src属性值 改变标签样式 x = document.getElementById(\"p\") //获取id为p的元素 x.style.color=\"blue\" //字体颜色 Document Hello\n5.1字符串 link Document 5.2数组 link Document 5.3对象 link 对象是一个具有映射关系的数据结构，对于存储有一定的关系的元素。 格式：d = {'key1':value1,'key2':value2,'key3':value3} 注意：对象通过key来访问value，所以key不允许在同一个字典中重复。 Document 6.操作符、流程控制、函数 link6.1操作符 link 一个特定的符号，与其他数据类型连接起来组成一个表达式，常用于条件判断，根据表达书返回Ture或False采取动作 Document 6.2流程控制 link if条件判断:判定给定的条件是否满足(True或False)， 根据判断的结果决定执行的语句。 语法： if (表达式) { \u003c代码块\u003e } else if (表达式) { \u003c代码块\u003e } else { \u003c代码块\u003e } Document for循环:一般用于遍历数据类型的元素进行处理，例如字符串、数组、对象。 Document 6.3函数 link 函数：是指一段可以直接被另一段程序或代码引用的程序或代码。 在编写代码时，常将一些常用的功能模块编写成函数，放在函数库中供公共使用，可减少重复编写程序段和简化代码结构。 普通函数 Document 你好 点我 匿名函数与箭头函数 Document 7.window对象 link 在JavaScript中，一个浏览器窗口就是一个window对象。 一个窗口就是一个window对象，这个窗口里面的HTML文档就是一个document对象，document对象是window对象的子对象。 location也是windows的子对象，用于操作URL地址 Document 刷新当前页面 重新请求当前页面 请求别的页面 8.jQuery库介绍 link 官网：https://jquery.com\njQuery：是一个JavaScript的库，极大的简化了JavaScript编程，例如JS原生代码几十行实现的功能，JQuery可能一两行代码就可以实现了，因此得到前端程序员广泛应用。 发布至今已经有三个大版本 1.x：常用版 2.x/3.x：除非特殊要求，一般用的很少 8.1基本使用 link cdn导入方式 Document 基础语法是：$(selector).action()\n$ 代表jQuery本身 (selector)：选择器、查找HTML元素 action()：对元素进行操作 代码示例：按钮实现\nDocument 点我1 点我2 8.2选择器 link 选择器介绍 名称 语法 示例 标签选择器 element $(\"h1\") 选择所有的h1的元素 类选择器 .class $(\".title\") 选择所有class为title的元素 ID选择器 #id $(\"#title\") 选取id为title的元素 并集选择器 selector1,selector2,… $(\"div,p,.title\") 选取所有div、p和拥有class为title的元素 属性选择器 [attr=value] (\"[href='#']\") 选取href值等于#的元素 代码示例 Document 在h5中如何使用jQuery 点我1 点我2 8.3操作html link 隐藏和显示元素 hide()：隐藏某个元素 show()：显示某个元素 toggle()：hide()和show()方法之间切换 Document 这是一句话\n隐藏 显示 切换 获取与设置内容 text()：设置或返回所选元素的文本内容 html()：设置或返回所选元素的HTML内容 val()：设置或返回表单字段的值 Document 这是一句话\n获取文本 获取Html 设置CSS样式 css()：设置或返回样式属性 addClass()：向被选中元素添加一个或多个类样式 removeClass()：从被选中元素中删除一个或多个样式 toggleClass()：对被选中元素进行添加/删除类样式的却换动作 Document 这是一句话\n设置为样式0 设置为样式1 设置为样式2 9.Ajax前后端数据交互 link 浏览器访问一个网站的页面时，Web服务器处理完后会以消息体的方式返回给浏览器，浏览器会自动解析HTML内容，如果局部有数据需要更新，需要刷新浏览器重新发起页面请求，获取最新数据，如果每次都是通过这个刷新来解决这个问题，势必会给服务器造成负载，页面加载缓慢。 Ajax（Asynchronous JavaScript And XML，异步JavaScript和XML），Ajax是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术，例如在你不断刷新页面的情况下查询数据，登录验证等。 无刷新的好处： 减少带宽，服务器负载 提高用户体验 9.1基本使用 link jQuery Ajax主要使用$.ajax()方法实现，用于向服务器发送HTTP请求。 语法：$.ajax([settings]); settings是$.ajax()方法的参数列表，用于配置Ajax请求的键值对集合，参数主要如以下 参数 类型 描述 url string 发送请求地址，默认为当前页面 type string 请求方式，默认为get data object、array、string 发送到服务器的数据 dataType string 预期服务器返回的数据类型，包括Json、XML、Text、HTML等 contentType string 发送信息到服务器时内容编码类型，默认是application/x-www-form-urlencoded timeout number 设置请求超时时间 headers object 设置请求头信息 async Boolean 默认为true，所有请求均为异步，设置false发送同步请求 //请求bing开放壁纸接口。展示到页面上 Document 9.2回调函数 link 回调函数:参数引用一个函数，并将数据作为参数传递给该函数。 jqXHR:一个XMLHttpRequest对象 参数 函数格式 描述 beforeSend function(jqXHR,object) 发送请求前调用的函数，例如自定义http头 success function(data, String textStatus,jqXHR) 请求成功后调用的函数，参数data: 可选，由服务端返回的数据（JSON） error function(jqXHR,String textStatus,errorThrown) 请求失败时调用的函数 complete function(jqXHR,String textStatus) 请求完成后（无论成功与否）调用的函数 "
            }
        );
    index.add(
            {
                id:  54 ,
                href: "\/docs\/dev\/front-end\/4.vue\/",
                title: "4.Vue",
                description: "一套用于快速构建用户界面的渐进式前端框架",
                content: "1.Vue介绍 link 官网：https://cn.vuejs.org\nVue.js：简称Vue，是一套用于快速构建用户界面的渐进式前端框架。 Vue.js核心实现 响应式数据绑定：当数据发生改变，视图可以自动更新，不用关心DOM操作，专心数据操作。 可组合的视图组件：把视图按照功能切分成若干个基本单元，可维护，可重用，可测试等特点。 响应式，双向数据绑定，即MVVM。是指数据层（Model）-视图层（View）-数据视图（ViewModel）的响应式框架。 1.2引入Vue.js link 参考文档：https://cn.vuejs.org/guide/quick-start.html\n在html中使用CDN包的形式引入 {{ message }} 现在数据和DOM已经被建立了关联，所有东西都是响应式的，可通过下面示例确认: demo Conter: {{ counter }} 1.4模版语法 link Vue.js使用了基于HTML的模板语法，允许开发者声明式的将DOM绑定致底层组件实例的数据，所有Vue.js的模板都是合法的HTML，所以能被遵循规范的浏览器和HTML解析器解析， 数据绑定最常见的形式就是使用{{ }}，语法在HTML中插入文本：Message：{{ msg }} {{ msg }}将被替换为对应组件实例中msg属性的值，无论何时，绑定的组件实例上msg属性发生改变，传入HTML的值也会随之改变。 2.Vue3响应式 link 解决了：Vue2中新增属性，删除属性(对象)，界面不会更新的问题。 解决了：Vue2中直接通过下标修改数组，界面不会刷新的问题。 2.1ref函数(基本数据类型的定义) link 作用：定义一个响应式的数据即变量(基本类型)。 语法： let a = ref('Hello Vue!') 创建一个包含响应式数据的引用对象（reference对象）。 JS中操作数据： a.value 模板中读取数据，不需要 .value，直接：{{ a }} 接收的数据可以是基本类型，也可以是对象类型（自动转reactive）。 基本类型的数据：响应式依然是靠Object.defineProperty()的get与set完成的（vue2响应式的实现方式）。 对象类型的数据：内部使用了Vue3中的一个新函数：reactive函数 demo {{ message }} 2.2reactive函数 link 作用：定义一个对象类型的响应式数据（基本类型数据不能用，要用ref函数）。 语法：const 代理对象=reactive(原函数)，接收一个对象或数组，返回一个代理对象（proxy对象）。 reactive定义的响应式数据是深层次的。 内部基于ES6的Proxy实现，通过代理对象操作源内部数据进行操作。 用法与ref创建的代理对象类似，不过操作时不需要再加.value了 demo {{ student }} {{ student.name }} "
            }
        );
    index.add(
            {
                id:  55 ,
                href: "\/docs\/ops\/kubernetes\/1.kubernetes-v1.28.3%E4%BA%8C%E8%BF%9B%E5%88%B6%E9%83%A8%E7%BD%B2\/",
                title: "1.Kubernetes-v1.28.3高可用集群二进制部署(IPv4+IPv6双栈)",
                description: "Kubernetes（简称k8s）是Google在2014年6月开源的一个容器集群管理系统，使用Go语言开发，用于管理云平台中多个主机上的容器化的应用，Kubernetes的目标是让部署容器化的应用简单并且高效,Kubernetes提供了资源调度、部署管理、服务发现、扩容缩容、监控，维护等一整套功能。努力成为跨主机集群的自动部署、扩展以及运行应用程序容器的平台。 它支持一系列容器工具, 包括且不限于Docker等。",
                content: "介绍 link kubernetes（k8s）二进制高可用安装部署，支持IPv4+IPv6双栈。 我使用IPV6的目的是在公网进行访问，所以我配置了IPV6静态地址。 若您没有IPV6环境，或者不想使用IPv6，不对主机进行配置IPv6地址即可。 不配置IPV6，不影响后续，不过集群依旧是支持IPv6的。为后期留有扩展可能性。 若不要IPv6 ，不给网卡配置IPv6即可，不要对IPv6相关配置删除或操作，否则会出问题。 1.环境 link 主机名称 IP地址 说明 软件 192.168.1.60 外网节点 下载各种所需安装包 Master01 192.168.1.31 master节点 kube-apiserver、kube-controller-manager、kube-scheduler、etcd、\nkubelet、kube-proxy、nfs-client、haproxy、keepalived、nginx Master02 192.168.1.32 master节点 kube-apiserver、kube-controller-manager、kube-scheduler、etcd、\nkubelet、kube-proxy、nfs-client、haproxy、keepalived、nginx Master03 192.168.1.33 master节点 kube-apiserver、kube-controller-manager、kube-scheduler、etcd、\nkubelet、kube-proxy、nfs-client、haproxy、keepalived、nginx Node01 192.168.1.34 node节点 kubelet、kube-proxy、nfs-client、nginx Node02 192.168.1.35 node节点 kubelet、kube-proxy、nfs-client、nginx 192.168.1.36 VIP 网段 物理主机：192.168.1.0/24 service：10.96.0.0/12 pod：172.16.0.0/12\n1.1.k8s基础系统环境配置 link1.2.配置IP link # 注意！ # 若虚拟机是进行克隆的那么网卡的UUID会重复 # 若UUID重复需要重新生成新的UUID # UUID重复无法获取到IPV6地址 # # 查看当前的网卡列表和 UUID： # nmcli con show # 删除要更改 UUID 的网络连接： # nmcli con delete uuid \u003c原 UUID\u003e # 重新生成 UUID： # nmcli con add type ethernet ifname \u003c接口名称\u003e con-name \u003c新名称\u003e # 重新启用网络连接： # nmcli con up \u003c新名称\u003e # 更改网卡的UUID ssh root@192.168.1.31 \"nmcli con delete uuid 708a1497-2192-43a5-9f03-2ab936fb3c44;nmcli con add type ethernet ifname eth0 con-name eth0;nmcli con up eth0\" ssh root@192.168.1.32 \"nmcli con delete uuid 708a1497-2192-43a5-9f03-2ab936fb3c44;nmcli con add type ethernet ifname eth0 con-name eth0;nmcli con up eth0\" ssh root@192.168.1.33 \"nmcli con delete uuid 708a1497-2192-43a5-9f03-2ab936fb3c44;nmcli con add type ethernet ifname eth0 con-name eth0;nmcli con up eth0\" ssh root@192.168.1.34 \"nmcli con delete uuid 708a1497-2192-43a5-9f03-2ab936fb3c44;nmcli con add type ethernet ifname eth0 con-name eth0;nmcli con up eth0\" ssh root@192.168.1.35 \"nmcli con delete uuid 708a1497-2192-43a5-9f03-2ab936fb3c44;nmcli con add type ethernet ifname eth0 con-name eth0;nmcli con up eth0\" # 参数解释 # # ssh ssh root@192.168.1.31 # 使用SSH登录到IP为192.168.1.31的主机，使用root用户身份。 # # nmcli con delete uuid 708a1497-2192-43a5-9f03-2ab936fb3c44 # 删除 UUID 为 708a1497-2192-43a5-9f03-2ab936fb3c44 的网络连接，这是 NetworkManager 中一种特定网络配置的唯一标识符。 # # nmcli con add type ethernet ifname eth0 con-name eth0 # 添加一种以太网连接类型，并指定接口名为 eth0，连接名称也为 eth0。 # # nmcli con up eth0 # 开启 eth0 这个网络连接。 # # 简单来说，这个命令的作用是删除一个特定的网络连接配置，并添加一个名为 eth0 的以太网连接，然后启用这个新的连接。 # 修改静态的IPv4地址 ssh root@192.168.1.104 \"nmcli con mod eth0 ipv4.addresses 192.168.1.31/24; nmcli con mod eth0 ipv4.gateway 192.168.1.1; nmcli con mod eth0 ipv4.method manual; nmcli con mod eth0 ipv4.dns \"8.8.8.8\"; nmcli con up eth0\" ssh root@192.168.1.106 \"nmcli con mod eth0 ipv4.addresses 192.168.1.32/24; nmcli con mod eth0 ipv4.gateway 192.168.1.1; nmcli con mod eth0 ipv4.method manual; nmcli con mod eth0 ipv4.dns \"8.8.8.8\"; nmcli con up eth0\" ssh root@192.168.1.107 \"nmcli con mod eth0 ipv4.addresses 192.168.1.33/24; nmcli con mod eth0 ipv4.gateway 192.168.1.1; nmcli con mod eth0 ipv4.method manual; nmcli con mod eth0 ipv4.dns \"8.8.8.8\"; nmcli con up eth0\" ssh root@192.168.1.109 \"nmcli con mod eth0 ipv4.addresses 192.168.1.34/24; nmcli con mod eth0 ipv4.gateway 192.168.1.1; nmcli con mod eth0 ipv4.method manual; nmcli con mod eth0 ipv4.dns \"8.8.8.8\"; nmcli con up eth0\" ssh root@192.168.1.110 \"nmcli con mod eth0 ipv4.addresses 192.168.1.35/24; nmcli con mod eth0 ipv4.gateway 192.168.1.1; nmcli con mod eth0 ipv4.method manual; nmcli con mod eth0 ipv4.dns \"8.8.8.8\"; nmcli con up eth0\" nmcli con mod eth0 ipv4.gateway 192.168.1.200; nmcli con mod eth0 ipv4.method manual; nmcli con mod eth0 ipv4.dns \"223.5.5.5\"; nmcli con up eth0 # 参数解释 # # ssh root@192.168.1.154 # 使用SSH登录到IP为192.168.1.154的主机，使用root用户身份。 # # \"nmcli con mod eth0 ipv4.addresses 192.168.1.31/24\" # 修改eth0网络连接的IPv4地址为192.168.1.31，子网掩码为 24。 # # \"nmcli con mod eth0 ipv4.gateway 192.168.1.1\" # 修改eth0网络连接的IPv4网关为192.168.1.1。 # # \"nmcli con mod eth0 ipv4.method manual\" # 将eth0网络连接的IPv4配置方法设置为手动。 # # \"nmcli con mod eth0 ipv4.dns \"8.8.8.8\" # 将eth0网络连接的IPv4 DNS服务器设置为 8.8.8.8。 # # \"nmcli con up eth0\" # 启动eth0网络连接。 # # 总体来说，这条命令是通过SSH远程登录到指定的主机，并使用网络管理命令 (nmcli) 修改eth0网络连接的配置，包括IP地址、网关、配置方法和DNS服务器，并启动该网络连接。 # 没有IPv6选择不配置即可 ssh root@192.168.1.31 \"nmcli con mod eth0 ipv6.addresses fc00:43f4:1eea:1::10; nmcli con mod eth0 ipv6.gateway fc00:43f4:1eea:1::1; nmcli con mod eth0 ipv6.method manual; nmcli con mod eth0 ipv6.dns \"2400:3200::1\"; nmcli con up eth0\" ssh root@192.168.1.32 \"nmcli con mod eth0 ipv6.addresses fc00:43f4:1eea:1::20; nmcli con mod eth0 ipv6.gateway fc00:43f4:1eea:1::1; nmcli con mod eth0 ipv6.method manual; nmcli con mod eth0 ipv6.dns \"2400:3200::1\"; nmcli con up eth0\" ssh root@192.168.1.33 \"nmcli con mod eth0 ipv6.addresses fc00:43f4:1eea:1::30; nmcli con mod eth0 ipv6.gateway fc00:43f4:1eea:1::1; nmcli con mod eth0 ipv6.method manual; nmcli con mod eth0 ipv6.dns \"2400:3200::1\"; nmcli con up eth0\" ssh root@192.168.1.34 \"nmcli con mod eth0 ipv6.addresses fc00:43f4:1eea:1::40; nmcli con mod eth0 ipv6.gateway fc00:43f4:1eea:1::1; nmcli con mod eth0 ipv6.method manual; nmcli con mod eth0 ipv6.dns \"2400:3200::1\"; nmcli con up eth0\" ssh root@192.168.1.35 \"nmcli con mod eth0 ipv6.addresses fc00:43f4:1eea:1::50; nmcli con mod eth0 ipv6.gateway fc00:43f4:1eea:1::1; nmcli con mod eth0 ipv6.method manual; nmcli con mod eth0 ipv6.dns \"2400:3200::1\"; nmcli con up eth0\" # 参数解释 # # ssh root@192.168.1.31 # 通过SSH连接到IP地址为192.168.1.31的远程主机，使用root用户进行登录。 # # \"nmcli con mod eth0 ipv6.addresses fc00:43f4:1eea:1::10\" # 使用nmcli命令修改eth0接口的IPv6地址为fc00:43f4:1eea:1::10。 # # \"nmcli con mod eth0 ipv6.gateway fc00:43f4:1eea:1::1\" # 使用nmcli命令修改eth0接口的IPv6网关为fc00:43f4:1eea:1::1。 # # \"nmcli con mod eth0 ipv6.method manual\" # 使用nmcli命令将eth0接口的IPv6配置方法修改为手动配置。 # # \"nmcli con mod eth0 ipv6.dns \"2400:3200::1\" # 使用nmcli命令设置eth0接口的IPv6 DNS服务器为2400:3200::1。 # # \"nmcli con up eth0\" # 使用nmcli命令启动eth0接口。 # # 这个命令的目的是在远程主机上配置eth0接口的IPv6地址、网关、配置方法和DNS服务器，并启动eth0接口。 # 查看网卡配置 # nmcli device show eth0 # nmcli con show eth0 [root@localhost ~]# cat /etc/sysconfig/network-scripts/ifcfg-eth0 TYPE=Ethernet PROXY_METHOD=none BROWSER_ONLY=no BOOTPROTO=none DEFROUTE=yes IPV4_FAILURE_FATAL=no IPV6INIT=yes IPV6_AUTOCONF=yes IPV6_DEFROUTE=yes IPV6_FAILURE_FATAL=no IPV6_ADDR_GEN_MODE=stable-privacy NAME=eth0 UUID=2aaddf95-3f36-4a48-8626-b55ebf7f53e7 DEVICE=eth0 ONBOOT=yes IPADDR=192.168.1.31 PREFIX=24 GATEWAY=192.168.1.1 DNS1=8.8.8.8 [root@localhost ~]# # 参数解释 # # TYPE=Ethernet # 指定连接类型为以太网。 # # PROXY_METHOD=none # 指定不使用代理方法。 # # BROWSER_ONLY=no # 指定不仅仅在浏览器中使用代理。 # # BOOTPROTO=none # 指定自动分配地址的方式为无（即手动配置IP地址）。 # # DEFROUTE=yes # 指定默认路由开启。 # # IPV4_FAILURE_FATAL=no # 指定IPv4连接失败时不宣告严重错误。 # # IPV6INIT=yes # 指定启用IPv6。 # # IPV6_AUTOCONF=no # 指定不自动配置IPv6地址。 # # IPV6_DEFROUTE=yes # 指定默认IPv6路由开启。 # # IPV6_FAILURE_FATAL=no # 指定IPv6连接失败时不宣告严重错误。 # # IPV6_ADDR_GEN_MODE=stable-privacy # 指定IPv6地址生成模式为稳定隐私模式。 # # NAME=eth0 # 指定设备名称为eth0。 # # UUID=424fd260-c480-4899-97e6-6fc9722031e8 # 指定设备的唯一标识符。 # # DEVICE=eth0 # 指定设备名称为eth0。 # # ONBOOT=yes # 指定开机自动启用这个连接。 # # IPADDR=192.168.1.31 # 指定IPv4地址为192.168.1.31。 # # PREFIX=24 # 指定IPv4地址的子网掩码为24。 # # GATEWAY=192.168.8.1 # 指定IPv4的网关地址为192.168.8.1。 # # DNS1=8.8.8.8 # 指定首选DNS服务器为8.8.8.8。 # # IPV6ADDR=fc00:43f4:1eea:1::10/128 # 指定IPv6地址为fc00:43f4:1eea:1::10，子网掩码为128。 # # IPV6_DEFAULTGW=fc00:43f4:1eea:1::1 # 指定IPv6的默认网关地址为fc00:43f4:1eea:1::1。 # # DNS2=2400:3200::1 # 指定备用DNS服务器为2400:3200::1。 1.3.设置主机名 link hostnamectl set-hostname k8s-master01 hostnamectl set-hostname k8s-master02 hostnamectl set-hostname k8s-master03 hostnamectl set-hostname k8s-node01 hostnamectl set-hostname k8s-node02 # 参数解释 # # 参数: set-hostname # 解释: 这是hostnamectl命令的一个参数，用于设置系统的主机名。 # # 参数: k8s-master01 # 解释: 这是要设置的主机名，将系统的主机名设置为\"k8s-master01\"。 1.4.配置yum源 link # 其他系统的源地址 # https://mirrors.tuna.tsinghua.edu.cn/help/ # 对于 Ubuntu sed -i 's/cn.archive.ubuntu.com/mirrors.ustc.edu.cn/g' /etc/apt/sources.list # 对于 CentOS 7 sudo sed -e 's|^mirrorlist=|#mirrorlist=|g' \\ -e 's|^#baseurl=http://mirror.centos.org/centos|baseurl=https://mirrors.tuna.tsinghua.edu.cn/centos|g' \\ -i.bak \\ /etc/yum.repos.d/CentOS-*.repo # 对于 CentOS 8 sudo sed -e 's|^mirrorlist=|#mirrorlist=|g' \\ -e 's|^#baseurl=http://mirror.centos.org/$contentdir|baseurl=https://mirrors.tuna.tsinghua.edu.cn/centos|g' \\ -i.bak \\ /etc/yum.repos.d/CentOS-*.repo # 对于私有仓库 sed -e 's|^mirrorlist=|#mirrorlist=|g' -e 's|^#baseurl=http://mirror.centos.org/\\$contentdir|baseurl=http://192.168.1.123/centos|g' -i.bak /etc/yum.repos.d/CentOS-*.repo # 参数解释 # # 以上命令是用于更改系统软件源的配置，以便从国内镜像站点下载软件包和更新。 # # 对于 Ubuntu 系统，将 /etc/apt/sources.list 文件中的软件源地址 cn.archive.ubuntu.com 替换为 mirrors.ustc.edu.cn。 # # 对于 CentOS 7 系统，将 /etc/yum.repos.d/CentOS-*.repo 文件中的 mirrorlist 注释掉，并将 baseurl 的值替换为 https://mirrors.tuna.tsinghua.edu.cn/centos。 # # 对于 CentOS 8 系统，同样将 /etc/yum.repos.d/CentOS-*.repo 文件中的 mirrorlist 注释掉，并将 baseurl 的值替换为 https://mirrors.tuna.tsinghua.edu.cn/centos。 # # 对于私有仓库，将 /etc/yum.repos.d/CentOS-*.repo 文件中的 mirrorlist 注释掉，并将 baseurl 的值替换为私有仓库地址 http://192.168.1.123/centos。 # # 这些命令通过使用 sed 工具和正则表达式，对相应的配置文件进行批量的替换操作，从而更改系统软件源配置。 1.5.安装一些必备工具 link # 对于 Ubuntu apt update \u0026\u0026 apt upgrade -y \u0026\u0026 apt install -y wget psmisc vim net-tools nfs-kernel-server telnet lvm2 git tar curl # 对于 CentOS 7 yum update -y \u0026\u0026 yum -y install wget psmisc vim net-tools nfs-utils telnet yum-utils device-mapper-persistent-data lvm2 git tar curl # 对于 CentOS 8 yum update -y \u0026\u0026 yum -y install wget psmisc vim net-tools nfs-utils telnet yum-utils device-mapper-persistent-data lvm2 git network-scripts tar curl 1.5.1 下载离线所需文件(可选) link在互联网服务器上安装一个一模一样的系统进行下载所需包\nCentOS7 link # 下载必要工具 yum -y install createrepo yum-utils wget epel* # 下载全量依赖包 repotrack createrepo wget psmisc vim net-tools nfs-utils telnet yum-utils device-mapper-persistent-data lvm2 git tar curl gcc keepalived haproxy bash-completion chrony sshpass ipvsadm ipset sysstat conntrack libseccomp # 删除libseccomp rm -rf libseccomp-*.rpm # 下载libseccomp wget http://rpmfind.net/linux/centos/8-stream/BaseOS/x86_64/os/Packages/libseccomp-2.5.1-1.el8.x86_64.rpm # 创建yum源信息 createrepo -u -d /data/centos7/ # 拷贝包到内网机器上 scp -r /data/centos7/ root@192.168.1.31: scp -r /data/centos7/ root@192.168.1.32: scp -r /data/centos7/ root@192.168.1.33: scp -r /data/centos7/ root@192.168.1.34: scp -r /data/centos7/ root@192.168.1.35: # 在内网机器上创建repo配置文件 rm -rf /etc/yum.repos.d/* cat \u003e /etc/yum.repos.d/123.repo \u003c\u003c EOF [fly] name=CentOS-$releasever - Media baseurl=file:///root/centos7/ gpgcheck=0 enabled=1 EOF # 安装下载好的包 yum clean all yum makecache yum install /root/centos7/* --skip-broken -y #### 备注 ##### # 安装完成后，可能还会出现yum无法使用那么再次执行 rm -rf /etc/yum.repos.d/* cat \u003e /etc/yum.repos.d/123.repo \u003c\u003c EOF [fly] name=CentOS-$releasever - Media baseurl=file:///root/centos7/ gpgcheck=0 enabled=1 EOF yum clean all yum makecache yum install /root/centos7/* --skip-broken -y #### 备注 ##### # 安装 chrony 和 libseccomp # yum install /root/centos7/libseccomp-2.5.1*.rpm -y # yum install /root/centos7/chrony-*.rpm -y CentOS8 link # 下载必要工具 yum -y install createrepo yum-utils wget epel* # 下载全量依赖包 repotrack wget psmisc vim net-tools nfs-utils telnet yum-utils device-mapper-persistent-data lvm2 git network-scripts tar curl gcc keepalived haproxy bash-completion chrony sshpass ipvsadm ipset sysstat conntrack libseccomp # 创建yum源信息 createrepo -u -d /data/centos8/ # 拷贝包到内网机器上 scp -r centos8/ root@192.168.1.31: scp -r centos8/ root@192.168.1.32: scp -r centos8/ root@192.168.1.33: scp -r centos8/ root@192.168.1.34: scp -r centos8/ root@192.168.1.35: # 在内网机器上创建repo配置文件 rm -rf /etc/yum.repos.d/* cat \u003e /etc/yum.repos.d/123.repo \u003c\u003c EOF [fly] name=CentOS-$releasever - Media baseurl=file:///root/centos8/ gpgcheck=0 enabled=1 EOF # 安装下载好的包 yum clean all yum makecache yum install /root/centos8/* --skip-broken -y #### 备注 ##### # 安装完成后，可能还会出现yum无法使用那么再次执行 rm -rf /etc/yum.repos.d/* cat \u003e /etc/yum.repos.d/123.repo \u003c\u003c EOF [fly] name=CentOS-$releasever - Media baseurl=file:///root/centos8/ gpgcheck=0 enabled=1 EOF yum clean all yum makecache yum install /root/centos8/* --skip-broken -y Ubuntu 下载包和依赖 link #!/bin/bash logfile=123.log ret=\"\" function getDepends() { echo \"fileName is\" $1\u003e\u003e$logfile # use tr to del \u003c \u003e ret=`apt-cache depends $1|grep Depends |cut -d: -f2 |tr -d \"\u003c\u003e\"` echo $ret|tee -a $logfile } # 需要获取其所依赖包的包 libs=\"wget psmisc vim net-tools nfs-kernel-server telnet lvm2 git tar curl gcc keepalived haproxy bash-completion chrony sshpass ipvsadm ipset sysstat conntrack libseccomp\" # download libs dependen. deep in 3 i=0 while [ $i -lt 3 ] ; do let i++ echo $i # download libs newlist=\" \" for j in $libs do added=\"$(getDepends $j)\" newlist=\"$newlist $added\" apt install $added --reinstall -d -y done libs=$newlist done # 创建源信息 apt install dpkg-dev sudo cp /var/cache/apt/archives/*.deb /data/ubuntu/ -r dpkg-scanpackages . /dev/null |gzip \u003e /data/ubuntu/Packages.gz -r # 拷贝包到内网机器上 scp -r ubuntu/ root@192.168.1.31: scp -r ubuntu/ root@192.168.1.32: scp -r ubuntu/ root@192.168.1.33: scp -r ubuntu/ root@192.168.1.34: scp -r ubuntu/ root@192.168.1.35: # 在内网机器上配置apt源 vim /etc/apt/sources.list cat /etc/apt/sources.list deb file:////root/ ubuntu/ # 安装deb包 apt install ./*.deb 1.6.选择性下载需要工具 link #!/bin/bash # 查看版本地址： # # https://github.com/containernetworking/plugins/releases/ # https://github.com/containerd/containerd/releases/ # https://github.com/kubernetes-sigs/cri-tools/releases/ # https://github.com/Mirantis/cri-dockerd/releases/ # https://github.com/etcd-io/etcd/releases/ # https://github.com/cloudflare/cfssl/releases/ # https://github.com/kubernetes/kubernetes/tree/master/CHANGELOG # https://download.docker.com/linux/static/stable/x86_64/ # https://github.com/opencontainers/runc/releases/ # https://mirrors.tuna.tsinghua.edu.cn/elrepo/kernel/el7/x86_64/RPMS/ # https://github.com/helm/helm/tags # http://nginx.org/download/ # Version numbers cni_plugins_version='v1.3.0' cri_containerd_cni_version='1.7.8' crictl_version='v1.28.0' cri_dockerd_version='0.3.7' etcd_version='v3.5.10' cfssl_version='1.6.4' kubernetes_server_version='1.28.3' docker_version='24.0.7' runc_version='1.1.10' kernel_version='5.4.260' helm_version='3.13.2' nginx_version='1.25.3' # URLs base_url='https://github.com' kernel_url=\"http://mirrors.tuna.tsinghua.edu.cn/elrepo/kernel/el7/x86_64/RPMS/kernel-lt-${kernel_version}-1.el7.elrepo.x86_64.rpm\" runc_url=\"${base_url}/opencontainers/runc/releases/download/v${runc_version}/runc.amd64\" docker_url=\"https://mirrors.ustc.edu.cn/docker-ce/linux/static/stable/x86_64/docker-${docker_version}.tgz\" cni_plugins_url=\"${base_url}/containernetworking/plugins/releases/download/${cni_plugins_version}/cni-plugins-linux-amd64-${cni_plugins_version}.tgz\" cri_containerd_cni_url=\"${base_url}/containerd/containerd/releases/download/v${cri_containerd_cni_version}/cri-containerd-cni-${cri_containerd_cni_version}-linux-amd64.tar.gz\" crictl_url=\"${base_url}/kubernetes-sigs/cri-tools/releases/download/${crictl_version}/crictl-${crictl_version}-linux-amd64.tar.gz\" cri_dockerd_url=\"${base_url}/Mirantis/cri-dockerd/releases/download/v${cri_dockerd_version}/cri-dockerd-${cri_dockerd_version}.amd64.tgz\" etcd_url=\"${base_url}/etcd-io/etcd/releases/download/${etcd_version}/etcd-${etcd_version}-linux-amd64.tar.gz\" cfssl_url=\"${base_url}/cloudflare/cfssl/releases/download/v${cfssl_version}/cfssl_${cfssl_version}_linux_amd64\" cfssljson_url=\"${base_url}/cloudflare/cfssl/releases/download/v${cfssl_version}/cfssljson_${cfssl_version}_linux_amd64\" helm_url=\"https://mirrors.huaweicloud.com/helm/v${helm_version}/helm-v${helm_version}-linux-amd64.tar.gz\" kubernetes_server_url=\"https://storage.googleapis.com/kubernetes-release/release/v${kubernetes_server_version}/kubernetes-server-linux-amd64.tar.gz\" nginx_url=\"http://nginx.org/download/nginx-${nginx_version}.tar.gz\" # Download packages packages=( $kernel_url $runc_url $docker_url $cni_plugins_url $cri_containerd_cni_url $crictl_url $cri_dockerd_url $etcd_url $cfssl_url $cfssljson_url $helm_url $kubernetes_server_url $nginx_url ) for package_url in \"${packages[@]}\"; do filename=$(basename \"$package_url\") if curl --parallel --parallel-immediate -k -L -C - -o \"$filename\" \"$package_url\"; then echo \"Downloaded $filename\" else echo \"Failed to download $filename\" exit 1 fi done 1.7.关闭防火墙 link # Ubuntu忽略，CentOS执行 systemctl disable --now firewalld 1.8.关闭SELinux link # Ubuntu忽略，CentOS执行 setenforce 0 sed -i 's#SELINUX=enforcing#SELINUX=disabled#g' /etc/selinux/config # 参数解释 # # setenforce 0 # 此命令用于设置 SELinux 的执行模式。0 表示关闭 SELinux。 # # sed -i 's#SELINUX=enforcing#SELINUX=disabled#g' /etc/selinux/config # 该命令使用 sed 工具来编辑 /etc/selinux/config 文件。其中 '-i' 参数表示直接修改原文件，而不是输出到终端或另一个文件。's#SELINUX=enforcing#SELINUX=disabled#g' 是 sed 的替换命令，它将文件中所有的 \"SELINUX=enforcing\" 替换为 \"SELINUX=disabled\"。这里的 '#' 是分隔符，用于替代传统的 '/' 分隔符，以避免与路径中的 '/' 冲突。 1.9.关闭交换分区 link sed -ri 's/.*swap.*/#\u0026/' /etc/fstab swapoff -a \u0026\u0026 sysctl -w vm.swappiness=0 cat /etc/fstab # /dev/mapper/centos-swap swap swap defaults 0 0 # 参数解释： # # -ri: 这个参数用于在原文件中替换匹配的模式。-r表示扩展正则表达式，-i允许直接修改文件。 # 's/.*swap.*/#\u0026/': 这是一个sed命令，用于在文件/etc/fstab中找到包含swap的行，并在行首添加#来注释掉该行。 # /etc/fstab: 这是一个文件路径，即/etc/fstab文件，用于存储文件系统表。 # swapoff -a: 这个命令用于关闭所有启用的交换分区。 # sysctl -w vm.swappiness=0: 这个命令用于修改vm.swappiness参数的值为0，表示系统在物理内存充足时更倾向于使用物理内存而非交换分区。 1.10.网络配置（俩种方式二选一） link # Ubuntu忽略，CentOS执行 # 方式一 # systemctl disable --now NetworkManager # systemctl start network \u0026\u0026 systemctl enable network # 方式二 cat \u003e /etc/NetworkManager/conf.d/calico.conf \u003c\u003c EOF [keyfile] unmanaged-devices=interface-name:cali*;interface-name:tunl* EOF systemctl restart NetworkManager # 参数解释 # # 这个参数用于指定不由 NetworkManager 管理的设备。它由以下两个部分组成 # # interface-name:cali* # 表示以 \"cali\" 开头的接口名称被排除在 NetworkManager 管理之外。例如，\"cali0\", \"cali1\" 等接口不受 NetworkManager 管理。 # # interface-name:tunl* # 表示以 \"tunl\" 开头的接口名称被排除在 NetworkManager 管理之外。例如，\"tunl0\", \"tunl1\" 等接口不受 NetworkManager 管理。 # # 通过使用这个参数，可以将特定的接口排除在 NetworkManager 的管理范围之外，以便其他工具或进程可以独立地管理和配置这些接口。 1.11.进行时间同步 link # 服务端 # apt install chrony -y yum install chrony -y cat \u003e /etc/chrony.conf \u003c\u003c EOF pool ntp.aliyun.com iburst driftfile /var/lib/chrony/drift makestep 1.0 3 rtcsync allow 192.168.1.0/24 local stratum 10 keyfile /etc/chrony.keys leapsectz right/UTC logdir /var/log/chrony EOF systemctl restart chronyd ; systemctl enable chronyd # 客户端 # apt install chrony -y yum install chrony -y cat \u003e /etc/chrony.conf \u003c\u003c EOF pool 192.168.1.31 iburst driftfile /var/lib/chrony/drift makestep 1.0 3 rtcsync keyfile /etc/chrony.keys leapsectz right/UTC logdir /var/log/chrony EOF systemctl restart chronyd ; systemctl enable chronyd #使用客户端进行验证 chronyc sources -v # 参数解释 # # pool ntp.aliyun.com iburst # 指定使用ntp.aliyun.com作为时间服务器池，iburst选项表示在初始同步时会发送多个请求以加快同步速度。 # # driftfile /var/lib/chrony/drift # 指定用于保存时钟漂移信息的文件路径。 # # makestep 1.0 3 # 设置当系统时间与服务器时间偏差大于1秒时，会以1秒的步长进行调整。如果偏差超过3秒，则立即进行时间调整。 # # rtcsync # 启用硬件时钟同步功能，可以提高时钟的准确性。 # # allow 192.168.0.0/24 # 允许192.168.0.0/24网段范围内的主机与chrony进行时间同步。 # # local stratum 10 # 将本地时钟设为stratum 10，stratum值表示时钟的准确度，值越小表示准确度越高。 # # keyfile /etc/chrony.keys # 指定使用的密钥文件路径，用于对时间同步进行身份验证。 # # leapsectz right/UTC # 指定时区为UTC。 # # logdir /var/log/chrony # 指定日志文件存放目录。 1.12.配置ulimit link ulimit -SHn 65535 cat \u003e\u003e /etc/security/limits.conf \u003c"
            }
        );
    index.add(
            {
                id:  56 ,
                href: "\/docs\/ops\/kubernetes\/2.kubernetes-v1.30.2%E4%BA%8C%E8%BF%9B%E5%88%B6%E9%83%A8%E7%BD%B2\/",
                title: "2.Kubernetes-v1.30.2高可用集群二进制部署(IPv4+IPv6双栈)",
                description: "Kubernetes（简称k8s）是Google在2014年6月开源的一个容器集群管理系统，使用Go语言开发，用于管理云平台中多个主机上的容器化的应用，Kubernetes的目标是让部署容器化的应用简单并且高效,Kubernetes提供了资源调度、部署管理、服务发现、扩容缩容、监控，维护等一整套功能。努力成为跨主机集群的自动部署、扩展以及运行应用程序容器的平台。 它支持一系列容器工具, 包括且不限于Docker等。",
                content: "介绍 link kubernetes（k8s）二进制高可用安装部署，支持IPv4+IPv6双栈。 我使用IPV6的目的是在公网进行访问，所以我配置了IPV6静态地址。 若您没有IPV6环境，或者不想使用IPv6，不对主机进行配置IPv6地址即可。 不配置IPV6，不影响后续，不过集群依旧是支持IPv6的。为后期留有扩展可能性。 若不要IPv6 ，不给网卡配置IPv6即可，不要对IPv6相关配置删除或操作，否则会出问题。 1.环境 link 主机名称 IP地址 说明 软件 192.168.1.60 外网节点 下载各种所需安装包 Master01 192.168.1.41 master节点 kube-apiserver、kube-controller-manager、kube-scheduler、etcd、\nkubelet、kube-proxy、nfs-client、haproxy、keepalived、nginx Master02 192.168.1.42 master节点 kube-apiserver、kube-controller-manager、kube-scheduler、etcd、\nkubelet、kube-proxy、nfs-client、haproxy、keepalived、nginx Master03 192.168.1.43 master节点 kube-apiserver、kube-controller-manager、kube-scheduler、etcd、\nkubelet、kube-proxy、nfs-client、haproxy、keepalived、nginx Node01 192.168.1.44 node节点 kubelet、kube-proxy、nfs-client、nginx Node02 192.168.1.45 node节点 kubelet、kube-proxy、nfs-client、nginx 192.168.1.46 VIP 网段 物理主机：192.168.1.0/24 service：10.96.0.0/12 pod：172.16.0.0/12\n1.1.k8s基础系统环境配置 link1.2.配置IP link # 注意！ # 若虚拟机是进行克隆的那么网卡的UUID和MachineID会重复 # 需要重新生成新的UUIDUUID和MachineID # UUID和MachineID重复无法DHCP获取到IPV6地址 ssh root@192.168.1.155 \"rm -rf /etc/machine-id; systemd-machine-id-setup;reboot\" ssh root@192.168.1.158 \"rm -rf /etc/machine-id; systemd-machine-id-setup;reboot\" ssh root@192.168.1.160 \"rm -rf /etc/machine-id; systemd-machine-id-setup;reboot\" ssh root@192.168.1.161 \"rm -rf /etc/machine-id; systemd-machine-id-setup;reboot\" ssh root@192.168.1.162 \"rm -rf /etc/machine-id; systemd-machine-id-setup;reboot\" # # 查看当前的网卡列表和 UUID： # nmcli con show # 删除要更改 UUID 的网络连接： # nmcli con delete uuid \u003c原 UUID\u003e # 重新生成 UUID： # nmcli con add type ethernet ifname \u003c接口名称\u003e con-name \u003c新名称\u003e # 重新启用网络连接： # nmcli con up \u003c新名称\u003e # 更改网卡的UUID # 先配置静态IP之后使用ssh方式配置不断连 ssh root@192.168.1.41 \"nmcli con delete uuid 8e8afb37-9cb4-362e-ba72-82568cb54312;nmcli con add type ethernet ifname ens18 con-name ens18;nmcli con up ens18\" ssh root@192.168.1.42 \"nmcli con delete uuid 8e8afb37-9cb4-362e-ba72-82568cb54312;nmcli con add type ethernet ifname ens18 con-name ens18;nmcli con up ens18\" ssh root@192.168.1.43 \"nmcli con delete uuid 8e8afb37-9cb4-362e-ba72-82568cb54312;nmcli con add type ethernet ifname ens18 con-name ens18;nmcli con up ens18\" ssh root@192.168.1.44 \"nmcli con delete uuid 8e8afb37-9cb4-362e-ba72-82568cb54312;nmcli con add type ethernet ifname ens18 con-name ens18;nmcli con up ens18\" ssh root@192.168.1.45 \"nmcli con delete uuid 8e8afb37-9cb4-362e-ba72-82568cb54312;nmcli con add type ethernet ifname ens18 con-name ens18;nmcli con up ens18\" # 参数解释 # # ssh ssh root@192.168.1.41 # 使用SSH登录到IP为192.168.1.41的主机，使用root用户身份。 # # nmcli con delete uuid 708a1497-2192-43a5-9f03-2ab936fb3c44 # 删除 UUID 为 708a1497-2192-43a5-9f03-2ab936fb3c44 的网络连接，这是 NetworkManager 中一种特定网络配置的唯一标识符。 # # nmcli con add type ethernet ifname ens18 con-name ens18 # 添加一种以太网连接类型，并指定接口名为 ens18，连接名称也为 ens18。 # # nmcli con up ens18 # 开启 ens18 这个网络连接。 # # 简单来说，这个命令的作用是删除一个特定的网络连接配置，并添加一个名为 ens18 的以太网连接，然后启用这个新的连接。 # 修改静态的IPv4地址 ssh root@192.168.1.158 \"nmcli con mod ens18 ipv4.addresses 192.168.1.41/24; nmcli con mod ens18 ipv4.gateway 192.168.1.1; nmcli con mod ens18 ipv4.method manual; nmcli con mod ens18 ipv4.dns \"8.8.8.8\"; nmcli con up ens18\" ssh root@192.168.1.151 \"nmcli con mod ens18 ipv4.addresses 192.168.1.42/24; nmcli con mod ens18 ipv4.gateway 192.168.1.1; nmcli con mod ens18 ipv4.method manual; nmcli con mod ens18 ipv4.dns \"8.8.8.8\"; nmcli con up ens18\" ssh root@192.168.1.152 \"nmcli con mod ens18 ipv4.addresses 192.168.1.43/24; nmcli con mod ens18 ipv4.gateway 192.168.1.1; nmcli con mod ens18 ipv4.method manual; nmcli con mod ens18 ipv4.dns \"8.8.8.8\"; nmcli con up ens18\" ssh root@192.168.1.157 \"nmcli con mod ens18 ipv4.addresses 192.168.1.44/24; nmcli con mod ens18 ipv4.gateway 192.168.1.1; nmcli con mod ens18 ipv4.method manual; nmcli con mod ens18 ipv4.dns \"8.8.8.8\"; nmcli con up ens18\" ssh root@192.168.1.155 \"nmcli con mod ens18 ipv4.addresses 192.168.1.45/24; nmcli con mod ens18 ipv4.gateway 192.168.1.1; nmcli con mod ens18 ipv4.method manual; nmcli con mod ens18 ipv4.dns \"8.8.8.8\"; nmcli con up ens18\" # 参数解释 # # ssh root@192.168.1.154 # 使用SSH登录到IP为192.168.1.154的主机，使用root用户身份。 # # \"nmcli con mod ens18 ipv4.addresses 192.168.1.41/24\" # 修改ens18网络连接的IPv4地址为192.168.1.41，子网掩码为 24。 # # \"nmcli con mod ens18 ipv4.gateway 192.168.1.1\" # 修改ens18网络连接的IPv4网关为192.168.1.1。 # # \"nmcli con mod ens18 ipv4.method manual\" # 将ens18网络连接的IPv4配置方法设置为手动。 # # \"nmcli con mod ens18 ipv4.dns \"8.8.8.8\" # 将ens18网络连接的IPv4 DNS服务器设置为 8.8.8.8。 # # \"nmcli con up ens18\" # 启动ens18网络连接。 # # 总体来说，这条命令是通过SSH远程登录到指定的主机，并使用网络管理命令 (nmcli) 修改ens18网络连接的配置，包括IP地址、网关、配置方法和DNS服务器，并启动该网络连接。 # 没有固定IPv6选择不配置即可 ssh root@192.168.1.41 \"nmcli con mod ens18 ipv6.addresses fc00:43f4:1eea:1::10; nmcli con mod ens18 ipv6.gateway fc00:43f4:1eea:1::1; nmcli con mod ens18 ipv6.method manual; nmcli con mod ens18 ipv6.dns \"2400:3200::1\"; nmcli con up ens18\" ssh root@192.168.1.42 \"nmcli con mod ens18 ipv6.addresses fc00:43f4:1eea:1::20; nmcli con mod ens18 ipv6.gateway fc00:43f4:1eea:1::1; nmcli con mod ens18 ipv6.method manual; nmcli con mod ens18 ipv6.dns \"2400:3200::1\"; nmcli con up ens18\" ssh root@192.168.1.43 \"nmcli con mod ens18 ipv6.addresses fc00:43f4:1eea:1::30; nmcli con mod ens18 ipv6.gateway fc00:43f4:1eea:1::1; nmcli con mod ens18 ipv6.method manual; nmcli con mod ens18 ipv6.dns \"2400:3200::1\"; nmcli con up ens18\" ssh root@192.168.1.44 \"nmcli con mod ens18 ipv6.addresses fc00:43f4:1eea:1::40; nmcli con mod ens18 ipv6.gateway fc00:43f4:1eea:1::1; nmcli con mod ens18 ipv6.method manual; nmcli con mod ens18 ipv6.dns \"2400:3200::1\"; nmcli con up ens18\" ssh root@192.168.1.45 \"nmcli con mod ens18 ipv6.addresses fc00:43f4:1eea:1::50; nmcli con mod ens18 ipv6.gateway fc00:43f4:1eea:1::1; nmcli con mod ens18 ipv6.method manual; nmcli con mod ens18 ipv6.dns \"2400:3200::1\"; nmcli con up ens18\" # 参数解释 # # ssh root@192.168.1.41 # 通过SSH连接到IP地址为192.168.1.41的远程主机，使用root用户进行登录。 # # \"nmcli con mod ens18 ipv6.addresses fc00:43f4:1eea:1::10\" # 使用nmcli命令修改ens18接口的IPv6地址为fc00:43f4:1eea:1::10。 # # \"nmcli con mod ens18 ipv6.gateway fc00:43f4:1eea:1::1\" # 使用nmcli命令修改ens18接口的IPv6网关为fc00:43f4:1eea:1::1。 # # \"nmcli con mod ens18 ipv6.method manual\" # 使用nmcli命令将ens18接口的IPv6配置方法修改为手动配置。 # # \"nmcli con mod ens18 ipv6.dns \"2400:3200::1\" # 使用nmcli命令设置ens18接口的IPv6 DNS服务器为2400:3200::1。 # # \"nmcli con up ens18\" # 使用nmcli命令启动ens18接口。 # # 这个命令的目的是在远程主机上配置ens18接口的IPv6地址、网关、配置方法和DNS服务器，并启动ens18接口。 # 查看网卡配置 # nmcli device show ens18 # nmcli con show ens18 [root@localhost ~]# cat /etc/NetworkManager/system-connections/ens18.nmconnection [connection] id=ens18 uuid=97445eea-70e8-47a7-8be4-a707de271f5e type=ethernet interface-name=ens18 timestamp=1716705021 [ethernet] [ipv4] address1=192.168.1.41/24,192.168.1.1 dns=8.8.8.8; method=manual [ipv6] addr-gen-mode=default method=auto [proxy] [root@localhost ~]# # 参数解释 # 1. `[connection]`: # - `id`: 连接的唯一标识符，用于内部引用。 # - `uuid`: 连接的通用唯一标识符（UUID），确保在系统中的唯一性。 # - `type`: 指定连接的类型，本例中为以太网。 # - `interface-name`: 网络接口的名称（`ens18`），表示与此连接关联的物理或逻辑网络接口。 # - `timestamp`: 时间戳，指示连接配置上次修改的时间。 # 2. `[ethernet]`: # - 通常包含以太网特定的配置设置，如MAC地址或链路速度。 # 3. `[ipv4]`: # - `address1`: 以CIDR表示法指定IPv4地址和子网掩码（`192.168.1.41/24`）。还包括网关IP（`192.168.1.1`）。 # - `dns`: 指定要使用的DNS服务器（本例中为`8.8.8.8`），提供将域名转换为IP地址的手段。 # - `method`: 指定获取IPv4地址的方法。在本例中，设置为手动，表示IP地址是静态配置的。 # 4. `[ipv6]`: # - `addr-gen-mode`: 指定IPv6地址生成模式。设置为默认，通常意味着地址是根据接口的MAC地址生成的。 # - `method`: 指定获取IPv6地址的方法。在本例中，设置为自动，表示使用DHCPv6或SLAAC等协议进行自动配置。 # 5. `[proxy]`: # - 通常用于配置代理设置，如HTTP或SOCKS代理。 1.3.设置主机名 link hostnamectl set-hostname k8s-master01 hostnamectl set-hostname k8s-master02 hostnamectl set-hostname k8s-master03 hostnamectl set-hostname k8s-node01 hostnamectl set-hostname k8s-node02 # 参数解释 # # 参数: set-hostname # 解释: 这是hostnamectl命令的一个参数，用于设置系统的主机名。 # # 参数: k8s-master01 # 解释: 这是要设置的主机名，将系统的主机名设置为\"k8s-master01\"。 1.4.配置yum源 link # 其他系统的源地址 # https://help.mirrors.cernet.edu.cn/ # 对于私有仓库 sed -e 's|^mirrorlist=|#mirrorlist=|g' -e 's|^#baseurl=http://mirror.centos.org/\\$contentdir|baseurl=http://192.168.1.123/centos|g' -i.bak /etc/yum.repos.d/CentOS-*.repo # 对于 Ubuntu sed -i 's/cn.archive.ubuntu.com/mirrors.ustc.edu.cn/g' /etc/apt/sources.list # epel扩展源 sudo yum install -y epel-release sudo sed -e 's!^metalink=!#metalink=!g' \\ -e 's!^#baseurl=!baseurl=!g' \\ -e 's!https\\?://download\\.fedoraproject\\.org/pub/epel!https://mirror.nju.edu.cn/epel!g' \\ -e 's!https\\?://download\\.example/pub/epel!https://mirror.nju.edu.cn/epel!g' \\ -i /etc/yum.repos.d/epel{,-testing}.repo # 对于 CentOS 7 sudo sed -e 's|^mirrorlist=|#mirrorlist=|g' \\ -e 's|^#baseurl=http://mirror.centos.org/centos|baseurl=https://mirror.nju.edu.cn/centos|g' \\ -i.bak \\ /etc/yum.repos.d/CentOS-*.repo # 对于 CentOS 8 sudo sed -e 's|^mirrorlist=|#mirrorlist=|g' \\ -e 's|^#baseurl=http://mirror.centos.org/$contentdir|baseurl=https://mirror.nju.edu.cn/centos|g' \\ -i.bak \\ /etc/yum.repos.d/CentOS-*.repo # 对于CentOS 9 cat \u003c\u003c'EOF' \u003e /etc/yum.repos.d/centos.repo [baseos] name=CentOS Stream $releasever - BaseOS baseurl=https://mirrors.tuna.tsinghua.edu.cn/centos-stream/$releasever-stream/BaseOS/$basearch/os # metalink=https://mirrors.centos.org/metalink?repo=centos-baseos-$stream\u0026arch=$basearch\u0026protocol=https,http gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-centosofficial gpgcheck=1 repo_gpgcheck=0 metadata_expire=6h countme=1 enabled=1 [baseos-debuginfo] name=CentOS Stream $releasever - BaseOS - Debug baseurl=https://mirrors.tuna.tsinghua.edu.cn/centos-stream/$releasever-stream/BaseOS/$basearch/debug/tree/ # metalink=https://mirrors.centos.org/metalink?repo=centos-baseos-debug-$stream\u0026arch=$basearch\u0026protocol=https,http gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-centosofficial gpgcheck=1 repo_gpgcheck=0 metadata_expire=6h enabled=0 [baseos-source] name=CentOS Stream $releasever - BaseOS - Source baseurl=https://mirrors.tuna.tsinghua.edu.cn/centos-stream/$releasever-stream/BaseOS/source/tree/ # metalink=https://mirrors.centos.org/metalink?repo=centos-baseos-source-$stream\u0026arch=source\u0026protocol=https,http gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-centosofficial gpgcheck=1 repo_gpgcheck=0 metadata_expire=6h enabled=0 [appstream] name=CentOS Stream $releasever - AppStream baseurl=https://mirrors.tuna.tsinghua.edu.cn/centos-stream/$releasever-stream/AppStream/$basearch/os # metalink=https://mirrors.centos.org/metalink?repo=centos-appstream-$stream\u0026arch=$basearch\u0026protocol=https,http gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-centosofficial gpgcheck=1 repo_gpgcheck=0 metadata_expire=6h countme=1 enabled=1 [appstream-debuginfo] name=CentOS Stream $releasever - AppStream - Debug baseurl=https://mirrors.tuna.tsinghua.edu.cn/centos-stream/$releasever-stream/AppStream/$basearch/debug/tree/ # metalink=https://mirrors.centos.org/metalink?repo=centos-appstream-debug-$stream\u0026arch=$basearch\u0026protocol=https,http gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-centosofficial gpgcheck=1 repo_gpgcheck=0 metadata_expire=6h enabled=0 [appstream-source] name=CentOS Stream $releasever - AppStream - Source baseurl=https://mirrors.tuna.tsinghua.edu.cn/centos-stream/$releasever-stream/AppStream/source/tree/ # metalink=https://mirrors.centos.org/metalink?repo=centos-appstream-source-$stream\u0026arch=source\u0026protocol=https,http gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-centosofficial gpgcheck=1 repo_gpgcheck=0 metadata_expire=6h enabled=0 [crb] name=CentOS Stream $releasever - CRB baseurl=https://mirrors.tuna.tsinghua.edu.cn/centos-stream/$releasever-stream/CRB/$basearch/os # metalink=https://mirrors.centos.org/metalink?repo=centos-crb-$stream\u0026arch=$basearch\u0026protocol=https,http gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-centosofficial gpgcheck=1 repo_gpgcheck=0 metadata_expire=6h countme=1 enabled=1 [crb-debuginfo] name=CentOS Stream $releasever - CRB - Debug baseurl=https://mirrors.tuna.tsinghua.edu.cn/centos-stream/$releasever-stream/CRB/$basearch/debug/tree/ # metalink=https://mirrors.centos.org/metalink?repo=centos-crb-debug-$stream\u0026arch=$basearch\u0026protocol=https,http gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-centosofficial gpgcheck=1 repo_gpgcheck=0 metadata_expire=6h enabled=0 [crb-source] name=CentOS Stream $releasever - CRB - Source baseurl=https://mirrors.tuna.tsinghua.edu.cn/centos-stream/$releasever-stream/CRB/source/tree/ # metalink=https://mirrors.centos.org/metalink?repo=centos-crb-source-$stream\u0026arch=source\u0026protocol=https,http gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-centosofficial gpgcheck=1 repo_gpgcheck=0 metadata_expire=6h enabled=0 EOF cat \u003c\u003c'EOF' \u003e /etc/yum.repos.d/centos-addons.repo [highavailability] name=CentOS Stream $releasever - HighAvailability baseurl=https://mirrors.tuna.tsinghua.edu.cn/centos-stream/$releasever-stream/HighAvailability/$basearch/os # metalink=https://mirrors.centos.org/metalink?repo=centos-highavailability-$stream\u0026arch=$basearch\u0026protocol=https,http gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-centosofficial gpgcheck=1 repo_gpgcheck=0 metadata_expire=6h countme=1 enabled=0 [highavailability-debuginfo] name=CentOS Stream $releasever - HighAvailability - Debug baseurl=https://mirrors.tuna.tsinghua.edu.cn/centos-stream/$releasever-stream/HighAvailability/$basearch/debug/tree/ # metalink=https://mirrors.centos.org/metalink?repo=centos-highavailability-debug-$stream\u0026arch=$basearch\u0026protocol=https,http gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-centosofficial gpgcheck=1 repo_gpgcheck=0 metadata_expire=6h enabled=0 [highavailability-source] name=CentOS Stream $releasever - HighAvailability - Source baseurl=https://mirrors.tuna.tsinghua.edu.cn/centos-stream/$releasever-stream/HighAvailability/source/tree/ # metalink=https://mirrors.centos.org/metalink?repo=centos-highavailability-source-$stream\u0026arch=source\u0026protocol=https,http gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-centosofficial gpgcheck=1 repo_gpgcheck=0 metadata_expire=6h enabled=0 [nfv] name=CentOS Stream $releasever - NFV baseurl=https://mirrors.tuna.tsinghua.edu.cn/centos-stream/$releasever-stream/NFV/$basearch/os # metalink=https://mirrors.centos.org/metalink?repo=centos-nfv-$stream\u0026arch=$basearch\u0026protocol=https,http gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-centosofficial gpgcheck=1 repo_gpgcheck=0 metadata_expire=6h countme=1 enabled=0 [nfv-debuginfo] name=CentOS Stream $releasever - NFV - Debug baseurl=https://mirrors.tuna.tsinghua.edu.cn/centos-stream/$releasever-stream/NFV/$basearch/debug/tree/ # metalink=https://mirrors.centos.org/metalink?repo=centos-nfv-debug-$stream\u0026arch=$basearch\u0026protocol=https,http gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-centosofficial gpgcheck=1 repo_gpgcheck=0 metadata_expire=6h enabled=0 [nfv-source] name=CentOS Stream $releasever - NFV - Source baseurl=https://mirrors.tuna.tsinghua.edu.cn/centos-stream/$releasever-stream/NFV/source/tree/ # metalink=https://mirrors.centos.org/metalink?repo=centos-nfv-source-$stream\u0026arch=source\u0026protocol=https,http gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-centosofficial gpgcheck=1 repo_gpgcheck=0 metadata_expire=6h enabled=0 [rt] name=CentOS Stream $releasever - RT baseurl=https://mirrors.tuna.tsinghua.edu.cn/centos-stream/$releasever-stream/RT/$basearch/os # metalink=https://mirrors.centos.org/metalink?repo=centos-rt-$stream\u0026arch=$basearch\u0026protocol=https,http gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-centosofficial gpgcheck=1 repo_gpgcheck=0 metadata_expire=6h countme=1 enabled=0 [rt-debuginfo] name=CentOS Stream $releasever - RT - Debug baseurl=https://mirrors.tuna.tsinghua.edu.cn/centos-stream/$releasever-stream/RT/$basearch/debug/tree/ # metalink=https://mirrors.centos.org/metalink?repo=centos-rt-debug-$stream\u0026arch=$basearch\u0026protocol=https,http gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-centosofficial gpgcheck=1 repo_gpgcheck=0 metadata_expire=6h enabled=0 [rt-source] name=CentOS Stream $releasever - RT - Source baseurl=https://mirrors.tuna.tsinghua.edu.cn/centos-stream/$releasever-stream/RT/source/tree/ # metalink=https://mirrors.centos.org/metalink?repo=centos-rt-source-$stream\u0026arch=source\u0026protocol=https,http gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-centosofficial gpgcheck=1 repo_gpgcheck=0 metadata_expire=6h enabled=0 [resilientstorage] name=CentOS Stream $releasever - ResilientStorage baseurl=https://mirrors.tuna.tsinghua.edu.cn/centos-stream/$releasever-stream/ResilientStorage/$basearch/os # metalink=https://mirrors.centos.org/metalink?repo=centos-resilientstorage-$stream\u0026arch=$basearch\u0026protocol=https,http gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-centosofficial gpgcheck=1 repo_gpgcheck=0 metadata_expire=6h countme=1 enabled=0 [resilientstorage-debuginfo] name=CentOS Stream $releasever - ResilientStorage - Debug baseurl=https://mirrors.tuna.tsinghua.edu.cn/centos-stream/$releasever-stream/ResilientStorage/$basearch/debug/tree/ # metalink=https://mirrors.centos.org/metalink?repo=centos-resilientstorage-debug-$stream\u0026arch=$basearch\u0026protocol=https,http gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-centosofficial gpgcheck=1 repo_gpgcheck=0 metadata_expire=6h enabled=0 [resilientstorage-source] name=CentOS Stream $releasever - ResilientStorage - Source baseurl=https://mirrors.tuna.tsinghua.edu.cn/centos-stream/$releasever-stream/ResilientStorage/source/tree/ # metalink=https://mirrors.centos.org/metalink?repo=centos-resilientstorage-source-$stream\u0026arch=source\u0026protocol=https,http gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-centosofficial gpgcheck=1 repo_gpgcheck=0 metadata_expire=6h enabled=0 [extras-common] name=CentOS Stream $releasever - Extras packages baseurl=https://mirrors.tuna.tsinghua.edu.cn/centos-stream/SIGs/$releasever-stream/extras/$basearch/extras-common # metalink=https://mirrors.centos.org/metalink?repo=centos-extras-sig-extras-common-$stream\u0026arch=$basearch\u0026protocol=https,http gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-SIG-Extras-SHA512 gpgcheck=1 repo_gpgcheck=0 metadata_expire=6h countme=1 enabled=1 [extras-common-source] name=CentOS Stream $releasever - Extras packages - Source baseurl=https://mirrors.tuna.tsinghua.edu.cn/centos-stream/SIGs/$releasever-stream/extras/source/extras-common # metalink=https://mirrors.centos.org/metalink?repo=centos-extras-sig-extras-common-source-$stream\u0026arch=source\u0026protocol=https,http gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-SIG-Extras-SHA512 gpgcheck=1 repo_gpgcheck=0 metadata_expire=6h enabled=0 EOF 1.5.安装一些必备工具 link # 对于 Ubuntu apt update \u0026\u0026 apt upgrade -y \u0026\u0026 apt install -y wget psmisc vim net-tools nfs-kernel-server telnet lvm2 git tar curl # 对于 CentOS 7 yum update -y \u0026\u0026 yum -y install wget psmisc vim net-tools nfs-utils telnet yum-utils device-mapper-persistent-data lvm2 git tar curl # 对于 CentOS 8 yum update -y \u0026\u0026 yum -y install wget psmisc vim net-tools nfs-utils telnet yum-utils device-mapper-persistent-data lvm2 git network-scripts tar curl # 对于 CentOS 9 yum update -y \u0026\u0026 yum -y install wget psmisc vim net-tools nfs-utils telnet yum-utils device-mapper-persistent-data lvm2 git tar curl 1.5.1 下载离线所需文件(可选) link在互联网服务器上安装一个一模一样的系统进行下载所需包\nCentOS7 link # 下载必要工具 yum -y install createrepo yum-utils wget epel* # 下载全量依赖包 repotrack createrepo wget psmisc vim net-tools nfs-utils telnet yum-utils device-mapper-persistent-data lvm2 git tar curl gcc keepalived haproxy bash-completion chrony sshpass ipvsadm ipset sysstat conntrack libseccomp # 删除libseccomp rm -rf libseccomp-*.rpm # 下载libseccomp wget http://rpmfind.net/linux/centos/8-stream/BaseOS/x86_64/os/Packages/libseccomp-2.5.1-1.el8.x86_64.rpm # 创建yum源信息 createrepo -u -d /data/centos7/ # 拷贝包到内网机器上 scp -r /data/centos7/ root@192.168.1.41: scp -r /data/centos7/ root@192.168.1.42: scp -r /data/centos7/ root@192.168.1.43: scp -r /data/centos7/ root@192.168.1.44: scp -r /data/centos7/ root@192.168.1.45: # 在内网机器上创建repo配置文件 rm -rf /etc/yum.repos.d/* cat \u003e /etc/yum.repos.d/123.repo \u003c\u003c EOF [fly] name=CentOS-$releasever - Media baseurl=file:///root/centos7/ gpgcheck=0 enabled=1 EOF # 安装下载好的包 yum clean all yum makecache yum install /root/centos7/* --skip-broken -y #### 备注 ##### # 安装完成后，可能还会出现yum无法使用那么再次执行 rm -rf /etc/yum.repos.d/* cat \u003e /etc/yum.repos.d/123.repo \u003c\u003c EOF [fly] name=CentOS-$releasever - Media baseurl=file:///root/centos7/ gpgcheck=0 enabled=1 EOF yum clean all yum makecache yum install /root/centos7/*.rpm --skip-broken -y #### 备注 ##### # 安装 chrony 和 libseccomp # yum install /root/centos7/libseccomp-2.5.1*.rpm -y # yum install /root/centos7/chrony-*.rpm -y CentOS8 link # 下载必要工具 yum -y install createrepo yum-utils wget epel* # 下载全量依赖包 repotrack wget psmisc vim net-tools nfs-utils telnet yum-utils device-mapper-persistent-data lvm2 git network-scripts tar curl gcc keepalived haproxy bash-completion chrony sshpass ipvsadm ipset sysstat conntrack libseccomp # 创建yum源信息 createrepo -u -d /data/centos8/ # 拷贝包到内网机器上 scp -r centos8/ root@192.168.1.41: scp -r centos8/ root@192.168.1.42: scp -r centos8/ root@192.168.1.43: scp -r centos8/ root@192.168.1.44: scp -r centos8/ root@192.168.1.45: # 在内网机器上创建repo配置文件 rm -rf /etc/yum.repos.d/* cat \u003e /etc/yum.repos.d/123.repo \u003c\u003c EOF [fly] name=CentOS-$releasever - Media baseurl=file:///root/centos8/ gpgcheck=0 enabled=1 EOF # 安装下载好的包 yum clean all yum makecache yum install /root/centos8/* --skip-broken -y #### 备注 ##### # 安装完成后，可能还会出现yum无法使用那么再次执行 rm -rf /etc/yum.repos.d/* cat \u003e /etc/yum.repos.d/123.repo \u003c\u003c EOF [fly] name=CentOS-$releasever - Media baseurl=file:///root/centos8/ gpgcheck=0 enabled=1 EOF yum clean all yum makecache yum install /root/centos8/*.rpm --skip-broken -y CentOS9 link # 下载必要工具 yum -y install createrepo yum-utils wget epel* # 下载全量依赖包 repotrack wget psmisc vim net-tools nfs-utils telnet yum-utils device-mapper-persistent-data lvm2 git tar curl gcc keepalived haproxy bash-completion chrony sshpass ipvsadm ipset sysstat conntrack libseccomp # 创建yum源信息 createrepo -u -d centos9/ # 拷贝包到内网机器上 scp -r centos9/ root@192.168.1.41: scp -r centos9/ root@192.168.1.42: scp -r centos9/ root@192.168.1.43: scp -r centos9/ root@192.168.1.44: scp -r centos9/ root@192.168.1.45: # 在内网机器上创建repo配置文件 rm -rf /etc/yum.repos.d/* cat \u003e /etc/yum.repos.d/123.repo \u003c\u003c EOF [fly] name=CentOS-$releasever - Media baseurl=file:///root/centos9/ gpgcheck=0 enabled=1 EOF # 安装下载好的包 yum clean all yum makecache yum install /root/centos9/*.rpm --skip-broken -y Ubuntu 下载包和依赖 link #!/bin/bash logfile=123.log ret=\"\" function getDepends() { echo \"fileName is\" $1\u003e\u003e$logfile # use tr to del \u003c \u003e ret=`apt-cache depends $1|grep Depends |cut -d: -f2 |tr -d \"\u003c\u003e\"` echo $ret|tee -a $logfile } # 需要获取其所依赖包的包 libs=\"wget psmisc vim net-tools nfs-kernel-server telnet lvm2 git tar curl gcc keepalived haproxy bash-completion chrony sshpass ipvsadm ipset sysstat conntrack libseccomp\" # download libs dependen. deep in 3 i=0 while [ $i -lt 3 ] ; do let i++ echo $i # download libs newlist=\" \" for j in $libs do added=\"$(getDepends $j)\" newlist=\"$newlist $added\" apt install $added --reinstall -d -y done libs=$newlist done # 创建源信息 apt install dpkg-dev sudo cp /var/cache/apt/archives/*.deb /data/ubuntu/ -r dpkg-scanpackages . /dev/null |gzip \u003e /data/ubuntu/Packages.gz -r # 拷贝包到内网机器上 scp -r ubuntu/ root@192.168.1.41: scp -r ubuntu/ root@192.168.1.42: scp -r ubuntu/ root@192.168.1.43: scp -r ubuntu/ root@192.168.1.44: scp -r ubuntu/ root@192.168.1.45: # 在内网机器上配置apt源 vim /etc/apt/sources.list cat /etc/apt/sources.list deb file:////root/ ubuntu/ # 安装deb包 apt install ./*.deb 1.6.选择性下载需要工具 link #!/bin/bash # 查看版本地址： # # https://github.com/containernetworking/plugins/releases/ # https://github.com/containerd/containerd/releases/ # https://github.com/kubernetes-sigs/cri-tools/releases/ # https://github.com/Mirantis/cri-dockerd/releases/ # https://github.com/etcd-io/etcd/releases/ # https://github.com/cloudflare/cfssl/releases/ # https://github.com/kubernetes/kubernetes/tree/master/CHANGELOG # https://download.docker.com/linux/static/stable/x86_64/ # https://github.com/opencontainers/runc/releases/ # https://mirrors.tuna.tsinghua.edu.cn/elrepo/kernel/el7/x86_64/RPMS/ # https://github.com/helm/helm/tags # http://nginx.org/download/ # Version numbers cni_plugins_version='v1.5.1' cri_containerd_cni_version='1.7.18' crictl_version='v1.30.0' cri_dockerd_version='0.3.14' etcd_version='v3.5.13' cfssl_version='1.6.5' kubernetes_server_version='1.30.2' docker_version='26.1.4' runc_version='1.1.13' kernel_version='5.4.278' helm_version='3.15.2' nginx_version='1.27.0' # URLs base_url='https://github.com' kernel_url=\"http://mirrors.tuna.tsinghua.edu.cn/elrepo/kernel/el7/x86_64/RPMS/kernel-lt-${kernel_version}-1.el7.elrepo.x86_64.rpm\" runc_url=\"${base_url}/opencontainers/runc/releases/download/v${runc_version}/runc.amd64\" docker_url=\"https://mirrors.ustc.edu.cn/docker-ce/linux/static/stable/x86_64/docker-${docker_version}.tgz\" cni_plugins_url=\"${base_url}/containernetworking/plugins/releases/download/${cni_plugins_version}/cni-plugins-linux-amd64-${cni_plugins_version}.tgz\" cri_containerd_cni_url=\"${base_url}/containerd/containerd/releases/download/v${cri_containerd_cni_version}/cri-containerd-cni-${cri_containerd_cni_version}-linux-amd64.tar.gz\" crictl_url=\"${base_url}/kubernetes-sigs/cri-tools/releases/download/${crictl_version}/crictl-${crictl_version}-linux-amd64.tar.gz\" cri_dockerd_url=\"${base_url}/Mirantis/cri-dockerd/releases/download/v${cri_dockerd_version}/cri-dockerd-${cri_dockerd_version}.amd64.tgz\" etcd_url=\"${base_url}/etcd-io/etcd/releases/download/${etcd_version}/etcd-${etcd_version}-linux-amd64.tar.gz\" cfssl_url=\"${base_url}/cloudflare/cfssl/releases/download/v${cfssl_version}/cfssl_${cfssl_version}_linux_amd64\" cfssljson_url=\"${base_url}/cloudflare/cfssl/releases/download/v${cfssl_version}/cfssljson_${cfssl_version}_linux_amd64\" helm_url=\"https://mirrors.huaweicloud.com/helm/v${helm_version}/helm-v${helm_version}-linux-amd64.tar.gz\" kubernetes_server_url=\"https://storage.googleapis.com/kubernetes-release/release/v${kubernetes_server_version}/kubernetes-server-linux-amd64.tar.gz\" nginx_url=\"http://nginx.org/download/nginx-${nginx_version}.tar.gz\" # Download packages packages=( # $kernel_url $runc_url $docker_url $cni_plugins_url $cri_containerd_cni_url $crictl_url $cri_dockerd_url $etcd_url $cfssl_url $cfssljson_url $helm_url $kubernetes_server_url $nginx_url ) for package_url in \"${packages[@]}\"; do filename=$(basename \"$package_url\") if curl --parallel --parallel-immediate -k -L -C - -o \"$filename\" \"$package_url\"; then echo \"Downloaded $filename\" else echo \"Failed to download $filename\" exit 1 fi done 1.7.关闭防火墙 link # Ubuntu忽略，CentOS执行 systemctl disable --now firewalld 1.8.关闭SELinux link # Ubuntu忽略，CentOS执行 setenforce 0 sed -i 's#SELINUX=enforcing#SELINUX=disabled#g' /etc/selinux/config # 参数解释 # # setenforce 0 # 此命令用于设置 SELinux 的执行模式。0 表示关闭 SELinux。 # # sed -i 's#SELINUX=enforcing#SELINUX=disabled#g' /etc/selinux/config # 该命令使用 sed 工具来编辑 /etc/selinux/config 文件。其中 '-i' 参数表示直接修改原文件，而不是输出到终端或另一个文件。's#SELINUX=enforcing#SELINUX=disabled#g' 是 sed 的替换命令，它将文件中所有的 \"SELINUX=enforcing\" 替换为 \"SELINUX=disabled\"。这里的 '#' 是分隔符，用于替代传统的 '/' 分隔符，以避免与路径中的 '/' 冲突。 1.9.关闭交换分区 link sed -ri 's/.*swap.*/#\u0026/' /etc/fstab swapoff -a \u0026\u0026 sysctl -w vm.swappiness=0 cat /etc/fstab # /dev/mapper/centos-swap swap swap defaults 0 0 # 参数解释： # # -ri: 这个参数用于在原文件中替换匹配的模式。-r表示扩展正则表达式，-i允许直接修改文件。 # 's/.*swap.*/#\u0026/': 这是一个sed命令，用于在文件/etc/fstab中找到包含swap的行，并在行首添加#来注释掉该行。 # /etc/fstab: 这是一个文件路径，即/etc/fstab文件，用于存储文件系统表。 # swapoff -a: 这个命令用于关闭所有启用的交换分区。 # sysctl -w vm.swappiness=0: 这个命令用于修改vm.swappiness参数的值为0，表示系统在物理内存充足时更倾向于使用物理内存而非交换分区。 1.10.网络配置（俩种方式二选一） link # Ubuntu忽略，CentOS执行，CentOS9不支持方式一 # 方式一 # systemctl disable --now NetworkManager # systemctl start network \u0026\u0026 systemctl enable network # 方式二 cat \u003e /etc/NetworkManager/conf.d/calico.conf \u003c\u003c EOF [keyfile] unmanaged-devices=interface-name:cali*;interface-name:tunl* EOF systemctl restart NetworkManager # 参数解释 # # 这个参数用于指定不由 NetworkManager 管理的设备。它由以下两个部分组成 # # interface-name:cali* # 表示以 \"cali\" 开头的接口名称被排除在 NetworkManager 管理之外。例如，\"cali0\", \"cali1\" 等接口不受 NetworkManager 管理。 # # interface-name:tunl* # 表示以 \"tunl\" 开头的接口名称被排除在 NetworkManager 管理之外。例如，\"tunl0\", \"tunl1\" 等接口不受 NetworkManager 管理。 # # 通过使用这个参数，可以将特定的接口排除在 NetworkManager 的管理范围之外，以便其他工具或进程可以独立地管理和配置这些接口。 1.11.进行时间同步 link # 服务端 # apt install chrony -y yum install chrony -y cat \u003e /etc/chrony.conf \u003c\u003c EOF pool ntp.aliyun.com iburst driftfile /var/lib/chrony/drift makestep 1.0 3 rtcsync allow 192.168.1.0/24 local stratum 10 keyfile /etc/chrony.keys leapsectz right/UTC logdir /var/log/chrony EOF systemctl restart chronyd ; systemctl enable chronyd # 客户端 # apt install chrony -y yum install chrony -y cat \u003e /etc/chrony.conf \u003c\u003c EOF pool 192.168.1.41 iburst driftfile /var/lib/chrony/drift makestep 1.0 3 rtcsync keyfile /etc/chrony.keys leapsectz right/UTC logdir /var/log/chrony EOF systemctl restart chronyd ; systemctl enable chronyd #使用客户端进行验证 chronyc sources -v # 参数解释 # # pool ntp.aliyun.com iburst # 指定使用ntp.aliyun.com作为时间服务器池，iburst选项表示在初始同步时会发送多个请求以加快同步速度。 # # driftfile /var/lib/chrony/drift # 指定用于保存时钟漂移信息的文件路径。 # # makestep 1.0 3 # 设置当系统时间与服务器时间偏差大于1秒时，会以1秒的步长进行调整。如果偏差超过3秒，则立即进行时间调整。 # # rtcsync # 启用硬件时钟同步功能，可以提高时钟的准确性。 # # allow 192.168.0.0/24 # 允许192.168.0.0/24网段范围内的主机与chrony进行时间同步。 # # local stratum 10 # 将本地时钟设为stratum 10，stratum值表示时钟的准确度，值越小表示准确度越高。 # # keyfile /etc/chrony.keys # 指定使用的密钥文件路径，用于对时间同步进行身份验证。 # # leapsectz right/UTC # 指定时区为UTC。 # # logdir /var/log/chrony # 指定日志文件存放目录。 1.12.配置ulimit link ulimit -SHn 65535 cat \u003e\u003e /etc/security/limits.conf \u003c"
            }
        );
    index.add(
            {
                id:  57 ,
                href: "\/docs\/ops\/kubernetes\/3.%E5%8D%87%E7%BA%A7%E4%BA%8C%E8%BF%9B%E5%88%B6%E9%83%A8%E7%BD%B2%E7%9A%84kubernetes%E9%9B%86%E7%BE%A4\/",
                title: "3.升级二进制部署的kubernetes集群",
                description: "Kubernetes（简称k8s）是Google在2014年6月开源的一个容器集群管理系统，使用Go语言开发，用于管理云平台中多个主机上的容器化应用，Kubernetes的目标是让部署容器化的应用简单并且高效，Kubernetes提供了资源调度、部署管理、服务发现、扩容缩容、监控，维护等一整套功能。努力成为跨主机集群的自动部署、扩展以及运行应用程序容器的平台。 它支持一系列容器工具, 包括且不限于Docker等。",
                content: "基础操作 link查看当前版本信息 link [root@k8s-master01 ~]# kubectl get node NAME STATUS ROLES AGE VERSION k8s-master01 Ready 57d v1.23.6 k8s-master02 Ready 57d v1.23.6 k8s-master03 Ready 57d v1.23.6 k8s-node01 Ready 57d v1.23.6 k8s-node02 Ready 57d v1.23.6 [root@k8s-master01 ~]# 主机域名以及IP地址 link [root@k8s-master01 ~]# cat /etc/hosts | grep k8s 192.168.1.230 k8s-master01 192.168.1.231 k8s-master02 192.168.1.232 k8s-master03 192.168.1.233 k8s-node01 192.168.1.234 k8s-node02 [root@k8s-master01 ~]# 下载二进制安装包 link [root@k8s-master01 ~]# wget https://dl.k8s.io/v1.23.9/kubernetes-server-linux-amd64.tar.gz [root@k8s-master01 ~]# 解压二进制安装包 link [root@k8s-master01 ~]# tar xf kubernetes-server-linux-amd64.tar.gz [root@k8s-master01 ~]# 升级Maser link升级三台主节点上的客户端 link [root@k8s-master01 ~]# scp kubernetes/server/bin/kubectl root@192.168.1.230:/usr/local/bin/ [root@k8s-master01 ~]# [root@k8s-master01 ~]# scp kubernetes/server/bin/kubectl root@192.168.1.231:/usr/local/bin/ [root@k8s-master01 ~]# [root@k8s-master01 ~]# scp kubernetes/server/bin/kubectl root@192.168.1.232:/usr/local/bin/ [root@k8s-master01 ~]# 升级三台主节点api组件 link [root@k8s-master01 ~]# ssh root@192.168.1.230 \"systemctl stop kube-apiserver\" [root@k8s-master01 ~]# [root@k8s-master01 ~]# scp kubernetes/server/bin/kube-apiserver root@192.168.1.230:/usr/local/bin/ [root@k8s-master01 ~]# [root@k8s-master01 ~]# ssh root@192.168.1.230 \"systemctl start kube-apiserver\" [root@k8s-master01 ~]# [root@k8s-master01 ~]# kube-apiserver --version Kubernetes v1.23.9 [root@k8s-master01 ~]# 升级三台主节点控制器组件 link [root@k8s-master01 ~]# ssh root@192.168.1.230 \"systemctl stop kube-controller-manager\" [root@k8s-master01 ~]# [root@k8s-master01 ~]# scp kubernetes/server/bin/kube-controller-manager root@192.168.1.230:/usr/local/bin/ [root@k8s-master01 ~]# [root@k8s-master01 ~]# ssh root@192.168.1.230 \"systemctl start kube-controller-manager\" [root@k8s-master01 ~]# 升级三台主节点选择器组件 link [root@k8s-master01 ~]# ssh root@192.168.1.230 \"systemctl stop kube-scheduler\" [root@k8s-master01 ~]# [root@k8s-master01 ~]# scp kubernetes/server/bin/kube-scheduler root@192.168.1.230:/usr/local/bin/ [root@k8s-master01 ~]# [root@k8s-master01 ~]# ssh root@192.168.1.230 \"systemctl start kube-scheduler\" [root@k8s-master01 ~]# 升级Worker link每一台机器都要升级kubelet link [root@k8s-master01 ~]# ssh root@192.168.1.230 \"systemctl stop kubelet\" [root@k8s-master01 ~]# [root@k8s-master01 ~]# scp kubernetes/server/bin/kubelet root@192.168.1.230:/usr/local/bin/ [root@k8s-master01 ~]# [root@k8s-master01 ~]# ssh root@192.168.1.230 \"systemctl start kubelet\" [root@k8s-master01 ~]# [root@k8s-master01 ~]# ssh root@192.168.1.230 \"kubelet --version\" Kubernetes v1.23.9 [root@k8s-master01 ~]# 每一台机器都要升级kube-proxy link [root@k8s-master01 ~]# ssh root@192.168.1.230 \"systemctl stop kube-proxy\" [root@k8s-master01 ~]# [root@k8s-master01 ~]# scp kubernetes/server/bin/kube-proxy root@192.168.1.230:/usr/local/bin/ [root@k8s-master01 ~]# [root@k8s-master01 ~]# ssh root@192.168.1.230 \"systemctl start kube-proxy\" [root@k8s-master01 ~]# 验证 link [root@k8s-master01 ~]# kubectl get node NAME STATUS ROLES AGE VERSION k8s-master01 Ready 57d v1.23.9 k8s-master02 Ready 57d v1.23.9 k8s-master03 Ready 57d v1.23.9 k8s-node01 Ready 57d v1.23.9 k8s-node02 Ready 57d v1.23.9 [root@k8s-master01 ~]# [root@k8s-master01 ~]# kubectl version Client Version: version.Info{Major:\"1\", Minor:\"23\", GitVersion:\"v1.23.9\", GitCommit:\"c1de2d70269039fe55efb98e737d9a29f9155246\", GitTreeState:\"clean\", BuildDate:\"2022-07-13T14:26:51Z\", GoVersion:\"go1.17.11\", Compiler:\"gc\", Platform:\"linux/amd64\"} Server Version: version.Info{Major:\"1\", Minor:\"23\", GitVersion:\"v1.23.9\", GitCommit:\"c1de2d70269039fe55efb98e737d9a29f9155246\", GitTreeState:\"clean\", BuildDate:\"2022-07-13T14:19:57Z\", GoVersion:\"go1.17.11\", Compiler:\"gc\", Platform:\"linux/amd64\"} [root@k8s-master01 ~]# "
            }
        );
    index.add(
            {
                id:  58 ,
                href: "\/docs\/ops\/kubernetes\/4.kubernetes%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%E4%BB%8B%E7%BB%8D\/",
                title: "4.Kubernetes核心概念介绍",
                description: "本文介绍kubernetes中一些核心概念，如：pod、工作负载、service、kube-proxy代理模式等",
                content: "1. kubernetes核心概念 link1.1 Pod linkPod是可以在 Kubernetes 中创建和管理的、最小的可部署的计算单元。\nPod就像豌豆荚一样，其中包含着一组（一个或多个）容器； 这些容器共享存储、网络、以及怎样运行这些容器的声明。\nPod就像一台物理服务器一样，其中包含一个或多个应用容器， 这些容器中运行着用户应用程序。\n举例说明Pod、Container、应用程序三者之间的关系：麻屋子,红帐子,里面住着白胖子。Pod就是麻屋子,Container就是红帐子,应用程序就是里面的白胖子。\n1.2 Controller link在 Kubernetes 中，用于管理和运行Pod的对象\n在 Kubernetes 中，控制器通过监控集群的公共状态，并致力于将当前状态转变为期望的状态\n举例说明Controller(控制器)作用：房间里的温度自动调节器\n当你设置了温度，告诉了温度自动调节器你的期望状态（Desired State）。 房间的实际温度是当前状态（Current State）。 通过对设备的开关控制，温度自动调节器让其当前状态接近期望状态。\n一个控制器至少追踪一种类型的 Kubernetes 资源。这些对象有一个代表期望状态的 spec 字段。 该资源的控制器负责确保其当前状态接近期望状态。\n不同的类型的控制器所实现的控制方式不一样，例如：\ndeployment 部署无状态应用 部署无状态应用: 认为pod 都一样，没有顺序要求， 不用考虑在哪个node 运行，随意进行扩展和伸缩 管理Pod和 ReplicaSet 部署、滚动升级等 典型的像web服务、分布式服务等 StatefulSet 部署有状态应用 有状态应用，每个pod 都独立运行，保持pod 启动顺序和唯一性； 有唯一的网络标识符，持久存储； 有序，比如mysql 主从； 主机名称固定。 而且其扩容以及升级等操作也是按顺序进行的操作。 DaemonSet 部署守护进程 DaemonSet保证在每个Node上都运行一个容器副本，常用来部署一些集群的日志、监控或者其他系统管理应用。 新加入的node 也同样运行在一个pod 里面。 job 一次性任务 Job负责批量处理短暂的一次性任务 (short lived one-off tasks)，即仅执行一次的任务，它保证批处理任务的一个或多个Pod成功结束。 Cronjob 周期性定时任务 1.3 Label link1.3.1 Label介绍 linkLabel是附着到object上（例如Pod）的键值对。可以在创建object的时候指定，也可以在object创建后随时指定。Labels的值对系统本身并没有什么含义，只是对用户才有意义。\n一个Label是一个key=value的键值对，其中key与value由用户自己指定。\nLabel可以附加到各种资源对象上，例如Node、Pod、Service、RC等，一个资源对象可以定义任意数量的Label，同一个Label也可以被添加到任意数量的资源对象上去，Label通常在资源对象定义时确定，也可以在对象创建后动态添加或者删除。\n我们可以通过指定的资源对象捆绑一个或多个不同的Label来实现多维度的资源分组管理功能，以便于灵活、方便地进行资源分配、调度、配置、部署等管理工作。例如：部署不同版本的应用到不同的环境中；或者监控和分析应用（日志记录、监控、告警）等。\n一些常用abel示例如下所示:\n版本标签：“release” : “stable” , “release” : “canary”…\n环境标签：“environment” : “dev” , “environment” : “production”\n架构标签：“tier” : “frontend” , “tier” : “backend” , “tier” : “middleware”\n分区标签：“partition” : “customerA” , “partition” : “customerB”…\n质量管控标签：“track” : “daily” , “track” : “weekly”\nLabel相当于我们熟悉的“标签”，给某个资源对象定义一个Label，就相当于给它打了一个标签，随后可以通过Label Selector（标签选择器）查询和筛选拥有某些Label的资源对象，Kubernetes通过这种方式实现了类似SQL的简单又通用的对象查询机制。\n1.3.2 Label语法及字符集 linkLabel key的组成：\n不得超过63个字符 可以使用前缀，使用/分隔，前缀必须是DNS子域，不得超过253个字符，系统中的自动化组件创建的label必须指定前缀，kubernetes.io/由kubernetes保留 起始必须是字母（大小写都可以）或数字，中间可以有连字符、下划线和点 Label value的组成：\n不得超过63个字符 起始必须是字母（大小写都可以）或数字，中间可以有连字符、下划线和点 1.4 Label Selector link通过label selector，客户端／用户可以指定一个object集合，通过label selector对object的集合进行操作。\nLabel selector有两种类型：\nequality-based（基于等式） ：可以使用=、==、!=操作符，可以使用逗号分隔多个表达式 set-based（基于集合） ：可以使用in、notin、!操作符，另外还可以没有操作符，直接写出某个label的key，表示过滤有某个key的object而不管该key的value是何值，!表示没有该label的object 举例说明Label Selector\nLabel Selector可以被类比为SQL语句中的where查询条件，例如，name=redis-slave这个label Selector作用于Pod时，可以被类比为select * from pod where pod’s name = ‘redis-slave’这样的语句。\n1.5 Service link将运行在一组 Pods上的应用程序公开为网络服务的抽象方法。\n由于Pod是非永久性资源对象，如果你使用Controller运行你的应用程序，你可以动态创建和销毁Pod，这样就会导致无法准确访问到所想要访问的Pod\n例如：如果一组 Pod（称为“后端”）为集群内的其他 Pod（称为“前端”）提供功能， 那么前端如何找出并跟踪要连接的 IP 地址，以便前端可以使用提供工作负载的后端部分？\n是一组iptables或ipvs规划，通过把客户端的请求转发到服务端（Pod）,如有多个Pod情况，亦可实现负载均衡的效果。\n例如：一个图片处理后端，它运行了 3 个副本（Pod）。这些副本是可互换的 —— 前端不需要关心它们调用了哪个后端副本。 然而组成这一组后端程序的 Pod 实际上可能会发生变化， 前端客户端不应该也没必要知道，而且也不需要跟踪这一组后端的状态。\n1.6 Endpoints link为Service管理后端Pod，当后端Pod被创建或销毁时，endpoints列表会更新Pod对应的IP地址，以便Service访问请求能够确保被响应。\n1.7 DNS link为kubernetes集群内资源对象的访问提供名称解析，这样就可以实现通过DNS名称而非IP地址来访问服务。\n实现集群内Service名称解析 实现集群内Pod内Container中应用访问互联网提供域名解析 2. Kubernetes核心概念之间的关系 link2.1 Pod与Controller linkpod 是通过Controller 实现应用的运维，比如伸缩，滚动升级等待。pod 和 controller 通过label 标签建立关系。\n2.2 Pod与Service linkservice 是为了防止pod 失联，提供的服务发现，类似于微服务的注册中心。定义一组pod 的访问策略。可以为一组具有相同功能的容器应用提供一个统一的入口地址，并将请求负载分发到后端的各个容器应用上。\nservice 通过selector 来管控对应的pod。根据label 和 selector 建立关联，通过service 实现pod 的负载均衡。\n2.3 Service与DNS link通过DNS实现对Service名称解析，以此达到访问后端Pod目的。\n3. 基于kubernetes集群容器化应用的微服务 link3.1 服务部署方式介绍 link 单体服务架构 所有服务进程运行在同一台主机内 分布式服务架构 服务进程分布于不同的主机，其中一台主机出现故障，不影响其它主机上的服务运行 微服务架构 使用容器化技术把分布式服务架构运行起来，并实现对不同的服务进程的高可用及快速发布等。 3.2 微服务架构服务组件（kubernetes核心概念）之间关系举例说明 link以在kubernetes集群中运行LNMT应用为例：\n把kubernetes集群看做是一个IDC机房，把LNMT Web架构应用以微服务（kubernetes集群资源对象）的方式部署到kubernetes集群中。\nKubernetes集群核心概念 Pod link1. 工作负载(workloads) link参考链接：workloads\n工作负载（workload）是在kubernetes集群中运行的应用程序。无论你的工作负载是单一服务还是多个一同工作的服务构成，在kubernetes中都可以使用pod来运行它。\nworkloads分为pod与controllers\npod通过控制器实现应用的运行，如何伸缩，升级等 controllers 在集群中管理pod pod与控制器之间通过label-selector相关联，是唯一的关联方式 在pod的YAML里指定pod标签\n定义标签 labels: app: nginx 在控制器的YAML里指定标签选择器匹配标签\n通过标签选择器选择对应的pod selector: matchLabels: app: nginx 2. pod介绍 link2.1 pod定义与分类 link参考链接: Pods\n2.1.1 Pod定义 link Pod(豌豆荚) 是Kubernetes集群管理（创建、部署）与调度的最小计算单元，表示处于运行状态的一组容器。 Pod不是进程，而是容器运行的环境。 一个Pod可以封装一个容器或多个容器(主容器或sidecar边车容器) 一个pod内的多个容器之间共享部分命名空间，例如：Net Namespace,UTS Namespace,IPC Namespace及存储资源 用户pod默认会被调度运行在node节点之上(不运行在master节点上，但也有例外情况) pod内的IP不是固定的，集群外不能直接访问pod 2.1.2 Pod分类 link 静态Pod\t也称之为“无控制器管理的自主式pod”，直接由特定节点上的 kubelet 守护进程管理， 不需要API 服务器看到它们，尽管大多数 Pod 都是通过控制面（例如，Deployment） 来管理的，对于静态 Pod 而言，kubelet 直接监控每个 Pod，并在其失效时重启之。 控制器管理的pod 控制器可以控制pod的副本数，扩容与裁剪，版本更新与回滚等 2.2 查看pod方法 linkpod是一种计算资源，可以通过kubectl get pod来查看\n[root@k8s-master1 ~]# kubectl get pod\t# pod或pods都可以，不指定namespace,默认是名为default的namespace [root@k8s-master1 ~]# kubectl get pod -n kube-system 2.3 pod的YAML资源清单格式 link先看一个yaml格式的pod定义文件解释\n# yaml格式的pod定义文件完整内容： apiVersion: v1 #必选，api版本号，例如v1 kind: Pod #必选，Pod metadata: #必选，元数据 name: string #必选，Pod名称 namespace: string #Pod所属的命名空间,默认在default的namespace labels: # 自定义标签 name: string #自定义标签名字 annotations: #自定义注释列表 name: string spec: #必选，Pod中容器的详细定义(期望) containers: #必选，Pod中容器列表 - name: string #必选，容器名称 image: string #必选，容器的镜像名称 imagePullPolicy: [Always | Never | IfNotPresent] #获取镜像的策略 Alawys表示下载镜像 IfnotPresent表示优先使用本地镜像，否则下载镜像，Nerver表示仅使用本地镜像 command: [string] #容器的启动命令列表，如不指定，使用打包时使用的启动命令 args: [string] #容器的启动命令参数列表 workingDir: string #容器的工作目录 volumeMounts: #挂载到容器内部的存储卷配置 - name: string #引用pod定义的共享存储卷的名称，需用volumes[]部分定义的的卷名 mountPath: string #存储卷在容器内mount的绝对路径，应少于512字符 readOnly: boolean #是否为只读模式 ports: #需要暴露的端口库号列表 - name: string #端口号名称 containerPort: int #容器需要监听的端口号 hostPort: int #容器所在主机需要监听的端口号，默认与Container相同 protocol: string #端口协议，支持TCP和UDP，默认TCP env: #容器运行前需设置的环境变量列表 - name: string #环境变量名称 value: string #环境变量的值 resources: #资源限制和请求的设置 limits: #资源限制的设置 cpu: string #Cpu的限制，单位为core数，将用于docker run --cpu-shares参数 memory: string #内存限制，单位可以为Mib/Gib，将用于docker run --memory参数 requests: #资源请求的设置 cpu: string #Cpu请求，容器启动的初始可用数量 memory: string #内存清求，容器启动的初始可用数量 livenessProbe: #对Pod内个容器健康检查的设置，当探测无响应几次后将自动重启该容器，检查方法有exec、httpGet和tcpSocket，对一个容器只需设置其中一种方法即可 exec: #对Pod容器内检查方式设置为exec方式 command: [string] #exec方式需要制定的命令或脚本 httpGet: #对Pod内个容器健康检查方法设置为HttpGet，需要制定Path、port path: string port: number host: string scheme: string HttpHeaders: - name: string value: string tcpSocket: #对Pod内个容器健康检查方式设置为tcpSocket方式 port: number initialDelaySeconds: 0 #容器启动完成后首次探测的时间，单位为秒 timeoutSeconds: 0 #对容器健康检查探测等待响应的超时时间，单位秒，默认1秒 periodSeconds: 0 #对容器监控检查的定期探测时间设置，单位秒，默认10秒一次 successThreshold: 0 failureThreshold: 0 securityContext: privileged:false restartPolicy: [Always | Never | OnFailure] # Pod的重启策略，Always表示一旦不管以何种方式终止运行，kubelet都将重启，OnFailure表示只有Pod以非0退出码退出才重启，Nerver表示不再重启该Pod nodeSelector: obeject # 设置NodeSelector表示将该Pod调度到包含这个label的node上，以key：value的格式指定 imagePullSecrets: #Pull镜像时使用的secret名称，以key：secretkey格式指定 - name: string hostNetwork: false #是否使用主机网络模式，默认为false，如果设置为true，表示使用宿主机网络 volumes: #在该pod上定义共享存储卷列表 - name: string #共享存储卷名称 （volumes类型有很多种） emptyDir: {} #类型为emtyDir的存储卷，与Pod同生命周期的一个临时目录。为空值 hostPath: string #类型为hostPath的存储卷，表示挂载Pod所在宿主机的目录 path: string #Pod所在宿主机的目录，将被用于同期中mount的目录 secret: #类型为secret的存储卷，挂载集群与定义的secret对象到容器内部 scretname: string items: - key: string path: string configMap: #类型为configMap的存储卷，挂载预定义的configMap对象到容器内部 name: string items: - key: string path: string YAML格式查找帮助方法回顾\n[root@k8s-master1 ~]# kubectl explain namespace [root@k8s-master1 ~]# kubectl explain pod [root@k8s-master1 ~]# kubectl explain pod.spec [root@k8s-master1 ~]# kubectl explain pod.spec.containers 3. pod创建与验证 link3.1 命令创建pod(v1.18变化) link k8s之前版本中, kubectl run命令用于创建deployment控制器 在v1.18版本中, kubectl run命令改为创建pod 3.1.1 创建一个名为pod-nginx的pod link [root@k8s-master1 ~]# kubectl run nginx1 --image=nginx:1.15-alpine pod/nginx1 created 3.1.2 验证 link [root@k8s-master1 ~]# kubectl get pods NAME READY STATUS RESTARTS AGE nginx1 1/1 Running 0 41s 3.2 YAML创建pod link3.2.1 准备yaml文件 link [root@k8s-master1 ~]# vim pod1.yml apiVersion: v1\t# api版本 kind: Pod\t# 资源类型为Pod metadata:\tname: pod-stress\t# 自定义pod的名称 spec: containers:\t# 定义pod里包含的容器 - name: c1\t# 自定义pod中的容器名 image: polinux/stress\t# 启动容器的镜像名 command: [\"stress\"]\t# 自定义启动容器时要执行的命令(类似dockerfile里的CMD) args: [\"--vm\", \"1\", \"--vm-bytes\", \"150M\", \"--vm-hang\", \"1\"] # 自定义启动容器执行命令的参数 # polinux/stress这个镜像用于压力测试,在启动容器时传命令与参数就是相当于分配容器运行时需要的压力 2, 通过yaml文件创建pod\n[root@k8s-master1 ~]# kubectl apply -f pod1.yml pod/pod-stress created 3.2.2 查看pod信息 link查看pod信息\n[root@k8s-master1 ~]# kubectl get pod NAME READY STATUS RESTARTS AGE pod-stress 1/1 Running 0 45s 查看pod详细信息\n[root@k8s-master1 ~]# kubectl get pods -o wide NAME READY STATUS RESTARTS AGE IP NODE NOMINATED NODE READINESS GATES pod-stress 1/1 Running 0 71s 10.244.194.72 k8s-worker1 描述pod详细信息\n[root@k8s-master1 ~]# kubectl describe pod pod-stress ...... Events: Type Reason Age From Message ---- ------ ---- ---- ------- Normal Scheduled 102s default-scheduler Successfully assigned default/pod-stress to k8s-worker1 Normal Pulling 102s kubelet Pulling image \"polinux/stress\" Normal Pulled 83s kubelet Successfully pulled image \"polinux/stress\" in 18.944533343s Normal Created 83s kubelet Created container c1 Normal Started 82s kubelet Started container c1 3.3 删除pod link3.3.1 单个pod删除 link方法1:\n[root@k8s-master1 ~]# kubectl delete pod pod-stress pod \"pod-stress\" deleted 方法2:\n[root@k8s-master1 ~]# kubectl delete -f pod1.yml 3.3.2 多个pod删除 link方法1: 后接多个pod名\n[root@k8s-master1 ~]# kubectl delete pod pod名1 pod名2 pod名3 ...... 方法2: 通过awk截取要删除的pod名称，然后管道给xargs\n[root@k8s-master1 ~]# kubectl get pods |awk 'NR\u003e1 {print $1}' |xargs kubectl delete pod 方法3: 如果要删除的pod都在同一个非default的命名空间，则可直接删除命名空间\n[root@k8s-master1 ~]# kubectl delete ns xxxx 3.4 镜像拉取策略 link由imagePullPolicy参数控制\nAlways : 不管本地有没有镜像，都要从仓库中下载镜像 Never : 从来不从仓库下载镜像, 只用本地镜像,本地没有就算了 IfNotPresent: 如果本地存在就直接使用, 不存在才从仓库下载 默认的策略是：\n当镜像标签版本是latest，默认策略就是Always 如果指定特定版本默认拉取策略就是IfNotPresent。 1, 将上面的pod删除再创建，使用下面命令查看信息\n[root@k8s-master1 ~]# kubectl apply -f pod1.yml [root@k8s-master1 ~]# kubectl delete -f pod1.yml [root@k8s-master1 ~]# kubectl describe pod pod-stress ...... Events: Type Reason Age From Message ---- ------ ---- ---- ------- Normal Scheduled 102s default-scheduler Successfully assigned default/pod-stress to k8s-worker1 Normal Pulling 102s kubelet Pulling image \"polinux/stress\" Normal Pulled 83s kubelet Successfully pulled image \"polinux/stress\" in 18.944533343s Normal Created 83s kubelet Created container c1 Normal Started 82s kubelet Started container c1 说明: 可以看到第二行信息还是pulling image下载镜像\n2, 修改YAML\n[root@k8s-master1 ~]# vim pod1.yml apiVersion: v1 kind: Pod metadata: name: pod-stress namespace: default spec: containers: - name: c1 image: polinux/stress command: [\"stress\"] args: [\"--vm\", \"1\", \"--vm-bytes\", \"150M\", \"--vm-hang\", \"1\"] imagePullPolicy: IfNotPresent\t# 增加了这一句 3，再次删除再创建\n[root@k8s-master1 ~]# kubectl describe pod pod-stress ...... Events: Type Reason Age From Message ---- ------ ---- ---- ------- Normal Scheduled 17s default-scheduler Successfully assigned default/pod-stress to k8s-worker1 Normal Pulled 17s kubelet Container image \"polinux/stress\" already present on machine Normal Created 17s kubelet Created container c1 Normal Started 17s kubelet Started container c1 说明: 第二行信息是说镜像已经存在，直接使用了\n3.5 pod的标签 link 为pod设置label,用于控制器通过label与pod关联 语法与前面学的node标签几乎一致 3.5.1 通过命令管理Pod标签 link 查看pod的标签 [root@k8s-master1 ~]# kubectl get pods --show-labels NAME READY STATUS RESTARTS AGE LABELS pod-stress 1/1 Running 0 7m25s 打标签,再查看 [root@k8s-master1 ~]# kubectl label pod pod-stress region=huanai zone=A env=test bussiness=game pod/pod-stress labeled [root@k8s-master1 ~]# kubectl get pods --show-labels NAME READY STATUS RESTARTS AGE LABELS pod-stress 1/1 Running 0 8m54s bussiness=game,env=test,region=huanai,zone=A 通过等值关系标签查询 [root@k8s-master1 ~]# kubectl get pods -l zone=A NAME READY STATUS RESTARTS AGE pod-stress 1/1 Running 0 9m22s 通过集合关系标签查询 [root@k8s-master1 ~]# kubectl get pods -l \"zone in (A,B,C)\" NAME READY STATUS RESTARTS AGE pod-stress 1/1 Running 0 9m55s 删除标签后再验证 [root@k8s-master1 ~]# kubectl label pod pod-stress region- zone- env- bussiness- pod/pod-stress labeled [root@k8s-master1 ~]# kubectl get pods --show-labels NAME READY STATUS RESTARTS AGE LABELS pod-stress 1/1 Running 0 16m 小结:\npod的label与node的label操作方式几乎相同 node的label用于pod调度到指定label的node节点 pod的label用于controller关联控制的pod 3.5.2 通过YAML创建Pod时添加标签 link1, 修改yaml\n[root@k8s-master1 ~]# vim pod1.yml apiVersion: v1 kind: Pod metadata: name: pod-stress namespace: default labels: env: dev app: nginx\t# 直接在原来的yaml里加上多个标签 spec: containers: - name: c1 image: polinux/stress command: [\"stress\"] args: [\"--vm\", \"1\", \"--vm-bytes\", \"150M\", \"--vm-hang\", \"1\"] imagePullPolicy: IfNotPresent 2, 直接apply应用\n[root@k8s-master1 ~]# kubectl apply -f pod1.yaml pod/pod-stress1 configured\t# 这里是configured,表示修改了 3, 验证\n[root@k8s-master1 ~]# kubectl get pods --show-labels NAME READY STATUS RESTARTS AGE LABELS pod-stress 1/1 Running 0 3m5s app=nginx,env=dev\t# 标签有了 3.6 pod资源限制 link准备2个不同限制方式的创建pod的yaml文件\n[root@k8s-master1 ~]# vim pod2.yml apiVersion: v1 kind: Namespace metadata: name: namespace1 --- apiVersion: v1 kind: Pod metadata: name: pod-stress2 namespace: namespace1 spec: containers: - name: c1 image: polinux/stress imagePullPolicy: IfNotPresent resources: limits: memory: \"200Mi\" requests: memory: \"100Mi\" command: [\"stress\"]\t# 启动容器时执行的命令 args: [\"--vm\", \"1\", \"--vm-bytes\", \"150M\", \"--vm-hang\", \"1\"] # 产生1个进程分配150M内存1秒后释放 [root@k8s-master1 ~]# vim pod3.yml apiVersion: v1 kind: Namespace metadata: name: namespace1 --- apiVersion: v1 kind: Pod metadata: name: pod-stress3 namespace: namespace1 spec: containers: - name: c1 image: polinux/stress imagePullPolicy: IfNotPresent resources: limits: memory: \"200Mi\" requests: memory: \"150Mi\" command: [\"stress\"] args: [\"--vm\", \"1\", \"--vm-bytes\", \"250M\", \"--vm-hang\", \"1\"] [root@k8s-master1 ~]# kubectl apply -f pod2.yml namespace/namespace1 created pod/pod-stress2 created [root@k8s-master1 ~]# kubectl apply -f pod3.yml namespace/namespace1 unchanged pod/pod-stress3 created [root@k8s-master1 ~]# kubectl get namespace |grep namespace1 namespace1 Active 1m28s [root@k8s-master1 ~]# kubectl get pod -n namespace1 NAME READY STATUS RESTARTS AGE pod-stress2 1/1 Running 0 2m2s pod-stress3 0/1 OOMKilled 4 115s 查看会发现pod-stress3这个pod状态变为OOMKilled，因为它是内存不足所以显示Container被杀死 说明: 一旦pod中的容器挂了，容器会有重启策略， 如下：\nAlways：表示容器挂了总是重启，这是默认策略\nOnFailures：表容器状态为错误时才重启，也就是容器正常终止时才重启\nNever：表示容器挂了不予重启\n对于Always这种策略，容器只要挂了，就会立即重启，这样是很耗费资源的。所以Always重启策略是这么做的：第一次容器挂了立即重启，如果再挂了就要延时10s重启，第三次挂了就等20s重启…… 依次类推\n测试完后删除\n[root@k8s-master1 ~]# kubectl delete ns namespace1 3.7 pod包含多个容器 link1, 准备yml文件\n[root@k8s-master1 ~]# vim pod4.yml apiVersion: v1 kind: Pod metadata: name: pod-stress4 spec: containers: - name: c1 image: polinux/stress imagePullPolicy: IfNotPresent resources: limits: memory: \"200Mi\" requests: memory: \"100Mi\" command: [\"stress\"] args: [\"--vm\", \"1\", \"--vm-bytes\", \"150M\", \"--vm-hang\", \"1\"] - name: c2 image: polinux/stress imagePullPolicy: IfNotPresent resources: limits: memory: \"200Mi\" requests: memory: \"100Mi\" command: [\"stress\"] args: [\"--vm\", \"1\", \"--vm-bytes\", \"150M\", \"--vm-hang\", \"1\"] 2, 应用yml文件创建pod\n[root@k8s-master1 ~]# kubectl apply -f pod4.yml pod/pod-stress4 created 3, 查看pod在哪个节点\n[root@k8s-master1 ~]# kubectl get pods -o wide NAME READY STATUS RESTARTS AGE IP NODE NOMINATED NODE READINESS GATES pod-stress4 2/2 Running 0 70s 10.244.159.136 k8s-master1 可以看到有2个容器,运行在k8s-master1节点 4,在k8s-master1上验证,确实产生了2个容器\n[root@k8s-master1 ~]# docker ps -a |grep stress d7827a963f9d df58d15b053d \"stress --vm 1 --vm-…\" 2 hours ago Up 2 hours k8s_c2_pod-stress4_default_a534bce1-3ffe-45f5-8128-34657e289b44_0 ae8e8f8d095b df58d15b053d \"stress --vm 1 --vm-…\" 2 hours ago Up 2 hours k8s_c1_pod-stress4_default_a534bce1-3ffe-45f5-8128-34657e289b44_0 e66461900426 easzlab/pause-amd64:3.2 \"/pause\" 2 hours ago Up 2 hours k8s_POD_pod-stress4_default_a534bce1-3ffe-45f5-8128-34657e289b44_0 或\n[root@k8s-master1 ~]# crictl ps CONTAINER IMAGE CREATED STATE NAME ATTEMPT POD ID 08cd23ac9b416 df58d15b053d1 2 hours ago Running c2 0 2dd084491f019 65f0ecba8dec3 df58d15b053d1 2 hours ago Running c1 0 2dd084491f019 3.8 对pod里的容器进行操作 link3.8.1 命令帮助 link [root@k8s-master1 ~]# kubectl exec -h 3.8.2 不用交互直接执行命令 link格式为: kubectl exec pod名 -c 容器名 -- 命令\n注意:\n-c 容器名为可选项,如果是1个pod中1个容器,则不用指定; 如果是1个pod中多个容器,不指定默认为第1个。 [root@k8s-master1 ~]# kubectl exec pod-stress4 -c c2 -- touch /111 [root@k8s-master1 ~]# kubectl exec pod-stress4 -c c2 -- ls /111 /111 不指定容器名,则默认为pod里的第1个容器\n[root@k8s-master1 ~]# kubectl exec pod-stress4 -- touch /222 Defaulting container name to c1. Use 'kubectl describe pod/pod-stress4 -n default' to see all of the containers in this pod. 3.8.3 和容器交互操作 link和docker exec几乎一样\n[root@k8s-master1 ~]# kubectl exec -it pod-stress4 -c c1 -- /bin/bash bash-5.0# touch /333 bash-5.0# ls 222 bin etc lib mnt proc run srv tmp var 333 dev home media opt root sbin sys usr bash-5.0# exit exit\t3.9 验证pod中多个容器网络共享 link1, 编写YAML\n[root@k8s-master1 ~]# vim pod-nginx.yaml apiVersion: v1 kind: Pod metadata: name: nginx2 spec: containers: - name: c1 image: nginx:1.15-alpine - name: c2 image: nginx:1.15-alpine 2, 应用YAML\n[root@k8s-master1 ~]# kubectl apply -f pod-nginx.yaml pod/nginx2 created 3, 查看pod信息与状态\n[root@k8s-master1 ~]# kubectl describe pod nginx2 ...... ...... Events: Type Reason Age From Message ---- ------ ---- ---- ------- Normal Scheduled 25s default-scheduler Successfully assigned default/nginx2 to k8s-worker1 Normal Pulling 24s kubelet Pulling image \"nginx:1.15-alpine\" Normal Pulled 5s kubelet Successfully pulled image \"nginx:1.15-alpine\" in 18.928009025s Normal Created 5s kubelet Created container c1 Normal Started 5s kubelet Started container c1 Normal Pulled 2s (x2 over 5s) kubelet Container image \"nginx:1.15-alpine\" already present on machine Normal Created 2s (x2 over 5s) kubelet Created container c2 Normal Started 2s (x2 over 5s) kubelet Started container c2 [root@k8s-master1 ~]# kubectl get pods |grep nginx2 nginx2 1/2 CrashLoopBackOff 3 2m40s 有一个启不来，因为一个容器中两个pod是共用网络的，所以不能两个都占用80端口 有一个启不来，因为一个pod中两个容器是共用网络的，所以不能两个都占用80端口\n通过查找k8s-worker1上面的容器，然后docker logs或crictl logs containerID查看，得到如下的报错，说明是端口被占用\n[root@k8s-worker1 ~]# docker logs k8s_c2_nginx2_default_51fd8e81-1c4b-4557-9498-9b25ed8a4c99_4 2020/11/21 04:29:12 [emerg] 1#1: bind() to 0.0.0.0:80 failed (98: Address in use) nginx: [emerg] bind() to 0.0.0.0:80 failed (98: Address in use) 2020/11/21 04:29:12 [emerg] 1#1: bind() to 0.0.0.0:80 failed (98: Address in use) nginx: [emerg] bind() to 0.0.0.0:80 failed (98: Address in use) 2020/11/21 04:29:12 [emerg] 1#1: bind() to 0.0.0.0:80 failed (98: Address in use) nginx: [emerg] bind() to 0.0.0.0:80 failed (98: Address in use) 2020/11/21 04:29:12 [emerg] 1#1: bind() to 0.0.0.0:80 failed (98: Address in use) nginx: [emerg] bind() to 0.0.0.0:80 failed (98: Address in use) 2020/11/21 04:29:12 [emerg] 1#1: bind() to 0.0.0.0:80 failed (98: Address in use) nginx: [emerg] bind() to 0.0.0.0:80 failed (98: Address in use) 2020/11/21 04:29:12 [emerg] 1#1: still could not bind() nginx: [emerg] still could not bind() 4. pod调度 link4.1 pod调度流程 link Step1 通过kubectl命令应用资源清单文件（yaml格式）向api server 发起一个create pod 请求 Step2 api server接收到pod创建请求后，生成一个包含创建信息资源清单文件 Step3 apiserver 将资源清单文件中信息写入etcd数据库 Step4 Scheduler启动后会一直watch API Server，获取 podSpec.NodeName为空的Pod,即判断pod.spec.Node == null? 若为null，表示这个Pod请求是新的，需要创建，因此先进行调度计算（共计2步：1、过滤不满足条件的，2、选择优先级高的），找到合适的node，然后将信息在etcd数据库中更新分配结果：pod.spec.Node = nodeA (设置一个具体的节点) Step5 kubelet 通过watch etcd数据库(即不停地看etcd中的记录)，发现有新的Node出现，如果这条记录中的Node与所在节点编号相同，即这个Pod由scheduler分配给自己，则调用node中的Container Runtime，进而创建container，并将创建后的结果返回到给api server用于更新etcd数据库中数据状态。 4.2 调度约束方法 link我们为了实现容器主机资源平衡使用, 可以使用约束把pod调度到指定的node节点\nnodeName 用于将pod调度到指定的node名称上 nodeSelector 用于将pod调度到匹配Label的node上 4.2.1 nodeName link1, 编写YAML文件\n[root@k8s-master1 ~]# vim pod-nodename.yml apiVersion: v1 kind: Pod metadata: name: pod-nodename spec: nodeName: k8s-worker1 # 通过nodeName调度到k8s-worker1节点 containers: - name: nginx image: nginx:1.15-alpine 2, 应用YAML文件创建pod\n[root@k8s-master1 ~]# kubectl apply -f pod-nodename.yml pod/pod-nodename created 3, 验证\n[root@k8s-master1 ~]# kubectl describe pod pod-nodename |tail -6 Events: Type Reason Age From Message ---- ------ ---- ---- ------- Normal Pulled 2m47s kubelet Container image \"nginx:1.15-alpine\" already present on machine Normal Created 2m47s kubelet Created container nginx Normal Started 2m47s kubelet Started container nginx 倒数第3行没有使用scheduler,而是直接给运行了,说明nodeName约束生效 4.2.2 nodeSelector link1, 为k8s-worker1打标签\n[root@k8s-master1 ~]# kubectl label nodes k8s-worker1 bussiness=game node/k8s-worker1 labeled 2, 编写YAML文件\n[root@k8s-master1 ~]# vim pod-nodeselector.yml apiVersion: v1 kind: Pod metadata: name: pod-nodeselect spec: nodeSelector: # nodeSelector节点选择器 bussiness: game # 指定调度到标签为bussiness=game的节点 containers: - name: nginx image: nginx:1.15-alpine 3, 应用YAML文件创建pod\n[root@k8s-master1 ~]# kubectl apply -f pod-nodeselector.yml pod/pod-nodeselect created 4, 验证\n[root@k8s-master1 ~]# kubectl describe pod pod-nodeselect |tail -6 Type Reason Age From Message ---- ------ ---- ---- ------- Normal Scheduled 20s default-scheduler Successfully assigned default/pod-nodeselect to k8s-worker1 Normal Pulled 19s kubelet Container image \"nginx:1.15-alpine\" already present on machine Normal Created 19s kubelet Created container nginx Normal Started 19s kubelet Started container nginx 仍然经过了scheduler,但确实分配到了 k8s-worker1上 有兴趣可以再删除后再创建,重复几次验证\n5. pod的生命周期 link5.1 Pod生命周期 link 有些pod(比如运行httpd服务),正常情况下会一直运行中,但如果手动删除它,此pod会终止 也有些pod(比如执行计算任务)，任务计算完后就会自动终止 上面两种场景中,pod从创建到终止的过程就是pod的生命周期。\n5.1.1 容器启动 link pod中的容器在创建前,有初始化容器(init container)来进行初始化环境\n初化完后,主容器(main container)开始启动\n主容器启动后,有一个post start的操作(启动后的触发型操作,或者叫启动后钩子)\npost start后,就开始做健康检查\n第一个健康检查叫存活状态检查(liveness probe )，用来检查主容器存活状态的\n第二个健康检查叫准备就绪检查(readiness probe)，用来检查主容器是否启动就绪\n5.1.2 容器终止 link 可以在容器终止前设置pre stop操作(终止前的触发型操作,或者叫终止前钩子) 当出现特殊情况不能正常销毁pod时,大概等待30秒会强制终止 终止容器后还可能会重启容器(视容器重启策略而定)。 5.1.3 回顾容器重启策略 link Always：表示容器挂了总是重启，这是默认策略\nOnFailures：表示容器状态为错误时才重启，也就是容器正常终止时不重启\nNever：表示容器挂了不予重启\n对于Always这种策略，容器只要挂了，就会立即重启，这样是很耗费资源的。所以Always重启策略是这么做的：第一次容器挂了立即重启，如果再挂了就要延时10s重启，第三次挂了就等20s重启…… 依次类推\n5.2 HealthCheck健康检查 link当Pod启动时，容器可能会因为某种错误(服务未启动或端口不正确)而无法访问等。\n5.2.1 Health Check方式 linkkubelet拥有两个检测器，它们分别对应不同的触发器(根据触发器的结构执行进一步的动作)\n方式 说明 Liveness Probe(存活状态探测) 指示容器是否正在运行。如果存活态探测失败，则 kubelet 会杀死容器， 并且容器将根据其重启策略决定未来。如果容器不提供存活探针， 则默认状态为 Success。 readiness Probe(就绪型探测) 指示容器是否准备好为请求提供服务。如果就绪态探测失败， 端点控制器将从与 Pod 匹配的所有服务的端点列表中删除该 Pod 的 IP 地址。 初始延迟之前的就绪态的状态值默认为 Failure。 如果容器不提供就绪态探针，则默认状态为 Success。注：检查后不健康，将容器设置为Notready;如果使用service来访问,流量不会转发给此种状态的pod startup Probe 指示容器中的应用是否已经启动。如果提供了启动探针，则所有其他探针都会被 禁用，直到此探针成功为止。如果启动探测失败，kubelet 将杀死容器，而容器依其 重启策略进行重启。 如果容器没有提供启动探测，则默认状态为 Success。 5.2.2 Probe探测方式 link 方式 说明 Exec 执行命令 HTTPGet http请求某一个URL路径 TCP tcp连接某一个端口 gRPC 使用 gRPC 执行一个远程过程调用。 目标应该实现 gRPC健康检查。 如果响应的状态是 “SERVING”，则认为诊断成功。 gRPC 探针是一个 alpha 特性，只有在你启用了 “GRPCContainerProbe” 特性门控时才能使用。 5.2.3 liveness-exec案例 link1, 准备YAML文件\n[root@k8s-master1 ~]# vim pod-liveness-exec.yml apiVersion: v1 kind: Pod metadata: name: liveness-exec namespace: default spec: containers: - name: liveness image: busybox imagePullPolicy: IfNotPresent args: - /bin/sh - -c - touch /tmp/healthy; sleep 30; rm -rf /tmp/healthy; sleep 600 livenessProbe: exec: command: - cat - /tmp/healthy initialDelaySeconds: 5 # pod启动延迟5秒后探测 periodSeconds: 5 # 每5秒探测1次 2, 应用YAML文件\n[root@k8s-master1 ~]# kubectl apply -f pod-liveness-exec.yml 3, 通过下面的命令观察\n[root@k8s-master1 ~]# kubectl describe pod liveness-exec ...... Events: Type Reason Age From Message ---- ------ ---- ---- ------- Normal Scheduled 40s default-scheduler Successfully assigned default/liveness-exec to k8s-worker1 Normal Pulled 38s kubelet Container image \"busybox\" already present on machine Normal Created 37s kubelet Created container liveness Normal Started 37s kubelet Started container liveness Warning Unhealthy 3s kubelet Liveness probe failed: cat: can't open '/tmp/healthy': No such file or directory 看到40s前被调度以k8s-worker1节点,3s前健康检查出问题 4, 过几分钟再观察\n[root@k8s-master1 ~]# kubectl describe pod liveness-exec ...... Events: Type Reason Age From Message ---- ------ ---- ---- ------- Normal Scheduled 3m42s default-scheduler Successfully assigned default/liveness-exec to k8s-worker1 Normal Pulled 70s (x3 over 3m40s) kubelet Container image \"busybox\" already present on machine Normal Created 70s (x3 over 3m39s) kubelet Created container liveness Normal Started 69s (x3 over 3m39s) kubelet Started container liveness Warning Unhealthy 26s (x9 over 3m5s) kubelet Liveness probe failed: cat: can't open '/tmp/healthy': No such file or directory Normal Killing 26s (x3 over 2m55s) kubelet Container liveness failed liveness probe, will be restarted [root@k8s-master1 ~]# kubectl get pod NAME READY STATUS RESTARTS AGE liveness-exec 1/1 Running 3 4m12s 看到重启3次,慢慢地重启间隔时间会越来越长 拓展: 容器重启策略验证 link apiVersion: v1 kind: Pod metadata: name: liveness-exec namespace: default spec: restartPolicy: Never\t# 把容器重启策略由默认的always改为Never containers: - name: liveness image: busybox imagePullPolicy: IfNotPresent args: - /bin/sh - -c - touch /tmp/healthy; sleep 30; rm -rf /tmp/healthy; sleep 600 livenessProbe: exec: command: - cat - /tmp/healthy initialDelaySeconds: 5 periodSeconds: 5 请自行验证\n验证结果为:\n容器健康检查出现问题后，不再重启，也不会继续sleep 600秒，而是直接关闭了 5.2.4 liveness-httpget案例 link1, 编写YMAL文件\n[root@k8s-master1 ~]# vim pod-liveness-httpget.yml apiVersion: v1 kind: Pod metadata: name: liveness-httpget namespace: default spec: containers: - name: liveness image: nginx:1.15-alpine imagePullPolicy: IfNotPresent ports:\t# 指定容器端口，这一段不写也行，端口由镜像决定 - name: http\t# 自定义名称，不需要与下面的port: http对应 containerPort: 80\t# 类似dockerfile里的expose 80 livenessProbe: httpGet: # 使用httpGet方式 port: http # http协议,也可以直接写80端口 path: /index.html # 探测家目录下的index.html initialDelaySeconds: 3 # 延迟3秒开始探测 periodSeconds: 5 # 每隔5s钟探测一次 2, 应用YAML文件\n[root@k8s-master1 ~]# kubectl apply -f pod-liveness-httpget.yml 3, 验证查看\n[root@k8s-master1 ~]# kubectl get pods NAME READY STATUS RESTARTS AGE liveness-httpget 1/1 Running 0 9s 4, 交互删除nginx里的主页文件\n[root@k8s-master1 ~]# kubectl exec -it liveness-httpget -- rm -rf /usr/share/nginx/html/index.html 5, 验证查看会发现\n[root@k8s-master1 ~]# kubectl get pod NAME READY STATUS RESTARTS AGE liveness-httpget 1/1 Running 1 11m 只restart一次 5.2.5 liveness-tcp案例 link1, 编写YAML文件\n[root@k8s-master1 ~]# vim pod-liveness-tcp.yml apiVersion: v1 kind: Pod metadata: name: liveness-tcp namespace: default spec: containers: - name: liveness image: nginx:1.15-alpine imagePullPolicy: IfNotPresent ports: - name: http containerPort: 80 livenessProbe: tcpSocket: # 使用tcp连接方式 port: 80 # 连接80端口进行探测 initialDelaySeconds: 3 periodSeconds: 5 2, 应用YAML文件创建pod\n[root@k8s-master1 ~]# kubectl apply -f pod-liveness-tcp.yml pod/liveness-tcp created 3, 查看验证\n[root@k8s-master1 ~]# kubectl get pod NAME READY STATUS RESTARTS AGE liveness-tcp 1/1 Running 0 14s 4, 交互关闭nginx\n[root@k8s-master1 ~]# kubectl exec -it liveness-tcp -- /usr/sbin/nginx -s stop 5, 再次验证查看\n[root@k8s-master1 ~]# kubectl get pod NAME READY STATUS RESTARTS AGE liveness-tcp 1/1 Running 1 5m13s 也只重启1次,重启后重新初始化了 5.2.6 readiness案例 link1, 编写YAML文件\n[root@k8s-master1 ~]# vim pod-readiness-httpget.yml apiVersion: v1 kind: Pod metadata: name: readiness-httpget namespace: default spec: containers: - name: readiness image: nginx:1.15-alpine imagePullPolicy: IfNotPresent ports: - name: http containerPort: 80 readinessProbe: # 这里由liveness换成了readiness httpGet: port: http path: /index.html initialDelaySeconds: 3 periodSeconds: 5 2, 应用YAML文件\n[root@k8s-master1 ~]# kubectl apply -f pod-readiness-httpget.yml pod/readiness-httpget created 3, 验证查看\n[root@k8s-master1 ~]# kubectl get pod NAME READY STATUS RESTARTS AGE readiness-httpget 1/1 Running 0 10s 4, 交互删除nginx主页\n[root@k8s-master1 ~]# kubectl exec -it readiness-httpget -- rm -rf /usr/share/nginx/html/index.html 5, 再次验证\n[root@k8s-master1 ~]# kubectl get pod NAME READY STATUS RESTARTS AGE readiness-httpget 0/1 Running 0 2m49s READY状态为0/1 6, 交互创建nginx主页文件再验证\n[root@k8s-master1 ~]# kubectl exec -it readiness-httpget -- touch /usr/share/nginx/html/index.html [root@k8s-master1 ~]# kubectl get pod NAME READY STATUS RESTARTS AGE readiness-httpget 1/1 Running 0 3m10s READY状态又为1/1了 5.2.7 readiness+liveness综合案例 link1, 编写YAML文件\n[root@k8s-master1 ~]# vim pod-readiness-liveiness.yml apiVersion: v1 kind: Pod metadata: name: readiness-liveness-httpget namespace: default spec: containers: - name: readiness-liveness image: nginx:1.15-alpine imagePullPolicy: IfNotPresent ports: - name: http containerPort: 80 livenessProbe: httpGet: port: http path: /index.html initialDelaySeconds: 1 periodSeconds: 3 readinessProbe: httpGet: port: http path: /index.html initialDelaySeconds: 5 periodSeconds: 5 2, 应用YAML文件\n[root@k8s-master1 ~]# kubectl apply -f pod-readiness-liveiness.yml pod/readiness-liveness-httpget created 3, 验证\n[root@k8s-master1 ~]# kubectl get pod |grep readiness-liveness-httpget NAME READY STATUS RESTARTS AGE readiness-liveness-httpget 0/1 Running 0 6s 5.3 post-start link1, 编写YAML文件\n[root@k8s-master1 ~]# vim pod-poststart.yml apiVersion: v1 kind: Pod metadata: name: poststart namespace: default spec: containers: - name: poststart image: nginx:1.15-alpine imagePullPolicy: IfNotPresent lifecycle: # 生命周期事件 postStart: exec: command: [\"mkdir\",\"-p\",\"/usr/share/nginx/html/haha\"] 2, 应用YMAL文件\n[root@k8s-master1 ~]# kubectl apply -f pod-poststart.yml 3, 验证\n[root@k8s-master1 ~]# kubectl get pods NAME READY STATUS RESTARTS AGE poststart 1/1 Running 0 25s [root@k8s-master1 ~]# kubectl exec -it poststart -- ls /usr/share/nginx/html -l total 8 -rw-r--r-- 1 root root 494 Apr 16 13:08 50x.html drwxr-xr-x 2 root root 6 Aug 5 05:33 haha\t有创建此目录 -rw-r--r-- 1 root root 612 Apr 16 13:08 index.html 5.4 pre-stop link容器终止前执行的命令\n1, 编写YAML文件\n[root@k8s-master1 ~]# vim prestop.yml apiVersion: v1 kind: Pod metadata: name: prestop namespace: default spec: containers: - name: prestop image: nginx:1.15-alpine imagePullPolicy: IfNotPresent lifecycle: # 生命周期事件 preStop: # preStop exec: command: [\"/bin/sh\",\"-c\",\"sleep 60000000\"] # 容器终止前sleep 60000000秒 2, 应用YAML文件创建pod\n[root@k8s-master1 ~]# kubectl apply -f prestop.yml pod/prestop created 3, 删除pod验证\n[root@k8s-master1 ~]# kubectl delete -f prestop.yml pod \"prestop\" deleted\t会在这一步等待一定的时间(大概30s-60s左右)才能删除,说明验证成功 结论: 当出现特殊情况不能正常销毁pod时,大概等待30秒会强制终止\n5.5 pod故障排除 link 状态 描述 Pending（悬决） Pod 已被 Kubernetes 系统接受，但有一个或者多个容器尚未创建亦未运行。此阶段包括等待 Pod 被调度的时间和通过网络下载镜像的时间。 Running（运行中） pod已经绑定到一个节点，并且已经创建了所有容器。至少有一个容器正在运行中，或正在启动或重新启动。 completed（完成） Pod中的所有容器都已成功终止，不会重新启动。 Failed（失败） Pod的所有容器均已终止，且至少有一个容器已在故障中终止。也就是说，容器要么以非零状态退出，要么被系统终止。 Unknown（未知） 由于某种原因apiserver无法获得Pod的状态，通常是由于Master与Pod所在主机kubelet通信时出错。 CrashLoopBackOff 多见于CMD语句错误或者找不到container入口语句导致了快速退出,可以用kubectl logs 查看日志进行排错 kubectl describe pod pod名 kubectl logs pod [-c CONTAINER] kubectl exec POD [-c CONTAINER] –COMMAND [args…] kubernetes核心概念 Controller link1. pod控制器controller link1.1 Controller作用及分类 linkcontroller用于控制pod\n参考: workloads\n控制器主要分为:\nDeployments 部署无状态应用，控制pod升级,回退 ReplicaSet 副本集,控制pod扩容,裁减 ReplicationController(相当于ReplicaSet的老版本,现在建议使用Deployments加ReplicaSet替代RC) StatefulSets 部署有状态应用，结合Service、存储等实现对有状态应用部署 DaemonSet 守护进程集，运行在所有集群节点(包括master), 比如使用filebeat,node_exporter Jobs 一次性 Cronjob 周期性 1.2 Deployment link1.2.1 Replicaset控制器的功能 link 支持新的基于集合的selector(以前的rc里没有这种功能) 通过改变Pod副本数量实现Pod的扩容和缩容 1.2.2 Deployment控制器的功能 link Deployment集成了上线部署、滚动升级、创建副本、回滚等功能 Deployment里包含并使用了ReplicaSet 1.2.3 Deployment用于部署无状态应用 link无状态应用的特点:\n所有pod无差别 所有pod中容器运行同一个image 所有pod可以运行在集群中任意node上 所有pod无启动顺序先后之分 随意pod数量扩容或缩容 例如简单运行一个静态web程序 1.2.4 创建deployment类型应用 link1, 准备YAML文件\n[root@k8s-master1 ~]# vim deployment-nginx.yml apiVersion: apps/v1 kind: Deployment metadata: name: deploy-nginx\t# deployment名 spec:\treplicas: 1\t# 副本集,deployment里使用了replicaset selector: matchLabels: app: nginx\t# 匹配的pod标签,表示deployment和rs控制器控制带有此标签的pod template:\t# 代表pod的配置模板 metadata: labels: app: nginx\t# pod的标签 spec: containers:\t# 以下为pod里的容器定义 - name: nginx image: nginx:1.15-alpine imagePullPolicy: IfNotPresent ports: - containerPort: 80 2, 应用YAML文件创建deployment\n[root@k8s-master1 ~]# kubectl apply -f deployment-nginx.yml deployment.apps/deploy-nginx created 3, 查看验证\n[root@k8s-master1 ~]# kubectl get deployment\t# deployment可简写成depoly NAME READY UP-TO-DATE AVAILABLE AGE deploy-nginx 1/1 1 1 19s [root@k8s-master1 ~]# kubectl get pods NAME READY STATUS RESTARTS AGE deploy-nginx-6c9764bb69-pbc2h 1/1 Running 0 75s [root@k8s-master1 ~]# kubectl get replicasets\t# replicasets可简写成rs NAME DESIRED CURRENT READY AGE deploy-nginx-6c9764bb69 1 1 1 2m6s 1.2.5 访问deployment link1,查看pod的IP地址\n[root@k8s-master1 ~]# kubectl get pods -o wide NAME READY STATUS RESTARTS AGE IP NODE NOMINATED NODE READINESS GATES deploy-nginx-6d9d558bb6-88nr8 1/1 Running 0 39s 10.244.159.155 k8s-master1 pod在k8s-master1节点,pod的IP为10.244.159.155 2, 查看所有集群节点的网卡\n[root@k8s-master1 ~]# ifconfig tunl0 |head -2 tunl0: flags=193 mtu 1480 inet 10.244.159.128 netmask 255.255.255.255 [root@k8s-master2 ~]# ifconfig tunl0 |head -2 tunl0: flags=193 mtu 1480 inet 10.244.224.0 netmask 255.255.255.255 [root@k8s-master3 ~]# ifconfig tunl0 |head -2 tunl0: flags=193 mtu 1480 inet 10.244.135.192 netmask 255.255.255.255 [root@k8s-worker1 ~]# ifconfig tunl0 |head -2 tunl0: flags=193 mtu 1480 inet 10.244.194.64 netmask 255.255.255.255 可以看到所有集群节点的IP都为10.244.0.0/16这个大网段内的子网 3, 在任意集群节点上都可以访问此deploy里pod\n# curl 10.244.159.155 结果是任意集群节点都可以访问这个POD,但集群外部是不能访问的 1.2.6 删除deployment中的pod link1, 删除pod（注意: 是删除deployment中的pod）\n[root@k8s-master1 ~]# kubectl delete pod deploy-nginx-6c9764bb69-pbc2h pod \"deploy-nginx-6c9764bb69-pbc2h\" deleted 2, 再次查看,发现又重新启动了一个pod(节点由k8s-master1转为k8s-worker1 了,IP地址也变化了)\n[root@k8s-master1 ~]# kubectl get pods -o wide NAME READY STATUS RESTARTS AGE IP NODE NOMINATED NODE READINESS GATES deploy-nginx-6d9d558bb6-f2t6r 1/1 Running 0 28s 10.244.194.94 k8s-worker1 也就是说**==pod的IP不是固定的==,比如把整个集群关闭再启动,pod也会自动启动,但是IP地址也会变化**\n既然IP地址不是固定的,所以需要一个固定的访问endpoint给用户,那么这种方式就是service.\n1.2.7 pod版本升级 link查看帮助\n[root@k8s-master1 ~]# kubectl set image -h 1, 升级前验证nginx版本\n[root@k8s-master1 ~]# kubectl describe pods deploy-nginx-6d9d558bb6-f2t6r | grep Image: Image: nginx:1.15-alpine [root@k8s-master1 ~]# kubectl exec deploy-nginx-6d9d558bb6-f2t6r -- nginx -v nginx version: nginx/1.15.12 2, 升级为1.16版\n[root@k8s-master1 ~]# kubectl set image deployment deploy-nginx nginx=nginx:1.16-alpine --record deployment.apps/deploy-nginx image updated 说明:\ndeployment deploy-nginx代表名为deploy-nginx的deployment\nnginx=nginx:1.16-alpine前面的nginx为容器名\n–record 表示会记录\n容器名怎么查看?\nkubectl describe pod pod名查看 kubectl edit deployment deployment名来查看容器名 kubectl get deployment deployment名 -o yaml来查看容器名 3, 验证\n如果升级的pod数量较多，则需要一定时间，可通过下面命令查看是否已经成功\n[root@k8s-master1 ~]# kubectl rollout status deployment deploy-nginx\tdeployment \"deploy-nginx\" successfully rolled out 验证 pod\n[root@k8s-master1 ~]# kubectl get pods NAME READY STATUS RESTARTS AGE deploy-nginx-5f4749c8c8-nskp9 1/1 Running 0 104s 更新后,后面的id变了 验证版本\n[root@k8s-master1 ~]# kubectl describe pod deploy-nginx-5f4749c8c8-nskp9 |grep Image: Image: nginx:1.16-alpine\t升级为1.16了 [root@k8s-master1 ~]# kubectl exec deploy-nginx-5f4749c8c8-nskp9 -- nginx -v nginx version: nginx/1.16.1\t升级为1.16了 练习: 再将nginx1升级为1.17版\n[root@k8s-master1 ~]# kubectl set image deployment deploy-nginx nginx=nginx:1.17-alpine --record deployment.apps/deploy-nginx image updated 1.2.8 pod版本回退 link1, 查看版本历史信息\n[root@k8s-master1 ~]# kubectl rollout history deployment deploy-nginx deployment.apps/deploy-nginx REVISION CHANGE-CAUSE 1 原1.15版 2 kubectl set image deployment deploy-nginx nginx=nginx:1.16-alpine --record=true 3 kubectl set image deployment deploy-nginx nginx=nginx:1.17-alpine --record=true 2, 定义要回退的版本（还需要执行才是真的回退版本)\n[root@k8s-master1 ~]# kubectl rollout history deployment deploy-nginx --revision=1 deployment.apps/deploy-nginx with revision #1 Pod Template: Labels: app=nginx pod-template-hash=6c9764bb69 Containers: nginx: Image: nginx:1.15-alpine\t可以看到这是要回退的1.15版本 Port: 80/TCP Host Port: 0/TCP Environment: Mounts: Volumes: 3, 执行回退\n[root@k8s-master1 ~]# kubectl rollout undo deployment deploy-nginx --to-revision=1 deployment.apps/deploy-nginx rolled back 4, 验证\n[root@k8s-master1 ~]# kubectl rollout history deployment deploy-nginx deployment.apps/deploy-nginx REVISION CHANGE-CAUSE 2 kubectl set image deployment deploy-nginx nginx=nginx:1.16-alpine --record=true 3 kubectl set image deployment deploy-nginx nginx=nginx:1.17-alpine --record=true 4 回到了1.15版,但revision的ID变了 [root@k8s-master1 ~]# kubectl get pods NAME READY STATUS RESTARTS AGE deploy-nginx-6c9764bb69-zgwpj 1/1 Running 0 54s [root@k8s-master1 ~]# kubectl describe pod deploy-nginx-6c9764bb69-zgwpj |grep Image: Image: nginx:1.15-alpine\t回到了1.15版 [root@k8s-master1 ~]# kubectl exec deploy-nginx-6c9764bb69-zgwpj -- nginx -v nginx version: nginx/1.15.12\t回到了1.15版 1.2.9 副本扩容 link查看帮助\n[root@k8s-master1 ~]# kubectl scale -h 1, 扩容为2个副本\n[root@k8s-master1 ~]# kubectl scale deployment deploy-nginx --replicas=2 deployment.apps/deploy-nginx scaled 2, 查看\n[root@k8s-master1 ~]# kubectl get pods -o wide NAME READY STATUS RESTARTS AGE IP NODE NOMINATED NODE READINESS GATES deploy-nginx-6d9d558bb6-4c64l 1/1 Running 0 27s 10.244.159.157 k8s-master1 deploy-nginx-6d9d558bb6-hkq2b 1/1 Running 0 71s 10.244.194.95 k8s-worker1 在两个node节点上各1个pod 3, 继续扩容(我们这里只有2个node,但是可以大于node节点数据)\n[root@master ~]# kubectl scale deployment deploy-nginx --replicas=4 deployment.extensions/nginx1 scaled [root@k8s-master1 ~]# kubectl get pods -o wide NAME READY STATUS RESTARTS AGE IP NODE NOMINATED NODE READINESS GATES deploy-nginx-6d9d558bb6-4c64l 1/1 Running 0 87s 10.244.159.157 k8s-master1 deploy-nginx-6d9d558bb6-586dr 1/1 Running 0 31s 10.244.135.197 k8s-master3 deploy-nginx-6d9d558bb6-hkq2b 1/1 Running 0 2m11s 10.244.194.95 k8s-worker1 deploy-nginx-6d9d558bb6-kvgsc 1/1 Running 0 31s 10.244.224.13 k8s-master2 1.2.10 副本裁减 link1, 指定副本数为1进行裁减\n[root@k8s-master1 ~]# kubectl scale deployment deploy-nginx --replicas=1 deployment.apps/deploy-nginx scaled 2, 查看验证\n[root@k8s-master1 ~]# kubectl get pods NAME READY STATUS RESTARTS AGE deploy-nginx-6d9d558bb6-hkq2b 1/1 Running 0 2m56s 1.2.11 多副本滚动更新 link1, 先扩容多点副本\n[root@k8s-master1 ~]# kubectl scale deployment deploy-nginx --replicas=16 deployment.apps/deploy-nginx scaled 2, 验证\n[root@master ~]# kubectl get pods NAME READY STATUS RESTARTS AGE nginx1-7d9b8757cf-2hd48 1/1 Running 0 61s nginx1-7d9b8757cf-5m72n 1/1 Running 0 61s nginx1-7d9b8757cf-5w2xr 1/1 Running 0 61s nginx1-7d9b8757cf-5wmdh 1/1 Running 0 61s nginx1-7d9b8757cf-6szjj 1/1 Running 0 61s nginx1-7d9b8757cf-9dgsw 1/1 Running 0 61s nginx1-7d9b8757cf-dc7qj 1/1 Running 0 61s nginx1-7d9b8757cf-l52pr 1/1 Running 0 61s nginx1-7d9b8757cf-m7rt4 1/1 Running 0 26m nginx1-7d9b8757cf-mdkj2 1/1 Running 0 61s nginx1-7d9b8757cf-s79kp 1/1 Running 0 61s nginx1-7d9b8757cf-shhvk 1/1 Running 0 61s nginx1-7d9b8757cf-sv8gb 1/1 Running 0 61s nginx1-7d9b8757cf-xbhf4 1/1 Running 0 61s nginx1-7d9b8757cf-zgdgd 1/1 Running 0 61s nginx1-7d9b8757cf-zzljl 1/1 Running 0 61s nginx2-559567f789-8hstz 1/1 Running 1 114m 3, 滚动更新\n[root@k8s-master1 ~]# kubectl set image deployment deploy-nginx nginx=nginx:1.17-alpine --record deployment.apps/deploy-nginx image updated 4, 验证\n[root@k8s-master1 ~]# kubectl rollout status deployment deploy-nginx ...... Waiting for deployment \"deploy-nginx\" rollout to finish: 13 of 16 updated replicas are available... Waiting for deployment \"deploy-nginx\" rollout to finish: 14 of 16 updated replicas are available... Waiting for deployment \"deploy-nginx\" rollout to finish: 15 of 16 updated replicas are available... deployment \"deploy-nginx\" successfully rolled out 1.2.12 删除deployment link如果使用 kubectl delete deployment deploy-nginx 命令删除deployment,那么里面的pod也会被自动删除\n1.3 Replicaset link1, 编写YAML文件\n[root@master ~]# vim rs-nginx.yml apiVersion: apps/v1 kind: ReplicaSet metadata: name: rs-nginx namespace: default spec: # replicaset的spec replicas: 2 # 副本数 selector: # 标签选择器,对应pod的标签 matchLabels: app: nginx # 匹配的label template: metadata: name: nginx\t# pod名 labels: # 对应上面定义的标签选择器selector里面的内容 app: nginx spec: # pod的spec containers: - name: nginx image: nginx:1.15-alpine ports: - name: http containerPort: 80 2, 应用YAML文件\n[root@k8s-master1 ~]# kubectl apply -f rs-nginx.yml replicaset.apps/rs-nginx created 3, 验证\n[root@k8s-master1 ~]# kubectl get rs NAME DESIRED CURRENT READY AGE rs-nginx 2 2 2 26s [root@k8s-master1 ~]# kubectl get pods NAME READY STATUS RESTARTS AGE rs-nginx-7j9hz 1/1 Running 0 44s rs-nginx-pncsk 1/1 Running 0 43s [root@k8s-master1 ~]# kubectl get deployment No resources found. 找不到deployment,说明创建rs并没有创建deployment 2. pod控制器Controller进阶 link2.1 DaemonSet link2.1.1 DaemonSet介绍 link DaemonSet能够让所有（或者特定）的节点运行同一个pod。 当节点加入到K8S集群中，pod会被（DaemonSet）调度到该节点上运行，当节点从K8S集群中被移除，被DaemonSet调度的pod会被移除 如果删除DaemonSet，所有跟这个DaemonSet相关的pods都会被删除。 如果一个DaemonSet的Pod被杀死、停止、或者崩溃，那么DaemonSet将会重新创建一个新的副本在这台计算节点上。 DaemonSet一般应用于日志收集、监控采集、分布式存储守护进程等 2.1.2 DaemonSet应用案例 link1, 编写YAML文件\n~ [root@master ~]# vim daemonset-nginx.yml apiVersion: apps/v1 kind: DaemonSet metadata: name: daemonset-nginx\tspec: selector: matchLabels: name: nginx-ds template: metadata: labels: name: nginx-ds spec: tolerations:\t# tolerations代表容忍 - key: node-role.kubernetes.io/master # 能容忍的污点key effect: NoSchedule # kubectl explain pod.spec.tolerations查看(能容忍的污点effect) containers: - name: nginx image: nginx:1.15-alpine imagePullPolicy: IfNotPresent resources: # resources资源限制是为了防止master节点的资源被占太多(根据实际情况配置) limits: memory: 100Mi requests: memory: 100Mi 2, apply应用YAML文件\n[root@k8s-master1 ~]# kubectl apply -f daemonset-nginx.yml daemonset.apps/daemonset-nginx created 3, 验证\n[root@master ~]# kubectl get daemonset\t# daemonset可简写为ds [root@k8s-master1 ~]# kubectl get ds NAME DESIRED CURRENT READY UP-TO-DATE AVAILABLE NODE SELECTOR AGE daemonset-nginx 4 4 4 4 4 114s [root@k8s-master1 ~]# kubectl get pods -o wide NAME READY STATUS RESTARTS AGE IP NODE NOMINATED NODE READINESS GATES daemonset-nginx-94z6d 1/1 Running 0 6s 10.244.194.104 k8s-worker1 daemonset-nginx-hs9mk 1/1 Running 0 6s 10.244.135.206 k8s-master3 daemonset-nginx-jrcf5 1/1 Running 0 6s 10.244.159.167 k8s-master1 daemonset-nginx-sslpl 1/1 Running 0 6s 10.244.224.22 k8s-master2 k8s集群中每个节点都会运行一个pod 2.2 Job link2.2.1 Job介绍 link 对于ReplicaSet而言，它希望pod保持预期数目、持久运行下去，除非用户明确删除，否则这些对象一直存在，它们针对的是耐久性任务，如web服务等。 对于非耐久性任务，比如压缩文件，任务完成后，pod需要结束运行，不需要pod继续保持在系统中，这个时候就要用到Job。 Job负责批量处理短暂的一次性任务 (short lived one-off tasks)，即仅执行一次的任务，它保证批处理任务的一个或多个Pod成功结束。 2.2.2 Job应用案例 link2.2.2.1 计算圆周率2000位 link1, 编写YAML文件\n[root@master ~]# vim job1.yml apiVersion: batch/v1 kind: Job metadata: name: pi\t# job名 spec: template: metadata: name: pi\t# pod名 spec: containers: - name: pi\t# 容器名 image: perl\t# 此镜像有800多M,可提前导入到所有节点,也可能指定导入到某一节点然后指定调度到此节点 imagePullPolicy: IfNotPresent command: [\"perl\", \"-Mbignum=bpi\", \"-wle\", \"print bpi(2000)\"] restartPolicy: Never # 执行完后不再重启 2, 应用YAML文件创建job\n[root@master ~]# kubectl apply -f job1.yml job.batch/pi created 3, 验证\n[root@k8s-master1 ~]# kubectl get jobs NAME COMPLETIONS DURATION AGE pi 1/1 11s 18s [root@k8s-master1 ~]# kubectl get pods NAME READY STATUS RESTARTS AGE pi-tjq9b 0/1 Completed 0 27s Completed状态,也不再是ready状态 [root@k8s-master1 ~]# kubectl logs pi-tjq9b 3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632788659361533818279682303019520353018529689957736225994138912497217752834791315155748572424541506959508295331168617278558890750983817546374649393192550604009277016711390098488240128583616035637076601047101819429555961989467678374494482553797747268471040475346462080466842590694912933136770289891521047521620569660240580381501935112533824300355876402474964732639141992726042699227967823547816360093417216412199245863150302861829745557067498385054945885869269956909272107975093029553211653449872027559602364806654991198818347977535663698074265425278625518184175746728909777727938000816470600161452491921732172147723501414419735685481613611573525521334757418494684385233239073941433345477624168625189835694855620992192221842725502542568876717904946016534668049886272327917860857843838279679766814541009538837863609506800642251252051173929848960841284886269456042419652850222106611863067442786220391949450471237137869609563643719172874677646575739624138908658326459958133904780275901 2.2.2.2 创建固定次数job link1, 编写YAML文件\n[root@master ~]# vim job2.yml apiVersion: batch/v1 kind: Job metadata: name: busybox-job spec: completions: 10 # 执行job的次数 parallelism: 1 # 执行job的并发数 template: metadata: name: busybox-job-pod spec: containers: - name: busybox image: busybox imagePullPolicy: IfNotPresent command: [\"echo\", \"hello\"] restartPolicy: Never 2, 应用YAML文件创建job\n[root@k8s-master1 ~]# kubectl apply -f job2.yml job.batch/busybox-job created 3, 验证\n[root@k8s-master1 ~]# kubectl get job NAME COMPLETIONS DURATION AGE busybox-job 2/10 9s 9s [root@k8s-master1 ~]# kubectl get job NAME COMPLETIONS DURATION AGE busybox-job 3/10 12s 12s [root@k8s-master1 ~]# kubectl get job NAME COMPLETIONS DURATION AGE busybox-job 4/10 15s 15s [root@k8s-master1 ~]# kubectl get job NAME COMPLETIONS DURATION AGE busybox-job 10/10 34s 48s 34秒左右结束 [root@master ~]# kubectl get pods NAME READY STATUS RESTARTS AGE busybox-job-5zn6l 0/1 Completed 0 34s busybox-job-cm9kw 0/1 Completed 0 29s busybox-job-fmpgt 0/1 Completed 0 38s busybox-job-gjjvh 0/1 Completed 0 45s busybox-job-krxpd 0/1 Completed 0 25s busybox-job-m2vcq 0/1 Completed 0 41s busybox-job-ncg78 0/1 Completed 0 47s busybox-job-tbzz8 0/1 Completed 0 51s busybox-job-vb99r 0/1 Completed 0 21s busybox-job-wnch7 0/1 Completed 0 32s 2.2.2.3 一次性备份MySQL数据库 link 通过Job控制器创建应用备份MySQL数据库\n2.2.2.3.1 MySQL数据库准备 link [root@nginx jobcontroller]# cat 00_mysql.yaml apiVersion: v1 kind: Service metadata: name: mysql-test namespace: default spec: ports: - port: 3306 name: mysql clusterIP: None selector: app: mysql-dump --- apiVersion: apps/v1 kind: StatefulSet metadata: name: db namespace: default spec: selector: matchLabels: app: mysql-dump serviceName: \"mysql-test\" template: metadata: labels: app: mysql-dump spec: nodeName: k8s-master3 containers: - name: mysql image: mysql:5.7 env: - name: MYSQL_ROOT_PASSWORD value: \"abc123\" ports: - containerPort: 3306 volumeMounts: - mountPath: \"/var/lib/mysql\" name: mysql-data volumes: - name: mysql-data hostPath: path: /opt/mysqldata 2.2.2.3.2 创建用于实现任务的资源清单文件 link [root@nginx jobcontroller]# cat 03_job.yaml apiVersion: batch/v1 kind: Job metadata: name: mysql-dump spec: template: metadata: name: mysql-dump spec: nodeName: k8s-master2 containers: - name: mysql-dump image: mysql:5.7 command: [\"/bin/sh\",\"-c\",\"mysqldump --host=mysql-test -uroot -pabc123 --databases mysql \u003e /root/mysql2022.sql\"] volumeMounts: - mountPath: \"/root\" name: mysql-data restartPolicy: Never volumes: - name: mysql-data hostPath: path: /opt/mysqldump 2.3 CronJob link2.3.1 CronJob介绍 link 类似于Linux系统的crontab，在指定的时间周期运行相关的任务 时间格式：分时日月周 2.3.2 CronJob应用案例 link2.3.2.1 周期性输出字符 link1, 编写YAML文件\n[root@k8s-master1 ~]# vim cronjob.yml apiVersion: batch/v1beta1 kind: CronJob metadata: name: cronjob1 spec: schedule: \"* * * * *\" # 分时日月周 jobTemplate: spec: template: spec: containers: - name: hello image: busybox args: - /bin/sh - -c - date; echo hello kubernetes imagePullPolicy: IfNotPresent restartPolicy: OnFailure 2, 应用YAML文件创建cronjob\n[root@k8s-master1 ~]# kubectl apply -f cronjob.yml cronjob.batch/cronjob1 created 3, 查看验证\n[root@k8s-master1 ~]# kubectl get cronjob NAME SCHEDULE SUSPEND ACTIVE LAST SCHEDULE AGE cronjob1 * * * * * False 0 21s [root@k8s-master1 ~]# kubectl get pods NAME READY STATUS RESTARTS AGE cronjob-1564993080-qlbgv 0/1 Completed 0 2m10s cronjob-1564993140-zbv7f 0/1 Completed 0 70s cronjob-1564993200-gx5xz 0/1 Completed 0 10s 看AGE时间,每分钟整点执行一次 2.3.2.2 周期性备份MySQL数据库 link2.3.2.2.1 MySQL数据库准备 link [root@nginx jobcontroller]# cat 00_mysql.yaml apiVersion: v1 kind: Service metadata: name: mysql-test namespace: default spec: ports: - port: 3306 name: mysql clusterIP: None selector: app: mysql-dump --- apiVersion: apps/v1 kind: StatefulSet metadata: name: db namespace: default spec: selector: matchLabels: app: mysql-dump serviceName: \"mysql-test\" template: metadata: labels: app: mysql-dump spec: nodeName: worker03 containers: - name: mysql image: mysql:5.7 env: - name: MYSQL_ROOT_PASSWORD value: \"abc123\" ports: - containerPort: 3306 volumeMounts: - mountPath: \"/var/lib/mysql\" name: mysql-data volumes: - name: mysql-data hostPath: path: /opt/mysqldata 2.3.2.2.2 Cronjob控制器类型应用资源清单文件 link [root@nginx jobcontroller]# cat 05_cronjob.yaml apiVersion: batch/v1beta1 kind: CronJob metadata: name: mysql-dump spec: schedule: \"*/1 * * * *\" jobTemplate: spec: template: spec: nodeName: worker02 containers: - name: c1 image: mysql:5.7 command: [\"/bin/sh\",\"-c\",\"mysqldump --host=mysql-test -uroot -pabc123 --databases mysql \u003e /root/mysql`date +%Y%m%d%H%M`.sql\"] volumeMounts: - name: mysql-data mountPath: \"/root\" restartPolicy: Never volumes: - name: mysql-data hostPath: path: /opt/mysqldump Kubernetes核心概念 Controller之StatefulSet控制器 link1. StatefulSet控制器作用 link StatefulSet 是用来管理有状态应用的控制器。\nStatefulSet 用来管理某Pod集合的部署和扩缩， 并为这些 Pod 提供持久存储和持久标识符。\n参考: statefulset\n2. 无状态应用与有状态应用 link2.1 无状态应用 link 如nginx 请求本身包含了响应端为响应这一请求所需的全部信息。每一个请求都像首次执行一样，不会依赖之前的数据进行响应。 不需要持久化的数据 无状态应用的多个实例之间互不依赖，可以无序的部署、删除或伸缩 2.2 有状态应用 link 如mysql 前后请求有关联与依赖 需要持久化的数据 有状态应用的多个实例之间有依赖，不能相互替换：无论怎么调度，每个 Pod 都有一个永久不变的 ID。 3. StatefulSet的特点 link 稳定的、唯一的网络标识符。\t(通过headless服务实现) 稳定的、持久的存储。\t(通过PV，PVC，storageclass实现) 有序的、优雅的部署和缩放。 有序的、自动的滚动更新。 4. StatefulSet的YAML组成 link需要三个组成部分:\nheadless service: 实现稳定，唯一的网络标识 statefulset类型资源: 写法和deployment几乎一致，就是类型不一样 volumeClaimTemplate : 指定存储卷 5. 创建StatefulSet应用 link 参考: basic-stateful-set 5.1 编辑YAML资源清单文件 link 创建statelfulset应用来调用名为nfs-client的storageclass,以实现动态供给\n[root@k8s-master1 ~]# vim nginx-storageclass-nfs.yml apiVersion: v1 kind: Service metadata: name: nginx labels: app: nginx spec: ports: - port: 80 name: web clusterIP: None\t# 无头服务 selector: app: nginx --- apiVersion: apps/v1 kind: StatefulSet metadata: name: web\t# statefulset的名称 spec: serviceName: \"nginx\" replicas: 3\t# 3个副本 selector: matchLabels: app: nginx template: metadata: labels: app: nginx spec: containers: - name: nginx image: nginx:1.15-alpine ports: - containerPort: 80 name: web volumeMounts: - name: www mountPath: /usr/share/nginx/html volumeClaimTemplates: - metadata: name: www spec: accessModes: [ \"ReadWriteOnce\" ] storageClassName: \"nfs-client\"\t# 与前面定义的storageclass名称对应 resources: requests: storage: 1Gi [root@k8s-master1 ~]# kubectl apply -f nginx-storageclass-nfs.yml service/nginx created statefulset.apps/web created 5.2 应用部署后验证 link5.2.1 验证pod link 产生了3个pod\n[root@k8s-master1 ~]# kubectl get pods |grep web web-0 1/1 Running 0 1m15s web-1 1/1 Running 0 1m7s web-2 1/1 Running 0 57s 5.2.2 验证pv link 自动产生了3个pv\n[root@k8s-master1 ~] # kubectl get pv pvc-2436b20d-1be3-4c2e-87a9-5533e5c5e2c6 1Gi RWO Delete Bound default/www-web-0 nfs-client 3m pvc-3114be74-5969-40eb-aeb3-87a3b9ae17bc 1Gi RWO Delete Bound default/www-web-1 nfs-client 2m pvc-43afb71d-1d02-4699-b00c-71679fd75fc3 1Gi RWO Delete ound default/www-web-2 nfs-client 2m 5.2.3 验证pvc link 自动产生了3个PVC\n[root@k8s-master1 ~]# kubectl get pvc |grep web www-web-0 Bound pvc-2436b20d-1be3-4c2e-87a9-5533e5c5e2c6 1Gi RWO nfs-client 3m www-web-1 Bound pvc-3114be74-5969-40eb-aeb3-87a3b9ae17bc 1Gi RWO nfs-client 2m www-web-2 Bound pvc-43afb71d-1d02-4699-b00c-71679fd75fc3 1Gi RWO nfs-client 2m 5.2.4 验证nfs服务目录 link在nfs服务器（这里为hostos)的共享目录中发现自动产生了3个子目录\n[root@nfsserver ~]# ls /data/nfs/ default-www-web-0-pvc-2436b20d-1be3-4c2e-87a9-5533e5c5e2c6 default-www-web-2-pvc-43afb71d-1d02-4699-b00c-71679fd75fc3 default-www-web-1-pvc-3114be74-5969-40eb-aeb3-87a3b9ae17bc 3个子目录默认都为空目录\n[root@nfsserver ~]# tree /data/nfs/ /data/nfs/ ├── default-www-web-0-pvc-2436b20d-1be3-4c2e-87a9-5533e5c5e2c6 ├── default-www-web-1-pvc-3114be74-5969-40eb-aeb3-87a3b9ae17bc └── default-www-web-2-pvc-43afb71d-1d02-4699-b00c-71679fd75fc3 5.2.5 验证存储持久性 link在3个pod中其中一个创建一个主页文件\n[root@k8s-master1 ~]# kubectl exec -it web-0 -- /bin/sh / # echo \"haha\" \u003e /usr/share/nginx/html/index.html / # exit 在nfs服务器上发现文件被创建到了对应的目录中\n[root@nfsserver ~]# tree /data/nfs/ /data/nfs/ ├── default-www-web-0-pvc-2436b20d-1be3-4c2e-87a9-5533e5c5e2c6 │ └── index.html\t# 此目录里多了index.html文件，对应刚才在web-0的pod中的创建 ├── default-www-web-1-pvc-3114be74-5969-40eb-aeb3-87a3b9ae17bc └── default-www-web-2-pvc-43afb71d-1d02-4699-b00c-71679fd75fc3 [root@nfsserver ~]# cat /data/nfs/default-www-web-0-pvc-2436b20d-1be3-4c2e-87a9-5533e5c5e2c6/index.html haha\t# 文件内的内容也与web-0的pod中创建的一致 删除web-0这个pod,再验证\n[root@k8s-master1 ~]# kubectl delete pod web-0 pod \"web-0\" deleted [root@k8s-master1 ~]# kubectl get pods |grep web\t# 因为控制器的原因，会迅速再拉起web-0这个pod web-0 1/1 Running 0 9s\t# 时间上看到是新拉起的pod web-1 1/1 Running 0 37m web-2 1/1 Running 0 37m [root@k8s-master1 ~]# kubectl exec -it web-0 -- cat /usr/share/nginx/html/index.html haha\t# 新拉起的pod仍然是相同的存储数据 [root@nfsserver ~]# cat /data/nfs/default-www-web-0-pvc-2436b20d-1be3-4c2e-87a9-5533e5c5e2c6/index.html haha\t# nfs服务器上的数据还在 结论: 说明数据可持久化\n5.2.6 访问验证 link 验证Coredns是否可用 # kubectl get svc -n kube-system NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE kube-dns ClusterIP 10.96.0.10 53/UDP,53/TCP,9153/TCP 6d23h # dig -t a www.baidu.com @10.96.0.10 # dig -t a nginx.default.svc.cluster.local. @10.96.0.10 .... ;; ANSWER SECTION: nginx.default.svc.cluster.local. 30 IN A 10.224.194.75 nginx.default.svc.cluster.local. 30 IN A 10.224.159.141 nginx.default.svc.cluster.local. 30 IN A 10.224.126.6 # dig -t a web-0.nginx.default.svc.cluster.local. @10.96.0.10 在kubernetes集群内创建pod访问 # kubectl run -it busybox --image=radial/busyboxplus / # curl nginx.default.svc.cluster.local. web-0 / # curl web-0.nginx.default.svc.cluster.local. web-0 6. 已部署应用滚动更新(含金丝雀发布) link 它将按照与 Pod 终止相同的顺序（从最大序号到最小序号）进行，每次更新一个 Pod。\nStatefulSet可以使用partition参数来实现金丝雀更新，partition参数可以控制StatefulSet控制器更新的Pod。下面，我们就进行StatefulSet控制器的金丝雀更新实战。\nkubectl patch sts web -p '{\"spec\":{\"updateStrategy\":{\"rollingUpdate\":{\"partition\":2}}}}' 说明： 使用patch参数来指定了StatefulSet控制器的partition参数为2，表示当更新时，只有Pod的编号大于等于2的才更新。 # kubectl exec -it web-0 -- nginx -v nginx version: nginx/1.15.12 kubectl set image sts/web nginx=nginx:latest kubectl get pods -w # kubectl exec -it web-2 -- nginx -v nginx version: nginx/1.21.6 # kubectl get pods -o custom-columns=Name:metadata.name,Image:spec.containers[0].image Name Image web-0 nginx:1.15-alpine web-1 nginx:1.15-alpine web-2 nginx:latest 如何实现全部更新呢？\nkubectl patch sts web -p '{\"spec\":{\"updateStrategy\":{\"rollingUpdate\":{\"partition\":0}}}}' kubectl set image sts/web nginx=nginx:latest # kubectl get pods -o custom-columns=Name:metadata.name,Image:spec.containers[0].image 7. 已部署应用扩容与缩容 link在StatefulSet扩容时，会创建一个新的Pod，该Pod与之前的所有Pod都是有顺序的，并且新Pod的序号最大。在缩容时，StatefulSet控制器删除的也是序号最大的Pod。\n# kubectl scale sts web --replicas=4 # kubectl get pods -w kubernetes核心概念 Service link1. service作用 link使用kubernetes集群运行工作负载时，由于Pod经常处于用后即焚状态，Pod经常被重新生成，因此Pod对应的IP地址也会经常变化，导致无法直接访问Pod提供的服务，Kubernetes中使用了Service来解决这一问题，即在Pod前面使用Service对Pod进行代理，无论Pod怎样变化 ，只要有Label，就可以让Service能够联系上Pod，把PodIP地址添加到Service对应的端点列表（Endpoints）实现对Pod IP跟踪，进而实现通过Service访问Pod目的。\n通过service为pod客户端提供访问pod方法，即可客户端访问pod入口 通过标签动态感知pod IP地址变化等 防止pod失联 定义访问pod访问策略 通过label-selector相关联 通过Service实现Pod的负载均衡（TCP/UDP 4层） 底层实现由kube-proxy通过userspace、iptables、ipvs三种代理模式 2. kube-proxy三种代理模式 link kubernetes集群中有三层网络，一类是真实存在的，例如Node Network、Pod Network,提供真实IP地址;一类是虚拟的，例如Cluster Network或Service Network，提供虚拟IP地址，不会出现在接口上，仅会出现在Service当中\nkube-proxy始终watch（监控）kube-apiserver上关于Service相关的资源变动状态，一旦获取相关信息kube-proxy都要把相关信息转化为当前节点之上的，能够实现Service资源调度到特定Pod之上的规则，进而实现访问Service就能够获取Pod所提供的服务\nkube-proxy三种代理模式：UserSpace模式、iptables模式、ipvs模式\n2.1 UserSpace模式 linkuserspace 模式是 kube-proxy 使用的第一代模式，该模式在 kubernetes v1.0 版本开始支持使用。\nuserspace 模式的实现原理图示如下：\nkube-proxy 会为每个 Service 随机监听一个端口(proxy port)，并增加一条 iptables 规则。所以通过 ClusterIP:Port 访问 Service 的报文都 redirect 到 proxy port，kube-proxy 从它监听的 proxy port 收到报文以后，走 round robin(默认) 或是 session affinity(会话亲和力，即同一 client IP 都走同一链路给同一 pod 服务)，分发给对应的 pod。\n由于 userspace 模式会造成所有报文都走一遍用户态（也就是 Service 请求会先从用户空间进入内核 iptables，然后再回到用户空间，由 kube-proxy 完成后端 Endpoints 的选择和代理工作），需要在内核空间和用户空间转换，流量从用户空间进出内核会带来性能损耗，所以这种模式效率低、性能不高，不推荐使用。\n2.2 iptables模式 linkiptables 模式是 kube-proxy 使用的第二代模式，该模式在 kubernetes v1.1 版本开始支持，从 v1.2 版本开始成为 kube-proxy 的默认模式。\niptables 模式的负载均衡模式是通过底层 netfilter/iptables 规则来实现的，通过 Informer 机制 Watch 接口实时跟踪 Service 和 Endpoint 的变更事件，并触发对 iptables 规则的同步更新。\niptables 模式的实现原理图示如下：\n通过图示我们可以发现在 iptables 模式下，kube-proxy 只是作为 controller，而不是 server，真正服务的是内核的 netfilter，体现在用户态的是 iptables。所以整体的效率会比 userspace 模式高。\n2.3 ipvs模式 linkipvs 模式被 kube-proxy 采纳为第三代模式，模式在 kubernetes v1.8 版本开始引入，在 v1.9 版本中处于 beta 阶段，在 v1.11 版本中正式开始使用。\nipvs(IP Virtual Server) 实现了传输层负载均衡，也就是 4 层交换，作为 Linux 内核的一部分。ipvs运行在主机上，在真实服务器前充当负载均衡器。ipvs 可以将基于 TCP 和 UDP 的服务请求转发到真实服务器上，并使真实服务器上的服务在单个 IP 地址上显示为虚拟服务。\nipvs 模式的实现原理图示如下：\nipvs 和 iptables 都是基于 netfilter 的，那么 ipvs 模式有哪些更好的性能呢？\nipvs 为大型集群提供了更好的可拓展性和性能 ipvs 支持比 iptables 更复杂的负载均衡算法（包括：最小负载、最少连接、加权等） ipvs 支持服务器健康检查和连接重试等功能 可以动态修改 ipset 的集合，即使 iptables 的规则正在使用这个集合 ipvs 依赖于 iptables。ipvs 会使用 iptables 进行包过滤、airpin-masquerade tricks(地址伪装)、SNAT 等功能，但是使用的是 iptables 的扩展 ipset，并不是直接调用 iptables 来生成规则链。通过 ipset 来存储需要 DROP 或 masquerade 的流量的源或目标地址，用于确保 iptables 规则的数量是恒定的，这样我们就不需要关心有多少 Service 或是 Pod 了。\n使用 ipset 相较于 iptables 有什么优点呢？iptables 是线性的数据结构，而 ipset 引入了带索引的数据结构，当规则很多的时候，ipset 依然可以很高效的查找和匹配。我们可以将 ipset 简单理解为一个 IP(段) 的集合，这个集合的内容可以是 IP 地址、IP 网段、端口等，iptables 可以直接添加规则对这个“可变的集合进行操作”，这样就可以大大减少 iptables 规则的数量，从而减少性能损耗。\n举一个例子，如果我们要禁止成千上万个 IP 访问我们的服务器，如果使用 iptables 就需要一条一条的添加规则，这样会在 iptables 中生成大量的规则；如果用 ipset 就只需要将相关的 IP 地址(网段)加入到 ipset 集合中，然后只需要设置少量的 iptables 规则就可以实现这个目标。\n下面的表格是 ipvs 模式下维护的 ipset 表集合： 设置名称 成员 用法 KUBE-CLUSTER-IP 所有服务 IP + 端口 在 masquerade-all=true 或 clusterCIDR 指定的情况下对 Service Cluster IP 地址进行伪装，解决数据包欺骗问题 KUBE-LOOP-BACK 所有服务 IP + 端口 + IP 解决数据包欺骗问题 KUBE-EXTERNAL-IP 服务外部 IP + 端口 将数据包伪装成 Service 的外部 IP 地址 KUBE-LOAD-BALANCER 负载均衡器入口 IP + 端口 将数据包伪装成 Load Balancer 类型的 Service KUBE-LOAD-BALANCER-LOCAL 负载均衡器入口 IP + 端口 以及externalTrafficPolicy=local 接受数据包到 Load Balancer externalTrafficPolicy=local KUBE-LOAD-BALANCER-FW 负载均衡器入口 IP + 端口 以及loadBalancerSourceRanges 使用指定的 loadBalancerSourceRanges 丢弃 Load Balancer 类型 Service 的数据包 KUBE-LOAD-BALANCER-SOURCE-CIDR 负载均衡器入口 IP + 端口 + 源 CIDR 接受 Load Balancer 类型 Service 的数据包，并指定 loadBalancerSourceRanges KUBE-NODE-PORT-TCP NodePort 类型服务 TCP 端口 将数据包伪装成 NodePort（TCP） KUBE-NODE-PORT-LOCAL-TCP NodePort 类型服务 TCP 端口，带有externalTrafficPolicy=local 接受数据包到 NodePort 服务，使用 externalTrafficPolicy=local KUBE-NODE-PORT-UDP NodePort 类型服务 UDP 端口 将数据包伪装成 NodePort(UDP) KUBE-NODE-PORT-LOCAL-UDP NodePort 类型服务 UDP 端口，使用externalTrafficPolicy=local 接受数据包到 NodePort 服务，使用 externalTrafficPolicy=local 2.4 iptables与ipvs对比 link iptables\n工作在内核空间 优点 灵活，功能强大（可以在数据包不同阶段对包进行操作） 缺点 表中规则过多时，响应变慢，即规则遍历匹配和更新，呈线性时延 ipvs\n工作在内核空间 优点 转发效率高 调度算法丰富：rr，wrr，lc，wlc，ip hash… 缺点 内核支持不全,低版本内核不能使用，需要升级到4.0或5.0以上。 使用iptables与ipvs时机\n1.10版本之前使用iptables(1.1版本之前使用UserSpace进行转发) 1.11版本之后同时支持iptables与ipvs，默认使用ipvs，如果ipvs模块没有加载时，会自动降级至iptables 3. service类型 linkService类型决定了访问Service的方法\n3.1 service类型 link ClusterIP\n默认，分配一个集群内部可以访问的虚拟IP NodePort\n在每个Node上分配一个端口作为外部访问入口 nodePort端口范围为:30000-32767 LoadBalancer\n工作在特定的Cloud Provider上，例如Google Cloud，AWS，OpenStack ExternalName\n表示把集群外部的服务引入到集群内部中来，即实现了集群内部pod和集群外部的服务进行通信 3.2 Service参数 link port 访问service使用的端口\ntargetPort Pod中容器端口\nnodePort 通过Node实现外网用户访问k8s集群内service (30000-32767)\n4. Service创建 link Service的创建在工作中有两种方式，一是命令行创建，二是通过资源清单文件YAML文件创建。\n4.1 ClusterIP类型 linkClusterIP根据是否生成ClusterIP又可分为普通Service和Headless Service\nService两类：\n普通Service: 为Kubernetes的Service分配一个集群内部可访问的固定虚拟IP(Cluster IP), 实现集群内的访问。\nHeadless Service: 该服务不会分配Cluster IP, 也不通过kube-proxy做反向代理和负载均衡。而是通过DNS提供稳定的网络ID来访问，DNS会将headless service的后端直接解析为pod IP列表。\n4.1.1 普通ClusterIP Service创建 link4.1.1.1 命令行创建Service link 创建Deployment类型的应用 [root@master01 ~]# cat 01_create_deployment_app_nginx.yaml apiVersion: apps/v1 kind: Deployment metadata: name: nginx-server1 spec: replicas: 2 selector: matchLabels: app: nginx template: metadata: labels: app: nginx spec: containers: - name: c1 image: nginx:1.15-alpine imagePullPolicy: IfNotPresent ports: - containerPort: 80 应用资源清单文件 [root@master01 ~]# kubectl apply -f 01_create_deployment_app_nginx.yaml 验证Deployment类型的创建情况 [root@master01 ~]# kubectl get deployment.apps NAME READY UP-TO-DATE AVAILABLE AGE nginx-server1 2/2 2 2 13s 创建ClusterIP类型service与Deployment类型应用关联 命令创建service [root@master01 ~]# kubectl expose deployment.apps nginx-server1 --type=ClusterIP --target-port=80 --port=80 输出 service/nginx-server1 exposed 说明 expose 创建service deployment.apps 控制器类型 nginx-server1 应用名称，也是service名称 --type=ClusterIP 指定service类型 --target-port=80 指定Pod中容器端口 --port=80 指定service端口 4.1.1.2 通过资源清单文件创建Service link [root@master01 ~]# cat 02_create_deployment_app_nginx_with_service.yaml apiVersion: apps/v1 kind: Deployment metadata: name: nginx-server1 spec: replicas: 2 selector: matchLabels: app: nginx template: metadata: labels: app: nginx spec: containers: - name: nginx-smart image: nginx:1.15-alpine imagePullPolicy: IfNotPresent ports: - containerPort: 80 --- apiVersion: v1 kind: Service metadata: name: nginx-svc spec: type: ClusterIP ports: - protocol: TCP port: 80 targetPort: 80 selector: app: nginx [root@master01 ~]# kubectl apply -f 02_create_deployment_app_nginx_with_service.yaml 验证 查看service [root@master01 ~]# kubectl get service NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE kubernetes ClusterIP 10.96.0.1 443/TCP 4d15h nginx-svc ClusterIP 10.101.153.50 80/TCP 3s 查看endpoints [root@master01 ~]# kubectl get endpoints NAME ENDPOINTS AGE kubernetes 192.168.122.30:6443 4d15h nginx-svc 172.16.189.74:80,172.16.235.150:80 8s 查看Pod [root@master01 ~]# kubectl get pods -l app=nginx NAME READY STATUS RESTARTS AGE nginx-server1-77d4c485d8-gsrmq 1/1 Running 0 12s nginx-server1-77d4c485d8-mmc52 1/1 Running 0 12s 4.1.1.3 访问 link [root@master01 ~]# curl http://10.101.153.50:80 \u003c!DOCTYPE html\u003e Welcome to nginx! Welcome to nginx! If you see this page, the nginx web server is successfully installed and working. Further configuration is required.\nFor online documentation and support please refer to nginx.org. Commercial support is available at nginx.com.\nThank you for using nginx.\n4.1.1.4 两个pod里做成不同的主页方便测试负载均衡 link [root@master01 ~]# kubectl exec -it nginx-server1-77d4c485d8-gsrmq -- /bin/bash root@deployment-nginx-6fcfb67547-nv7dn:/# cd /usr/share/nginx/html/ root@deployment-nginx-6fcfb67547-nv7dn:/usr/share/nginx/html# echo web1 \u003e index.html root@deployment-nginx-6fcfb67547-nv7dn:/usr/share/nginx/html# exit exit [root@master01 ~]# kubectl exec -it nginx-server1-77d4c485d8-mmc52 -- /bin/bash root@deployment-nginx-6fcfb67547-rqrcw:/# cd /usr/share/nginx/html/ root@deployment-nginx-6fcfb67547-rqrcw:/usr/share/nginx/html# echo web2 \u003e index.html root@deployment-nginx-6fcfb67547-rqrcw:/usr/share/nginx/html# exit exit 4.1.1.5 测试 link [root@master01 ~]# curl 10.101.153.50 或 [root@master01 ~]# while true;do curl 10.101.153.50;sleep 1; done 4.1.2 Headless Service link 普通的ClusterIP service是service name解析为cluster ip,然后cluster ip对应到后面的pod ip Headless service是指service name 直接解析为后面的pod ip 4.1.2.1 编写用于创建Deployment控制器类型的资源清单文件 link [root@master01 ~]# cat 03_create_deployment_app_nginx.yaml apiVersion: apps/v1 kind: Deployment metadata: name: nginx-server1 spec: replicas: 2 selector: matchLabels: app: nginx template: metadata: labels: app: nginx spec: containers: - name: nginx-smart image: nginx:1.15-alpine imagePullPolicy: IfNotPresent ports: - containerPort: 80 4.1.2.2 通过资源清单文件创建headless Service link 编写YAML文件 命令 [root@master ~]# vim 04_headless-service.yml apiVersion: v1 kind: Service metadata: name: headless-service namespace: default spec: type: ClusterIP # ClusterIP类型,也是默认类型 clusterIP: None # None就代表是无头service ports: # 指定service 端口及容器端口 - port: 80 # service ip中的端口 protocol: TCP targetPort: 80 # pod中的端口 selector: # 指定后端pod标签 app: nginx # 可通过kubectl get pod -l app=nginx查看哪些pod在使用此标签 4.1.2.3 应用资源清单文件创建headless Service link 命令 [root@master ~]# kubectl apply -f 04_headless_service.yml 输出 service/headless-service created 4.1.2.4 查看已创建的headless Service link 命令 [root@master ~]# kubectl get svc 输出 NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE headless-service ClusterIP None 80/TCP 2m18s kubernetes ClusterIP 10.96.0.1 443/TCP 5d9h 可以看到headless-service没有CLUSTER-IP,用None表示 4.1.2.5 DNS linkDNS服务监视Kubernetes API,为每一个Service创建DNS记录用于域名解析\nheadless service需要DNS来解决访问问题\nDNS记录格式为: ..svc.cluster.local.\n4.1.2.5.1 查看kube-dns服务的IP link 命令 [root@master1 ~]# kubectl get svc -n kube-system 输出 NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE kube-dns ClusterIP 10.96.0.2 53/UDP,53/TCP,9153/TCP 5d9h metrics-server ClusterIP 10.105.219.44 443/TCP 45h 查看到coreDNS的服务地址是10.96.0.2 4.1.2.5.2 在集群主机通过DNS服务地址查找无头服务的dns解析 link 命令 [root@master01 ~]# dig -t A headless-service.default.svc.cluster.local. @10.96.0.2 输出 ; \u003c\u003c\u003e\u003e DiG 9.11.4-P2-RedHat-9.11.4-16.P2.el7_8.2 \u003c\u003c\u003e\u003e -t A headless-service.default.svc.cluster.local. @10.96.0.2 ;; global options: +cmd ;; Got answer: ;; WARNING: .local is reserved for Multicast DNS ;; You are currently testing what happens when an mDNS query is leaked to DNS ;; -\u003e\u003eHEADER\u003c\u003c- opcode: QUERY, status: NOERROR, id: 31371 ;; flags: qr aa rd; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 1 ;; WARNING: recursion requested but not available ;; OPT PSEUDOSECTION: ; EDNS: version: 0, flags:; udp: 4096 ;; QUESTION SECTION: ;headless-service.default.svc.cluster.local. IN A #被解析域名 ;; ANSWER SECTION: headless-service.default.svc.cluster.local. 30 IN A 10.224.235.147 #注意这里IP ;; Query time: 0 msec ;; SERVER: 10.96.0.10#53(10.96.0.2) ;; WHEN: Sun May 17 10:58:50 CST 2020 ;; MSG SIZE rcvd: 129 4.1.2.5.3 验证pod的IP link 命令 [root@master ~]# kubectl get pod -o wide 输出 NAME READY STATUS RESTARTS AGE IP NODE NOMINATED NODE READINESS GATES nginx-deployment-56bf6c9c8c-jmk7r 1/1 Running 0 35m 10.224.235.147 worker1 4.1.2.5.4 在集群中创建一个pod验证 link 创建一个镜像为busyboxplus:curl的pod，pod名称为bb2,用来解析域名\n命令 [root@master01 ~]# kubectl run bbp --image=busyboxplus:curl -it 或 [root@master01 ~]# kubectl run bbp --image=1.28 -it 输出 If you don't see a command prompt, try pressing enter. 解析域名 nslookup headless-service.default.svc.cluster.local. 访问命令 [ root@bbp:/ ]$ curl http://headless-service.default.svc.cluster.local. 输出 \u003c!DOCTYPE html\u003e Welcome to nginx! Welcome to nginx! If you see this page, the nginx web server is successfully installed and working. Further configuration is required.\nFor online documentation and support please refer to nginx.org. Commercial support is available at nginx.com.\nThank you for using nginx.\n[ root@bbp:/ ]$ exit Session ended, resume using 'kubectl attach bbp -c bbp -i -t' command when the pod is running 4.2 NodePort类型 link 创建资源清单文件 [root@master01 ~]# cat 05_create_nodeport_service_app.yaml apiVersion: apps/v1 kind: Deployment metadata: name: nginx-app labels: app: nginx-app spec: replicas: 2 selector: matchLabels: app: nginx-app template: metadata: labels: app: nginx-app spec: containers: - name: c1 image: nginx:1.15-alpine imagePullPolicy: IfNotPresent ports: - containerPort: 80 --- apiVersion: v1 kind: Service metadata: name: nginx-app spec: type: NodePort selector: app: nginx-app ports: - protocol: TCP nodePort: 30001 port: 8060 targetPort: 80 应用资源清单文件 [root@master01 ~]# kubectl apply -f 05_create_nodeport_service_app.yaml deployment.apps/nginx-app created service/nginx-app created 验证service创建 [root@master01 ~]# kubectl get deployment.apps NAME READY UP-TO-DATE AVAILABLE AGE nginx-app 2/2 2 2 26s [root@master01 ~]# kubectl get svc NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE kubernetes ClusterIP 10.96.0.1 443/TCP 2d22h nginx-app NodePort 10.104.157.20 8060:30001/TCP 36s [root@master01 ~]# kubectl get endpoints NAME ENDPOINTS AGE kubernetes 192.168.122.10:6443 2d22h nginx-app 172.16.1.24:80,172.16.2.20:80 2m10s [root@master01 ~]# ss -anput | grep \":30001\" tcp LISTEN 0 128 :::30001 :::* users:((\"kube-proxy\",pid=5826,fd=9)) [root@worker01 ~]# ss -anput | grep \":30001\" tcp LISTEN 0 128 :::30001 :::* users:((\"kube-proxy\",pid=4937,fd=11)) [root@worker02 ~]# ss -anput | grep \":30001\" tcp LISTEN 0 128 :::30001 :::* users:((\"kube-proxy\",pid=5253,fd=11)) [root@master01 ~]# kubectl get pods NAME READY STATUS RESTARTS AGE nginx-app-ffd5ccc78-cnwbx 1/1 Running 0 8m59s nginx-app-ffd5ccc78-mz77g 1/1 Running 0 8m59s [root@master01 ~]# kubectl exec -it nginx-app-ffd5ccc78-cnwbx -- bash root@nginx-app-ffd5ccc78-cnwbx:/# echo \"nginx-app-1\" \u003e /usr/share/nginx/html/index.html root@nginx-app-ffd5ccc78-cnwbx:/# exit exit [root@master01 ~]# kubectl exec -it nginx-app-ffd5ccc78-mz77g -- bash root@nginx-app-ffd5ccc78-mz77g:/# echo \"nginx-app-2\" \u003e /usr/share/nginx/html/index.html root@nginx-app-ffd5ccc78-mz77g:/# exit exit 在与kubernetes 节点同一网络主机中访问k8s集群内service [root@bogon ~]# curl http://192.168.10.12:30001 nginx-app-2 [root@bogon ~]# curl http://192.168.10.13:30001 nginx-app-1 [root@bogon ~]# curl http://192.168.10.14:30001 nginx-app-1 [root@bogon ~]# curl http://192.168.10.15:30001 nginx-app-2 4.3 LoadBalancer link4.3.1 集群外访问过程 link 用户 link 域名 link 云服务提供商提供LB服务 link NodeIP:Port(service IP) link Pod IP：端口 link 4.3.2 自建Kubernetes的LoadBalancer类型服务方案-MetalLB linkMetalLB可以为kubernetes集群中的Service提供网络负载均衡功能。\nMetalLB两大功能为:\n地址分配，类似于DHCP 外部通告，一旦MetalLB为服务分配了外部IP地址，它就需要使群集之外的网络意识到该IP在群集中“存在”。MetalLB使用标准路由协议来实现此目的：ARP，NDP或BGP。 4.3.2.1 参考资料 link参考网址： https://metallb.universe.tf/installation/\n4.3.2.2 应用资源清单文件 link 资源清单文件下载： # kubectl apply -f https://raw.githubusercontent.com/metallb/metallb/v0.12.1/manifests/namespace.yaml # kubectl apply -f https://raw.githubusercontent.com/metallb/metallb/v0.12.1/manifests/metallb.yaml 4.3.2.3 准备metallb配置文件 link [root@nginx metallb]# cat metallb-conf.yaml apiVersion: v1 kind: ConfigMap metadata: namespace: metallb-system name: config data: config: | address-pools: - name: default protocol: layer2 addresses: - 192.168.10.90-192.168.10.100 192.168.10.90-192.168.10.100是集群节点服务器IP同一段。 在master01节点应用资源清单文件 [root@master01 ~]# kubectl apply -f metallb-conf.yaml\t验证配置 # kubectl describe configmap config -n metallb-system Name: config Namespace: metallb-system Labels: Annotations: Data ==== config: ---- address-pools: - name: default protocol: layer2 addresses: - 192.168.10.90-192.168.10.100 Events: 4.3.2.4发布Service类型为LoadBalancer的Deployment控制器类型应用 link 创建Deployment控制器类型应用nginx-metallb及service，service类型为LoadBalancer [root@master01 ~]# vim 02_nginx-metabllb.yaml apiVersion: apps/v1 kind: Deployment metadata: name: nginx-metallb spec: selector: matchLabels: app: nginx template: metadata: labels: app: nginx spec: containers: - name: nginx-metallb1 image: nginx:1.15-alpine imagePullPolicy: IfNotPresent ports: - containerPort: 80 --- apiVersion: v1 kind: Service metadata: name: nginx-metallb spec: ports: - port: 8090 protocol: TCP targetPort: 80 selector: app: nginx type: LoadBalancer [root@master01 ~]# kubectl apply -f nginx.yaml 4.3.2.5 验证 link [root@master01 ~]# kubectl get ns NAME STATUS AGE default Active 16d kube-node-lease Active 16d kube-public Active 16d kube-system Active 16d kubernetes-dashboard Active 13d metallb-system Active 130m test1 Active 12d [root@master01 ~]# kubectl get pods -n metallb-system NAME READY STATUS RESTARTS AGE controller-64f8f944d-qdf8m 1/1 Running 0 110m speaker-cwzq7 1/1 Running 0 110m speaker-qk5fb 1/1 Running 0 110m speaker-wsllb 1/1 Running 0 110m speaker-x4bwt 1/1 Running 0 110m [root@master01 ~]# kubectl get svc NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE kubernetes ClusterIP 10.96.0.1 443/TCP 16d nginx-metallb LoadBalancer 10.105.239.69 192.168.10.90 8090:31372/TCP 106m [root@master01 ~]# ping 192.168.10.90 PING 192.168.10.90 (192.168.10.90) 56(84) bytes of data. 64 bytes from 192.168.10.90: icmp_seq=1 ttl=64 time=3.45 ms 64 bytes from 192.168.10.90: icmp_seq=2 ttl=64 time=0.040 ms 4.3.2.6 访问 link [root@master01 ~]# curl http://192.168.122.90:8090 \u003c!DOCTYPE html\u003e Welcome to nginx! Welcome to nginx! If you see this page, the nginx web server is successfully installed and working. Further configuration is required.\nFor online documentation and support please refer to nginx.org. Commercial support is available at nginx.com.\nThank you for using nginx.\n注意：使用kubeadm部署kubernetes集群修改方法\n如果在IPVS模式下使用kube-proxy，从Kubernetes v1.14.2开始，必须启用ARP模式。 可以通过在当前集群中编辑kube-proxy配置来实现： # kubectl edit configmap -n kube-system kube-proxy 并设置： apiVersion: kubeproxy.config.k8s.io/v1alpha1 kind: KubeProxyConfiguration mode: \"ipvs\" ipvs: strictARP: true 4.4 ExternalName link4.4.1 ExternalName作用 link 把集群外部的服务引入到集群内部中来，实现了集群内部pod和集群外部的服务进行通信 ExternalName 类型的服务适用于外部服务使用域名的方式，缺点是不能指定端口 还有一点要注意: 集群内的Pod会继承Node上的DNS解析规则。所以只要Node可以访问的服务，Pod中也可以访问到, 这就实现了集群内服务访问集群外服务 4.4.2 将公网域名引入 link1, 编写YAML文件\n[root@master01 ~]# vim externelname.yml apiVersion: v1 kind: Service metadata: name: my-externalname namespace: default spec: type: ExternalName externalName: www.baidu.com # 对应的外部域名为www.baidu.com 2, 应用YAML文件\n[root@master01 ~]# kubectl apply -f externelname.yml service/my-externalname created 3, 查看service\n[root@master01 ~]# kubectl get svc |grep exter my-externalname ExternalName www.baidu.com 69s 4, 查看my-service的dns解析\n[root@master01 ~]# dig -t A my-externalname.default.svc.cluster.local. @10.96.0.2 ; \u003c\u003c\u003e\u003e DiG 9.9.4-RedHat-9.9.4-72.el7 \u003c\u003c\u003e\u003e -t A my-externalname.default.svc.cluster.local. @10.2.0.2 ;; global options: +cmd ;; Got answer: ;; -\u003e\u003eHEADER\u003c\u003c- opcode: QUERY, status: NOERROR, id: 31378 ;; flags: qr aa rd; QUERY: 1, ANSWER: 4, AUTHORITY: 0, ADDITIONAL: 1 ;; WARNING: recursion requested but not available ;; OPT PSEUDOSECTION: ; EDNS: version: 0, flags:; udp: 4096 ;; QUESTION SECTION: ;my-externalname.default.svc.cluster.local. IN A ;; ANSWER SECTION: my-externalname.default.svc.cluster.local. 5 IN CNAME www.baidu.com. www.baidu.com. 5 IN CNAME www.a.shifen.com. www.a.shifen.com. 5 IN A 14.215.177.38 解析的是百度的IP www.a.shifen.com. 5 IN A 14.215.177.39 解析的是百度的IP ;; Query time: 32 msec ;; SERVER: 10.2.0.2#53(10.96.0.2) ;; WHEN: Thu Nov 05 11:23:41 CST 2020 ;; MSG SIZE rcvd: 245 [root@master01 ~]# kubectl exec -it deploy-nginx-6c9764bb69-86gwj -- /bin/sh / # nslookup www.baidu.com ...... Name: www.baidu.com Address 1: 14.215.177.39 Address 2: 14.215.177.38 / # nslookup my-externalname.default.svc.cluster.local ...... Name: my-externalname.default.svc.cluster.local Address 1: 14.215.177.38 Address 2: 14.215.177.39 解析此my-externalname.default.svc.cluster.local域名和解析www.baidu.com是一样的结果\n4.4.3 不同命名空间访问 link1， 创建ns1命名空间和相关deploy, pod,service\n[root@master01 ~]# vim ns1-nginx.yml apiVersion: v1 kind: Namespace metadata: name: ns1 # 创建ns1命名空间 --- apiVersion: apps/v1 kind: Deployment metadata: name: deploy-nginx namespace: ns1 # 属于ns1命名空间 spec: replicas: 1 selector: matchLabels: app: nginx template: metadata: labels: app: nginx spec: containers: - name: nginx image: nginx:1.15-alpine imagePullPolicy: IfNotPresent ports: - containerPort: 80 --- apiVersion: v1 kind: Service metadata: name: svc1 # 服务名 namespace: ns1 # 属于ns1命名空间 spec: selector: app: nginx clusterIP: None # 无头service ports: - port: 80 targetPort: 80 --- kind: Service apiVersion: v1 metadata: name: external-svc1 namespace: ns1 # 属于ns1命名空间 spec: type: ExternalName externalName: svc2.ns2.svc.cluster.local # 将ns2空间的svc2服务引入到ns1命名空间 [root@master1 ~]# kubectl apply -f ns1-nginx.yml namespace/ns1 created deployment.apps/deploy-nginx created service/svc1 created 2， 创建ns2命名空间和相关deploy, pod,service\n[root@master01 ~]# vim ns1-nginx.yml apiVersion: v1 kind: Namespace metadata: name: ns2 # 创建ns2命名空间 --- apiVersion: apps/v1 kind: Deployment metadata: name: deploy-nginx namespace: ns2 # 属于ns2命名空间 spec: replicas: 1 selector: matchLabels: app: nginx template: metadata: labels: app: nginx spec: containers: - name: nginx image: nginx:1.15-alpine imagePullPolicy: IfNotPresent ports: - containerPort: 80 --- apiVersion: v1 kind: Service metadata: name: svc2 # 服务名 namespace: ns2 # 属于ns2命名空间 spec: selector: app: nginx clusterIP: None # 无头service ports: - port: 80 targetPort: 80 --- kind: Service apiVersion: v1 metadata: name: external-svc1 namespace: ns2 # 属于ns2命名空间 spec: type: ExternalName externalName: svc1.ns1.svc.cluster.local # 将ns1空间的svc1服务引入到ns2命名空间 [root@master01 ~]# kubectl apply -f ns2-nginx.yml namespace/ns2 created deployment.apps/deploy-nginx created service/svc2 created service/external-svc2 created 3, 在ns1命名空间的pod里验证\n[root@master01 ~]# kubectl get pods -n ns1 NAME READY STATUS RESTARTS AGE deploy-nginx-6c9764bb69-g5xl8 1/1 Running 0 8m10s [root@master01 ~]# kubectl exec -it -n ns1 deploy-nginx-6c9764bb69-g5xl8 -- /bin/sh / # nslookup svc1 ...... Name: svc1 Address 1: 10.3.166.140 deploy-nginx-6c9764bb69-g5xl8 IP与ns1里的podIP一致(见下面的查询结果) / # nslookup svc2.ns2.svc.cluster.local ..... Name: svc2.ns2.svc.cluster.local Address 1: 10.3.104.17 10-3-104-17.svc2.ns2.svc.cluster.local IP与ns2里的podIP一致(见下面的查询结果) / # exit [root@master01 ~]# kubectl get pods -o wide -n ns1 NAME READY STATUS RESTARTS AGE IP NODE NOMINATED NODE READINESS GATES deploy-nginx-6c9764bb69-g5xl8 1/1 Running 0 70m 10.3.166.140 192.168.122.13 [root@master01 ~]# kubectl get pods -o wide -n ns2 NAME READY STATUS RESTARTS AGE IP NODE NOMINATED NODE READI NESS GATES deploy-nginx-6c9764bb69-8psxl 1/1 Running 0 68m 10.3.104.17 192.168.122.14 反之，在ns2命名空间的pod里访问svc1.ns1.svc.cluster.local，解析的IP是ns1命名空间里的pod的IP(请自行验证)\n4， 验证ns2中的pod的IP变化, ns1中的pod仍然可以使用svc2.ns2.svc.cluster.local访问\n[root@master01 ~]# kubectl get pod -n ns2 NAME READY STATUS RESTARTS AGE deploy-nginx-6c9764bb69-8psxl 1/1 Running 0 81m [root@master01 ~]# kubectl delete pod deploy-nginx-6c9764bb69-8psxl -n ns2 pod \"deploy-nginx-6c9764bb69-8psxl\" deleted 因为有replicas控制器，所以删除pod会自动拉一个起来 [root@master01 ~]# kubectl get pod -o wide -n ns2 NAME READY STATUS RESTARTS AGE IP NODE NOMINATED NODE READINESS GATES deploy-nginx-6c9764bb69-8qbz2 1/1 Running 0 5m36s 10.3.166.141 192.168.122.13 pod名称变了,IP也变成了10.3.166.141 回到ns1中的pod验证\n[root@master01 ~]# kubectl exec -it -n ns1 deploy-nginx-6c9764bb69-g5xl8 -- /bin/sh / # ping svc2.ns2.svc.cluster.local -c 2 PING svc2.ns2.svc.cluster.local (10.3.166.141): 56 data bytes 解析的IP就是ns2中pod的新IP 64 bytes from 10.3.166.141: seq=0 ttl=63 time=0.181 ms 64 bytes from 10.3.166.141: seq=1 ttl=63 time=0.186 ms --- svc2.ns2.svc.cluster.local ping statistics --- 2 packets transmitted, 2 packets received, 0% packet loss round-trip min/avg/max = 0.181/0.183/0.186 ms / # exit 5. sessionAffinity link 会话粘贴\n设置sessionAffinity为Clientip (类似nginx的ip_hash算法,lvs的sh算法)\n[root@nginx ~]# cat 02_create_deployment_app_nginx_with_service.yaml apiVersion: apps/v1 kind: Deployment metadata: name: nginx-server1 spec: replicas: 2 selector: matchLabels: app: nginx template: metadata: labels: app: nginx spec: containers: - name: c1 image: nginx:1.15-alpine imagePullPolicy: IfNotPresent ports: - containerPort: 80 --- apiVersion: v1 kind: Service metadata: name: nginx-svc spec: type: ClusterIP ports: - protocol: TCP port: 80 targetPort: 80 selector: app: nginx [root@master01 ~]# kubectl apply -f 02_create_deployment_app_nginx_with_service.yaml deployment.apps/nginx-server1 created service/nginx-svc created [root@master01 ~]# kubectl get pods NAME READY STATUS RESTARTS AGE nginx-server1-58845f75f4-9zlnw 1/1 Running 0 2m11s nginx-server1-58845f75f4-ffqdt 1/1 Running 0 2m11s [root@master01 ~]# kubectl exec -it nginx-server1-58845f75f4-9zlnw bash kubectl exec [POD] [COMMAND] is DEPRECATED and will be removed in a future version. Use kubectl kubectl exec [POD] -- [COMMAND] instead. root@nginx-server1-58845f75f4-9zlnw:/# echo web1 \u003e /usr/share/nginx/html/index.html root@nginx-server1-58845f75f4-9zlnw:/# exit exit [root@master01 ~]# kubectl exec -it nginx-server1-58845f75f4-ffqdt bash kubectl exec [POD] [COMMAND] is DEPRECATED and will be removed in a future version. Use kubectl kubectl exec [POD] -- [COMMAND] instead. root@nginx-server1-58845f75f4-ffqdt:/# echo web2 \u003e /usr/share/nginx/html/index.html root@nginx-server1-58845f75f4-ffqdt:/# exit exit [root@master01 ~]# kubectl get svc NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE kubernetes ClusterIP 10.96.0.1 443/TCP 16d nginx-svc ClusterIP 10.100.53.31 80/TCP 3m53s [root@master01 ~]# curl http://10.100.53.31 web1 [root@master01 ~]# curl http://10.100.53.31 web2 或 [root@master01 ~]# while true;do curl 10.100.53.31;sleep 1; done [root@master01 ~]# kubectl patch svc nginx-svc -p '{\"spec\":{\"sessionAffinity\":\"ClientIP\"}}' service/nginx-svc patched [root@master01 ~]# curl 10.100.53.31 web1 多次访问,会话粘贴 设置回sessionAffinity为None [root@master01 ~]# kubectl patch svc nginx-svc -p '{\"spec\":{\"sessionAffinity\":\"None\"}}' service/my-service patched 测试 [root@master01 ~]# curl 10.100.53.31 web1 多次访问,回到负载均衡 或 [root@master01 ~]# while true;do curl 10.100.53.31;sleep 1; done web1 多次访问,会话粘贴 6. 修改为ipvs调度方式（拓展） link 部署方式不同，修改方法不一样。\n本次主要介绍使用kubeadm部署集群方式，二进制部署较为简单。\n二进制部署修改：/etc/kubernetes/kube-proxy.yaml文件即可。\n从kubernetes1.8版本开始，新增了kube-proxy对ipvs的支持，在kubernetes1.11版本中被纳入了GA.\n6.1 修改为IPVS调度方式前升级内核 link 现使用Centos7u6发布版本，默认内核版本为3.10.0，使用kubernetes为1.18.0时，可升级内核版本至4.18.0或5.6.0版本。\n在所有节点中安装,需要重启操作系统更换内核。以下升级方法供参考。\n[root@localhost ~]# yum -y install perl [root@localhost ~]# rpm --import https://www.elrepo.org/RPM-GPG-KEY-elrepo.org [root@localhost ~]# yum -y install https://www.elrepo.org/elrepo-release-7.0-4.el7.elrepo.noarch.rpm [root@localhost ~]# yum --enablerepo=\"elrepo-kernel\" -y install kernel-ml.x86_64 此处升级为5.0以上版本。 [root@localhost ~]# grub2-set-default 0 [root@localhost ~]# grub2-mkconfig -o /boot/grub2/grub.cfg [root@localhost ~]# reboot 6.2 修改kube-proxy的配置文件 link [root@master01 ~]# kubectl edit configmap kube-proxy -n kube-system 26 iptables: 27 masqueradeAll: false 28 masqueradeBit: 14 29 minSyncPeriod: 0s 30 syncPeriod: 30s 31 ipvs: 32 excludeCIDRs: null 33 minSyncPeriod: 0s 34 scheduler: \"\"\t# 可以在这里修改ipvs的算法,默认为rr轮循算法 35 strictARP: false 36 syncPeriod: 30s 37 kind: KubeProxyConfiguration 38 metricsBindAddress: 127.0.0.1:10249 39 mode: \"ipvs\"\t# 默认\"\"号里为空,加上ipvs 6.3 查看kube-system的namespace中kube-proxy有关的pod link [root@master01 ~]# kubectl get pods -n kube-system |grep kube-proxy kube-proxy-69mv6 1/1 Running 6 2d18h kube-proxy-jpc6c 1/1 Running 4 4d16h kube-proxy-kq65l 1/1 Running 4 4d16h kube-proxy-lmphf 1/1 Running 5 4d16h 6.4 验证kube-proxy-xxx的pod中的信息 link [root@master01 ~]# kubectl logs kube-proxy-jpc6c -n kube-system W0517 00:55:10.914754 1 server_others.go:559] Unknown proxy mode \"\", assuming iptables proxy I0517 00:55:10.923228 1 node.go:136] Successfully retrieved node IP: 192.168.122.32 I0517 00:55:10.923264 1 server_others.go:186] Using iptables Proxier. I0517 00:55:10.923567 1 server.go:583] Version: v1.18.2 I0517 00:55:10.923965 1 conntrack.go:100] Set sysctl 'net/netfilter/nf_conntrack_max' to 131072 I0517 00:55:10.924001 1 conntrack.go:52] Setting nf_conntrack_max to 131072 I0517 00:55:10.924258 1 conntrack.go:83] Setting conntrack hashsize to 32768 I0517 00:55:10.927041 1 conntrack.go:100] Set sysctl 'net/netfilter/nf_conntrack_tcp_timeout_established' to 86400 I0517 00:55:10.927086 1 conntrack.go:100] Set sysctl 'net/netfilter/nf_conntrack_tcp_timeout_close_wait' to 3600 I0517 00:55:10.927540 1 config.go:315] Starting service config controller I0517 00:55:10.927556 1 shared_informer.go:223] Waiting for caches to sync for service config I0517 00:55:10.927576 1 config.go:133] Starting endpoints config controller I0517 00:55:10.927594 1 shared_informer.go:223] Waiting for caches to sync for endpoints config I0517 00:55:11.027749 1 shared_informer.go:230] Caches are synced for service config I0517 00:55:11.027858 1 shared_informer.go:230] Caches are synced for endpoints config 6.5 删除kube-proxy-xxx的所有pod，让它重新拉取新的kube-proxy-xxx的pod link [root@master01 ~]# kubectl delete pod kube-proxy-69mv6 -n kube-system pod \"kube-proxy-69mv6\" deleted [root@master01 ~]# kubectl delete pod kube-proxy-jpc6c -n kube-system pod \"kube-proxy-jpc6c\" deleted [root@master01 ~]# kubectl delete pod kube-proxy-kq65l -n kube-system pod \"kube-proxy-kq65l\" deleted [root@master01 ~]# kubectl delete pod kube-proxy-lmphf -n kube-system pod \"kube-proxy-lmphf\" deleted [root@master01 ~]# kubectl get pods -n kube-system |grep kube-proxy kube-proxy-2mk2b 1/1 Running 0 2m23s kube-proxy-5bj87 1/1 Running 0 30s kube-proxy-7qq9l 1/1 Running 0 52s kube-proxy-tjtqf 1/1 Running 0 80s 随意查看其中1个或3个kube-proxy-xxx的pod,验证是否为IPVS方式了 [root@master1 ~]# kubectl logs kube-proxy-tjtqf -n kube-system I0517 02:32:26.557696 1 node.go:136] Successfully retrieved node IP: 192.168.122.32 I0517 02:32:26.557745 1 server_others.go:259] Using ipvs Proxier. W0517 02:32:26.557912 1 proxier.go:429] IPVS scheduler not specified, use rr by default I0517 02:32:26.560008 1 server.go:583] Version: v1.18.2 I0517 02:32:26.560428 1 conntrack.go:52] Setting nf_conntrack_max to 131072 I0517 02:32:26.561094 1 config.go:315] Starting service config controller I0517 02:32:26.562251 1 shared_informer.go:223] Waiting for caches to sync for service config I0517 02:32:26.561579 1 config.go:133] Starting endpoints config controller I0517 02:32:26.562271 1 shared_informer.go:223] Waiting for caches to sync for endpoints config I0517 02:32:26.662541 1 shared_informer.go:230] Caches are synced for service config I0517 02:32:26.662566 1 shared_informer.go:230] Caches are synced for endpoints config "
            }
        );
    index.add(
            {
                id:  59 ,
                href: "\/docs\/ops\/container\/1.%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF%E6%89%80%E6%B6%89%E5%8F%8A%E7%9A%84linux%E5%86%85%E6%A0%B8%E5%85%B3%E9%94%AE%E6%8A%80%E6%9C%AF\/",
                title: "1.容器技术所涉及的Linux内核关键技术",
                description: "容器的前世今生",
                content: "1. 容器技术前世今生 link1.1 1979年 — chroot link 容器技术的概念可以追溯到1979年的UNIX chroot。 它是一套“UNIX操作系统”系统，旨在将其root目录及其它子目录变更至文件系统内的新位置，且只接受特定进程的访问。 这项功能的设计目的在于为每个进程提供一套隔离化磁盘空间。 1982年其被添加至BSD当中。 1.2 2000年 — FreeBSD Jails link FreeBSD Jails是由Derrick T. Woolworth于2000年在FreeBSD研发协会中构建而成的早期容器技术之一。 这是一套“操作系统”系统，与chroot的定位类似，不过其中包含有其它进程沙箱机制以对文件系统、用户及网络等资源进行隔离。 通过这种方式，它能够为每个Jail、定制化软件安装包乃至配置方案等提供一个对应的IP地址。 1.3 2001年 — Linux VServer link Linux VServer属于另一种jail机制，其能够被用于保护计算机系统之上各分区资源的安全(包括文件系统、CPU时间、网络地址以及内存等)。 每个分区被称为一套安全背景(security context)，而其中的虚拟化系统则被称为一套虚拟私有服务器。 1.4 2004年 — Solaris容器 link Solaris容器诞生之时面向x86与SPARC系统架构，其最初亮相于2004年2月的Solaris 10 Build 51 beta当中，随后于2005年正式登陆Solaris 10的完整版本。 Solaris容器相当于将系统资源控制与由分区提供的边界加以结合。各分区立足于单一操作系统实例之内以完全隔离的虚拟服务器形式运行。 1.5 2005年 — OpenVZ link OpenVZ与Solaris容器非常相似，且使用安装有补丁的Linux内核以实现虚拟化、隔离能力、资源管理以及检查点交付。 每套OpenVZ容器拥有一套隔离化文件系统、用户与用户群组、一套进程树、网络、设备以及IPC对象。 1.6 2006年 — Process容器 link Process容器于2006年由谷歌公司推出，旨在对一整套进程集合中的资源使用量(包括CPU、内存、磁盘I/O以及网络等等)加以限制、分配与隔离。 此后其被更名为Control Groups(即控制组)，从而避免其中的“容器”字眼与Linux内核2.6.24中的另一术语出现冲突。这表明了谷歌公司率先重视容器技术的敏锐眼光以及为其做出的突出贡献。 1.7 2007年 — Control Groups linkControl Groups也就是谷歌实现的cgroups，其于2007年被添加至Linux内核当中。\n1.8 2008年 — LXC link LXC指代的是Linux Containers 是第一套完整的Linux容器管理实现方案。 其功能通过cgroups以及Linux namespaces实现。 LXC通过liblxc库进行交付，并提供可与Python3、Python2、Lua、Go、Ruby以及Haskell等语言相对接的API。 相较于其它容器技术，LXC能够在无需任何额外补丁的前提下运行在原版Linux内核之上。 1.9 2011年 — Warden link Warden由CloudFoundry公司于2011年所建立，其利用LXC作为初始阶段，随后又将其替换为自家实现方案。 与LXC不同，Warden并不会与Linux紧密耦合。相反，其能够运行在任意能够提供多种隔离环境方式的操作系统之上。Warden以后台进程方式运行并提供API以实现容器管理。 1.10 2013年 — LMCTFY link Lmctfy代表的是“Let Me Contain That For You(帮你实现容器化)”。它其实属于谷歌容器技术堆栈的开源版本，负责提供Linux应用程序容器。谷歌公司在该项目的起步阶段宣称其能够提供值得信赖的性能表现、高资源利用率、共享资源机制、充裕的发展空间以及趋近于零的额外资源消耗。 2013年10月lmctfy的首个版本正式推出，谷歌公司在2015年决定将lmctfy的核心概念与抽象机制转化为libcontainer。在失去了主干之后，如今lmctfy已经失去一切积极的发展势头。 Libcontainer项目最初由Docker公司建立，如今已经被归入开放容器基金会的管辖范畴。\n1.11 2013年-Docker link 在2013年Docker刚发布的时候，它是一款基于LXC的开源容器管理引擎。 把LXC复杂的容器创建与使用方式简化为Docker自己的一套命令体系。 随着Docker的不断发展，它开始有了更为远大的目标，那就是反向定义容器的实现标准，将底层实现都抽象化到Libcontainer的接口。这就意味着，底层容器的实现方式变成了一种可变的方案，无论是使用namespace、cgroups技术抑或是使用systemd等其他方案，只要实现了Libcontainer定义的一组接口，Docker都可以运行。这也为Docker实现全面的跨平台带来了可能。 2. NameSpace link2.1 NameSpace介绍 link 很多编程语言都包含了命名空间的概念，我们可以认为命名空间是一种封装，封装本身实际上实现了代码的隔离\n在操作系统中命名空间命名空间提供的是系统资源的隔离，其中系统资源包括了：进程、网络、文件系统……\n实际上linux系统实现命名空间主要目的之一就是为了实现轻量级虚拟化服务，也就是我们说的容器，在同一个命名空间下的进程可以感知彼此的变化，而对其他命名空间的进程一无所知，这样就可以让容器中的进程产生一个错觉，仿佛它自己置身于一个独立的系统环境当中，以此达到独立和隔离的目的。\n2.2 Linux系统中NameSpace分类 link 命名空间 描述 作用 备注 进程命名空间 隔离进程ID Linux通过命名空间管理进程号，同一个进程，在不同的命名空间进程号不同 进程命名空间是一个父子结构，子空间对于父空间可见 网络命名空间 隔离网络设备、协议栈、端口等 通过网络命名空间，实现网络隔离 docker采用虚拟网络设备，将不同命名空间的网络设备连接到一起 IPC命名空间 隔离进程间通信 进程间交互方法 PID命名空间和IPC命名空间可以组合起来用，同一个IPC名字空间内的进程可以彼此看见，允许进行交互，不同空间进程无法交互 挂载命名空间 隔离挂载点 隔离文件目录 进程运行时可以将挂载点与系统分离，使用这个功能时，我们可以达到 chroot 的功能，而在安全性方面比 chroot 更高 UTS命名空间 隔离Hostname和NIS域名 让容器拥有独立的主机名和域名，从而让容器看起来像个独立的主机 目的是独立出主机名和网络信息服务（NIS） 用户命名空间 隔离用户和group ID 每个容器内上的用户跟宿主主机上不在一个命名空间 同进程 ID 一样，用户 ID 和组 ID 在命名空间内外是不一样的，并且在不同命名空间内可以存在相同的 ID 2.3 NameSpace应用案例 link 以net namespace为例\n在 Linux 中，网络命名空间可以被认为是隔离的拥有单独网络栈（网卡、路由转发表、iptables）的环境。网络命名空间经常用来隔离网络设备和服务，只有拥有同样网络命名空间的设备，才能看到彼此。 从逻辑上说，网络命名空间是网络栈的副本，拥有自己的网络设备、路由选择表、邻接表、Netfilter表、网络套接字、网络procfs条目、网络sysfs条目和其他网络资源。 从系统的角度来看，当通过clone()系统调用创建新进程时，传递标志CLONE_NEWNET将在新进程中创建一个全新的网络命名空间。 从用户的角度来看，我们只需使用工具ip（package is iproute2）来创建一个新的持久网络命名空间。 2.3.1 创建net命名空间 link 创建名称为msb的网络命名空间 # ip netns add msb 查看已创建的网络命名空间 # ip netns ls msb 2.3.2 删除net命名空间 link 删除已创建的网络命名空间 # ip netns delete msb 2.3.3 在net命名空间中执行命令 link 在网络命名空间中执行bash命令，如果想退出，需要使用exit # ip netns exec msb bash 2.3.4 在net命令空间中执行查看网络连接(网卡)命令 link 在网络命名空间中查看网络命名空间中的网卡信息 # ip link 1: lo: mtu 65536 qdisc noop state DOWN mode DEFAULT group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 在Linux主机系统中查看 # ip netns exec msb ip link list 1: lo: mtu 65536 qdisc noop state DOWN mode DEFAULT group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 2.3.5 退出当前的net命名空间 link 退出已进入的网络命名空间 # exit exit 2.3.6 在net命名空间中执行多条命令 link 在网络命名空间中查看路由表 # route -n Kernel IP routing table Destination Gateway Genmask Flags Metric Ref Use Iface 在网络命名空间中查看防火墙规则 # iptables -t nat -nL Chain PREROUTING (policy ACCEPT) target prot opt source destination Chain INPUT (policy ACCEPT) target prot opt source destination Chain OUTPUT (policy ACCEPT) target prot opt source destination Chain POSTROUTING (policy ACCEPT) target prot opt source destination 2.3.7 创建虚拟网卡 link 同时创建一对虚拟网卡\n创建虚拟网卡对 # ip link add veth0 type veth peer name veth1 在物理机上查看 # ip a s ...... 10: veth1@veth0: mtu 1500 qdisc noop state DOWN group default qlen 1000 link/ether de:44:f8:b7:12:65 brd ff:ff:ff:ff:ff:ff 11: veth0@veth1: mtu 1500 qdisc noop state DOWN group default qlen 1000 link/ether 46:5e:89:8c:cb:b3 brd ff:ff:ff:ff:ff:ff 2.3.8 迁移虚拟网卡到命名空间中 link 这两个网卡还都属于“default”或“global”命名空间，和物理网卡一样。把其中一个网卡转移到命名空间msb中。\n把创建的veth1网卡添加到msb网络命名空间中 # ip link set veth1 netns msb 在Linux系统命令行查看网络命名空间中的网络 # ip netns exec msb ip link 1: lo: mtu 65536 qdisc noop state DOWN mode DEFAULT group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 10: veth1@if11: mtu 1500 qdisc noop state DOWN mode DEFAULT group default qlen 1000 link/ether de:44:f8:b7:12:65 brd ff:ff:ff:ff:ff:ff link-netnsid 0 2.3.9 命名空间中迁出虚拟网卡 link 在Linux系统命令行把虚拟网卡veth1从网络命名空间删除 # ip netns exec msb ip link delete veth1 在Linux系统命令行查看结果 # ip netns exec msb ip link 1: lo: mtu 65536 qdisc noop state DOWN mode DEFAULT group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 2.3.10 配置虚拟网卡IP地址 link 再次创建虚拟网卡，添加到msb网络命名空间，并设置IP地址 # ip link add veth0 type veth peer name veth1 # ip link set veth1 netns msb # ip netns exec msb ip addr add 192.168.50.2/24 dev veth1 在Linux系统命令行查看网络状态 # ip netns exec msb ip addr 1: lo: mtu 65536 qdisc noop state DOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 12: veth1@if13: mtu 1500 qdisc noop state DOWN group default qlen 1000 link/ether fe:20:ac:a8:13:4c brd ff:ff:ff:ff:ff:ff link-netnsid 0 inet 192.168.50.2/24 scope global veth1 valid_lft forever preferred_lft forever 启动虚拟网卡,veth1与lo全部要启动 # ip netns exec msb ip link set veth1 up # ip netns exec msb ip link set lo up 为物理机veth0添加IP地址 # ip a s ...... 15: veth0@if14: mtu 1500 qdisc noop state DOWN group defau lt qlen 1000 link/ether 2e:b4:40:c8:73:dc brd ff:ff:ff:ff:ff:ff link-netnsid 0 # ip addr add 192.168.50.3/24 dev veth0 # ip a s veth0 15: veth0@if14: mtu 1500 qdisc noop state DOWN group default qlen 1000 link/ether 2e:b4:40:c8:73:dc brd ff:ff:ff:ff:ff:ff link-netnsid 0 inet 192.168.50.3/24 scope global veth0 valid_lft forever preferred_lft forever # ip link set veth0 up 在宿主机上ping msb中的veth1 # ping 192.168.50.2 PING 192.168.50.2 (192.168.50.2) 56(84) bytes of data. 64 bytes from 192.168.50.2: icmp_seq=1 ttl=64 time=0.102 ms 64 bytes from 192.168.50.2: icmp_seq=2 ttl=64 time=0.068 ms 64 bytes from 192.168.50.2: icmp_seq=3 ttl=64 time=0.068 ms 在msb中的veth1 ping 宿主机上veth0 # ip netns exec msb ping 192.168.50.3 PING 192.168.50.3 (192.168.50.3) 56(84) bytes of data. 64 bytes from 192.168.50.3: icmp_seq=1 ttl=64 time=0.053 ms 64 bytes from 192.168.50.3: icmp_seq=2 ttl=64 time=0.031 ms 64 bytes from 192.168.50.3: icmp_seq=3 ttl=64 time=0.029 ms 如果需要访问本机的其它网段，可手动添加如下默认路由条目。 # ip netns exec msb ip route add default via 192.168.50.3 关于如何ping通外网主机，可设置路由转发完成。\n3. CGroups link3.1 CGroups介绍 link Control groups(cgroups) 控制组\nlinux内核提供的可以限制、记录、隔离进程组所使用的物理资源的机制。为容器而生，没有cgroups就没有今天的容器技术。\n3.2 CGroups功能 link 资源限制（Resource Limitation）：cgroups 可以对进程组使用的资源总额进行限制。如设定应用运行时使用内存的上限，一旦超过这个配额就发出 OOM（Out of Memory）。 优先级分配（Prioritization）：通过分配的 CPU 时间片数量及硬盘 IO 带宽大小，实际上就相当于控制了进程运行的优先级。 资源统计（Accounting）： cgroups 可以统计系统的资源使用量，如 CPU 使用时长、内存用量等等，这个功能非常适用于计费。 进程控制（Control）：cgroups 可以对进程组执行挂起、恢复等操作。 3.3 CGroups应用案例 link3.3.1 安装及开启服务 link [root@localhost ~]# yum -y install libcgroup [root@localhost ~]# systemctl start cgconfig.service [root@localhost ~]# systemctl enable cgconfig.service 3.3.2 限制进程使用CPU link3.3.2.1 查看cpu shares link 查看资源限制子系统 [root@localhost ~]# lssubsys cpuset cpu,cpuacct memory devices freezer net_cls,net_prio blkio perf_event hugetlb pids 查看子系统配置文件所在位置 [root@localhost ~]# ls /sys/fs/cgroup/ blkio cpuacct cpuset freezer memory net_cls,net_prio perf_event systemd cpu cpu,cpuacct devices hugetlb net_cls net_prio pids [root@localhost ~]# ls /sys/fs/cgroup/cpu cgroup.clone_children cpuacct.stat cpu.cfs_quota_us cpu.stat cgroup.event_control cpuacct.usage cpu.rt_period_us notify_on_release cgroup.procs cpuacct.usage_percpu cpu.rt_runtime_us release_agent cgroup.sane_behavior cpu.cfs_period_us cpu.shares tasks 查看CPU时间分片，用于保证分组所得到的CPU分片总量。 [root@localhost ~]# cat /sys/fs/cgroup/cpu/cpu.shares 1024 3.3.2.2 使用CPU子系统创建2个group分组 link [root@localhost ~]# vim /etc/cgconfig.conf group lesscpu { cpu{ cpu.shares=200; }\t} group morecpu { cpu{ cpu.shares=800; }\t} [root@localhost ~]# systemctl restart cgconfig 准备一个脚本\n#!/bin/bash a=1 while true do a=$[$a+1] done 将将要运行的应用程序分配到指定分组(请使用单CPU机器,三个终端验证)\n终端1# cgexec -g cpu:lesscpu sh /tmp/1.sh 终端2# cgexec -g cpu:morecpu sh /tmp/1.sh 终端3# top PS: 如果主机有多CPU，为了验证效果，可以进行如下操作\n# lscpu # echo 0 \u003e /sys/devices/system/cpu/cpu0/online # echo 1 \u003e /sys/devices/system/cpu/cpu1/online "
            }
        );
    index.add(
            {
                id:  60 ,
                href: "\/docs\/ops\/container\/containerd\/1.containerd%E8%BD%BB%E9%87%8F%E7%BA%A7or%E5%B7%A5%E4%B8%9A%E7%BA%A7%E7%9A%84%E5%AE%B9%E5%99%A8%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7\/",
                title: "1.Containerd轻量级or工业级的容器管理工具",
                description: "Containerd 是一个工业级标准的容器运行时，它强调简单性、健壮性和可移植性。",
                content: "1. Containerd介绍 link1.0 前言 link 早在2016年3月，Docker 1.11的Docker Engine里就包含了containerd，而现在则是把containerd从Docker Engine里彻底剥离出来，作为一个独立的开源项目独立发展，目标是提供一个更加开放、稳定的容器运行基础设施。和原先包含在Docker Engine里containerd相比，独立的containerd将具有更多的功能，可以涵盖整个容器运行时管理的所有需求。\ncontainerd并不是直接面向最终用户的，而是主要用于集成到更上层的系统里，比如Swarm, Kubernetes, Mesos等容器编排系统。\ncontainerd以Daemon的形式运行在系统上，通过暴露底层的gRPC API，上层系统可以通过这些API管理机器上的容器。\n每个containerd只负责一台机器，Pull镜像，对容器的操作（启动、停止等），网络，存储都是由containerd完成。具体运行容器由runC负责，实际上只要是符合OCI规范的容器都可以支持。\n对于容器编排服务来说，运行时只需要使用containerd+runC，更加轻量，容易管理。\n独立之后containerd的特性演进可以和Docker Engine分开，专注容器运行时管理，可以更稳定。\n1.1 Containerd前世今生 link2013年docker公司在推出docker产品后,由于其对全球技术产生了一定的影响力，Google公司明显感觉到自己公司内部所使用的Brog系统江湖地位受到的威胁，希望Docker公司能够与自己联合打造一款开源的容器运行时作为Docker核心依赖，但Docker公司拒绝了；接着Google公司联合RedHat、IBM等公司说服Docker公司把其容器核心技术libcontainer捐给中立社区(OCI,Open Container Intiative)，并更名为runC。 为了进一步遏制Docker在未来技术市场影响力，避免在容器市场上Docker一家独大，Google公司带领导RedHat、IBM等成立了CNCF(Cloud Native Computing Fundation)基金会，即云原生计算基金会。CNCF的目标很明确，既然在容器应用领域无法与Docker相抗衡，那就做Google更有经验的技术市场——大规模容器编排应用场景，Google公司把自己内部使用的Brog系统开源——Kubernetes，也就是我们今天所说的云原生技术生态。\n2016年Docker公司推出了Docker Swarm，意在一统Docker生态，让Docker既可以实现容器应用管理，也可以实现大规模容器编排，经过近1年左右时间的市场验证后，发现在容器编排方面无法独立抗衡kubernetes,所以Docker公司于2017年正式宣布原生支持Kubernetes,至此，Docker在大规模容器编排应用市场败下阵来，但是Docker依然不甘心失败，把Docker核心依赖Containerd捐给了CNCF，依此说明Docker依旧是一个PaaS平台。\n2020年CNCF基金会宣布Kubernetes 1.20版本将不再仅支持Docker容器管理工具，此事的起因主要也与Docker捐给CNCF基金会的Containerd有关，早期为了实现Kubernetes能够使用Docker实现容器管理，专门在Kubernetes组件中集成一个shim（垫片）技术，用来将Kubernetes容器运行时接口（CRI，Container Runntime Interface）调用翻译成Docker的API,这样就可以很好地使用Docker了，但是随着Kubernetes在全球技术市场的广泛应用，有更多的容器管理工具的出现，它们都想能够借助于Kubernetes被用户所使用，所以就提出标准化容器运行时接口，只要适配了这个接口就可以集成到Kubernetes生态当中，所以Kubernetes取消了对shim的维护，并且由于Containerd技术的成功，可以实现无缝对接Kubernetes，所以接下来Kubernetes容器运行时的主角是Containerd。\n1.2 Containerd架构 link1.2.1 架构图 linkContainerd设计的目的是为了嵌入到Kubernetes中使用，它是一个工业级的容器运行时，不提供给开发人员和终端用户直接使用，这样就避免了与Docker产生竞争，但事实上，Containerd已经实现大多数容器管理功能，例如：容器生命周期管理、容器镜像传输和管理、容器存储与网络管理等。\nContainerd 采用标准的 C/S 架构\n服务端通过 GRPC 协议提供稳定的 API 客户端通过调用服务端的 API 进行高级的操作 为了实现解耦，Containerd 将不同的职责划分给不同的组件，每个组件就相当于一个子系统（subsystem）。连接不同子系统的组件被称为模块。\nContainerd 两大子系统为：\nBundle : 在 Containerd 中，Bundle 包含了配置、元数据和根文件系统数据，你可以理解为容器的文件系统。而 Bundle 子系统允许用户从镜像中提取和打包 Bundles。 Runtime : Runtime 子系统用来执行 Bundles，比如创建容器。 其中，每一个子系统的行为都由一个或多个模块协作完成（架构图中的 Core 部分）。每一种类型的模块都以插件的形式集成到 Containerd 中，而且插件之间是相互依赖的。\n例如，上图中的每一个长虚线的方框都表示一种类型的插件，包括 Service Plugin、Metadata Plugin、GC Plugin、Runtime Plugin 等，其中 Service Plugin 又会依赖 Metadata Plugin、GC Plugin 和 Runtime Plugin。每一个小方框都表示一个细分的插件，例如 Metadata Plugin 依赖 Containers Plugin、Content Plugin 等。\n1.2.2 常用插件 link Content Plugin : 提供对镜像中可寻址内容的访问，所有不可变的内容都被存储在这里。 Snapshot Plugin : 用来管理容器镜像的文件系统快照。镜像中的每一个 layer 都会被解压成文件系统快照，类似于 Docker 中的 graphdriver。 Metrics : 暴露各个组件的监控指标。 1.2.3 架构缩略图 linkContainerd 被分为三个大块：Storage、Metadata 和 Runtime\n1.2.4 与其它容器运行时工具性能对比 link这是使用 bucketbench 对 Docker、crio 和 Containerd 的性能测试结果，包括启动、停止和删除容器，以比较它们所耗的时间：\n结论： Containerd 在各个方面都表现良好，总体性能优于 Docker 和 crio 。\n2. Containerd安装 link 课程操作系统环境为centos7u6\n2.1 YUM方式安装 link2.1.1 获取YUM源 link 获取阿里云YUM源 # wget -O /etc/yum.repos.d/docker-ce.repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo 查看YUM源中Containerd软件 # yum list | grep containerd containerd.io.x86_64 1.4.12-3.1.el7 docker-ce-stable 2.1.2 使用yum命令安装 link 安装Containerd.io软件，即可安装Containerd # yum -y install containerd.io 2.1.3 验证安装及启动服务 link 使用rpm -qa命令查看是否安装 # rpm -qa | grep containerd containerd.io-1.4.12-3.1.el7.x86_64 设置containerd服务启动及开机自启动 # systemctl enable containerd # systemctl start containerd 查看containerd服务启动状态 # systemctl status containerd ● containerd.service - containerd container runtime Loaded: loaded (/usr/lib/systemd/system/containerd.service; enabled; vendor preset: disabled) Active: active (running) since 五 2022-02-18 11:38:30 CST; 9s ago 此行第二列及第三列表示其正在运行状态 Docs: https://containerd.io Process: 59437 ExecStartPre=/sbin/modprobe overlay (code=exited, status=0/SUCCESS) Main PID: 59439 (containerd) Tasks: 7 Memory: 19.5M CGroup: /system.slice/containerd.service └─59439 /usr/bin/containerd ...... 2.1.4 验证可用性 link 安装Containerd时ctr命令亦可使用，ctr命令主要用于管理容器及容器镜像等。 使用ctr命令查看Containerd客户端及服务端相关信息。 # ctr version Client: Version: 1.4.12 Revision: 7b11cfaabd73bb80907dd23182b9347b4245eb5d Go version: go1.16.10 Server: Version: 1.4.12 Revision: 7b11cfaabd73bb80907dd23182b9347b4245eb5d UUID: 3c4b142d-d91d-44a5-aae2-9673785d4b2c 2.2 二进制方式安装 linkContainerd有两种安装包：\n第一种是containerd-xxx,这种包用于单机测试没问题，不包含runC，需要提前安装。 第二种是cri-containerd-cni-xxxx，包含runc和k8s里的所需要的相关文件。k8s集群里需要用到此包。虽然包含runC，但是依赖系统中的seccomp（安全计算模式，是一种限制容器调用系统资源的模式。） 2.2.1 获取安装包 link 下载Containerd安装包 # wget https://github.com/containerd/containerd/releases/download/v1.6.0/cri-containerd-cni-1.6.0-linux-amd64.tar.gz 2.2.2 安装并测试可用性 link2.2.2.1 安装containerd link 查看已获取的安装包 # ls cri-containerd-cni-1.6.0-linux-amd64.tar.gz 解压已下载的软件包 # tar xf cri-containerd-cni-1.6.0-linux-amd64.tar.gz 查看解压后目录 # ls etc opt usr 查看etc目录，主要为containerd服务管理配置文件及cni虚拟网卡配置文件 # ls etc cni crictl.yaml systemd # ls etc/systemd/ system # ls etc/systemd/system/ containerd.service 查看opt目录，主要为gce环境中使用containerd配置文件及cni插件 # ls opt cni containerd # ls opt/containerd/ cluster # ls opt/containerd/cluster/ gce version # ls opt/containerd/cluster/gce cloud-init cni.template configure.sh env 查看usr目录，主要为containerd运行时文件，包含runc # ls usr local # ls usr/local/ bin sbin # ls usr/local/bin containerd containerd-shim containerd-shim-runc-v1 containerd-shim-runc-v2 containerd-stress crictl critest ctd-decoder ctr # ls usr/local/sbin runc 2.2.2.2 查看containerd安装位置 link 查看containerd.service文件，了解containerd文件安装位置 # cat etc/systemd/system/containerd.service # Copyright The containerd Authors. # # Licensed under the Apache License, Version 2.0 (the \"License\"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. [Unit] Description=containerd container runtime Documentation=https://containerd.io After=network.target local-fs.target [Service] ExecStartPre=-/sbin/modprobe overlay ExecStart=/usr/local/bin/containerd 查看此位置,把containerd二进制文件放置于此处即可完成安装。 Type=notify Delegate=yes KillMode=process Restart=always RestartSec=5 # Having non-zero Limit*s causes performance problems due to accounting overhead # in the kernel. We recommend using cgroups to do container-local accounting. LimitNPROC=infinity LimitCORE=infinity LimitNOFILE=infinity # Comment TasksMax if your systemd version does not supports it. # Only systemd 226 and above support this version. TasksMax=infinity OOMScoreAdjust=-999 [Install] WantedBy=multi-user.target 2.2.2.3 复制containerd运行时文件至系统 link 查看宿主机/usr/local/bin目录，里面没有任何内容。 # ls /usr/local/bin/ 查看解压后usr/local/bin目录，里面包含containerd运行时文件 # ls usr/ local # ls usr/local/ bin sbin # ls usr/local/bin/ containerd containerd-shim containerd-shim-runc-v1 containerd-shim-runc-v2 containerd-stress crictl critest ctd-decoder ctr 复制containerd文件至/usr/local/bin目录中，本次可仅复制containerd一个文件也可复制全部文件。 # cp usr/local/bin/containerd /usr/local/bin/ # ls /usr/local/bin/ containerd 2.2.2.4 添加containerd.service文件至系统 link 查看解压后的etc/system目录 # ls etc cni crictl.yaml systemd # ls etc/systemd/ system # ls etc/systemd/system/ containerd.service 复制containerd服务管理配置文件至/usr/lib/systemd/system/目录中 # cp etc/systemd/system/containerd.service /usr/lib/systemd/system/containerd.service 查看复制后结果 # ls /usr/lib/systemd/system/containerd.service /usr/lib/systemd/system/containerd.service 2.2.2.5 查看containerd使用帮助 link # containerd --help NAME: containerd - __ _ __ _________ ____ / /_____ _(_)___ ___ _________/ / / ___/ __ \\/ __ \\/ __/ __ `/ / __ \\/ _ \\/ ___/ __ / / /__/ /_/ / / / / /_/ /_/ / / / / / __/ / / /_/ / \\___/\\____/_/ /_/\\__/\\__,_/_/_/ /_/\\___/_/ \\__,_/ high performance container runtime USAGE: containerd [global options] command [command options] [arguments...] VERSION: v1.6.0 DESCRIPTION: containerd is a high performance container runtime whose daemon can be started by using this command. If none of the *config*, *publish*, or *help* commands are specified, the default action of the **containerd** command is to start the containerd daemon in the foreground. A default configuration is used if no TOML configuration is specified or located at the default file location. The *containerd config* command can be used to generate the default configuration for containerd. The output of that command can be used and modified as necessary as a custom configuration. COMMANDS: config information on the containerd config publish binary to publish events to containerd oci-hook provides a base for OCI runtime hooks to allow arguments to be injected. help, h Shows a list of commands or help for one command GLOBAL OPTIONS: --config value, -c value path to the configuration file (default: \"/etc/containerd/config.toml\") --log-level value, -l value set the logging level [trace, debug, info, warn, error, fatal, panic] --address value, -a value address for containerd's GRPC server --root value containerd root directory --state value containerd state directory --help, -h show help --version, -v print the version 2.2.2.6 生成containerd模块配置文件 link2.2.2.6.1 生成默认模块配置文件 linkContainerd 的默认配置文件为 /etc/containerd/config.toml，可以使用containerd config default \u003e /etc/containerd/config.toml命令创建一份模块配置文件\n创建配置文件目录 # mkdir /etc/containerd 生成配置文件 # containerd config default \u003e /etc/containerd/config.toml 查看配置文件 # cat /etc/containerd/config.toml disabled_plugins = [] imports = [] oom_score = 0 plugin_dir = \"\" required_plugins = [] root = \"/var/lib/containerd\" state = \"/run/containerd\" temp = \"\" version = 2 [cgroup] path = \"\" [debug] address = \"\" format = \"\" gid = 0 level = \"\" uid = 0 [grpc] address = \"/run/containerd/containerd.sock\" gid = 0 max_recv_message_size = 16777216 max_send_message_size = 16777216 tcp_address = \"\" tcp_tls_ca = \"\" tcp_tls_cert = \"\" tcp_tls_key = \"\" uid = 0 [metrics] address = \"\" grpc_histogram = false [plugins] [plugins.\"io.containerd.gc.v1.scheduler\"] deletion_threshold = 0 mutation_threshold = 100 pause_threshold = 0.02 schedule_delay = \"0s\" startup_delay = \"100ms\" [plugins.\"io.containerd.grpc.v1.cri\"] device_ownership_from_security_context = false disable_apparmor = false disable_cgroup = false disable_hugetlb_controller = true disable_proc_mount = false disable_tcp_service = true enable_selinux = false enable_tls_streaming = false enable_unprivileged_icmp = false enable_unprivileged_ports = false ignore_image_defined_volumes = false max_concurrent_downloads = 3 max_container_log_line_size = 16384 netns_mounts_under_state_dir = false restrict_oom_score_adj = false sandbox_image = \"k8s.gcr.io/pause:3.6\" 由于网络原因，此处被替换 selinux_category_range = 1024 stats_collect_period = 10 stream_idle_timeout = \"4h0m0s\" stream_server_address = \"127.0.0.1\" stream_server_port = \"0\" systemd_cgroup = false tolerate_missing_hugetlb_controller = true unset_seccomp_profile = \"\" [plugins.\"io.containerd.grpc.v1.cri\".cni] bin_dir = \"/opt/cni/bin\" conf_dir = \"/etc/cni/net.d\" conf_template = \"\" ip_pref = \"\" max_conf_num = 1 [plugins.\"io.containerd.grpc.v1.cri\".containerd] default_runtime_name = \"runc\" disable_snapshot_annotations = true discard_unpacked_layers = false ignore_rdt_not_enabled_errors = false no_pivot = false snapshotter = \"overlayfs\" [plugins.\"io.containerd.grpc.v1.cri\".containerd.default_runtime] base_runtime_spec = \"\" cni_conf_dir = \"\" cni_max_conf_num = 0 container_annotations = [] pod_annotations = [] privileged_without_host_devices = false runtime_engine = \"\" runtime_path = \"\" runtime_root = \"\" runtime_type = \"\" [plugins.\"io.containerd.grpc.v1.cri\".containerd.default_runtime.options] [plugins.\"io.containerd.grpc.v1.cri\".containerd.runtimes] [plugins.\"io.containerd.grpc.v1.cri\".containerd.runtimes.runc] base_runtime_spec = \"\" cni_conf_dir = \"\" cni_max_conf_num = 0 container_annotations = [] pod_annotations = [] privileged_without_host_devices = false runtime_engine = \"\" runtime_path = \"\" runtime_root = \"\" runtime_type = \"io.containerd.runc.v2\" [plugins.\"io.containerd.grpc.v1.cri\".containerd.runtimes.runc.options] BinaryName = \"\" CriuImagePath = \"\" CriuPath = \"\" CriuWorkPath = \"\" IoGid = 0 IoUid = 0 NoNewKeyring = false NoPivotRoot = false Root = \"\" ShimCgroup = \"\" SystemdCgroup = false [plugins.\"io.containerd.grpc.v1.cri\".containerd.untrusted_workload_runtime] base_runtime_spec = \"\" cni_conf_dir = \"\" cni_max_conf_num = 0 container_annotations = [] pod_annotations = [] privileged_without_host_devices = false runtime_engine = \"\" runtime_path = \"\" runtime_root = \"\" runtime_type = \"\" [plugins.\"io.containerd.grpc.v1.cri\".containerd.untrusted_workload_runtime.options] [plugins.\"io.containerd.grpc.v1.cri\".image_decryption] key_model = \"node\" [plugins.\"io.containerd.grpc.v1.cri\".registry] config_path = \"\" [plugins.\"io.containerd.grpc.v1.cri\".registry.auths] [plugins.\"io.containerd.grpc.v1.cri\".registry.configs] [plugins.\"io.containerd.grpc.v1.cri\".registry.headers] [plugins.\"io.containerd.grpc.v1.cri\".registry.mirrors] [plugins.\"io.containerd.grpc.v1.cri\".x509_key_pair_streaming] tls_cert_file = \"\" tls_key_file = \"\" [plugins.\"io.containerd.internal.v1.opt\"] path = \"/opt/containerd\" [plugins.\"io.containerd.internal.v1.restart\"] interval = \"10s\" [plugins.\"io.containerd.internal.v1.tracing\"] sampling_ratio = 1.0 service_name = \"containerd\" [plugins.\"io.containerd.metadata.v1.bolt\"] content_sharing_policy = \"shared\" [plugins.\"io.containerd.monitor.v1.cgroups\"] no_prometheus = false [plugins.\"io.containerd.runtime.v1.linux\"] no_shim = false runtime = \"runc\" runtime_root = \"\" shim = \"containerd-shim\" shim_debug = false [plugins.\"io.containerd.runtime.v2.task\"] platforms = [\"linux/amd64\"] sched_core = false [plugins.\"io.containerd.service.v1.diff-service\"] default = [\"walking\"] [plugins.\"io.containerd.service.v1.tasks-service\"] rdt_config_file = \"\" [plugins.\"io.containerd.snapshotter.v1.aufs\"] root_path = \"\" [plugins.\"io.containerd.snapshotter.v1.btrfs\"] root_path = \"\" [plugins.\"io.containerd.snapshotter.v1.devmapper\"] async_remove = false base_image_size = \"\" discard_blocks = false fs_options = \"\" fs_type = \"\" pool_name = \"\" root_path = \"\" [plugins.\"io.containerd.snapshotter.v1.native\"] root_path = \"\" [plugins.\"io.containerd.snapshotter.v1.overlayfs\"] root_path = \"\" upperdir_label = false [plugins.\"io.containerd.snapshotter.v1.zfs\"] root_path = \"\" [plugins.\"io.containerd.tracing.processor.v1.otlp\"] endpoint = \"\" insecure = false protocol = \"\" [proxy_plugins] [stream_processors] [stream_processors.\"io.containerd.ocicrypt.decoder.v1.tar\"] accepts = [\"application/vnd.oci.image.layer.v1.tar+encrypted\"] args = [\"--decryption-keys-path\", \"/etc/containerd/ocicrypt/keys\"] env = [\"OCICRYPT_KEYPROVIDER_CONFIG=/etc/containerd/ocicrypt/ocicrypt_keyprovider.conf\"] path = \"ctd-decoder\" returns = \"application/vnd.oci.image.layer.v1.tar\" [stream_processors.\"io.containerd.ocicrypt.decoder.v1.tar.gzip\"] accepts = [\"application/vnd.oci.image.layer.v1.tar+gzip+encrypted\"] args = [\"--decryption-keys-path\", \"/etc/containerd/ocicrypt/keys\"] env = [\"OCICRYPT_KEYPROVIDER_CONFIG=/etc/containerd/ocicrypt/ocicrypt_keyprovider.conf\"] path = \"ctd-decoder\" returns = \"application/vnd.oci.image.layer.v1.tar+gzip\" [timeouts] \"io.containerd.timeout.bolt.open\" = \"0s\" \"io.containerd.timeout.shim.cleanup\" = \"5s\" \"io.containerd.timeout.shim.load\" = \"5s\" \"io.containerd.timeout.shim.shutdown\" = \"3s\" \"io.containerd.timeout.task.state\" = \"2s\" [ttrpc] address = \"\" gid = 0 uid = 0 2.2.2.6.2 替换默认配置文件 link但上述配置文件后期改动的地方较多，这里直接换成可单机使用也可k8s环境使用的配置文件并配置好镜像加速器。\n# vim /etc/containerd/config.toml # cat /etc/containerd/config.toml root = \"/var/lib/containerd\" state = \"/run/containerd\" oom_score = -999 [grpc] address = \"/run/containerd/containerd.sock\" uid = 0 gid = 0 max_recv_message_size = 16777216 max_send_message_size = 16777216 [debug] address = \"\" uid = 0 gid = 0 level = \"\" [metrics] address = \"\" grpc_histogram = false [cgroup] path = \"\" [plugins] [plugins.cgroups] no_prometheus = false [plugins.cri] stream_server_address = \"127.0.0.1\" stream_server_port = \"0\" enable_selinux = false sandbox_image = \"easzlab/pause-amd64:3.2\" stats_collect_period = 10 systemd_cgroup = false enable_tls_streaming = false max_container_log_line_size = 16384 [plugins.cri.containerd] snapshotter = \"overlayfs\" no_pivot = false [plugins.cri.containerd.default_runtime] runtime_type = \"io.containerd.runtime.v1.linux\" runtime_engine = \"\" runtime_root = \"\" [plugins.cri.containerd.untrusted_workload_runtime] runtime_type = \"\" runtime_engine = \"\" runtime_root = \"\" [plugins.cri.cni] bin_dir = \"/opt/kube/bin\" conf_dir = \"/etc/cni/net.d\" conf_template = \"/etc/cni/net.d/10-default.conf\" [plugins.cri.registry] [plugins.cri.registry.mirrors] [plugins.cri.registry.mirrors.\"docker.io\"] endpoint = [ \"https://docker.mirrors.ustc.edu.cn\", \"http://hub-mirror.c.163.com\" ] [plugins.cri.registry.mirrors.\"gcr.io\"] endpoint = [ \"https://gcr.mirrors.ustc.edu.cn\" ] [plugins.cri.registry.mirrors.\"k8s.gcr.io\"] endpoint = [ \"https://gcr.mirrors.ustc.edu.cn/google-containers/\" ] [plugins.cri.registry.mirrors.\"quay.io\"] endpoint = [ \"https://quay.mirrors.ustc.edu.cn\" ] [plugins.cri.registry.mirrors.\"harbor.kubemsb.com\"] 此处添加了本地容器镜像仓库 Harbor,做为本地容器镜像仓库。 endpoint = [ \"http://harbor.kubemsb.com\" ] [plugins.cri.x509_key_pair_streaming] tls_cert_file = \"\" tls_key_file = \"\" [plugins.diff-service] default = [\"walking\"] [plugins.linux] shim = \"containerd-shim\" runtime = \"runc\" runtime_root = \"\" no_shim = false shim_debug = false [plugins.opt] path = \"/opt/containerd\" [plugins.restart] interval = \"10s\" [plugins.scheduler] pause_threshold = 0.02 deletion_threshold = 0 mutation_threshold = 100 schedule_delay = \"0s\" startup_delay = \"100ms\" 2.2.2.7 启动containerd服务并设置开机自启动 link # systemctl enable containerd Created symlink from /etc/systemd/system/multi-user.target.wants/containerd.service to /usr/lib/systemd/system/containerd.service. # systemctl start containerd # systemctl status containerd ● containerd.service - containerd container runtime Loaded: loaded (/usr/lib/systemd/system/containerd.service; enabled; vendor preset: disabled) Active: active (running) since 五 2022-02-18 13:02:37 CST; 7s ago Docs: https://containerd.io Process: 60383 ExecStartPre=/sbin/modprobe overlay (code=exited, status=0/SUCCESS) Main PID: 60384 (containerd) Tasks: 8 Memory: 20.0M CGroup: /system.slice/containerd.service └─60384 /usr/local/bin/containerd ...... 2.2.2.8 复制ctr命令至系统 link # ls usr/local/bin/ containerd containerd-shim containerd-shim-runc-v1 containerd-shim-runc-v2 containerd-stress crictl critest ctd-decoder ctr # cp usr/local/bin/ctr /usr/bin/ 2.2.2.9 查看已安装containerd服务版本 link # ctr version Client: Version: v1.6.0 Revision: 39259a8f35919a0d02c9ecc2871ddd6ccf6a7c6e Go version: go1.17.2 Server: Version: v1.6.0 Revision: 39259a8f35919a0d02c9ecc2871ddd6ccf6a7c6e UUID: c1972cbe-884a-41b0-867f-f8a58c168e6d 2.2.2.10 安装runC link 由于二进制包中提供的runC默认需要系统中安装seccomp支持，需要单独安装，且不同版本runC对seccomp版本要求一致，所以建议单独下载runC 二进制包进行安装，里面包含了seccomp模块支持。\n2.2.2.10.1 获取runC link 使用wget下载 # wget https://github.com/opencontainers/runc/releases/download/v1.1.0/runc.amd64 2.2.2.10.2 安装runC并验证安装结果 link 查看已下载文件 # ls runc.amd64 安装runC # mv runc.amd64 /usr/sbin/runc 为runC添加可执行权限 # chmod +x /usr/sbin/runc 使用runc命令验证是否安装成功 # runc -v runc version 1.1.0 commit: v1.1.0-0-g067aaf85 spec: 1.0.2-dev go: go1.17.6 libseccomp: 2.5.3 3. Containerd容器镜像管理 link3.1 Containerd容器镜像管理命令 link docker使用docker images命令管理镜像 单机containerd使用ctr images命令管理镜像,containerd本身的CLI k8s中containerd使用crictl images命令管理镜像,Kubernetes社区的专用CLI工具 获取命令帮助 # ctr --help NAME: ctr - __ _____/ /______ / ___/ __/ ___/ / /__/ /_/ / \\___/\\__/_/ containerd CLI USAGE: ctr [global options] command [command options] [arguments...] VERSION: v1.6.0 DESCRIPTION: ctr is an unsupported debug and administrative client for interacting with the containerd daemon. Because it is unsupported, the commands, options, and operations are not guaranteed to be backward compatible or stable from release to release of the containerd project. COMMANDS: plugins, plugin provides information about containerd plugins version print the client and server versions containers, c, container manage containers content manage content events, event display containerd events images, image, i manage images leases manage leases namespaces, namespace, ns manage namespaces pprof provide golang pprof outputs for containerd run run a container snapshots, snapshot manage snapshots tasks, t, task manage tasks install install a new package oci OCI tools shim interact with a shim directly help, h Shows a list of commands or help for one command GLOBAL OPTIONS: --debug enable debug output in logs --address value, -a value address for containerd's GRPC server (default: \"/run/containerd/containerd.sock\") [$CONTAINERD_ADDRESS] --timeout value total timeout for ctr commands (default: 0s) --connect-timeout value timeout for connecting to containerd (default: 0s) --namespace value, -n value namespace to use with commands (default: \"default\") [$CONTAINERD_NAMESPACE] --help, -h show help --version, -v print the version 获取命令帮助 # ctr images NAME: ctr images - manage images USAGE: ctr images command [command options] [arguments...] COMMANDS: check check existing images to ensure all content is available locally export export images import import images list, ls list images known to containerd mount mount an image to a target path unmount unmount the image from the target pull pull an image from a remote push push an image to a remote delete, del, remove, rm remove one or more images by reference tag tag an image label set and clear labels for an image convert convert an image OPTIONS: --help, -h show help 3.2 查看镜像 link # ctr images ls REF TYPE DIGEST SIZE PLATFORMS LABELS 3.3 下载镜像 linkcontainerd支持oci标准的镜像，所以可以直接使用docker官方或dockerfile构建的镜像\n# ctr images pull --all-platforms docker.io/library/nginx:alpine docker.io/library/nginx:alpine: resolved |++++++++++++++++++++++++++++++++++++++| docker.io/library/nginx:alpine: resolved |++++++++++++++++++++++++++++++++++++++| index-sha256:da9c94bec1da829ebd52431a84502ec471c8e548ffb2cedbf36260fd9bd1d4d3: done |++++++++++++++++++++++++++++++++++++++| manifest-sha256:050385609d832fae11b007fbbfba77d0bba12bf72bc0dca0ac03e09b1998580f: done |++++++++++++++++++++++++++++++++++++++| layer-sha256:f2303c6c88653b9a6739d50f611c170b9d97d161c6432409c680f6b46a5f112f: done |++++++++++++++++++++++++++++++++++++++| config-sha256:bef258acf10dc257d641c47c3a600c92f87be4b4ce4a5e4752b3eade7533dcd9: done |++++++++++++++++++++++++++++++++++++++| layer-sha256:59bf1c3509f33515622619af21ed55bbe26d24913cedbca106468a5fb37a50c3: done |++++++++++++++++++++++++++++++++++++++| layer-sha256:8d6ba530f6489d12676d7f61628427d067243ba4a3a512c3e28813b977cb3b0e: done |++++++++++++++++++++++++++++++++++++++| layer-sha256:5288d7ad7a7f84bdd19c1e8f0abb8684b5338f3da86fe9ae1d7f0e9bc2de6595: done |++++++++++++++++++++++++++++++++++++++| layer-sha256:39e51c61c033442d00c40a30b2a9ed01f40205875fbd8664c50b4dc3e99ad5cf: done |++++++++++++++++++++++++++++++++++++++| layer-sha256:ee6f71c6f4a82b2afd01f92bdf6be0079364d03020e8a2c569062e1c06d3822b: done |++++++++++++++++++++++++++++++++++++++| elapsed: 11.0s total: 8.7 Mi (809.5 KiB/s) unpacking linux/amd64 sha256:da9c94bec1da829ebd52431a84502ec471c8e548ffb2cedbf36260fd9bd1d4d3... done: 1.860946163s 说明： 这里ctr命令pull镜像时，不能直接把镜像名字写成`nginx:alpine` 查看已下载容器镜像 # ctr images ls REF TYPE DIGEST SIZE PLATFORMS LABELS docker.io/library/nginx:alpine application/vnd.docker.distribution.manifest.list.v2+json sha256:da9c94bec1da829ebd52431a84502ec471c8e548ffb2cedbf36260fd9bd1d4d3 9.7 MiB linux/386,linux/amd64,linux/arm/v6,linux/arm/v7,linux/arm64/v8,linux/ppc64le,linux/s390x - 指定平台下载容器镜像 # ctr images pull --platform linux/amd64 docker.io/library/nginx:alpine 3.4 镜像挂载 link 方便查看镜像中包含的内容。\n把已下载的容器镜像挂载至当前文件系统 # ctr images mount docker.io/library/nginx:alpine /mnt sha256:af2fcce448e2e4451a5f4796a9bf9cb5c9b5f88e0d6d10029cada42fb9d268ac /mnt [root@localhost ~]# ls /mnt bin dev docker-entrypoint.d docker-entrypoint.sh etc home lib media mnt opt proc root run sbin srv sys tmp usr var 卸载 # umount /mnt 3.5 镜像导出 link 把容器镜像导出 # ctr i export --all-platforms nginx.img docker.io/library/nginx:alpine 说明 --all-platforms,导出所有平台镜像，本版本为1.6版本，1.4版本不需要添加此选项。 查看已导出容器镜像 # ls nginx.img # ls -lh 总用量 196M -rw-r--r-- 1 root root 73M 2月 18 14:48 nginx.img 3.6 镜像删除 link 删除指定容器镜像 # ctr image rm docker.io/library/nginx:alpine docker.io/library/nginx:alpine 再次查看容器镜像 [root@192 ~]# ctr images ls REF TYPE DIGEST SIZE PLATFORMS LABELS 3.7 镜像导入 link 导入容器镜像 # ctr images import nginx.img unpacking docker.io/library/nginx:alpine (sha256:da9c94bec1da829ebd52431a84502ec471c8e548ffb2cedbf36260fd9bd1d4d3)...done 3.8 修改镜像tag link # ctr images tag docker.io/library/nginx:alpine nginx:alpine nginx:alpine 说明： 把docker.io/library/nginx:alpine 修改为 nginx:alpine 查看修改后的容器镜像 # ctr images ls REF TYPE DIGEST SIZE PLATFORMS LABELS docker.io/library/nginx:alpine application/vnd.docker.distribution.manifest.list.v2+json sha256:da9c94bec1da829ebd52431a84502ec471c8e548ffb2cedbf36260fd9bd1d4d3 9.7 MiB linux/386,linux/amd64,linux/arm/v6,linux/arm/v7,linux/arm64/v8,linux/ppc64le,linux/s390x - nginx:alpine application/vnd.docker.distribution.manifest.list.v2+json sha256:da9c94bec1da829ebd52431a84502ec471c8e548ffb2cedbf36260fd9bd1d4d3 9.7 MiB linux/386,linux/amd64,linux/arm/v6,linux/arm/v7,linux/arm64/v8,linux/ppc64le,linux/s390x - 修改后对容器镜像做检查比对 # ctr images check REF TYPE DIGEST STATUS SIZE UNPACKED docker.io/library/nginx:alpine application/vnd.docker.distribution.manifest.list.v2+json sha256:da9c94bec1da829ebd52431a84502ec471c8e548ffb2cedbf36260fd9bd1d4d3 complete (7/7) 9.7 MiB/9.7 MiB true nginx:alpine application/vnd.docker.distribution.manifest.list.v2+json sha256:da9c94bec1da829ebd52431a84502ec471c8e548ffb2cedbf36260fd9bd1d4d3 complete (7/7) 9.7 MiB/9.7 MiB true 4. Containerd容器管理 link4.1 获取命令帮助 link4.1.1 获取ctr命令帮助 link [root@localhost ~]# ctr --help NAME: ctr - __ _____/ /______ / ___/ __/ ___/ / /__/ /_/ / \\___/\\__/_/ containerd CLI USAGE: ctr [global options] command [command options] [arguments...] VERSION: v1.6.0 DESCRIPTION: ctr is an unsupported debug and administrative client for interacting with the containerd daemon. Because it is unsupported, the commands, options, and operations are not guaranteed to be backward compatible or stable from release to release of the containerd project. COMMANDS: plugins, plugin provides information about containerd plugins version print the client and server versions containers, c, container manage containers content manage content events, event display containerd events images, image, i manage images leases manage leases namespaces, namespace, ns manage namespaces pprof provide golang pprof outputs for containerd run run a container snapshots, snapshot manage snapshots tasks, t, task manage tasks install install a new package oci OCI tools shim interact with a shim directly help, h Shows a list of commands or help for one command GLOBAL OPTIONS: --debug enable debug output in logs --address value, -a value address for containerd's GRPC server (default: \"/run/containerd/containerd.sock\") [$CONTAINERD_ADDRESS] --timeout value total timeout for ctr commands (default: 0s) --connect-timeout value timeout for connecting to containerd (default: 0s) --namespace value, -n value namespace to use with commands (default: \"default\") [$CONTAINERD_NAMESPACE] --help, -h show help --version, -v print the version 4.1.2 获取创建静态容器命令帮助 link # ctr container --help NAME: ctr containers - manage containers USAGE: ctr containers command [command options] [arguments...] COMMANDS: create create container delete, del, remove, rm delete one or more existing containers info get info about a container list, ls list containers label set and clear labels for a container checkpoint checkpoint a container restore restore a container from checkpoint OPTIONS: --help, -h show help 说明： 使用`ctr container create `命令创建容器后，容器并没有处于运行状态，其只是一个静态的容器。这个 container 对象只是包含了运行一个容器所需的资源及配置的数据结构，例如： namespaces、rootfs 和容器的配置都已经初始化成功了，只是用户进程(本案例为nginx)还没有启动。需要使用`ctr tasks`命令才能获取一个动态容器。 4.1.3 获取动态容器命令帮助 link # ctr run --help NAME: ctr run - run a container USAGE: ctr run [command options] [flags] Image|RootFS ID [COMMAND] [ARG...] OPTIONS: --rm remove the container after running --null-io send all IO to /dev/null --log-uri value log uri --detach, -d detach from the task after it has started execution --fifo-dir value directory used for storing IO FIFOs --cgroup value cgroup path (To disable use of cgroup, set to \"\" explicitly) --platform value run image for specific platform --cni enable cni networking for the container --runc-binary value specify runc-compatible binary --runc-root value specify runc-compatible root --runc-systemd-cgroup start runc with systemd cgroup manager --uidmap container-uid:host-uid:length run inside a user namespace with the specified UID mapping range; specified with the format container-uid:host-uid:length --gidmap container-gid:host-gid:length run inside a user namespace with the specified GID mapping range; specified with the format container-gid:host-gid:length --remap-labels provide the user namespace ID remapping to the snapshotter via label options; requires snapshotter support --cpus value set the CFS cpu quota (default: 0) --cpu-shares value set the cpu shares (default: 1024) --snapshotter value snapshotter name. Empty value stands for the default value. [$CONTAINERD_SNAPSHOTTER] --snapshotter-label value labels added to the new snapshot for this container. --config value, -c value path to the runtime-specific spec config file --cwd value specify the working directory of the process --env value specify additional container environment variables (e.g. FOO=bar) --env-file value specify additional container environment variables in a file(e.g. FOO=bar, one per line) --label value specify additional labels (e.g. foo=bar) --mount value specify additional container mount (e.g. type=bind,src=/tmp,dst=/host,options=rbind:ro) --net-host enable host networking for the container --privileged run privileged container --read-only set the containers filesystem as readonly --runtime value runtime name (default: \"io.containerd.runc.v2\") --runtime-config-path value optional runtime config path --tty, -t allocate a TTY for the container --with-ns value specify existing Linux namespaces to join at container runtime (format ':') --pid-file value file path to write the task's pid --gpus value add gpus to the container --allow-new-privs turn off OCI spec's NoNewPrivileges feature flag --memory-limit value memory limit (in bytes) for the container (default: 0) --device value file path to a device to add to the container; or a path to a directory tree of devices to add to the container --cap-add value add Linux capabilities (Set capabilities with 'CAP_' prefix) --cap-drop value drop Linux capabilities (Set capabilities with 'CAP_' prefix) --seccomp enable the default seccomp profile --seccomp-profile value file path to custom seccomp profile. seccomp must be set to true, before using seccomp-profile --apparmor-default-profile value enable AppArmor with the default profile with the specified name, e.g. \"cri-containerd.apparmor.d\" --apparmor-profile value enable AppArmor with an existing custom profile --rdt-class value name of the RDT class to associate the container with. Specifies a Class of Service (CLOS) for cache and memory bandwidth management. --rootfs use custom rootfs that is not managed by containerd snapshotter --no-pivot disable use of pivot-root (linux only) --cpu-quota value Limit CPU CFS quota (default: -1) --cpu-period value Limit CPU CFS period (default: 0) --rootfs-propagation value set the propagation of the container rootfs 说明： 使用`ctr run`命令可以创建一个静态容器并使其运行。一步到位运行容器。 4.2 查看容器 linkcontainer表示静态容器，可用c缩写代表container\n# ctr container ls CONTAINER IMAGE RUNTIME 或\n# ctr c ls CONTAINER IMAGE RUNTIME 4.3 查看任务 linktask表示容器里跑的进程, 可用t缩写代表task\n# ctr task ls TASK PID STATUS 或\n# ctr t ls TASK PID STATUS 4.4 创建静态容器 link # ctr c create docker.io/library/nginx:alpine nginx1 # ctr container ls CONTAINER IMAGE RUNTIME nginx1 docker.io/library/nginx:alpine io.containerd.runc.v2 查看容器详细信息 # ctr container info nginx1 4.5 静态容器启动为动态容器 link 复制containerd连接runC垫片工具至系统 # ls usr/local/bin/ containerd containerd-shim containerd-shim-runc-v1 containerd-shim-runc-v2 containerd-stress crictl critest ctd-decoder ctr [root@localhost ~]# cp usr/local/bin/containerd-shim-runc-v2 /usr/bin/ 启动task，即表时在容器中运行了进程，即为动态容器。 # ctr task start -d nginx1 /docker-entrypoint.sh: /docker-entrypoint.d/ is not empty, will attempt to perform configuration /docker-entrypoint.sh: Looking for shell scripts in /docker-entrypoint.d/ 说明： -d表示daemon或者后台的意思，否则会卡住终端 查看容器所在宿主机进程，是以宿主机进程的方式存在的。 # ctr task ls TASK PID STATUS nginx1 3395 RUNNING 查看容器的进程(都是物理机的进程) # ctr task ps nginx1 PID INFO 3395 - 3434 - 物理机查看到相应的进程 # ps -ef | grep 3395 root 3395 3375 0 19:16 ? 00:00:00 nginx: master process nginx -g daemon off; 101 3434 3395 0 19:16 ? 00:00:00 nginx: worker process 4.6 进入容器操作 link # ctr task exec --exec-id 1 nginx1 /bin/sh ifconfig 查看网卡信息 lo Link encap:Local Loopback inet addr:127.0.0.1 Mask:255.0.0.0 inet6 addr: ::1/128 Scope:Host UP LOOPBACK RUNNING MTU:65536 Metric:1 RX packets:0 errors:0 dropped:0 overruns:0 frame:0 TX packets:0 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:1000 RX bytes:0 (0.0 B) TX bytes:0 (0.0 B) curl 127.0.0.1 访问本地提供的web服务 % Total % Received % Xferd Average Speed Time Time Time Current Dload Upload Total Spent Left Speed 0 0 0 0 0 0 0 0 --:--:-- --:--:-- --:--:-- 0\u003c!DOCTYPE html\u003e Welcome to nginx! Welcome to nginx! If you see this page, the nginx web server is successfully installed and working. Further configuration is required.\nFor online documentation and support please refer to nginx.org. Commercial support is available at nginx.com.\nThank you for using nginx.\n100 615 100 615 0 0 429k 0 --:--:-- --:--:-- --:--:-- 600k 说明： 为exec进程设定一个id，可以随意输入，只要保证唯一即可，也可使用$RANDOM变量。 4.7 直接运行一个动态容器 link # ctr run -d --net-host docker.io/library/nginx:alpine nginx2 /docker-entrypoint.sh: /docker-entrypoint.d/ is not empty, will attempt to perform configuration /docker-entrypoint.sh: Looking for shell scripts in /docker-entrypoint.d/ 说明： * -d 代表dameon，后台运行 * --net-host 代表容器的IP就是宿主机的IP(相当于docker里的host类型网络) 查看已运行容器 # ctr container ls CONTAINER IMAGE RUNTIME nginx2 docker.io/library/nginx:alpine io.containerd.runc.v2 查看已运行容器中运行的进程,既tasks # ctr tasks ls TASK PID STATUS nginx2 4061 RUNNING 进入容器 # ctr task exec --exec-id 1 -t nginx2 /bin/sh / # ifconfig ens33 Link encap:Ethernet HWaddr 00:0C:29:B1:B6:1D inet addr:192.168.10.164 Bcast:192.168.10.255 Mask:255.255.255.0 inet6 addr: fe80::2b33:40ed:9311:8812/64 Scope:Link inet6 addr: fe80::adf4:a8bc:a1c:a9f7/64 Scope:Link UP BROADCAST RUNNING MULTICAST MTU:1500 Metric:1 RX packets:55360 errors:0 dropped:0 overruns:0 frame:0 TX packets:30526 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:1000 RX bytes:53511295 (51.0 MiB) TX bytes:2735050 (2.6 MiB) lo Link encap:Local Loopback inet addr:127.0.0.1 Mask:255.0.0.0 inet6 addr: ::1/128 Scope:Host UP LOOPBACK RUNNING MTU:65536 Metric:1 RX packets:68 errors:0 dropped:0 overruns:0 frame:0 TX packets:68 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:1000 RX bytes:5916 (5.7 KiB) TX bytes:5916 (5.7 KiB) virbr0 Link encap:Ethernet HWaddr 52:54:00:E9:51:82 inet addr:192.168.122.1 Bcast:192.168.122.255 Mask:255.255.255.0 UP BROADCAST MULTICAST MTU:1500 Metric:1 RX packets:0 errors:0 dropped:0 overruns:0 frame:0 TX packets:0 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:1000 RX bytes:0 (0.0 B) TX bytes:0 (0.0 B) 为容器中运行的网站添加网站文件 / # echo \"nginx2\" \u003e /usr/share/nginx/html/index.html / # exit 在宿主机上访问网站 [root@localhost ~]# curl 192.168.10.164 nginx2 4.8 暂停容器 link 查看容器状态 # ctr tasks ls TASK PID STATUS nginx2 4061 RUNNING 暂停容器 # ctr tasks pause nginx2 再次查看容器状态，看到其状态为PAUSED，表示停止。 # ctr tasks ls TASK PID STATUS nginx2 4061 PAUSED [root@localhost ~]# curl http://192.168.10.164 在宿主机访问，发现不可以访问到网站 4.9 恢复容器 link 使用resume命令恢复容器 # ctr tasks resume nginx2 查看恢复后状态 # ctr tasks ls TASK PID STATUS nginx2 4061 RUNNING 在宿主机上访问容器中提供的服务 # curl http://192.168.10.164 nginx2 4.10 停止容器 link # ctr tasks --help NAME: ctr tasks - manage tasks USAGE: ctr tasks command [command options] [arguments...] COMMANDS: attach attach to the IO of a running container checkpoint checkpoint a container delete, del, remove, rm delete one or more tasks exec execute additional processes in an existing container list, ls list tasks kill signal a container (default: SIGTERM) pause pause an existing container ps list processes for container resume resume a paused container start start a container that has been created metrics, metric get a single data point of metrics for a task with the built-in Linux runtime OPTIONS: --help, -h show help 使用kill命令停止容器中运行的进程，既为停止容器 # ctr tasks kill nginx2 查看容器停止后状态，STATUS为STOPPED # ctr tasks ls TASK PID STATUS nginx1 3395 RUNNING nginx2 4061 STOPPED 4.11 删除容器 link # ctr tasks delete nginx2 必须先停止tasks或先删除task，再删除容器 查看静态容器，确认其还存在于系统中 # ctr container ls CONTAINER IMAGE RUNTIME nginx2 docker.io/library/nginx:alpine io.containerd.runc.v2 删除容器 # ctr container delete nginx2 5. Containerd使用私有容器镜像仓库 Harbor link5.1 Harbor准备 link 5.2 配置Containerd使用Harbor仓库 link5.2.1 Harbor主机名解析 link 在所有安装containerd宿主机上添加此配置信息。\n# vim /etc/hosts # cat /etc/hosts 127.0.0.1 localhost localhost.localdomain localhost4 localhost4.localdomain4 ::1 localhost localhost.localdomain localhost6 localhost6.localdomain6 192.168.10.165 harbor.kubemsb.com 说明 * 192.168.10.165是harbor的IP * harbor.kubemsb.com建议用FQDN形式，如果用类似harbor这种短名，后面下载镜像会出问题 5.2.2 修改Containerd配置文件 link 此配置文件已提前替换过，仅修改本地容器镜像仓库地址即可。 # vim /etc/containerd/config.toml # cat /etc/containerd/config.toml root = \"/var/lib/containerd\" state = \"/run/containerd\" oom_score = -999 [grpc] address = \"/run/containerd/containerd.sock\" uid = 0 gid = 0 max_recv_message_size = 16777216 max_send_message_size = 16777216 [debug] address = \"\" uid = 0 gid = 0 level = \"\" [metrics] address = \"\" grpc_histogram = false [cgroup] path = \"\" [plugins] [plugins.cgroups] no_prometheus = false [plugins.cri] stream_server_address = \"127.0.0.1\" stream_server_port = \"0\" enable_selinux = false sandbox_image = \"easzlab/pause-amd64:3.2\" stats_collect_period = 10 systemd_cgroup = false enable_tls_streaming = false max_container_log_line_size = 16384 [plugins.cri.containerd] snapshotter = \"overlayfs\" no_pivot = false [plugins.cri.containerd.default_runtime] runtime_type = \"io.containerd.runtime.v1.linux\" runtime_engine = \"\" runtime_root = \"\" [plugins.cri.containerd.untrusted_workload_runtime] runtime_type = \"\" runtime_engine = \"\" runtime_root = \"\" [plugins.cri.cni] bin_dir = \"/opt/kube/bin\" conf_dir = \"/etc/cni/net.d\" conf_template = \"/etc/cni/net.d/10-default.conf\" [plugins.cri.registry] [plugins.cri.registry.mirrors] [plugins.cri.registry.mirrors.\"docker.io\"] endpoint = [ \"https://docker.mirrors.ustc.edu.cn\", \"http://hub-mirror.c.163.com\" ] [plugins.cri.registry.mirrors.\"gcr.io\"] endpoint = [ \"https://gcr.mirrors.ustc.edu.cn\" ] [plugins.cri.registry.mirrors.\"k8s.gcr.io\"] endpoint = [ \"https://gcr.mirrors.ustc.edu.cn/google-containers/\" ] [plugins.cri.registry.mirrors.\"quay.io\"] endpoint = [ \"https://quay.mirrors.ustc.edu.cn\" ] [plugins.cri.registry.mirrors.\"harbor.kubemsb.com\"] 在此处添加,在镜像加速器下面添加这一段 endpoint = [ \"http://harbor.kubemsb.com\" ] [plugins.cri.x509_key_pair_streaming] tls_cert_file = \"\" tls_key_file = \"\" [plugins.diff-service] default = [\"walking\"] [plugins.linux] shim = \"containerd-shim\" runtime = \"runc\" runtime_root = \"\" no_shim = false shim_debug = false [plugins.opt] path = \"/opt/containerd\" [plugins.restart] interval = \"10s\" [plugins.scheduler] pause_threshold = 0.02 deletion_threshold = 0 mutation_threshold = 100 schedule_delay = \"0s\" startup_delay = \"100ms\" 重启containerd，以便于重新加载配置文件。 # systemctl restart containerd 5.2.3 ctr下载镜像 link 下载容器镜像 # ctr images pull --platform linux/amd64 docker.io/library/nginx:latest 说明: * --platform linux/amd64 指定系统平台，也可以使用--all-platforms指定所有平台镜像。 输出： docker.io/library/nginx:latest: resolved |++++++++++++++++++++++++++++++++++++++| index-sha256:2834dc507516af02784808c5f48b7cbe38b8ed5d0f4837f16e78d00deb7e7767: done |++++++++++++++++++++++++++++++++++++++| manifest-sha256:bb129a712c2431ecce4af8dde831e980373b26368233ef0f3b2bae9e9ec515ee: done |++++++++++++++++++++++++++++++++++++++| layer-sha256:b559bad762bec166fd028483dd2a03f086d363ee827d8c98b7268112c508665a: done |++++++++++++++++++++++++++++++++++++++| config-sha256:c316d5a335a5cf324b0dc83b3da82d7608724769f6454f6d9a621f3ec2534a5a: done |++++++++++++++++++++++++++++++++++++++| layer-sha256:5eb5b503b37671af16371272f9c5313a3e82f1d0756e14506704489ad9900803: done |++++++++++++++++++++++++++++++++++++++| layer-sha256:1ae07ab881bd848493ad54c2ba32017f94d1d8dbfd0ba41b618f17e80f834a0f: done |++++++++++++++++++++++++++++++++++++++| layer-sha256:78091884b7bea0fa918527207924e9993bcc21bf7f1c9687da40042ceca31ac9: done |++++++++++++++++++++++++++++++++++++++| layer-sha256:091c283c6a66ad0edd2ab84cb10edacc00a1a7bc5277f5365c0d5c5457a75aff: done |++++++++++++++++++++++++++++++++++++++| layer-sha256:55de5851019b8f65ed6e28120c6300e35e556689d021e4b3411c7f4e90a9704b: done |++++++++++++++++++++++++++++++++++++++| elapsed: 20.0s total: 53.2 M (2.7 MiB/s) unpacking linux/amd64 sha256:2834dc507516af02784808c5f48b7cbe38b8ed5d0f4837f16e78d00deb7e7767... done: 3.028652226s 查看已下载容器镜像 # ctr images ls REF TYPE DIGEST SIZE PLATFORMS LABELS docker.io/library/nginx:latest application/vnd.docker.distribution.manifest.list.v2+json sha256:2834dc507516af02784808c5f48b7cbe38b8ed5d0f4837f16e78d00deb7e7767 54.1 MiB linux/386,linux/amd64,linux/arm/v5,linux/arm/v7,linux/arm64/v8,linux/mips64le,linux/ppc64le,linux/s390x - 5.2.4 ctr上传镜像 link 上传到Harbor library公有项目\n重新生成新的tag # ctr images tag docker.io/library/nginx:latest harbor.kubemsb.com/library/nginx:latest harbor.kubemsb.com/library/nginx:latest 查看已生成容器镜像 # ctr images ls REF TYPE DIGEST SIZE PLATFORMS LABELS docker.io/library/nginx:latest application/vnd.docker.distribution.manifest.list.v2+json sha256:2834dc507516af02784808c5f48b7cbe38b8ed5d0f4837f16e78d00deb7e7767 54.1 MiB linux/386,linux/amd64,linux/arm/v5,linux/arm/v7,linux/arm64/v8,linux/mips64le,linux/ppc64le,linux/s390x - harbor.kubemsb.com/library/nginx:latest application/vnd.docker.distribution.manifest.list.v2+json sha256:2834dc507516af02784808c5f48b7cbe38b8ed5d0f4837f16e78d00deb7e7767 54.1 MiB linux/386,linux/amd64,linux/arm/v5,linux/arm/v7,linux/arm64/v8,linux/mips64le,linux/ppc64le,linux/s390x - 推送容器镜像至Harbor # ctr images push --platform linux/amd64 --plain-http -u admin:Harbor12345 harbor.kubemsb.com/library/nginx:latest 说明: * 先tag再push * 因为我们harbor是http协议，不是https协议，所以需要加上`--plain-http` * `--user admin:Harbor12345`指定harbor的用户名与密码 输出： manifest-sha256:0fd68ec4b64b8dbb2bef1f1a5de9d47b658afd3635dc9c45bf0cbeac46e72101: done |++++++++++++++++++++++++++++++++++++++| config-sha256:dd025cdfe837e1c6395365870a491cf16bae668218edb07d85c626928a60e478: done |++++++++++++++++++++++++++++++++++++++| elapsed: 0.5 s total: 9.3 Ki (18.1 KiB/s) 下载已上传容器镜像 # ctr images pull --plain-http harbor.kubemsb.com/library/nginx:latest 6. Containerd NameSpace管理 link containerd中namespace的作用为:隔离运行的容器，可以实现运行多个容器。\n查看命令帮助 # ctr namespace --help NAME: ctr namespaces - manage namespaces USAGE: ctr namespaces command [command options] [arguments...] COMMANDS: create, c create a new namespace list, ls list namespaces remove, rm remove one or more namespaces label set and clear labels for a namespace OPTIONS: --help, -h show help 列出已有namespace # ctr namespace ls NAME LABELS default k8s.io 创建namespace # ctr namespace create kubemsb [root@localhost ~]# ctr namespace ls NAME LABELS default k8s.io kubemsb 此命名空间为新添加的 删除namespace # ctr namespace rm kubemsb kubemsb 再次查看是否删除 [root@localhost ~]# ctr namespace ls NAME LABELS default k8s.io 查看指定namespace中是否有用户进程在运行 # ctr -n kubemsb tasks ls TASK PID STATUS 在指定namespace中下载容器镜像 # ctr -n kubemsb images pull docker.io/library/nginx:latest 在指定namespace中创建静态容器 # ctr -n kubemsb container create docker.io/library/nginx:latest nginxapp 查看在指定namespace中创建的容器 # ctr -n kubemsb container ls CONTAINER IMAGE RUNTIME nginxapp docker.io/library/nginx:latest io.containerd.runc.v2 7. Containerd Network管理 link 默认Containerd管理的容器仅有lo网络，无法访问容器之外的网络，可以为其添加网络插件，使用容器可以连接外网。CNI（Container Network Interface）\n7.1 创建CNI网络 link containernetworking/cni CNI v1.0.1 containernetworking/plugins CNI Plugins v1.0.1 7.1.1 获取CNI工具源码 link 使用wget下载cni工具源码包 # wget https://github.com/containernetworking/cni/archive/refs/tags/v1.0.1.tar.gz 查看已下载cni工具源码包 # ls v1.0.1.tar.gz 解压已下载cni工具源码包 # tar xf v1.0.1.tar.gz 查看解压后已下载cni工具源码包 # ls cni-1.0.1 重命名已下载cni工具源码包目录 # mv cni-1.0.1 cni 查看重新命名后目录 # ls cni 查看cni工具目录中包含的文件 # ls cni cnitool CONTRIBUTING.md DCO go.mod GOVERNANCE.md LICENSE MAINTAINERS plugins RELEASING.md scripts test.sh CODE-OF-CONDUCT.md CONVENTIONS.md Documentation go.sum libcni logo.png pkg README.md ROADMAP.md SPEC.md 7.1.2 获取CNI Plugins（CNI插件） link 使用wget下载cni插件工具源码包 # wget https://github.com/containernetworking/plugins/releases/download/v1.0.1/cni-plugins-linux-amd64-v1.0.1.tgz 查看已下载cni插件工具源码包 # ls cni-plugins-linux-amd64-v1.0.1.tgz cni 创建cni插件工具解压目录 # mkdir /home/cni-plugins 解压cni插件工具至上述创建的目录中 # tar xf cni-plugins-linux-amd64-v1.0.1.tgz -C /home/cni-plugins 查看解压后目录 # ls cni-plugins bandwidth bridge dhcp firewall host-device host-local ipvlan loopback macvlan portmap ptp sbr static tuning vlan vrf 7.1.3 准备CNI网络配置文件 link 准备容器网络配置文件，用于为容器提供网关、IP地址等。\n创建名为mynet的网络，其中包含名为cni0的网桥 # vim /etc/cni/net.d/10-mynet.conf # cat /etc/cni/net.d/10-mynet.conf { \"cniVersion\": \"1.0.0\", \"name\": \"mynet\", \"type\": \"bridge\", \"bridge\": \"cni0\", \"isGateway\": true, \"ipMasq\": true, \"ipam\": { \"type\": \"host-local\", \"subnet\": \"10.66.0.0/16\", \"routes\": [ { \"dst\": \"0.0.0.0/0\" } ] } } # vim /etc/cni/net.d/99-loopback.conf # cat /etc/cni/net.d/99-loopback.conf { \"cniVerion\": \"1.0.0\", \"name\": \"lo\", \"type\": \"loopback\" } 7.1.4 生成CNI网络 link 获取epel源 # wget -O /etc/yum.repos.d/epel.repo http://mirrors.aliyun.com/repo/epel-7.repo 安装jq # yum -y install jq 进入cni工具目录 # cd cni [root@localhost cni]# ls cnitool CONTRIBUTING.md DCO go.mod GOVERNANCE.md LICENSE MAINTAINERS plugins RELEASING.md scripts test.sh CODE-OF-CONDUCT.md CONVENTIONS.md Documentation go.sum libcni logo.png pkg README.md ROADMAP.md SPEC.md 必须在scripts目录中执行，需要依赖exec-plugins.sh文件，再次进入scripts目录 [root@localhost cni]# cd scripts/ 查看执行脚本文件 [root@localhost scripts]# ls docker-run.sh exec-plugins.sh priv-net-run.sh release.sh 执行脚本文件，基于/etc/cni/net.d/目录中的*.conf配置文件生成容器网络 [root@localhost scripts]# CNI_PATH=/home/cni-plugins ./priv-net-run.sh echo \"Hello World\" Hello World 在宿主机上查看是否生成容器网络名为cni0的网桥 # ip a s ...... 5: cni0: mtu 1500 qdisc noqueue state DOWN group default qlen 1000 link/ether 36:af:7a:4a:d6:12 brd ff:ff:ff:ff:ff:ff inet 10.66.0.1/16 brd 10.66.255.255 scope global cni0 valid_lft forever preferred_lft forever inet6 fe80::34af:7aff:fe4a:d612/64 scope link valid_lft forever preferred_lft forever 在宿主机上查看其路由表情况 # ip route default via 192.168.10.2 dev ens33 proto dhcp metric 100 10.66.0.0/16 dev cni0 proto kernel scope link src 10.66.0.1 192.168.10.0/24 dev ens33 proto kernel scope link src 192.168.10.164 metric 100 192.168.122.0/24 dev virbr0 proto kernel scope link src 192.168.122.1 7.2 为Containerd容器配置网络功能 link7.2.1 创建一个容器 link # ctr images ls REF TYPE DIGEST SIZE PLATFORMS LABELS # ctr images pull docker.io/library/busybox:latest # ctr run -d docker.io/library/busybox:latest busybox # ctr container ls CONTAINER IMAGE RUNTIME busybox docker.io/library/busybox:latest io.containerd.runc.v2 # ctr tasks ls TASK PID STATUS busybox 8377 RUNNING 7.2.2 进入容器查看其网络情况 link # ctr tasks exec --exec-id $RANDOM -t busybox sh / # ip a s 1: lo: mtu 65536 qdisc noqueue qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever 7.2.3 获取容器进程ID及其网络命名空间 link 在宿主机中完成指定容器进程ID获取 # pid=$(ctr tasks ls | grep busybox | awk '{print $2}') # echo $pid 8377 在宿主机中完成指定容器网络命名空间路径获取 # netnspath=/proc/$pid/ns/net # echo $netnspath /proc/8377/ns/net 7.2.4 为指定容器添加网络配置 link 确认执行脚本文件时所在的目录 [root@localhost scripts]# pwd /home/cni/scripts 执行脚本文件为容器添加网络配置 [root@localhost scripts]# CNI_PATH=/home/cni-plugins ./exec-plugins.sh add $pid $netnspath 进入容器确认是否添加网卡信息 # ctr tasks exec --exec-id $RANDOM -t busybox sh / # ip a s 1: lo: mtu 65536 qdisc noqueue qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever 2: eth0@if7: mtu 1500 qdisc noqueue link/ether a2:35:b7:e0:60:0a brd ff:ff:ff:ff:ff:ff inet 10.66.0.3/16 brd 10.66.255.255 scope global eth0 valid_lft forever preferred_lft forever inet6 fe80::a035:b7ff:fee0:600a/64 scope link valid_lft forever preferred_lft forever 在容器中ping容器宿主机IP地址 / # ping -c 2 192.168.10.164 PING 192.168.10.164 (192.168.10.164): 56 data bytes 64 bytes from 192.168.10.164: seq=0 ttl=64 time=0.132 ms 64 bytes from 192.168.10.164: seq=1 ttl=64 time=0.044 ms --- 192.168.10.164 ping statistics --- 2 packets transmitted, 2 packets received, 0% packet loss round-trip min/avg/max = 0.044/0.088/0.132 ms 在容器中ping宿主机所在网络的网关IP地址 / # ping -c 2 192.168.10.2 PING 192.168.10.2 (192.168.10.2): 56 data bytes 64 bytes from 192.168.10.2: seq=0 ttl=127 time=0.338 ms 64 bytes from 192.168.10.2: seq=1 ttl=127 time=0.280 ms --- 192.168.10.2 ping statistics --- 2 packets transmitted, 2 packets received, 0% packet loss round-trip min/avg/max = 0.280/0.309/0.338 ms 在容器中ping宿主机所在网络中的其它主机IP地址 / # ping -c 2 192.168.10.165 PING 192.168.10.165 (192.168.10.165): 56 data bytes 64 bytes from 192.168.10.165: seq=0 ttl=63 time=0.422 ms 64 bytes from 192.168.10.165: seq=1 ttl=63 time=0.908 ms --- 192.168.10.165 ping statistics --- 2 packets transmitted, 2 packets received, 0% packet loss round-trip min/avg/max = 0.422/0.665/0.908 ms 在容器中开启httpd服务 / # echo \"containerd net web test\" \u003e /tmp/index.html / # httpd -h /tmp / # wget -O - -q 127.0.0.1 containerd net web test / # exit 在宿主机访问容器提供的httpd服务 [root@localhost scripts]# curl http://10.66.0.3 containerd net web test 8. Containerd容器数据持久化存储 link 实现把宿主机目录挂载至Containerd容器中，实现容器数据持久化存储\n# ctr container create docker.io/library/busybox:latest busybox3 --mount type=bind,src=/tmp,dst=/hostdir,options=rbind:rw 说明： 创建一个静态容器，实现宿主机目录与容器挂载 src=/tmp 为宿主机目录 dst=/hostdir 为容器中目录 运行用户进程 # ctr tasks start -d busybox3 bash 进入容器，查看是否挂载成功 # ctr tasks exec --exec-id $RANDOM -t busybox3 sh / # ls /hostdir VMwareDnD systemd-private-cf1fe70805214c80867e7eb62dff5be7-bolt.service-MWV1Ju systemd-private-cf1fe70805214c80867e7eb62dff5be7-chronyd.service-6B6j8p systemd-private-cf1fe70805214c80867e7eb62dff5be7-colord.service-6fI31A systemd-private-cf1fe70805214c80867e7eb62dff5be7-cups.service-tuK4zI systemd-private-cf1fe70805214c80867e7eb62dff5be7-rtkit-daemon.service-vhP67o tracker-extract-files.0 vmware-root_703-3988031936 vmware-root_704-2990744159 vmware-root_713-4290166671 向容器中挂载目录中添加文件 / # echo \"hello world\" \u003e /hostdir/test.txt 退出容器 / # exit 在宿主机上查看被容器挂载的目录中是否添加了新的文件，已添加表明被容器挂载成功，并可以读写此目录中内容。 [root@localhost ~]# cat /tmp/test.txt hello world 9. 与其它Containerd容器共享命名空间 link 当需要与其它Containerd管理的容器共享命名空间时，可使用如下方法。\n# ctr tasks ls TASK PID STATUS busybox3 13778 RUNNING busybox 8377 RUNNING busybox1 12469 RUNNING # ctr container create --with-ns \"pid:/proc/13778/ns/pid\" docker.io/library/busybox:latest busybox4 [root@localhost ~]# ctr tasks start -d busybox4 bash [root@localhost ~]# ctr tasks exec --exec-id $RANDOM -t busybox3 sh / # ps aux PID USER TIME COMMAND 1 root 0:00 sh 20 root 0:00 sh 26 root 0:00 sh 32 root 0:00 ps aux 10. Docker集成Containerd实现容器管理 link目前Containerd主要任务还在于解决容器运行时的问题，对于其周边生态还不完善，所以可以借助Docker结合Containerd来实现Docker完整的功能应用。\n准备Docker安装YUM源 # wget -O /etc/yum.repos.d/docker-ce.repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo 安装Docker-ce # yum -y install docker-ce 修改Docker服务文件，以便使用已安装的containerd。 # vim /etc/systemd/system/multi-user.target.wants/docker.service 修改前： [Service] Type=notify # the default is not to use systemd for cgroups because the delegate issues still # exists and systemd currently does not support the cgroup feature set required # for containers run by docker ExecStart=/usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock 此处 ExecReload=/bin/kill -s HUP $MAINPID 修改后： [Service] Type=notify # the default is not to use systemd for cgroups because the delegate issues still # exists and systemd currently does not support the cgroup feature set required # for containers run by docker ExecStart=/usr/bin/dockerd --containerd /run/containerd/containerd.sock --debug 此处 ExecReload=/bin/kill -s HUP $MAINPID TimeoutSec=0 RestartSec=2 Restart=always 设置docker daemon启动并设置其开机自启动 # systemctl daemon-reload # systemctl enable docker Created symlink from /etc/systemd/system/multi-user.target.wants/docker.service to /usr/lib/systemd/system/docker.service. # systemctl start docker 查看其启动后进程 # ps aux | grep docker root 16270 0.0 3.1 1155116 63320 ? Ssl 12:09 0:00 /usr/bin/dockerd --containerd /run/containerd/containerd.sock --debug 使用docker运行容器 # docker run -d nginx:latest ...... 219a9c6727bcd162d0a4868746c513a277276a110f47e15368b4229988003c13 使用docker ps命令查看正在运行的容器 # docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 219a9c6727bc nginx:latest \"/docker-entrypoint.…\" 14 seconds ago Up 13 seconds 80/tcp happy_tu 使用ctr查看是否添加一个新的namespace，本案例中发现添加一个moby命名空间，即为docker使用的命名空间。 # ctr namespace ls NAME LABELS default k8s.io kubemsb moby 查看moby命名空间，发现使用docker run运行的容器包含在其中。 # ctr -n moby container ls CONTAINER IMAGE RUNTIME 219a9c6727bcd162d0a4868746c513a277276a110f47e15368b4229988003c13 - io.containerd.runc.v2 使用ctr能够查看到一个正在运行的容器，既表示docker run运行的容器是被containerd管理的。 # ctr -n moby tasks ls TASK PID STATUS 219a9c6727bcd162d0a4868746c513a277276a110f47e15368b4229988003c13 16719 RUNNING 使用docker stop停止且使用docker rm删除容器后再观察，发现容器被删除。 # docker stop 219;docker rm 219 219 219 # ctr -n moby container ls CONTAINER IMAGE RUNTIME # ctr -n moby tasks ls TASK PID STATUS "
            }
        );
    index.add(
            {
                id:  61 ,
                href: "\/docs\/ops\/container\/docker\/1.docker%E9%95%9C%E5%83%8F%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E5%92%8C%E4%BB%8B%E7%BB%8D\/",
                title: "1.Docker镜像基本操作和介绍",
                description: "Docker镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。",
                content: "1. Docker容器镜像操作 link1.1 查看本地容器镜像 link1.1.1 使用docker images命令查看 link # docker images REPOSITORY TAG IMAGE ID CREATED SIZE bash latest 5557e073f11c 2 weeks ago 13MB nginx latest 605c77e624dd 3 weeks ago 141MB centos latest 5d0da3dc9764 4 months ago 231MB 1.1.2 使用docker image命令查看 link # docker image list REPOSITORY TAG IMAGE ID CREATED SIZE bash latest 5557e073f11c 2 weeks ago 13MB nginx latest 605c77e624dd 3 weeks ago 141MB centos latest 5d0da3dc9764 4 months ago 231MB 1.1.3 查看docker容器镜像本地存储位置 link 考虑到docker容器镜像会占用本地存储空间，建议搭建其它存储系统挂载到本地以便解决占用大量本地存储的问题。\n# ls /var/lib/docker buildkit containers image network overlay2 plugins runtimes swarm tmp trust volumes 1.2 搜索Docker Hub容器镜像 link1.2.1 命令行搜索 link # docker search centos 输出 NAME DESCRIPTION STARS OFFICIAL AUTOMATED centos The official build of CentOS. 6987 [OK] ansible/centos7-ansible Ansible on Centos7 135 [OK] consol/centos-xfce-vnc Centos container with \"headless\" VNC session… 135 [OK] jdeathe/centos-ssh OpenSSH / Supervisor / EPEL/IUS/SCL Repos - … 121 [OK] 1.2.2 Docker Hub Web界面搜索 link 1.3 Docker 容器镜像下载 link # docker pull centos 1.4 Docker容器镜像删除方法 link # docker images REPOSITORY TAG IMAGE ID CREATED SIZE bash latest 5557e073f11c 2 weeks ago 13MB nginx latest 605c77e624dd 3 weeks ago 141MB centos latest 5d0da3dc9764 4 months ago 231MB # docker rmi centos Untagged: centos:latest Untagged: centos@sha256:a27fd8080b517143cbbbab9dfb7c8571c40d67d534bbdee55bd6c473f432b177 Deleted: sha256:5d0da3dc976460b72c77d94c8a1ad043720b0416bfc16c52c45d4847e53fadb6 Deleted: sha256:74ddd0ec08fa43d09f32636ba91a0a3053b02cb4627c35051aff89f853606b59 或\n# docker images REPOSITORY TAG IMAGE ID CREATED SIZE centos latest 5d0da3dc9764 4 months ago 231MB # docker rmi 5d0da3dc9764 2. Docker容器镜像介绍 link2.1 Docker Image link Docker 镜像是只读的容器模板，是Docker容器基础 为Docker容器提供了静态文件系统运行环境（rootfs） 是容器的静止状态 容器是镜像的运行状态 2.2 联合文件系统 link2.2.1 联合文件系统定义 link 联合文件系统(union filesystem) 联合文件系统是实现联合挂载技术的文件系统 联合挂载技术可以实现在一个挂载点同时挂载多个文件系统，将挂载点的原目录与被挂载内容进行整合，使得最终可见的文件系统包含整合之后的各层文件和目录 2.2.2 图解 link 2.3 Docker Overlay2 link容器文件系统有多种存储驱动实现方式：aufs，devicemapper，overlay，overlay2 等，本次以overlay2为例进行说明。\n2.3.1 概念 link registry/repository： registry 是 repository 的集合，repository 是镜像的集合。 image：image 是存储镜像相关的元数据，包括镜像的架构，镜像默认配置信息，镜像的容器配置信息等等。它是“逻辑”上的概念，并无物理上的镜像文件与之对应。 layer：layer(镜像层) 组成了镜像，单个 layer 可以被多个镜像共享。 2.3.2 查看Docker Host存储驱动方式 link # docker info | grep overlay Storage Driver: overlay2 2.3.3 了解images分层 link # docker pull nginx Using default tag: latest latest: Pulling from library/nginx a2abf6c4d29d: Pull complete a9edb18cadd1: Pull complete 589b7251471a: Pull complete 186b1aaa4aa6: Pull complete b4df32aa5a72: Pull complete a0bcbecc962e: Pull complete Digest: sha256:0d17b565c37bcbd895e9d92315a05c1c3c9a29f762b011a10c54a66cd53c9b31 Status: Downloaded newer image for nginx:latest docker.io/library/nginx:latest 可以看到上述下载的镜像分为6层，如何找到这6层存储在Docker Host哪个位置呢？\n首先查看nginx镜像\n# docker images REPOSITORY TAG IMAGE ID CREATED SIZE nginx latest 605c77e624dd 3 weeks ago 141MB 通过其Image ID 605c77e624dd 就可以找到存储位置\n# ls /var/lib/docker/image/overlay2/ distribution imagedb layerdb repositories.json 这个目录是查找的入口，非常重要。它存储了镜像管理的元数据。\nrepositories.json 记录了 repo 与镜像 ID 的映射关系 imagedb 记录了镜像架构，操作系统，构建镜像的容器 ID 和配置以及 rootfs 等信息 layerdb 记录了每层镜像层的元数据。 通过短 ID 查找 repositories.json 文件，找到镜像 nginx 的长 ID，通过长 ID 在 imagedb 中找到该镜像的元数据：\n# cat /var/lib/docker/image/overlay2/repositories.json | grep 605c77e624dd {\"Repositories\":\"nginx\":{\"nginx:latest\":\"sha256:605c77e624ddb75e6110f997c58876baa13f8754486b461117934b24a9dc3a85\",\"nginx@sha256:0d17b565c37bcbd895e9d92315a05c1c3c9a29f762b011a10c54a66cd53c9b31\":\"sha256:605c77e624ddb75e6110f997c58876baa13f8754486b461117934b24a9dc3a85\"}}}} # cat /var/lib/docker/image/overlay2/imagedb/content/sha256/605c77e624ddb75e6110f997c58876baa13f8754486b461117934b24a9dc3a85 ...... \"os\":\"linux\",\"rootfs\":{\"type\":\"layers\",\"diff_ids\":[\"sha256:2edcec3590a4ec7f40cf0743c15d78fb39d8326bc029073b41ef9727da6c851f\",\"sha256:e379e8aedd4d72bb4c529a4ca07a4e4d230b5a1d3f7a61bc80179e8f02421ad8\",\"sha256:b8d6e692a25e11b0d32c5c3dd544b71b1085ddc1fddad08e68cbd7fda7f70221\",\"sha256:f1db227348d0a5e0b99b15a096d930d1a69db7474a1847acbc31f05e4ef8df8c\",\"sha256:32ce5f6a5106cc637d09a98289782edf47c32cb082dc475dd47cbf19a4f866da\",\"sha256:d874fd2bc83bb3322b566df739681fbd2248c58d3369cb25908d68e7ed6040a6\"]}} 这里仅保留我们想要的元数据 rootfs。在 rootfs 中看到 layers 有6层，这6层即对应镜像的6层镜像层。并且，自上而下分别映射到容器的底层到顶层。找到了镜像的6层，接下来的问题是每层的文件内容在哪里呢？\nlayerdb 元数据会给我们想要的信息，通过底层 diff-id: 2edcec3590a4ec7f40cf0743c15d78fb39d8326bc029073b41ef9727da6c851f 我们查到最底层镜像层的 cache_id，通过 cache_id 即可查找到镜像层的文件内容：\n# ls /var/lib/docker/image/overlay2/layerdb/sha256/2edcec3590a4ec7f40cf0743c15d78fb39d8326bc029073b41ef9727da6c851f cache-id diff size tar-split.json.gz # cat /var/lib/docker/image/overlay2/layerdb/sha256/2edcec3590a4ec7f40cf0743c15d78fb39d8326bc029073b41ef9727da6c851f/cache-id 85c4c5ecdac6c0d197f899dac227b9d493911a9a5820eac501bb5e9ae361f4c7 # cat /var/lib/docker/image/overlay2/layerdb/sha256/2edcec3590a4ec7f40cf0743c15d78fb39d8326bc029073b41ef9727da6c851f/diff sha256:2edcec3590a4ec7f40cf0743c15d78fb39d8326bc029073b41ef9727da6c851f 使用 cacheID 查找文件内容\n# ls /var/lib/docker/overlay2/85c4c5ecdac6c0d197f899dac227b9d493911a9a5820eac501bb5e9ae361f4c7 committed diff link # ls /var/lib/docker/overlay2/85c4c5ecdac6c0d197f899dac227b9d493911a9a5820eac501bb5e9ae361f4c7/diff bin dev home lib64 mnt proc run srv tmp var boot etc lib media opt root sbin sys usr 上示例中，镜像元数据和镜像层内容是分开存储的。因此通过 cache-id 我们需要到 /var/lib/docker/overlay2 目录下查看镜像层内容，它就存在 diff 目录下，其中 link 存储的是镜像层对应的短 ID，后面会看到它的用场。\n找到了镜像层的最底层，接着查找镜像层的“中间层”，发现在 layerdb 目录下没有 diff-id e0379e8aedd4d72bb4c529a4ca07a4e4d230b5a1d3f7a61bc80179e8f02421ad8的镜像层：\n# ls /var/lib/docker/image/overlay2/layerdb/sha256/e379e8aedd4d72bb4c529a4ca07a4e4d230b5a1d3f7a61bc80179e8f02421ad8 ls: 无法访问/var/lib/docker/image/overlay2/layerdb/sha256/e379e8aedd4d72bb4c529a4ca07a4e4d230b5a1d3f7a61bc80179e8f02421ad8: 没有那个文件或目录 这是因为 docker 引入了内容寻址机制，该机制会根据文件内容来索引镜像和镜像层。docker 利用 rootfs 中的 diff_id 计算出内容寻址的 chainID，通过 chainID 获取 layer 相关信息，最终索引到镜像层文件内容。\n对于最底层镜像层其 diff_id 即是 chainID。因此我们可以查找到它的文件内容。除最底层外，chainID 需通过公式 chainID(n) = SHA256(chain(n-1) diffID(n)) 计算得到，计算“中间层” chainID：\n# echo -n \"sha256:2edcec3590a4ec7f40cf0743c15d78fb39d8326bc029073b41ef9727da6c851f sha256:e379e8aedd4d72bb4c529a4ca07a4e4d230b5a1d3f7a61bc80179e8f02421ad8\" | sha256sum - 780238f18c540007376dd5e904f583896a69fe620876cabc06977a3af4ba4fb5 - 根据 “中间层” chainID 查找文件内容：\n# ls /var/lib/docker/image/overlay2/layerdb/sha256/780238f18c540007376dd5e904f583896a69fe620876cabc06977a3af4ba4fb5 cache-id diff parent size tar-split.json.gz # cat /var/lib/docker/image/overlay2/layerdb/sha256/780238f18c540007376dd5e904f583896a69fe620876cabc06977a3af4ba4fb5/cache-id 57e1f1b11e26f748161b7fccbf2ba6b24c2f98dc8a821729f0be215ad267498c # cat /var/lib/docker/image/overlay2/layerdb/sha256/780238f18c540007376dd5e904f583896a69fe620876cabc06977a3af4ba4fb5/diff sha256:e379e8aedd4d72bb4c529a4ca07a4e4d230b5a1d3f7a61bc80179e8f02421ad8 # cat /var/lib/docker/image/overlay2/layerdb/sha256/780238f18c540007376dd5e904f583896a69fe620876cabc06977a3af4ba4fb5/parent sha256:2edcec3590a4ec7f40cf0743c15d78fb39d8326bc029073b41ef9727da6c851f 镜像层文件内容 # ls /var/lib/docker/overlay2/57e1f1b11e26f748161b7fccbf2ba6b24c2f98dc8a821729f0be215ad267498c committed diff link lower work # ls /var/lib/docker/overlay2/57e1f1b11e26f748161b7fccbf2ba6b24c2f98dc8a821729f0be215ad267498c/diff/ docker-entrypoint.d etc lib tmp usr var 镜像层文件内容短 ID # cat /var/lib/docker/overlay2/57e1f1b11e26f748161b7fccbf2ba6b24c2f98dc8a821729f0be215ad267498c/link 24GM2IZVPTUROAG7AWJO5ZWE6B “父”镜像层文件内容短 ID # cat /var/lib/docker/overlay2/57e1f1b11e26f748161b7fccbf2ba6b24c2f98dc8a821729f0be215ad267498c/lower l/SICZO4QNVZEVOIJ4HDXVDKNYA2 找到最底层文件内容和“中间层”文件内容，再去找最顶层文件内容就变的不难了\n2.4 Docker容器与镜像 link通过 docker run 命令启动一个镜像为 nginx的容器：\n# docker run -d nginx:latest 3272831107a3499afe8160b0cd423e2ac4223522f1995b7be3504a1d3d272878 # docker ps | grep nginx 3272831107a3 nginx:latest \"/docker-entrypoint.…\" 11 seconds ago Up 9 seconds 80/tcp angry_beaver # mount | grep overlay overlay on /var/lib/docker/overlay2/b3f5c8b42ac055c715216e376cfe44571f618a876f481533ec1434aa0bc4f8ed/merged type overlay (rw,relatime,seclabel,lowerdir=/var/lib/docker/overlay2/l/MS2X66BYF6UZ7EKUWMZJKCF4HO:/var/lib/docker/overlay2/l/ODJROQUGY3WQMOGQ3BLYZGIAG4:/var/lib/docker/overlay2/l/Q5LOBFJRH5M7M5CMSWW5L4VYOY:/var/lib/docker/overlay2/l/ZR35FN2E3WEARZV4HLRU373FT7:/var/lib/docker/overlay2/l/NSM2PTAT6TIT2H6G3HFNGZJH5N:/var/lib/docker/overlay2/l/24GM2IZVPTUROAG7AWJO5ZWE6B:/var/lib/docker/overlay2/l/SICZO4QNVZEVOIJ4HDXVDKNYA2,upperdir=/var/lib/docker/overlay2/b3f5c8b42ac055c715216e376cfe44571f618a876f481533ec1434aa0bc4f8ed/diff,workdir=/var/lib/docker/overla 2/b3f5c8b42ac055c715216e376cfe44571f618a876f481533ec1434aa0bc4f8ed/work) 可以看到，启动容器会 mount 一个 overlay 的联合文件系统到容器内。这个文件系统由三层组成：\nlowerdir：只读层，即为镜像的镜像层。 upperdir：读写层，该层是容器的读写层，对容器的读写操作将反映在读写层。 workdir： overlayfs 的内部层，用于实现从只读层到读写层的 copy_up 操作。 merge：容器内作为同一视图联合挂载点的目录。 这里需要着重介绍的是容器的 lowerdir 镜像只读层，查看只读层的短 ID：\nlowerdir=/var/lib/docker/overlay2/l/MS2X66BYF6UZ7EKUWMZJKCF4HO /var/lib/docker/overlay2/l/ODJROQUGY3WQMOGQ3BLYZGIAG4 /var/lib/docker/overlay2/l/Q5LOBFJRH5M7M5CMSWW5L4VYOY /var/lib/docker/overlay2/l/ZR35FN2E3WEARZV4HLRU373FT7 /var/lib/docker/overlay2/l/NSM2PTAT6TIT2H6G3HFNGZJH5N /var/lib/docker/overlay2/l/24GM2IZVPTUROAG7AWJO5ZWE6B /var/lib/docker/overlay2/l/SICZO4QNVZEVOIJ4HDXVDKNYA2 镜像层只有6层这里的短 ID 却有7个？ 在 /var/lib/docker/overlay2/l 目录下我们找到了答案：\n# cd /var/lib/docker/overlay2/l # pwd /var/lib/docker/overlay2/l # ls 24GM2IZVPTUROAG7AWJO5ZWE6B LZEAXJGRW6HKBBGGB2N4CWMSVJ R2XTGODAA67NQJM44MIKMDUF4W 5OI5WMJ2FP7QI7IFWDMHLBRDDN MS2X66BYF6UZ7EKUWMZJKCF4HO SICZO4QNVZEVOIJ4HDXVDKNYA2 644ISPHLTBSSC2KLP6BGHHHZPR NSM2PTAT6TIT2H6G3HFNGZJH5N ZR35FN2E3WEARZV4HLRU373FT7 6CQUILQSJNVTMFFV3ABCCOGOYG ODJROQUGY3WQMOGQ3BLYZGIAG4 BQENAYC44O2ZCZFT5URMH5OADK Q5LOBFJRH5M7M5CMSWW5L4VYOY # ls -l MS2X66BYF6UZ7EKUWMZJKCF4HO/ 总用量 0 drwxr-xr-x. 4 root root 43 1月 25 01:27 dev drwxr-xr-x. 2 root root 66 1月 25 01:27 etc [root@192 l]# ls -l ODJROQUGY3WQMOGQ3BLYZGIAG4/ 总用量 0 drwxr-xr-x. 2 root root 41 12月 30 03:28 docker-entrypoint.d [root@192 l]# ls -l Q5LOBFJRH5M7M5CMSWW5L4VYOY/ 总用量 0 drwxr-xr-x. 2 root root 41 12月 30 03:28 docker-entrypoint.d [root@192 l]# ls -l ZR35FN2E3WEARZV4HLRU373FT7/ 总用量 0 drwxr-xr-x. 2 root root 45 12月 30 03:28 docker-entrypoint.d [root@192 l]# ls -l NSM2PTAT6TIT2H6G3HFNGZJH5N/ 总用量 4 -rwxrwxr-x. 1 root root 1202 12月 30 03:28 docker-entrypoint.sh [root@192 l]# ls -l 24GM2IZVPTUROAG7AWJO5ZWE6B/ 总用量 4 drwxr-xr-x. 2 root root 6 12月 30 03:28 docker-entrypoint.d drwxr-xr-x. 18 root root 4096 12月 30 03:28 etc drwxr-xr-x. 4 root root 45 12月 20 08:00 lib drwxrwxrwt. 2 root root 6 12月 30 03:28 tmp drwxr-xr-x. 7 root root 66 12月 20 08:00 usr drwxr-xr-x. 5 root root 41 12月 20 08:00 var [root@192 l]# ls -l SICZO4QNVZEVOIJ4HDXVDKNYA2/ 总用量 12 drwxr-xr-x. 2 root root 4096 12月 20 08:00 bin drwxr-xr-x. 2 root root 6 12月 12 01:25 boot drwxr-xr-x. 2 root root 6 12月 20 08:00 dev drwxr-xr-x. 30 root root 4096 12月 20 08:00 etc drwxr-xr-x. 2 root root 6 12月 12 01:25 home drwxr-xr-x. 8 root root 96 12月 20 08:00 lib drwxr-xr-x. 2 root root 34 12月 20 08:00 lib64 drwxr-xr-x. 2 root root 6 12月 20 08:00 media drwxr-xr-x. 2 root root 6 12月 20 08:00 mnt drwxr-xr-x. 2 root root 6 12月 20 08:00 opt drwxr-xr-x. 2 root root 6 12月 12 01:25 proc drwx------. 2 root root 37 12月 20 08:00 root drwxr-xr-x. 3 root root 30 12月 20 08:00 run drwxr-xr-x. 2 root root 4096 12月 20 08:00 sbin drwxr-xr-x. 2 root root 6 12月 20 08:00 srv drwxr-xr-x. 2 root root 6 12月 12 01:25 sys drwxrwxrwt. 2 root root 6 12月 20 08:00 tmp drwxr-xr-x. 11 root root 120 12月 20 08:00 usr drwxr-xr-x. 11 root root 139 12月 20 08:00 var 镜像层ODJROQUGY3WQMOGQ3BLYZGIAG4/Q5LOBFJRH5M7M5CMSWW5L4VYOY/ZR35FN2E3WEARZV4HLRU373FT7/NSM2PTAT6TIT2H6G3HFNGZJH5N/24GM2IZVPTUROAG7AWJO5ZWE6B/SICZO4QNVZEVOIJ4HDXVDKNYA2 分别对应镜像的6层镜像层文件内容，它们分别映射到镜像层的 diff 目录。而 MS2X66BYF6UZ7EKUWMZJKCF4HO映射的是容器的初始化层 init，该层内容是和容器配置相关的文件内容，它是只读的。\n启动了容器，docker 将镜像的内容 mount 到容器中。那么，如果在容器内写文件会对镜像有什么影响呢？\n2.5 容器内写文件 link不难理解，镜像层是只读的，在容器中写文件其实是将文件写入到 overlay 的可读写层。\n这里有几个 case 可以测试：\n读写层不存在该文件，只读层存在。 读写层存在该文件，只读层不存在。 读写层和只读层都不存在该文件。 我们简单构建一种读写层和只读层都不存在的场景：\n# docker run -it centos:latest bash [root@355e99982248 /]# touch msb.txt [root@355e99982248 /]# ls bin etc lib lost+found mnt opt root sbin sys usr dev home lib64 media msb.txt proc run srv tmp var 查看读写层是否有该文件：\n查看镜像是否有变化 # docker images REPOSITORY TAG IMAGE ID CREATED SIZE ubuntu latest d13c942271d6 2 weeks ago 72.8MB bash latest 5557e073f11c 2 weeks ago 13MB nginx latest 605c77e624dd 3 weeks ago 141MB centos latest 5d0da3dc9764 4 months ago 231MB [root@localhost ~]# cat /var/lib/docker/image/overlay2/repositories.json | grep 5d0da3dc9764 {\"Repositories\"{\"centos:latest\":\"sha256:5d0da3dc976460b72c77d94c8a1ad043720b0416bfc16c52c45d4847e53fadb6\",\"centos@sha256:a27fd8080b517143cbbbab9dfb7c8571c40d67d534bbdee55bd6c473f432b177\":\"sha256:5d0da3dc976460b72c77d94c8a1ad043720b0416bfc16c52c45d4847e53fadb6\"}}} [root@localhost ~]# cat /var/lib/docker/image/overlay2/imagedb/content/sha256/5d0da3dc976460b72c77d94c8a1ad043720b0416bfc16c52c45d4847e53fadb6 {\"os\":\"linux\",\"rootfs\":{\"type\":\"layers\",\"diff_ids\":[\"sha256:74ddd0ec08fa43d09f32636ba91a0a3053b02cb4627c35051aff89f853606b59\"]}} [root@localhost ~]# ls /var/lib/docker/image/overlay2/layerdb/sha256/74ddd0ec08fa43d09f32636ba91a0a3053b02cb4627c35051aff89f853606b59: cache-id diff size tar-split.json.gz [root@localhost ~]# cat /var/lib/docker/image/overlay2/layerdb/sha256/74ddd0ec08fa43d09f32636ba91a0a3053b02cb4627c35051aff89f853606b59/cache-id b17bc5c5103514923a30983c48f909e06f366b7aa1e85f112b67abb3ef5cd0cb [root@localhost ~]# cat /var/lib/docker/image/overlay2/layerdb/sha256/74ddd0ec08fa43d09f32636ba91a0a3053b02cb4627c35051aff89f853606b59/diff sha256:74ddd0ec08fa43d09f32636ba91a0a3053b02cb4627c35051aff89f853606b59 [root@localhost ~]# ls /var/lib/docker/overlay2/b17bc5c5103514923a30983c48f909e06f366b7aa1e85f112b67abb3ef5cd0cb committed diff link [root@localhost ~]# ls /var/lib/docker/overlay2/b17bc5c5103514923a30983c48f909e06f366b7aa1e85f112b67abb3ef5cd0cb/diff/ bin etc lib lost+found mnt proc run srv tmp var dev home lib64 media opt root sbin sys usr 查看容器是否有变化 [root@localhost ~]# mount | grep overlay type overlay (rw,relatime,seclabel,lowerdir=/var/lib/docker/overlay2/l/R2W2LEMDPRIUFYDVSLIQSCYTGX:/var/lib/docker/overlay2/l/R2XTGODAA67NQJM44MIKMDUF4W,upperdir=/var/lib/docker overlay2/7f0b54c748171872ce564305e394547555cb1182abf802c2262384be3dc78a8f/diff,workdir=/var/lib/docker/overlay2/7f0b54c748171872ce564305e394547555cb1182abf802c2262384be3dc78a8f/work) [root@localhost ~]# ls -l /var/lib/docker/overlay2/l/ 总用量 0 lrwxrwxrwx. 1 root root 77 1月 25 01:41 R2W2LEMDPRIUFYDVSLIQSCYTGX -\u003e ../7f0b54c748171872ce564305e394547555cb1182abf802c2262384be3dc78a8f-init/diff lrwxrwxrwx. 1 root root 72 1月 25 00:29 R2XTGODAA67NQJM44MIKMDUF4W -\u003e ../b17bc5c5103514923a30983c48f909e06f366b7aa1e85f112b67abb3ef5cd0cb/diff [root@localhost ~]# ls /var/lib/docker/overlay2/7f0b54c748171872ce564305e394547555cb1182abf802c2262384be3dc78a8f/diff msb.txt [root@localhost ~]# ls /var/lib/docker/overlay2/7f0b54c748171872ce564305e394547555cb1182abf802c2262384be3dc78a8f/merged/ bin etc lib lost+found mnt opt root sbin sys usr dev home lib64 media msb.txt proc run srv tmp var 3. Docker容器镜像操作命令 link3.1 docker commit link上节提到容器内写文件会反映在 overlay 的可读写层，那么读写层的文件内容可以做成镜像吗？\n可以。docker 通过 commit 和 build 操作实现镜像的构建。commit 将容器提交为一个镜像，build 在一个镜像的基础上构建镜像。\n使用 commit 将上节的容器提交为一个镜像：\n[root@355e99982248 /]# ctrl+p+q # docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 355e99982248 centos:latest \"bash\" 21 minutes ago Up 21 minutes fervent_perlman # docker commit 355e99982248 sha256:8965dcf23201ed42d4904e2f10854d301ad93b34bea73f384440692e006943de # docker images REPOSITORY TAG IMAGE ID CREATED SIZE 8965dcf23201 About a minute ago 231MB image 短 ID 8965dcf23201 即为容器提交的镜像，查看镜像的 imagedb 元数据：\n# cat /var/lib/docker/image/overlay2/imagedb/content/sha256/8965dcf23201ed42d4904e2f10854d301ad93b34bea73f384440692e006943de ...... \"os\":\"linux\",\"rootfs\":{\"type\":\"layers\",\"diff_ids\":[\"sha256:74ddd0ec08fa43d09f32636ba91a0a3053b02cb4627c35051aff89f853606b59\",\"sha256:551c3089b186b4027e949910981ff1ba54114610f2aab9359d28694c18b0203b\"]}} 可以看到镜像层自上而下的前1个镜像层 diff_id 和 centos 镜像层 diff_id 是一样的，说明每层镜像层可以被多个镜像共享。而多出来的一层镜像层内容即是上节我们写入文件的内容：\n# echo -n \"sha256:74ddd0ec08fa43d09f32636ba91a0a3053b02cb4627c35051aff89f853606b59 sha256:551c3089b186b4027e949910981ff1ba54114610f2aab9359d28694c18b0203b\" | sha256sum - 92f7208b1cc0b5cc8fe214a4b0178aa4962b58af8ec535ee7211f335b1e0ed3b - # cd /var/lib/docker/image/overlay2/layerdb/sha256/92f7208b1cc0b5cc8fe214a4b0178aa4962b58af8ec535ee7211f335b1e0ed3b [root@192 92f7208b1cc0b5cc8fe214a4b0178aa4962b58af8ec535ee7211f335b1e0ed3b]# ls cache-id diff parent size tar-split.json.gz [root@192 92f7208b1cc0b5cc8fe214a4b0178aa4962b58af8ec535ee7211f335b1e0ed3b]# cat cache-id 250dc0b4f2c5f27952241a55cd4c286bfaaf8af4b77c9d0a38976df4c147cb95 [root@192 92f7208b1cc0b5cc8fe214a4b0178aa4962b58af8ec535ee7211f335b1e0ed3b]# ls /var/lib/docker/overlay2/250dc0b4f2c5f27952241a55cd4c286bfaaf8af4b77c9d0a38976df4c147cb95 diff link lower work [root@192 92f7208b1cc0b5cc8fe214a4b0178aa4962b58af8ec535ee7211f335b1e0ed3b]# ls /var/lib/docker/overlay2/250dc0b4f2c5f27952241a55cd4c286bfaaf8af4b77c9d0a38976df4c147cb95/diff msb.txt 3.2 docker save link 导出容器镜像，方便分享。\n# docker save -o centos.tar centos:latest # ls centos.tar 3.3 docker load link 把他人分享的容器镜像导入到本地，这通常是容器镜像分发方式之一。\n# docker load -i centos.tar 3.4 docker export link 把正在运行的容器导出\n# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 355e99982248 centos:latest \"bash\" 7 hours ago Up 7 hours fervent_perlman # docker export -o centos7.tar 355e99982248 # ls centos7.tar 3.5 docker import link 导入使用docker export导入的容器做为本地容器镜像。\n# ls centos7.tar # docker import centos7.tar centos7:v1 # docker images REPOSITORY TAG IMAGE ID CREATED SIZE centos7 v1 3639f9a13231 17 seconds ago 231MB 通过docker save与docker load及docker export与docker import分享容器镜像都是非常麻烦的，有没有更方便的方式分享容器镜像呢？\n"
            }
        );
    index.add(
            {
                id:  62 ,
                href: "\/docs\/ops\/container\/docker\/2.docker%E5%AE%B9%E5%99%A8%E9%95%9C%E5%83%8F%E5%9B%BD%E5%86%85%E5%8A%A0%E9%80%9F%E5%8F%8A%E6%9C%AC%E5%9C%B0%E5%AE%B9%E5%99%A8%E9%95%9C%E5%83%8F%E4%BB%93%E5%BA%93%E6%90%AD%E5%BB%BA\/",
                title: "2.Docker容器镜像国内加速及本地容器镜像仓库搭建",
                description: "众所周知的原因和解决方案",
                content: "1. 容器镜像加速器 link 由于国内访问国外的容器镜像仓库速度比较慢，因此国内企业创建了容器镜像加速器，以方便国内用户使用容器镜像。\n1.1 获取阿里云容器镜像加速地址 link 1.2 配置docker daemon使用加速器 link 添加daemon.json配置文件 # vim /etc/docker/daemon.json # cat /etc/docker/daemon.json { \"registry-mirrors\": [\"https://s27w6kze.mirror.aliyuncs.com\"] } 重启docker # systemctl daemon-reload # systemctl restart docker 尝试下载容器镜像 # docker pull centos 2. 容器镜像仓库 link2.1 docker hub link2.1.1 注册 link 准备邮箱及用户ID\n2.1.2 登录 link 2.1.3 创建容器镜像仓库 link 2.1.4 在本地登录Docker Hub link 默认可以不添加docker hub容器镜像仓库地址 # docker login Login with your Docker ID to push and pull images from Docker Hub. If you don't have a Docker ID, head over to https://hub.docker.com to create one. Username: dockersmartmsb Password: WARNING! Your password will be stored unencrypted in /root/.docker/config.json. Configure a credential helper to remove this warning. See https://docs.docker.com/engine/reference/commandline/login/#credentials-store Login Succeeded 成功 登出 # docker logout Removing login credentials for https://index.docker.io/v1/ 2.1.5 上传容器镜像 link 在登录Docker Hub主机上传容器镜像,向全球用户共享容器镜像。\n为容器镜像重新打标记 原始容器镜像 # docker images REPOSITORY TAG IMAGE ID CREATED SIZE centos latest 5d0da3dc9764 4 months ago 231MB 重新为容器镜像打标记 # docker tag centos:latest dockersmartmsb/centos:v1 重新打标记后容器镜像 # docker images REPOSITORY TAG IMAGE ID CREATED SIZE dockersmartmsb/centos v1 5d0da3dc9764 4 months ago 231MB centos latest 5d0da3dc9764 4 months ago 231MB 上传容器镜像至docker hub # docker push dockersmartmsb/centos:v1 The push refers to repository [docker.io/dockersmartmsb/centos] 74ddd0ec08fa: Mounted from library/centos v1: digest: sha256:a1801b843b1bfaf77c501e7a6d3f709401a1e0c83863037fa3aab063a7fdb9dc size: 529 2.1.6 下载容器镜像 link 在其它主机上下载 下载 # docker pull dockersmartmsb/centos:v1 v1: Pulling from dockersmartmsb/centos a1d0c7532777: Pull complete Digest: sha256:a1801b843b1bfaf77c501e7a6d3f709401a1e0c83863037fa3aab063a7fdb9dc Status: Downloaded newer image for dockersmartmsb/centos:v1 docker.io/dockersmartmsb/centos:v1 查看下载后容器镜像 # docker images REPOSITORY TAG IMAGE ID CREATED SIZE dockersmartmsb/centos v1 5d0da3dc9764 4 months ago 231MB 2.2 harbor link2.2.1 获取 docker compose二进制文件 link 下载docker-compose二进制文件 # wget https://github.com/docker/compose/releases/download/1.25.0/docker-compose-Linux-x86_64 查看已下载二进制文件 # ls docker-compose-Linux-x86_64 移动二进制文件到/usr/bin目录，并更名为docker-compose # mv docker-compose-Linux-x86_64 /usr/bin/docker-compose 为二进制文件添加可执行权限 # chmod +x /usr/bin/docker-compose 安装完成后，查看docker-compse版本 # docker-compose version docker-compose version 1.25.0, build 0a186604 docker-py version: 4.1.0 CPython version: 3.7.4 OpenSSL version: OpenSSL 1.1.0l 10 Sep 2019 2.2.2 获取harbor安装文件 link 下载harbor离线安装包 # wget https://github.com/goharbor/harbor/releases/download/v2.4.1/harbor-offline-installer-v2.4.1.tgz 查看已下载的离线安装包 # ls harbor-offline-installer-v2.4.1.tgz 2.2.3 获取TLS文件 link 查看准备好的证书 # ls kubemsb.com_nginx.zip 解压证书压缩包文件 # unzip kubemsb.com_nginx.zip Archive: kubemsb.com_nginx.zip Aliyun Certificate Download inflating: 6864844_kubemsb.com.pem inflating: 6864844_kubemsb.com.key 查看解压出的文件 # ls 6864844_kubemsb.com.key 6864844_kubemsb.com.pem 2.2.4 修改配置文件 link 解压harbor离线安装包 # tar xf harbor-offline-installer-v2.4.1.tgz 查看解压出来的目录 # ls harbor 移动证书到harbor目录 # # mv 6864844_kubemsb.com.* harbor 查看harbor目录 # ls harbor 6864844_kubemsb.com.key 6864844_kubemsb.com.pem common.sh harbor.v2.4.1.tar.gz harbor.yml.tmpl install.sh LICENSE prepare 创建配置文件 # cd harbor/ # mv harbor.yml.tmpl harbor.yml 修改配置文件内容 # vim harbor.yml # Configuration file of Harbor # The IP address or hostname to access admin UI and registry service. # DO NOT use localhost or 127.0.0.1, because Harbor needs to be accessed by external clients. hostname: www.kubemsb.com 修改为域名，而且一定是证书签发的域名 # http related config http: # port for http, default is 80. If https enabled, this port will redirect to https port port: 80 # https related config https: # https port for harbor, default is 443 port: 443 # The path of cert and key files for nginx certificate: /root/harbor/6864844_kubemsb.com.pem 证书 private_key: /root/harbor/6864844_kubemsb.com.key 密钥 # # Uncomment following will enable tls communication between all harbor components # internal_tls: # # set enabled to true means internal tls is enabled # enabled: true # # put your cert and key files on dir # dir: /etc/harbor/tls/internal # Uncomment external_url if you want to enable external proxy # And when it enabled the hostname will no longer used # external_url: https://reg.mydomain.com:8433 # The initial password of Harbor admin # It only works in first time to install harbor # Remember Change the admin password from UI after launching Harbor. harbor_admin_password: 12345 访问密码 ...... 2.2.5 执行预备脚本 link # ./prepare 输出 prepare base dir is set to /root/harbor Clearing the configuration file: /config/portal/nginx.conf Clearing the configuration file: /config/log/logrotate.conf Clearing the configuration file: /config/log/rsyslog_docker.conf Generated configuration file: /config/portal/nginx.conf Generated configuration file: /config/log/logrotate.conf Generated configuration file: /config/log/rsyslog_docker.conf Generated configuration file: /config/nginx/nginx.conf Generated configuration file: /config/core/env Generated configuration file: /config/core/app.conf Generated configuration file: /config/registry/config.yml Generated configuration file: /config/registryctl/env Generated configuration file: /config/registryctl/config.yml Generated configuration file: /config/db/env Generated configuration file: /config/jobservice/env Generated configuration file: /config/jobservice/config.yml Generated and saved secret to file: /data/secret/keys/secretkey Successfully called func: create_root_cert Generated configuration file: /compose_location/docker-compose.yml Clean up the input dir 2.2.6 执行安装脚本 link # ./install.sh 输出 [Step 0]: checking if docker is installed ... Note: docker version: 20.10.12 [Step 1]: checking docker-compose is installed ... Note: docker-compose version: 1.25.0 [Step 2]: loading Harbor images ... [Step 3]: preparing environment ... [Step 4]: preparing harbor configs ... prepare base dir is set to /root/harbor [Step 5]: starting Harbor ... Creating network \"harbor_harbor\" with the default driver Creating harbor-log ... done Creating harbor-db ... done Creating registry ... done Creating registryctl ... done Creating redis ... done Creating harbor-portal ... done Creating harbor-core ... done Creating harbor-jobservice ... done Creating nginx ... done ✔ ----Harbor has been installed and started successfully.---- 2.2.7 验证运行情况 link # docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 71c0db683e4a goharbor/nginx-photon:v2.4.1 \"nginx -g 'daemon of…\" About a minute ago Up About a minute (healthy) 0.0.0.0:80-\u003e8080/tcp, :::80-\u003e8080/tcp, 0.0.0.0:443-\u003e8443/tcp, :::443-\u003e8443/tcp nginx 4e3b53a86f01 goharbor/harbor-jobservice:v2.4.1 \"/harbor/entrypoint.…\" About a minute ago Up About a minute (healthy) harbor-jobservice df76e1eabbf7 goharbor/harbor-core:v2.4.1 \"/harbor/entrypoint.…\" About a minute ago Up About a minute (healthy) harbor-core eeb4d224dfc4 goharbor/harbor-portal:v2.4.1 \"nginx -g 'daemon of…\" About a minute ago Up About a minute (healthy) harbor-portal 70e162c38b59 goharbor/redis-photon:v2.4.1 \"redis-server /etc/r…\" About a minute ago Up About a minute (healthy) redis 8bcc0e9b06ec goharbor/harbor-registryctl:v2.4.1 \"/home/harbor/start.…\" About a minute ago Up About a minute (healthy) registryctl d88196398df7 goharbor/registry-photon:v2.4.1 \"/home/harbor/entryp…\" About a minute ago Up About a minute (healthy) registry ed5ba2ba9c82 goharbor/harbor-db:v2.4.1 \"/docker-entrypoint.…\" About a minute ago Up About a minute (healthy) harbor-db dcb4b57c7542 goharbor/harbor-log:v2.4.1 \"/bin/sh -c /usr/loc…\" About a minute ago Up About a minute (healthy) 127.0.0.1:1514-\u003e10514/tcp harbor-log 2.2.8 访问harbor UI界面 link2.2.8.1 在物理机通过浏览器访问 link 2.2.8.2 在Docker Host主机通过域名访问 link 添加域名解析 # vim /etc/hosts # cat /etc/hosts 127.0.0.1 localhost localhost.localdomain localhost4 localhost4.localdomain4 ::1 localhost localhost.localdomain localhost6 localhost6.localdomain6 192.168.10.155 www.kubemsb.com 3. docker镜像上传至Harbor及从harbor下载 link3.1 修改docker daemon使用harbor link 添加/etc/docker/daemon.json文件，默认不存在，需要手动添加 # vim /etc/docker/daemon.json # cat /etc/docker/daemon.json { \"insecure-registries\": [\"www.kubemsb.com\"] } 重启加载daemon配置 # systemctl daemon-reload 重启docker # systemctl restart docker 3.2 docker tag link 查看已有容器镜像文件 # docker images REPOSITORY TAG IMAGE ID CREATED SIZE centos latest 5d0da3dc9764 4 months ago 231MB 为已存在镜像重新添加tag # docker tag centos:latest www.kubemsb.com/library/centos:v1 再次查看本地容器镜像 # docker images REPOSITORY TAG IMAGE ID CREATED SIZE centos latest 5d0da3dc9764 4 months ago 231MB www.kubemsb.com/library/centos v1 5d0da3dc9764 4 months ago 231MB 3.3 docker push link # docker login www.kubemsb.com Username: admin 用户名 admin Password: 密码 12345 WARNING! Your password will be stored unencrypted in /root/.docker/config.json. Configure a credential helper to remove this warning. See https://docs.docker.com/engine/reference/commandline/login/#credentials-store Login Succeeded 登陆成功 推送本地容器镜像到harbor仓库 # docker push www.kubemsb.com/library/centos:v1 3.4 docker pull link 在其它主机上下载或使用harbor容器镜像仓库中的容器镜像\n在本地添加域名解析 # vim /etc/hosts # cat /etc/hosts 127.0.0.1 localhost localhost.localdomain localhost4 localhost4.localdomain4 ::1 localhost localhost.localdomain localhost6 localhost6.localdomain6 192.168.10.155 www.kubemsb.com 在本地添加/etc/docker/daemon.json文件，其中为本地主机访问的容器镜像仓库 # vim /etc/docker/daemon.json # cat /etc/docker/daemon.json { \"insecure-registries\": [\"www.kubemsb.com\"] } # systemctl daemon-reload # systemctl restart docker 下载容器镜像 # docker pull www.kubemsb.com/library/centos:v1 v1: Pulling from library/centos Digest: sha256:a1801b843b1bfaf77c501e7a6d3f709401a1e0c83863037fa3aab063a7fdb9dc Status: Downloaded newer image for www.kubemsb.com/library/centos:v1 www.kubemsb.com/library/centos:v1 查看已下载的容器镜像 # docker images REPOSITORY TAG IMAGE ID CREATED SIZE www.kubemsb.com/library/centos v1 5d0da3dc9764 4 months ago 231MB "
            }
        );
    index.add(
            {
                id:  63 ,
                href: "\/docs\/ops\/container\/docker\/3.dockerfile%E4%BB%8B%E7%BB%8D\/",
                title: "3.Dockerfile介绍",
                description: "学习制作docker镜像",
                content: "1. 容器与容器镜像之间的关系 link说到Docker管理的容器不得不说容器镜像，主要因为容器镜像是容器模板，通过容器镜像我们才能快速创建容器。\n如下图所示：\nDocker Daemon通过容器镜像创建容器。\n2. 容器镜像分类 link 操作系统类 CentOS Ubuntu 在dockerhub下载或自行制作 应用类 Tomcat Nginx MySQL Redis 3. 容器镜像获取的方法 link主要有以下几种：\n1、在DockerHub直接下载\n2、把操作系统中文件系统打包为容器镜像\n3、把正在运行的容器打包为容器镜像，即docker commit\n4、通过Dockerfile实现容器镜像的自定义及生成\n4. 容器镜像获取方法演示 link4.1 在DockerHub直接下载 link # docker pull centos:latest # docker pull nginx:latest 4.2 把操作系统中文件系统打包为容器镜像 link4.2.1 安装一个最化的操作系统 link 4.2.2 把操作系统中文件系统进行打包 link # tar --numeric-owner --exclude=/proc --exclude=/sys -cvf centos7u6.tar / 4.2.3 把打包后文件加载至本地文件系统生成本地容器镜像 link # ls centos7u6.tar # docker import centos7u6.tar centos7u6:v1 # docker images REPOSITORY TAG IMAGE ID CREATED SIZE centos7u6 v1 130cb005b2dc 7 seconds ago 1.09GB # docker run -it centos7u6:v1 bash [root@50f24f688b4d /]# ip a s 1: lo: mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever 7: eth0@if8: mtu 1500 qdisc noqueue state UP group default link/ether 02:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff link-netnsid 0 inet 172.17.0.2/16 brd 172.17.255.255 scope global eth0 valid_lft forever preferred_lft forever 4.3 把正在运行的容器打包为容器镜像 link4.3.1 运行一个容器 link # docker run -it centos7u6:v1 bash 4.3.2 在容器中安装应用 link [root@064aace45718 /]# yum -y install httpd 4.3.3 把正在运行的容器打包为容器镜像 link [root@064aace45718 /]# ctrl + p +q # docker commit 064aace45718 centos7u6-httpd:v1 # docker images REPOSITORY TAG IMAGE ID CREATED SIZE centos7u6-httpd v1 30ec9d728880 6 seconds ago 1.29GB # docker run -it centos7u6-httpd:v1 bash [root@01a1373b4a3f /]# rpm -qa | grep httpd httpd-tools-2.4.6-97.el7.centos.4.x86_64 httpd-2.4.6-97.el7.centos.4.x86_64 4.4 通过Dockerfile实现容器镜像的自定义及生成 link4.4.1 Dockerfile介绍 linkDockerfile是一种能够被Docker程序解释的剧本。Dockerfile由一条一条的指令组成，并且有自己的书写格式和支持的命令。当我们需要在容器镜像中指定自己额外的需求时，只需在Dockerfile上添加或修改指令，然后通过docker build生成我们自定义的容器镜像（image）。\n4.4.2 Dockerfile指令 link 构建类指令\n用于构建image 其指定的操作不会在运行image的容器上执行（FROM、MAINTAINER、RUN、ENV、ADD、COPY） 设置类指令\n用于设置image的属性 其指定的操作将在运行image的容器中执行（CMD、ENTRYPOINT、USER 、EXPOSE、VOLUME、WORKDIR、ONBUILD） 指令说明\n指令 描述 FROM 构建新镜像基于的基础镜像 LABEL 标签 RUN 构建镜像时运行的Shell命令 COPY 拷贝文件或目录到镜像中 ADD 解压压缩包并拷贝 ENV 设置环境变量 USER 为RUN、CMD和ENTRYPOINT执行命令指定运行用户 EXPOSE 声明容器运行的服务端口 WORKDIR 为RUN、CMD、ENTRYPOINT、COPY和ADD设置工作目录 CMD 运行容器时默认执行，如果有多个CMD指令，最后一个生效 指令详细解释 通过man docker_file可以查看到详细的说明,这里简单的翻译并列出常用的指令\n1, FROM\nFROM指令用于指定其后构建新镜像所使用的基础镜像。\nFROM指令必是Dockerfile文件中的首条命令。\nFROM指令指定的基础image可以是官方远程仓库中的，也可以位于本地仓库，优先本地仓库。\n格式:FROM : 例:FROM centos:latest 2, RUN\nRUN指令用于在构建镜像中执行命令，有以下两种格式:\nshell格式 格式:RUN \u003c命令\u003e 例:RUN echo 'kubemsb' \u003e /var/www/html/index.html exec格式 格式:RUN [\"可执行文件\", \"参数1\", \"参数2\"] 例:RUN [\"/bin/bash\", \"-c\", \"echo kubemsb \u003e /var/www/html/index.html\"] 注意: 按优化的角度来讲:当有多条要执行的命令,不要使用多条RUN,尽量使用\u0026\u0026符号与\\符号连接成一行。因为多条RUN命令会让镜像建立多层(总之就是会变得臃肿了😃)。\nRUN yum install httpd httpd-devel -y RUN echo test \u003e /var/www/html/index.html 可以改成 RUN yum install httpd httpd-devel -y \u0026\u0026 echo test \u003e /var/www/html/index.html 或者改成 RUN yum install httpd httpd-devel -y \\ \u0026\u0026 echo test \u003e /var/www/html/index.html 3, CMD\nCMD不同于RUN,CMD用于指定在容器启动时所要执行的命令,而RUN用于指定镜像构建时所要执行的命令。\n格式有三种: CMD [\"executable\",\"param1\",\"param2\"] CMD [\"param1\",\"param2\"] CMD command param1 param2 每个Dockerfile只能有一条CMD命令。如果指定了多条命令，只有最后一条会被执行。\n如果用户启动容器时候指定了运行的命令，则会覆盖掉CMD指定的命令。\n什么是启动容器时指定运行的命令? # docker run -d -p 80:80 镜像名 运行的命令 4, EXPOSE\nEXPOSE指令用于指定容器在运行时监听的端口\n格式:EXPOSE [...] 例:EXPOSE 80 3306 8080 上述运行的端口还需要使用docker run运行容器时通过-p参数映射到宿主机的端口.\n5, ENV\nENV指令用于指定一个环境变量.\n格式:ENV 或者 ENV = 例:ENV JAVA_HOME /usr/local/jdkxxxx/ 6, ADD\nADD指令用于把宿主机上的文件拷贝到镜像中\n格式:ADD 可以是一个本地文件或本地压缩文件，还可以是一个url, 如果把写成一个url，那么ADD就类似于wget命令 路径的填写可以是容器内的绝对路径，也可以是相对于工作目录的相对路径 7, COPY\nCOPY指令与ADD指令类似,但COPY的源文件只能是本地文件\n格式:COPY 8, ENTRYPOINT\nENTRYPOINT与CMD非常类似\n相同点： 一个Dockerfile只写一条，如果写了多条，那么只有最后一条生效 都是容器启动时才运行\n不同点： 如果用户启动容器时候指定了运行的命令，ENTRYPOINT不会被运行的命令覆盖，而CMD则会被覆盖\n格式有两种: ENTRYPOINT [\"executable\", \"param1\", \"param2\"] ENTRYPOINT command param1 param2 9, VOLUME\nVOLUME指令用于把宿主机里的目录与容器里的目录映射.\n只指定挂载点,docker宿主机映射的目录为自动生成的。\n格式:VOLUME [\"\"] 10, USER\nUSER指令设置启动容器的用户(像hadoop需要hadoop用户操作，oracle需要oracle用户操作),可以是用户名或UID\nUSER daemon USER 1001 注意：如果设置了容器以daemon用户去运行，那么RUN,CMD和ENTRYPOINT都会以这个用户去运行 镜像构建完成后，通过docker run运行容器时，可以通过-u参数来覆盖所指定的用户\n11, WORKDIR\nWORKDIR指令设置工作目录,类似于cd命令。不建议使用RUN cd /root ,建议使用WORKDIR\nWORKDIR /root 4.4.3 Dockerfile基本构成 link 基础镜像信息\n维护者信息\n镜像操作指令\n容器启动时执行指令\n4.4.4 Dockerfile生成容器镜像方法 link 4.4.5 Dockerfile生成容器镜像案例 link4.4.5.0 使用Dockerfile生成容器镜像步骤 link 第一步：创建一个文件夹（目录） 第二步：在文件夹（目录）中创建Dockerfile文件(并编写)及其它文件 第三步：使用`docker build`命令构建镜像 第四步：使用构建的镜像启动容器 4.4.5.1 使用Dockerfile生成Nginx容器镜像 link [root@localhost ~]# mkdir nginxroot [root@localhost ~]# cd nginxroot [root@localhost nginxroot]# [root@localhost nginxroot]# echo \"nginx's running\" \u003e\u003e index.html [root@localhost nginxroot]# ls index.html [root@localhost nginxroot]# cat index.html nginx's running [root@localhost nginxroot]# vim Dockerfile [root@localhost nginxroot]# cat Dockerfile FROM centos:centos7 MAINTAINER \"www.kubemsb.com\" RUN yum -y install wget RUN wget -O /etc/yum.repos.d/epel.repo http://mirrors.aliyun.com/repo/epel-7.repo RUN yum -y install nginx ADD index.html /usr/share/nginx/html/ RUN echo \"daemon off;\" \u003e\u003e /etc/nginx/nginx.conf EXPOSE 80 CMD /usr/sbin/nginx [root@localhost nginxroot]# docker build -t centos7-nginx:v1 . 输出： Sending build context to Docker daemon 3.072kB 第一步：下载基础镜像 Step 1/9 : FROM centos:centos7 ---\u003e eeb6ee3f44bd 第二步：维护者信息 Step 2/9 : MAINTAINER \"www.kubemsb.com\" ---\u003e Using cache ---\u003e f978e524772c 第三步：安装wget Step 3/9 : RUN yum -y install wget ---\u003e Running in 4e0fc3854088 Loaded plugins: fastestmirror, ovl Determining fastest mirrors * base: mirrors.huaweicloud.com * extras: mirrors.tuna.tsinghua.edu.cn * updates: mirrors.tuna.tsinghua.edu.cn Resolving Dependencies --\u003e Running transaction check ---\u003e Package wget.x86_64 0:1.14-18.el7_6.1 will be installed --\u003e Finished Dependency Resolution Dependencies Resolved ================================================================================ Package Arch Version Repository Size ================================================================================ Installing: wget x86_64 1.14-18.el7_6.1 base 547 k Transaction Summary ================================================================================ Install 1 Package Total download size: 547 k Installed size: 2.0 M Downloading packages: warning: /var/cache/yum/x86_64/7/base/packages/wget-1.14-18.el7_6.1.x86_64.rpm: Header V3 RSA/SHA256 Signature, key ID f4a80eb5: NOKEY Public key for wget-1.14-18.el7_6.1.x86_64.rpm is not installed Retrieving key from file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7 Importing GPG key 0xF4A80EB5: Userid : \"CentOS-7 Key (CentOS 7 Official Signing Key) \" Fingerprint: 6341 ab27 53d7 8a78 a7c2 7bb1 24c6 a8a7 f4a8 0eb5 Package : centos-release-7-9.2009.0.el7.centos.x86_64 (@CentOS) From : /etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7 Running transaction check Running transaction test Transaction test succeeded Running transaction Installing : wget-1.14-18.el7_6.1.x86_64 1/1 install-info: No such file or directory for /usr/share/info/wget.info.gz Verifying : wget-1.14-18.el7_6.1.x86_64 1/1 Installed: wget.x86_64 0:1.14-18.el7_6.1 Complete! Removing intermediate container 4e0fc3854088 ---\u003e 369e33a2152a 第四步：使用wget下载YUM源 Step 4/9 : RUN wget -O /etc/yum.repos.d/epel.repo http://mirrors.aliyun.com/repo/epel-7.repo ---\u003e Running in 4bdfc0a1c844 --2022-02-10 06:18:07-- http://mirrors.aliyun.com/repo/epel-7.repo Resolving mirrors.aliyun.com (mirrors.aliyun.com)... 221.195.209.65, 221.195.209.64, 221.195.209.70, ... Connecting to mirrors.aliyun.com (mirrors.aliyun.com)|221.195.209.65|:80... connected. HTTP request sent, awaiting response... 200 OK Length: 664 [application/octet-stream] Saving to: '/etc/yum.repos.d/epel.repo' 0K 100% 158M=0s 2022-02-10 06:18:07 (158 MB/s) - '/etc/yum.repos.d/epel.repo' saved [664/664] Removing intermediate container 4bdfc0a1c844 ---\u003e 1d73faa62447 第五步：安装Nginx Step 5/9 : RUN yum -y install nginx ---\u003e Running in 51b50c2ce841 Loaded plugins: fastestmirror, ovl Loading mirror speeds from cached hostfile * base: mirrors.huaweicloud.com * extras: mirrors.tuna.tsinghua.edu.cn * updates: mirrors.tuna.tsinghua.edu.cn Resolving Dependencies --\u003e Running transaction check ---\u003e Package nginx.x86_64 1:1.20.1-9.el7 will be installed --\u003e Processing Dependency: nginx-filesystem = 1:1.20.1-9.el7 for package: 1:nginx-1.20.1-9.el7.x86_64 --\u003e Processing Dependency: libcrypto.so.1.1(OPENSSL_1_1_0)(64bit) for package: 1:nginx-1.20.1-9.el7.x86_64 --\u003e Processing Dependency: libssl.so.1.1(OPENSSL_1_1_0)(64bit) for package: 1:nginx-1.20.1-9.el7.x86_64 --\u003e Processing Dependency: libssl.so.1.1(OPENSSL_1_1_1)(64bit) for package: 1:nginx-1.20.1-9.el7.x86_64 --\u003e Processing Dependency: nginx-filesystem for package: 1:nginx-1.20.1-9.el7.x86_64 --\u003e Processing Dependency: openssl for package: 1:nginx-1.20.1-9.el7.x86_64 --\u003e Processing Dependency: redhat-indexhtml for package: 1:nginx-1.20.1-9.el7.x86_64 --\u003e Processing Dependency: system-logos for package: 1:nginx-1.20.1-9.el7.x86_64 --\u003e Processing Dependency: libcrypto.so.1.1()(64bit) for package: 1:nginx-1.20.1-9.el7.x86_64 --\u003e Processing Dependency: libprofiler.so.0()(64bit) for package: 1:nginx-1.20.1-9.el7.x86_64 --\u003e Processing Dependency: libssl.so.1.1()(64bit) for package: 1:nginx-1.20.1-9.el7.x86_64 --\u003e Running transaction check ---\u003e Package centos-indexhtml.noarch 0:7-9.el7.centos will be installed ---\u003e Package centos-logos.noarch 0:70.0.6-3.el7.centos will be installed ---\u003e Package gperftools-libs.x86_64 0:2.6.1-1.el7 will be installed ---\u003e Package nginx-filesystem.noarch 1:1.20.1-9.el7 will be installed ---\u003e Package openssl.x86_64 1:1.0.2k-24.el7_9 will be installed --\u003e Processing Dependency: openssl-libs(x86-64) = 1:1.0.2k-24.el7_9 for package: 1:openssl-1.0.2k-24.el7_9.x86_64 --\u003e Processing Dependency: make for package: 1:openssl-1.0.2k-24.el7_9.x86_64 ---\u003e Package openssl11-libs.x86_64 1:1.1.1k-2.el7 will be installed --\u003e Running transaction check ---\u003e Package make.x86_64 1:3.82-24.el7 will be installed ---\u003e Package openssl-libs.x86_64 1:1.0.2k-19.el7 will be updated ---\u003e Package openssl-libs.x86_64 1:1.0.2k-24.el7_9 will be an update --\u003e Finished Dependency Resolution Dependencies Resolved ================================================================================ Package Arch Version Repository Size ================================================================================ Installing: nginx x86_64 1:1.20.1-9.el7 epel 587 k Installing for dependencies: centos-indexhtml noarch 7-9.el7.centos base 92 k centos-logos noarch 70.0.6-3.el7.centos base 21 M gperftools-libs x86_64 2.6.1-1.el7 base 272 k make x86_64 1:3.82-24.el7 base 421 k nginx-filesystem noarch 1:1.20.1-9.el7 epel 24 k openssl x86_64 1:1.0.2k-24.el7_9 updates 494 k openssl11-libs x86_64 1:1.1.1k-2.el7 epel 1.5 M Updating for dependencies: openssl-libs x86_64 1:1.0.2k-24.el7_9 updates 1.2 M Transaction Summary ================================================================================ Install 1 Package (+7 Dependent packages) Upgrade ( 1 Dependent package) Total download size: 26 M Downloading packages: Delta RPMs disabled because /usr/bin/applydeltarpm not installed. -------------------------------------------------------------------------------- Total 3.1 MB/s | 26 MB 00:08 Running transaction check Running transaction test Transaction test succeeded Running transaction Installing : centos-logos-70.0.6-3.el7.centos.noarch 1/10 Installing : centos-indexhtml-7-9.el7.centos.noarch 2/10 Installing : 1:make-3.82-24.el7.x86_64 3/10 Installing : gperftools-libs-2.6.1-1.el7.x86_64 4/10 Installing : 1:openssl11-libs-1.1.1k-2.el7.x86_64 5/10 Updating : 1:openssl-libs-1.0.2k-24.el7_9.x86_64 6/10 Installing : 1:openssl-1.0.2k-24.el7_9.x86_64 7/10 Installing : 1:nginx-filesystem-1.20.1-9.el7.noarch 8/10 Installing : 1:nginx-1.20.1-9.el7.x86_64 9/10 Cleanup : 1:openssl-libs-1.0.2k-19.el7.x86_64 10/10 Verifying : 1:nginx-filesystem-1.20.1-9.el7.noarch 1/10 Verifying : 1:nginx-1.20.1-9.el7.x86_64 2/10 Verifying : 1:openssl-libs-1.0.2k-24.el7_9.x86_64 3/10 Verifying : 1:openssl11-libs-1.1.1k-2.el7.x86_64 4/10 Verifying : gperftools-libs-2.6.1-1.el7.x86_64 5/10 Verifying : 1:make-3.82-24.el7.x86_64 6/10 Verifying : 1:openssl-1.0.2k-24.el7_9.x86_64 7/10 Verifying : centos-indexhtml-7-9.el7.centos.noarch 8/10 Verifying : centos-logos-70.0.6-3.el7.centos.noarch 9/10 Verifying : 1:openssl-libs-1.0.2k-19.el7.x86_64 10/10 Installed: nginx.x86_64 1:1.20.1-9.el7 Dependency Installed: centos-indexhtml.noarch 0:7-9.el7.centos centos-logos.noarch 0:70.0.6-3.el7.centos gperftools-libs.x86_64 0:2.6.1-1.el7 make.x86_64 1:3.82-24.el7 nginx-filesystem.noarch 1:1.20.1-9.el7 openssl.x86_64 1:1.0.2k-24.el7_9 openssl11-libs.x86_64 1:1.1.1k-2.el7 Dependency Updated: openssl-libs.x86_64 1:1.0.2k-24.el7_9 Complete! Removing intermediate container 51b50c2ce841 ---\u003e 88a7d7a2c522 第六步：添加文件至容器 Step 6/9 : ADD index.html /usr/share/nginx/html/ ---\u003e a2226a4d6720 第七步：设置nginx服务运行方式 Step 7/9 : RUN echo \"daemon off;\" \u003e\u003e /etc/nginx/nginx.conf ---\u003e Running in 01d623937807 Removing intermediate container 01d623937807 ---\u003e 53fddea5b491 第八步：暴露端口 Step 8/9 : EXPOSE 80 ---\u003e Running in 9b73fcf7ee1b Removing intermediate container 9b73fcf7ee1b ---\u003e 903377216b23 第九步：运行命令，执行nginx二进制文件 Step 9/9 : CMD /usr/sbin/nginx ---\u003e Running in 58037652952c Removing intermediate container 58037652952c ---\u003e 944d27b80f1f 生成镜像，并为镜像打标记： Successfully built 944d27b80f1f Successfully tagged centos7-nginx:v1 [root@localhost nginxroot]# docker images REPOSITORY TAG IMAGE ID CREATED SIZE centos7-nginx v1 944d27b80f1f 3 minutes ago 587MB [root@localhost ~]# docker run -d -p 8081:80 centos7-nginx:v1 [root@localhost ~]# curl http://localhost:8081 nginx's running 4.4.5.2 使用Dockerfile生成Tomcat容器镜像 link [root@localhost ~]# mkdir tomcatdir [root@localhost ~]# cd tomcatdir/ [root@localhost tomcatdir]# [root@localhost tomcatdir]# echo \"tomcat is running\" \u003e\u003e index.html [root@localhost tomcatdir]# ls Dockerfile jdk index.html jdk为目录 index.html 网站首页 [root@localhost tomcatdir]# vim Dockerfile [root@localhost tomcatdir]# cat Dockerfile FROM centos:centos7 MAINTAINER \"www.kubemsb.com\" ENV VERSION=8.5.75 ENV JAVA_HOME=/usr/local/jdk ENV TOMCAT_HOME=/usr/local/tomcat RUN yum -y install wget RUN wget https://dlcdn.apache.org/tomcat/tomcat-8/v${VERSION}/bin/apache-tomcat-${VERSION}.tar.gz RUN tar xf apache-tomcat-${VERSION}.tar.gz RUN mv apache-tomcat-${VERSION} /usr/local/tomcat RUN rm -rf apache-tomcat-${VERSION}.tar.gz /usr/local/tomcat/webapps/* RUN mkdir /usr/local/tomcat/webapps/ROOT ADD ./index.html /usr/local/tomcat/webapps/ROOT/ ADD ./jdk /usr/local/jdk RUN echo \"export TOMCAT_HOME=/usr/local/tomcat\" \u003e\u003e /etc/profile RUN echo \"export JAVA_HOME=/usr/local/jdk\" \u003e\u003e /etc/profile RUN echo \"export PATH=${TOMCAT_HOME}/bin:${JAVA_HOME}/bin:$PATH\" \u003e\u003e /etc/profile RUN echo \"export CLASSPATH=.:${JAVA_HOME}/lib/dt.jar:${JAVA_HOME}/lib/tools.jar\" \u003e\u003e /etc/profile RUN source /etc/profile EXPOSE 8080 CMD [\"/usr/local/tomcat/bin/catalina.sh\",\"run\"] [root@localhost tomcatdir]# docker build -t centos-tomcat:v1 . Sending build context to Docker daemon 398.9MB Step 1/20 : FROM centos:centos7 ---\u003e eeb6ee3f44bd Step 2/20 : MAINTAINER \"www.kubemsb.com\" ---\u003e Using cache ---\u003e f978e524772c Step 3/20 : ENV VERSION=8.5.75 ---\u003e Using cache ---\u003e 792767bbdb22 Step 4/20 : ENV JAVA_HOME=/usr/local/jdk ---\u003e Using cache ---\u003e 6eb3855650f0 Step 5/20 : ENV TOMCAT_HOME=/usr/local/tomcat ---\u003e Using cache ---\u003e e38bdbbfd19d Step 6/20 : RUN yum -y install wget ---\u003e Using cache ---\u003e 4c6aafa6d8ba Step 7/20 : RUN wget http://dlcdn.apache.org/tomcat/tomcat-8/v${VERSION}/bin/apache-tomcat-${VERSION}.tar.gz ---\u003e Using cache ---\u003e 9bdb6f636a5f Step 8/20 : RUN tar xf apache-tomcat-${VERSION}.tar.gz ---\u003e Using cache ---\u003e 6abe5cb0ef26 Step 9/20 : RUN mv apache-tomcat-${VERSION} /usr/local/tomcat ---\u003e Using cache ---\u003e b3907af15c22 Step 10/20 : RUN rm -rf apache-tomcat-${VERSION}.tar.gz /usr/local/tomcat/webapps/* ---\u003e Using cache ---\u003e b775439344e3 Step 11/20 : RUN mkdir /usr/local/tomcat/webapps/ROOT ---\u003e Using cache ---\u003e 149ad46776eb Step 12/20 : ADD ./index.html /usr/local/tomcat/webapps/ROOT/ ---\u003e 064579c39a46 Step 13/20 : ADD ./jdk /usr/local/jdk ---\u003e 477fd38dfbcf Step 14/20 : RUN echo \"export TOMCAT_HOME=/usr/local/tomcat\" \u003e\u003e /etc/profile ---\u003e Running in 3fc9bc5e8ba5 Removing intermediate container 3fc9bc5e8ba5 ---\u003e 3c43bccd5779 Step 15/20 : RUN echo \"export JAVA_HOME=/usr/local/jdk\" \u003e\u003e /etc/profile ---\u003e Running in 80f8150f0e80 Removing intermediate container 80f8150f0e80 ---\u003e e01307ccb02a Step 16/20 : RUN echo \"export PATH=${TOMCAT_HOME}/bin:${JAVA_HOME}/bin:$PATH\" \u003e\u003e /etc/profile ---\u003e Running in 92a6a4fd1cbc Removing intermediate container 92a6a4fd1cbc ---\u003e 1d26f53b7095 Step 17/20 : RUN echo \"export CLASSPATH=.:${JAVA_HOME}/lib/dt.jar:${JAVA_HOME}/lib/tools.jar\" \u003e\u003e /etc/profile ---\u003e Running in fb5ee1710c36 Removing intermediate container fb5ee1710c36 ---\u003e d2eaff35dce3 Step 18/20 : RUN source /etc/profile ---\u003e Running in 0422af810b35 Removing intermediate container 0422af810b35 ---\u003e fc6d285288ca Step 19/20 : EXPOSE 8080 ---\u003e Running in eeb64d4f9e94 Removing intermediate container eeb64d4f9e94 ---\u003e 05ec1c6d06cf Step 20/20 : CMD [\"/usr/local/tomcat/bin/catalina.sh\",\"run\"] ---\u003e Running in 66b7851e2772 Removing intermediate container 66b7851e2772 ---\u003e ad338289055c Successfully built ad338289055c Successfully tagged centos-tomcat:v1 # docker images REPOSITORY TAG IMAGE ID CREATED SIZE centos-tomcat v1 ad338289055c 6 minutes ago 797MB # docker run -d -p 8082:8080 centos-tomcat:v1 # curl http://localhost:8082 tomcat is running 4.4.6 使用Dockerfile生成容器镜像优化 link4.4.6.1 减少镜像分层 linkDockerfile中包含多种指令，如果涉及到部署最多使用的算是RUN命令了，使用RUN命令时，不建议每次安装都使用一条单独的RUN命令，可以把能够合并安装指令合并为一条，这样就可以减少镜像分层。\nFROM centos:latest MAINTAINER www.kubemsb.com RUN yum install epel-release -y RUN yum install -y gcc gcc-c++ make -y RUN wget http://docs.php.net/distributions/php-5.6.36.tar.gz RUN tar zxf php-5.6.36.tar.gz RUN cd php-5.6.36 RUN ./configure --prefix=/usr/local/php RUN make -j 4 RUN make install EXPOSE 9000 CMD [\"php-fpm\"] 优化内容如下：\nFROM centos:latest MAINTAINER www.kubemsb.com RUN yum install epel-release -y \u0026\u0026 \\ yum install -y gcc gcc-c++ make RUN wget http://docs.php.net/distributions/php-5.6.36.tar.gz \u0026\u0026 \\ tar zxf php-5.6.36.tar.gz \u0026\u0026 \\ cd php-5.6.36 \u0026\u0026 \\ ./configure --prefix=/usr/local/php \u0026\u0026 \\ make -j 4 \u0026\u0026 make install EXPOSE 9000 CMD [\"php-fpm\"] 4.4.6.2 清理无用数据 link 一次RUN形成新的一层，如果没有在同一层删除，无论文件是否最后删除，都会带到下一层，所以要在每一层清理对应的残留数据，减小镜像大小。 把生成容器镜像过程中部署的应用软件包做删除处理 FROM centos:latest MAINTAINER www.kubemsb.com RUN yum install epel-release -y \u0026\u0026 \\ yum install -y gcc gcc-c++ make gd-devel libxml2-devel \\ libcurl-devel libjpeg-devel libpng-devel openssl-devel \\ libmcrypt-devel libxslt-devel libtidy-devel autoconf \\ iproute net-tools telnet wget curl \u0026\u0026 \\ yum clean all \u0026\u0026 \\ rm -rf /var/cache/yum/* RUN wget http://docs.php.net/distributions/php-5.6.36.tar.gz \u0026\u0026 \\ tar zxf php-5.6.36.tar.gz \u0026\u0026 \\ cd php-5.6.36 \u0026\u0026 \\ ./configure --prefix=/usr/local/php \\ make -j 4 \u0026\u0026 make install \u0026\u0026 \\ cd / \u0026\u0026 rm -rf php* 4.4.6.3 多阶段构建镜像 link项目容器镜像有两种，一种直接把项目代码复制到容器镜像中，下次使用容器镜像时即可直接启动；另一种把需要对项目源码进行编译，再复制到容器镜像中使用。\n不论是哪种方法都会让制作镜像复杂了些，并也会让容器镜像比较大，建议采用分阶段构建镜像的方法实现。\n$ git clone https://github.com/kubemsb/tomcat-java-demo $ cd tomcat-java-demo $ vi Dockerfile FROM maven AS build ADD ./pom.xml pom.xml ADD ./src src/ RUN mvn clean package FROM kubemsb/tomcat RUN rm -rf /usr/local/tomcat/webapps/ROOT COPY --from=build target/*.war /usr/local/tomcat/webapps/ROOT.war $ docker build -t demo:v1 . $ docker container run -d -v demo:v1 第一个 FROM 后边多了个 AS 关键字，可以给这个阶段起个名字 第二个 FROM 使用上面构建的 Tomcat 镜像，COPY 关键字增加了 —from 参数，用于拷贝某个阶段的文件到当前阶段。 "
            }
        );
    index.add(
            {
                id:  64 ,
                href: "\/docs\/ops\/1.nginx%E9%85%8D%E7%BD%AE%E5%B0%8F%E5%85%A8\/",
                title: "1.Nginx配置小全",
                description: "Nginx是一款自由的、开源的、高性能的HTTP服务器和反向代理服务器；",
                content: "安装 nginx link下载 nginx 的压缩包文件到根目录，官网下载地址：nginx.org/download/nginx-x.xx.xx.tar.gz\nyum update #更新系统软件 cd / wget nginx.org/download/nginx-1.17.2.tar.gz 解压tar.gz压缩包文件，进去 nginx-1.17.2\ntar -xzvf nginx-1.17.2.tar.gz cd nginx-1.17.2 进入文件夹后进行配置检查\n通过安装前的配置检查，发现有报错。检查中发现一些依赖库没有找到，这时候需要先安装nginx的一些依赖库\nyum -y install pcre* #安装使nginx支持rewrite yum -y install gcc-c++ yum -y install zlib* yum -y install openssl openssl-devel 再次进行检查操作 ./configure 没发现报错显示，接下来进行编译并安装的操作\n// 检查模块支持 ./configure --prefix=/usr/local/nginx --with-http_ssl_module --with-http_v2_module --with-http_realip_module --with-http_addition_module --with-http_sub_module --with-http_dav_module --with-http_flv_module --with-http_mp4_module --with-http_gunzip_module --with-http_gzip_static_module --with-http_auth_request_module --with-http_random_index_module --with-http_secure_link_module --with-http_degradation_module --with-http_slice_module --with-http_stub_status_module --with-mail --with-mail_ssl_module --with-stream --with-stream_ssl_module --with-stream_realip_module --with-stream_ssl_preread_module --with-threads --user=www --group=www 这里得特别注意下，你以后需要用到的功能模块是否存在，不然以后添加新的包会比较麻烦。\n查看默认安装的模块支持\n命令 ls nginx-1.17.2 查看 nginx 的文件列表，可以发现里面有一个 auto 的目录。\n在这个 auto 目录中有一个 options 文件，这个文件里面保存的就是 nginx 编译过程中的所有选项配置。\n通过命令：cat nginx-1.17.2/auto/options | grep YES就可以查看\nnginx 编译安装时，怎么查看安装模块 (opens new window)\n编译并安装\n这里需要注意，模块的支持跟后续的nginx配置有关，比如 SSL，gzip 压缩等等，编译安装前最好检查需要配置的模块存不存在。\n查看 nginx 安装后在的目录，可以看到已经安装到 /usr/local/nginx 目录了\nwhereis nginx $nginx: /usr/local/nginx 启动 nginx 服务\ncd /usr/local/nginx/sbin/ ./nginx 服务启动的时候报错了：nginx: [emerg] bind() to 0.0.0.0:80 failed (98: Address already in use) ，通过命令查看本机网络地址和端口等一些信息，找到被占用的 80 端口 netstat -ntpl 的 tcp 连接，并杀死进程(kill 进程 pid)\nnetstat -ntpl kill 进程PID 继续启动 nginx 服务，启动成功\n在浏览器直接访问 ip 地址，页面出现 Welcome to Nginx! 则安装成功。\nnginx 配置 link基本结构 link main # 全局配置，对全局生效 ├── events # 配置影响 nginx 服务器或与用户的网络连接 ├── http # 配置代理，缓存，日志定义等绝大多数功能和第三方模块的配置 │ ├── upstream # 配置后端服务器具体地址，负载均衡配置不可或缺的部分 │ ├── server # 配置虚拟主机的相关参数，一个 http 块中可以有多个 server 块 │ ├── server │ │ ├── location # server 块可以包含多个 location 块，location 指令用于匹配 uri │ │ ├── location │ │ └── ... │ └── ... └── ... 主要配置含义 link main:nginx 的全局配置，对全局生效。 events:配置影响 nginx 服务器或与用户的网络连接。 http：可以嵌套多个 server，配置代理，缓存，日志定义等绝大多数功能和第三方模块的配置。 server：配置虚拟主机的相关参数，一个 http 中可以有多个server。 location：配置请求的路由，以及各种页面的处理情况。 upstream：配置后端服务器具体地址，负载均衡配置不可或缺的部分。 nginx.conf 配置文件的语法规则 link 配置文件由指令与指令块构成 每条指令以 “;” 分号结尾，指令与参数间以空格符号分隔 指令块以 {} 大括号将多条指令组织在一起 include 语句允许组合多个配置文件以提升可维护性 通过 # 符号添加注释，提高可读性 通过 $ 符号使用变量 部分指令的参数支持正则表达式，例如常用的 location 指令 内置变量 linknginx 常用的内置全局变量，你可以在配置中随意使用：\nTCP UDP $host 请求信息中的 Host，如果请求中没有 Host 行，则等于设置的服务器名 $request_method 客户端请求类型，如 GET、POST $remote_addr 客户端的 IP 地址 $args 请求中的参数 $content_length 请求头中的 Content-length 字段 $http_user_agent 客户端 agent 信息 $http_cookie 客户端cookie信息 $remote_port 客户端的端口 $server_protocol 请求使用的协议，如 HTTP/1.1 $server_addr 服务器地址 $server_name 服务器名称 $server_port 服务器的端口号 常用命令 link这里列举几个常用的命令：\nnginx -s reload # 向主进程发送信号，重新加载配置文件，热重启 nginx -s reopen # 重启 Nginx nginx -s stop # 快速关闭 nginx -s quit # 等待工作进程处理完成后关闭 nginx -T # 查看当前 Nginx 最终的配置 nginx -t -c \u003c配置路径\u003e # 检查配置是否有问题，如果已经在配置目录，则不需要 -c 以上命令通过 nginx -h 就可以查看到，还有其它不常用这里未列出。\nLinux 系统应用管理工具 systemd 关于 nginx 的常用命令：\nsystemctl start nginx # 启动 Nginx systemctl stop nginx # 停止 Nginx systemctl restart nginx # 重启 Nginx systemctl reload nginx # 重新加载 Nginx，用于修改配置后 systemctl enable nginx # 设置开机启动 Nginx systemctl disable nginx # 关闭开机启动 Nginx systemctl status nginx # 查看 Nginx 运行状态 配置 nginx 开机自启 link利用 systemctl 命令：\n如果用 yum install 命令安装的 nginx，yum 命令会自动创建 nginx.service 文件，直接用命令:\nsystemctl enable nginx # 设置开机启动 Nginx systemctl disable nginx # 关闭开机启动 Nginx 就可以设置开机自启，否则需要在系统服务目录里创建 nginx.service 文件。\n创建并打开 nginx.service 文件：\nvi /lib/systemd/system/nginx.service 内容如下：\n[Unit] Description=nginx After=network.target [Service] Type=forking ExecStart=/usr/local/nginx/sbin/nginx ExecReload=/usr/local/nginx/sbin/nginx -s reload ExecStop=/usr/local/nginx/sbin/nginx -s quit PrivateTmp=true [Install] WantedBy=multi-user.target :wq 保存退出，运行 systemctl daemon-reload 使文件生效。\n这样便可以通过以下命令操作 nginx 了：\nsystemctl start nginx.service # 启动nginx服务 systemctl enable nginx.service # 设置开机启动 systemctl disable nginx.service # 停止开机自启动 systemctl status nginx.service　# 查看服务当前状态 systemctl restart nginx.service # 重新启动服务 systemctl is-enabled nginx.service #查询服务是否开机启动 通过开机启动命令脚本实现开机自启\n创建开机启动命令脚本文件：\n在这个 nginx 文件中插入一下启动脚本代码，启动脚本代码来源网络复制，实测有效：\n#! /bin/bash # chkconfig: - 85 15 PATH=/usr/local/nginx DESC=\"nginx daemon\" NAME=nginx DAEMON=$PATH/sbin/$NAME CONFIGFILE=$PATH/conf/$NAME.conf PIDFILE=$PATH/logs/$NAME.pid scriptNAME=/etc/init.d/$NAME set -e [ -x \"$DAEMON\" ] || exit 0 do_start() { $DAEMON -c $CONFIGFILE || echo -n \"nginx already running\" } do_stop() { $DAEMON -s stop || echo -n \"nginx not running\" } do_reload() { $DAEMON -s reload || echo -n \"nginx can't reload\" } case \"$1\" in start) echo -n \"Starting $DESC: $NAME\" do_start echo \".\" ;; stop) echo -n \"Stopping $DESC: $NAME\" do_stop echo \".\" ;; reload|graceful) echo -n \"Reloading $DESC configuration...\" do_reload echo \".\" ;; restart) echo -n \"Restarting $DESC: $NAME\" do_stop do_start echo \".\" ;; *) echo \"Usage: $scriptNAME {start|stop|reload|restart}\" \u003e\u00262 exit 3 ;; esac exit 0 设置所有人都有对这个启动脚本 nginx 文件的执行权限：\nchmod a+x /etc/init.d/nginx 把nginx加入系统服务中：\n把服务设置为开机启动：\nreboot 重启系统生效，可以使用上面 systemctl 方法相同的命令：\nsystemctl start nginx.service # 启动nginx服务 systemctl enable nginx.service # 设置开机启动 systemctl disable nginx.service # 停止开机自启动 systemctl status nginx.service　# 查看服务当前状态 systemctl restart nginx.service # 重新启动服务 systemctl is-enabled nginx.service #查询服务是否开机启动 如果服务启动的时候出现 Restarting nginx daemon: nginxnginx: [error] open() \"/usr/local/nginx/logs/nginx.pid\" failed (2: No such file or directory) nginx not running 的错误，通过nginx -c 参数指定配置文件即可解决\n/usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf 如果服务启动中出现 nginx: [emerg] bind() to 0.0.0.0:80 failed (98: Address already in use) 的错误，可以先通过 service nginx stop 停止服务，再启动就好。\n配置 nginx 全局可用 link当你每次改了 nginx.conf 配置文件的内容都需要重新到 nginx 启动目录去执行命令，或者通过 -p 参数指向特定目录，会不会感觉很麻烦？\n例如： 直接执行 nginx -s reload 会报错 -bash: nginx: command not found，需要到 /usr/local/nginx/sbin 目录下面去执行，并且是执行 ./nginx -s reload。\n这里有两种方式可以解决，一种是通过脚本对 nginx 命令包装，这里介绍另外一种比较简单：通过把 nginx 配置到环境变量里，用 nginx 执行指令即可。步骤如下：\n1、编辑 /etc/profile\n2、在最后一行添加配置，:wq 保存\nexport PATH=$PATH:/usr/local/nginx/sbin 3、使配置立即生效\n这样就可以愉快的直接在全局使用 nginx 命令了。\nnginx 常用功能 link反向代理 link我们最常说的反向代理的是通过反向代理解决跨域问题。\n其实反向代理还可以用来控制缓存（代理缓存 proxy cache），进行访问控制等等，以及后面说的负载均衡其实都是通过反向代理来实现的。\nserver { listen 8080; # 用户访问 ip:8080/test 下的所有路径代理到 github location /test { proxy_pass https://github.com; } # 所有 /api 下的接口访问都代理到本地的 8888 端口 # 例如你本地运行的 java 服务的端口是 8888，接口都是以 /api 开头 location /api { proxy_pass http://127.0.0.1:8888; } } 访问控制 link server { location ~ ^/index.html { # 匹配 index.html 页面 除了 127.0.0.1 以外都可以访问 deny 192.168.1.1; deny 192.168.1.2; allow all; } } 上面的命令表示禁止 192.168.1.1 和 192.168.1.2 两个 ip 访问，其它全部允许。从上到下的顺序，匹配到了便跳出，可以按你的需求设置。\n负载均衡 link通过负载均衡充利用服务器资源，nginx 目前支持自带 4 种负载均衡策略，还有 2 种常用的第三方策略。\n轮询策略（默认）\n每个请求按时间顺序逐一分配到不同的后端服务器，如果有后端服务器挂掉，能自动剔除。但是如果其中某一台服务器压力太大，出现延迟，会影响所有分配在这台服务器下的用户。\nhttp { upstream test.com { server 192.168.1.12:8887; server 192.168.1.13:8888; } server { location /api { proxy_pass http://test.com; } } } 根据服务器权重\n例如要配置：10 次请求中大概 1 次访问到 8888 端口，9 次访问到 8887 端口：\nhttp { upstream test.com { server 192.168.1.12:8887 weight=9; server 192.168.1.13:8888 weight=1; } server { location /api { proxy_pass http://test.com; } } } 客户端 ip 绑定（ip_hash）\n来自同一个 ip 的请求永远只分配一台服务器，有效解决了动态网页存在的 session 共享问题。例如：比如把登录信息保存到了 session 中，那么跳转到另外一台服务器的时候就需要重新登录了。\n所以很多时候我们需要一个客户只访问一个服务器，那么就需要用 ip_hash 了。\nhttp { upstream test.com { ip_hash; server 192.168.1.12:8887; server 192.168.1.13:8888; } server { location /api { proxy_pass http://test.com; } } } 最小连接数策略\n将请求优先分配给压力较小的服务器，它可以平衡每个队列的长度，并避免向压力大的服务器添加更多的请求。\nhttp { upstream test.com { least_conn; server 192.168.1.12:8887; server 192.168.1.13:8888; } server { location /api { proxy_pass http://test.com; } } } 最快响应时间策略（依赖于第三方 NGINX Plus）\n依赖于 NGINX Plus，优先分配给响应时间最短的服务器。\nhttp { upstream test.com { fair; server 192.168.1.12:8887; server 192.168.1.13:8888; } server { location /api { proxy_pass http://test.com; } } } 按访问url的hash结果（第三方）\n按访问 url 的 hash 结果来分配请求，使每个 url 定向到同一个后端服务器，后端服务器为缓存时比较有效。 在 upstream 中加入 hash 语句，server 语句中不能写入 weight 等其他的参数，hash_method 是使用的 hash 算法\nhttp { upstream test.com { hash $request_uri; hash_method crc32; server 192.168.1.12:8887; server 192.168.1.13:8888; } server { location /api { proxy_pass http://test.com; } } } 采用 HAproxy 的 loadbalance uri 或者 nginx 的 upstream_hash 模块，都可以做到针对 url 进行哈希算法式的负载均衡转发。\ngzip 压缩 link开启 gzip 压缩可以大幅减少 http 传输过程中文件的大小，可以极大的提高网站的访问速度，基本是必不可少的优化操作：\ngzip on; # 开启gzip 压缩 # gzip_types # gzip_static on; # gzip_proxied expired no-cache no-store private auth; # gzip_buffers 16 8k; gzip_min_length 1k; gzip_comp_level 4; gzip_http_version 1.0; gzip_vary off; gzip_disable \"MSIE [1-6]\\.\"; 解释一下：\ngzip_types：要采用 gzip 压缩的 MIME 文件类型，其中 text/html 被系统强制启用； gzip_static：默认 off，该模块启用后，Nginx 首先检查是否存在请求静态文件的 gz 结尾的文件，如果有则直接返回该 .gz 文件内容； gzip_proxied：默认 off，nginx 做为反向代理时启用，用于设置启用或禁用从代理服务器上收到相应内容 gzip 压缩； gzip_buffers：获取多少内存用于缓存压缩结果，16 8k 表示以 8k*16 为单位获得； gzip_min_length：允许压缩的页面最小字节数，页面字节数从 header 头中的 Content-Length 中进行获取。默认值是 0，不管页面多大都压缩。建议设置成大于 1k 的字节数，小于 1k 可能会越压越大； gzip_comp_level：gzip 压缩比，压缩级别是 1-9，1 压缩级别最低，9 最高，级别越高压缩率越大，压缩时间越长，建议 4-6； gzip_http_version：默认 1.1，启用 gzip 所需的 HTTP 最低版本； gzip_vary：用于在响应消息头中添加 Vary：Accept-Encoding，使代理服务器根据请求头中的 Accept-Encoding 识别是否启用 gzip 压缩； gzip_disable 指定哪些不需要 gzip 压缩的浏览器 其中第 2 点，普遍是结合前端打包的时候打包成 gzip 文件后部署到服务器上，这样服务器就可以直接使用 gzip 的文件了，并且可以把压缩比例提高，这样 nginx 就不用压缩，也就不会影响速度。一般不追求极致的情况下，前端不用做任何配置就可以使用啦~\n附前端 webpack 开启 gzip 压缩配置，在 vue-cli3 的 vue.config.js 配置文件中： const CompressionWebpackPlugin = require('compression-webpack-plugin') module.exports = { // gzip 配置 configureWebpack: config =\u003e { if (process.env.NODE_ENV === 'production') { // 生产环境 return { plugins: [new CompressionWebpackPlugin({ test: /\\.js$|\\.html$|\\.css/, // 匹配文件名 threshold: 1024, // 文件压缩阈值，对超过 1k 的进行压缩 deleteOriginalAssets: false // 是否删除源文件 })] } } }, ... } HTTP服务器 linknginx 本身也是一个静态资源的服务器，当只有静态资源的时候，就可以使用 nginx 来做服务器：\nserver { listen 80; server_name localhost; location / { root /usr/local/app; index index.html; } } 这样如果访问 http://ip 就会默认访问到 /usr/local/app 目录下面的 index.html，如果一个网站只是静态页面的话，那么就可以通过这种方式来实现部署，比如一个静态官网。\n动静分离 link就是把动态和静态的请求分开。方式主要有两种：\n一种是纯粹把静态文件独立成单独的域名，放在独立的服务器上，也是目前主流推崇的方案 一种方法就是动态跟静态文件混合在一起发布， 通过 nginx 配置来分开 # 所有静态请求都由nginx处理，存放目录为 html location ~ \\.(gif|jpg|jpeg|png|bmp|swf|css|js)$ { root /usr/local/resource; expires 10h; # 设置过期时间为10小时 } # 所有动态请求都转发给 tomcat 处理 location ~ \\.(jsp|do)$ { proxy_pass 127.0.0.1:8888; } 注意上面设置了 expires，当 nginx 设置了 expires 后，例如设置为：expires 10d; 那么，所在的 location 或 if 的内容，用户在 10 天内请求的时候，都只会访问浏览器中的缓存，而不会去请求 nginx 。\n请求限制 link对于大流量恶意的访问，会造成带宽的浪费，给服务器增加压力。可以通过 nginx 对于同一 IP 的连接数以及并发数进行限制。合理的控制还可以用来防止 DDos 和 CC 攻击。\n关于请求限制主要使用 nginx 默认集成的 2 个模块：\nlimit_conn_module 连接频率限制模块 limit_req_module 请求频率限制模块 涉及到的配置主要是：\nlimit_req_zone 限制请求数 limit_conn_zone 限制并发连接数 通过 limit_req_zone 限制请求数\nhttp{ limit_conn_zone $binary_remote_addrzone=limit:10m; // 设置共享内存空间大 server{ location /{ limit_conn addr 5; # 同一用户地址同一时间只允许有5个连接。 } } } 如果共享内存空间被耗尽，服务器将会对后续所有的请求返回 503 (Service Temporarily Unavailable) 错误。\n当多个 limit_conn_zone 指令被配置时，所有的连接数限制都会生效。比如，下面配置不仅会限制单一 IP 来源的连接数，同时也会限制单一虚拟服务器的总连接数：\nlimit_conn_zone $binary_remote_addr zone=perip:10m; limit_conn_zone $server_name zone=perserver:10m; server { limit_conn perip 10; # 限制每个 ip 连接到服务器的数量 limit_conn perserver 2000; # 限制连接到服务器的总数 } 通过 limit_conn_zone 限制并发连接数\nlimit_req_zone $binary_remote_addr zone=creq:10 mrate=10r/s; server{ location /{ limit_req zone=creq burst=5; } } 限制平均每秒不超过一个请求，同时允许超过频率限制的请求数不多于5个。 如果不希望超过的请求被延迟，可以用 nodelay 参数,如：\nlimit_req zone=creq burst=5 nodelay;\n这里只是简单讲讲，让大家有这个概念，配置的时候可以深入去找找资料。\n正向代理 link正向代理，意思是一个位于客户端和原始服务器(origin server)之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标(原始服务器)，然后代理向原始服务器转交请求并将获得的内容返回给客户端。客户端才能使用正向代理，比如我们使用的 VPN 服务就是正向代理，直观区别（图片来源于 前端开发者必备的 Nginx 知识 (opens new window)）：\n配置正向代理：\nresolver 8.8.8.8 # 谷歌的域名解析地址 server { resolver_timeout 5s; // 设超时时间 location / { # 当客户端请求我的时候，我会把请求转发给它 # $host 要访问的主机名 $request_uri 请求路径 proxy_pass http://$host$request_uri; } } 正向代理的对象是客户端，服务器端看不到真正的客户端。\n图片防盗链 link server { listen 80; server_name *.test; # 图片防盗链 location ~* \\.(gif|jpg|jpeg|png|bmp|swf)$ { valid_referers none blocked server_names ~\\.google\\. ~\\.baidu\\. *.qq.com; # 只允许本机 IP 外链引用，将百度和谷歌也加入白名单有利于 SEO if ($invalid_referer){ return 403; } } } 以上设置就能防止其它网站利用外链访问我们的图片，有利于节省流量\n适配 PC 或移动设备 link根据用户设备不同返回不同样式的站点，以前经常使用的是纯前端的自适应布局，但是复杂的网站并不适合响应式，无论是复杂性和易用性上面还是不如分开编写的好，比如我们常见的淘宝、京东。\n根据用户请求的 user-agent 来判断是返回 PC 还是 H5 站点：\nserver { listen 80; server_name test.com; location / { root /usr/local/app/pc; # pc 的 html 路径 if ($http_user_agent ~* '(Android|webOS|iPhone|iPod|BlackBerry)') { root /usr/local/app/mobile; # mobile 的 html 路径 } index index.html; } } 设置二级域名 link新建一个 server 即可：\nserver { listen 80; server_name admin.test.com; // 二级域名 location / { root /usr/local/app/admin; # 二级域名的 html 路径 index index.html; } } 配置 HTTPS link这里我使用的是 certbot 免费证书，但申请一次有效期只有3个月（好像可以用 crontab 尝试配置自动续期，我暂时没试过）：\n先安装 certbot\nwget https://dl.eff.org/certbot-auto chmod a+x certbot-auto 申请证书（注意：需要把要申请证书的域名先解析到这台服务器上，才能申请）:\nsudo ./certbot-auto certonly --standalone --email admin@abc.com -d test.com -d www.test.com 执行上面指令，按提示操作。\nCertbot 会启动一个临时服务器来完成验证（会占用 80 端口或 443 端口，因此需要暂时关闭 Web 服务器），然后 Certbot 会把证书以文件的形式保存，包括完整的证书链文件和私钥文件。\n文件保存在 /etc/letsencrypt/live/ 下面的域名目录下。\n修改 nginx 配置：\nserver { #SSL 默认访问端口号为 443 listen 443 ssl; #请填写绑定证书的域名 server_name docs.cakepanit.com; #请填写证书文件的相对路径或绝对路径 ssl_certificate docs.cakepanit.com.crt; #请填写私钥文件的相对路径或绝对路径 ssl_certificate_key docs.cakepanit.com.key; ssl_session_timeout 5m; #请按照以下协议配置 ssl_protocols TLSv1.2 TLSv1.3; #请按照以下套件配置，配置加密套件，写法遵循 openssl 标准。 ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE; ssl_prefer_server_ciphers on; location / { proxy_pass http://127.0.0.1:8888; } } 配置 HTTP 转 HTTPS link server { listen 80; server_name test.com www.test.com; # 单域名重定向 if ($host = 'www.sherlocked93.club'){ return 301 https://www.sherlocked93.club$request_uri; } # 全局非 https 协议时重定向 if ($scheme != 'https') { return 301 https://$server_name$request_uri; } # 或者全部重定向 return 301 https://$server_name$request_uri; } 以上配置选择自己需要的一条即可，不用全部加。\n单页面项目 history 路由配置 link server { listen 80; server_name fe.sherlocked93.club; location / { root /usr/local/app/dist; # vue 打包后的文件夹 index index.html index.htm; try_files $uri $uri/ /index.html @rewrites; # 默认目录下的 index.html，如果都不存在则重定向 expires -1; # 首页一般没有强制缓存 add_header Cache-Control no-cache; } location @rewrites { // 重定向设置 rewrite ^(.+)$ /index.html break; } } vue-router (opens new window) 官网只有一句话 try_files $uri $uri/ /index.html;，而上面做了一些重定向处理。\n配置高可用集群（双机热备） link当主 nginx 服务器宕机之后，切换到备份的 nginx 服务器\n首先安装 keepalived:\nyum install keepalived -y 1\n然后编辑 /etc/keepalived/keepalived.conf 配置文件，并在配置文件中增加 vrrp_script 定义一个外围检测机制，并在 vrrp_instance 中通过定义 track_script 来追踪脚本执行过程，实现节点转移：\nglobal_defs{ notification_email { cchroot@gmail.com } notification_email_from test@firewall.loc smtp_server 127.0.0.1 smtp_connect_timeout 30 // 上面都是邮件配置 router_id LVS_DEVEL // 当前服务器名字，用 hostname 命令来查看 } vrrp_script chk_maintainace { // 检测机制的脚本名称为chk_maintainace script \"[[ -e/etc/keepalived/down ]] \u0026\u0026 exit 1 || exit 0\" // 可以是脚本路径或脚本命令 // script \"/etc/keepalived/nginx_check.sh\" // 比如这样的脚本路径 interval 2 // 每隔2秒检测一次 weight -20 // 当脚本执行成立，那么把当前服务器优先级改为-20 } vrrp_instanceVI_1 { // 每一个vrrp_instance就是定义一个虚拟路由器 state MASTER // 主机为MASTER，备用机为BACKUP interface eth0 // 网卡名字，可以从ifconfig中查找 virtual_router_id 51 // 虚拟路由的id号，一般小于255，主备机id需要一样 priority 100 // 优先级，master的优先级比backup的大 advert_int 1 // 默认心跳间隔 authentication { // 认证机制 auth_type PASS auth_pass 1111 // 密码 } virtual_ipaddress { // 虚拟地址vip 172.16.2.8 } } 其中检测脚本 nginx_check.sh，这里提供一个：\n#!/bin/bash A=`ps -C nginx --no-header | wc -l` if [ $A -eq 0 ];then /usr/sbin/nginx # 尝试重新启动nginx sleep 2 # 睡眠2秒 if [ `ps -C nginx --no-header | wc -l` -eq 0 ];then killall keepalived # 启动失败，将keepalived服务杀死。将vip漂移到其它备份节点 fi fi 复制一份到备份服务器，备份 nginx 的配置要将 state 后改为 BACKUP，priority 改为比主机小。 设置完毕后各自 service keepalived start 启动，经过访问成功之后，可以把 Master 机的 keepalived 停掉，此时 Master 机就不再是主机了 service keepalived stop，看访问虚拟 IP 时是否能够自动切换到备机 ip addr。\n再次启动 Master 的 keepalived，此时 vip 又变到了主机上。\n配置高可用集群的内容来源于：Nginx 从入门到实践，万字详解！ (opens new window)\n其它功能和技巧 link代理缓存 linknginx 的 http_proxy 模块，提供类似于 Squid 的缓存功能，使用 proxy_cache_path 来配置。\nnginx 可以对访问过的内容在 nginx 服务器本地建立副本，这样在一段时间内再次访问该数据，就不需要通过 nginx 服务器再次向后端服务器发出请求，减小数据传输延迟，提高访问速度：\nproxy_cache_path usr/local/cache levels=1:2 keys_zone=my_cache:10m; server { listen 80; server_name test.com; location / { proxy_cache my_cache; proxy_pass http://127.0.0.1:8888; proxy_set_header Host $host; } } 上面的配置表示： nginx 提供一块 10 M 的内存用于缓存，名字为 my_cache, levels 等级为 1:2，缓存存放的路径为 usr/local/cache。\n访问日志 link访问日志默认是注释的状态，需要可以打开和进行更详细的配置，一下是 nginx 的默认配置：\nhttp { log_format main '$remote_addr - $remote_user [$time_local] \"$request\" ' '$status $body_bytes_sent \"$http_referer\" ' '\"$http_user_agent\" \"$http_x_forwarded_for\"'; access_log logs/access.log main; } 错误日志 link错误日志放在 main 全局区块中，童鞋们打开 nginx.conf 就可以看见在配置文件中和下面一样的代码了：\n#error_log logs/error.log; #error_log logs/error.log notice; #error_log logs/error.log info; nginx 错误日志默认配置为：\nerror_log logs/error.log error;\n静态资源服务器 link server { listen 80; server_name static.bin; charset utf-8; # 防止中文文件名乱码 location /download { alias /usr/share/nginx/static; # 静态资源目录 autoindex on; # 开启静态资源列目录，浏览目录权限 autoindex_exact_size off; # on(默认)显示文件的确切大小，单位是byte；off显示文件大概大小，单位KB、MB、GB autoindex_localtime off; # off(默认)时显示的文件时间为GMT时间；on显示的文件时间为服务器时间 } } 禁止指定 user_agent linknginx 可以禁止指定的浏览器和爬虫框架访问：\n# http_user_agent 为浏览器标识 # 禁止 user_agent 为baidu、360和sohu，~*表示不区分大小写匹配 if ($http_user_agent ~* 'baidu|360|sohu') { return 404; } # 禁止 Scrapy 等工具的抓取 if ($http_user_agent ~* (Scrapy|Curl|HttpClient)) { return 403; } 请求过滤 link根据请求类型过滤\n# 非指定请求全返回 403 if ( $request_method !~ ^(GET|POST|HEAD)$ ) { return 403; } 根据状态码过滤\nerror_page 502 503 /50x.html; location = /50x.html { root /usr/share/nginx/html; } 这样实际上是一个内部跳转，当访问出现 502、503 的时候就能返回 50x.html 中的内容，这里需要注意是否可以找到 50x.html 页面，所以加了个 location 保证找到你自定义的 50x 页面。\n根据URL名称过滤\nif ($host = zy.com' ) { #其中$1是取自regex部分()里的内容,匹配成功后跳转到的URL。 rewrite ^/(.*)$ http://www.zy.com/$1 permanent； } location /test { // /test 全部重定向到首页 rewrite ^(.*)$ /index.html redirect; } ab 命令 linkab命令全称为：Apache bench，是 Apache 自带的压力测试工具，也可以测试 Nginx、IIS 等其他 Web 服务器:\n-n 总共的请求数 -c 并发的请求数 -t 测试所进行的最大秒数，默认值 为 50000 -p 包含了需要的 POST 的数据文件 -T POST数据所使用的 Content-type 头信息 ab -n 1000 -c 5000 http://127.0.0.1/ # 每次发送1000并发的请求数，请求数总数为5000。 1\n测试前需要安装 httpd-tools： yum install httpd-tools\n泛域名路径分离 link这是一个非常实用的技能，经常有时候我们可能需要配置一些二级或者三级域名，希望通过 nginx 自动指向对应目录，比如：\ntest1.doc.test.club 自动指向 /usr/local/html/doc/test1 服务器地址； test2.doc.test.club 自动指向 /usr/local/html/doc/test2 服务器地址； server { listen 80; server_name ~^([\\w-]+)\\.doc\\.test\\.club$; root /usr/local/html/doc/$1; } 泛域名转发 link和之前的功能类似，有时候我们希望把二级或者三级域名链接重写到我们希望的路径，让后端就可以根据路由解析不同的规则：\ntest1.serv.test.club/api?name=a 自动转发到 127.0.0.1:8080/test1/api?name=a test2.serv.test.club/api?name=a 自动转发到 127.0.0.1:8080/test2/api?name=a server { listen 80; server_name ~^([\\w-]+)\\.serv\\.test\\.club$; location / { proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header Host $http_host; proxy_set_header X-NginX-Proxy true; proxy_pass http://127.0.0.1:8080/$1$request_uri; } } 常见问题 linknginx 中怎么设置变量 link或许你不知道，nginx 的配置文件使用的是一门微型的编程语言。既然是编程语言，一般也就少不了“变量”这种东西，但是在 nginx 配置中，变量只能存放一种类型的值，因为也只存在一种类型的值，那就是字符串。\n例如我们在 nginx.conf 中有这样一行配置：\n上面使用了 set 配置指令对变量 $name进行了赋值操作，把 “chroot” 赋值给了 $name。nginx 变量名前面有一个 $ 符号，这是记法上的要求。所有的 Nginx 变量在 Nginx 配置文件中引用时都须带上 $ 前缀。这种表示方法和 Perl、PHP 这些语言是相似的。\n这种表示方法的用处在哪里呢，那就是可以直接把变量嵌入到字符串常量中以构造出新的字符串，例如你需要进行一个字符串拼接：\nserver { listen 80; server_name test.com; location / { set $temp hello; return \"$temp world\"; } } 以上当匹配成功的时候就会返回字符串 “hello world” 了。需要注意的是，当引用的变量名之后紧跟着变量名的构成字符时（比如后跟字母、数字以及下划线），我们就需要使用特别的记法来消除歧义，例如：\nserver { listen 80; server_name test.com; location / { set $temp \"hello \"; return \"${temp}world\"; } } 这里，我们在配置指令的参数值中引用变量 $temp 的时候，后面紧跟着 world 这个单词，所以如果直接写作 \"$tempworld\" 则 nginx 的计算引擎会将之识别为引用了变量 $tempworld. 为了解决这个问题，nginx 的字符串支持使用花括号在 $ 之后把变量名围起来，比如这里的 ${temp}，所以 上面这个例子返回的还是 “hello world”：\n$ curl 'http://test.com/' hello world 还需要注意的是，若是想输出 $ 符号本身，可以这样做：\ngeo $dollar { default \"$\"; } server { listen 80; server_name test.com; location / { set $temp \"hello \"; return \"${temp}world: $dollar\"; } } 上面用到了标准模块 ngx_geo 提供的配置指令 geo 来为变量 $dollar 赋予字符串 \"$\" ，这样，这里的返回值就是 “hello world: $” 了。\n附 nginx 内置预定义变量 link按字母顺序：\n变量名 定义 $arg_PARAMETER GET 请求中变量名 PARAMETER 参数的值 $args 这个变量等于 GET 请求中的参数，例如，foo=123\u0026bar=blahblah;这个变量只可以被修改 $binary_remote_addr 二进制码形式的客户端地址 $body_bytes_sent 传送页面的字节数 $content_length 请求头中的 Content-length 字段 $content_type 请求头中的 Content-Type 字段 $cookie_COOKIE cookie COOKIE 的值 $document_root 当前请求在 root 指令中指定的值 $document_uri 与 $uri 相同 $host 请求中的主机头(Host)字段，如果请求中的主机头不可用或者空，则为处理请求的 server 名称(处理请求的 server 的 server_name 指令的值)。值为小写，不包含端口。 $hostname 机器名使用 gethostname 系统调用的值 $http_HEADER HTTP 请求头中的内容，HEADER 为 HTTP 请求中的内容转为小写，-变为_(破折号变为下划线)，例如：$http_user_agent(Uaer-Agent 的值) $sent_http_HEADER HTTP 响应头中的内容，HEADER 为 HTTP 响应中的内容转为小写，-变为_(破折号变为下划线)，例如：$sent_http_cache_control、$sent_http_content_type… $is_args 如果 $args 设置，值为\"?\"，否则为\"\" $limit_rate 这个变量可以限制连接速率 $nginx_version 当前运行的 nginx 版本号 $query_string 与 $args 相同 $remote_addr 客户端的IP地址 $remote_port 客户端的端口 $remote_port 已经经过 Auth Basic Module 验证的用户名 $request_filename 当前连接请求的文件路径，由 root 或 alias 指令与 URI 请求生成 $request_body 这个变量（0.7.58+）包含请求的主要信息。在使用 proxy_pass 或 fastcgi_pass 指令的 location 中比较有意义 $request_body_file 客户端请求主体信息的临时文件名 $request_completion 如果请求成功，设为\"OK\"；如果请求未完成或者不是一系列请求中最后一部分则设为空 $request_method 这个变量是客户端请求的动作，通常为 GET 或 POST。包括 0.8.20 及之前的版本中，这个变量总为 main request 中的动作，如果当前请求是一个子请求，并不使用这个当前请求的动作 $request_uri 这个变量等于包含一些客户端请求参数的原始 URI，它无法修改，请查看 $uri 更改或重写 URI $scheme 所用的协议，例如 http 或者是 https，例如 rewrite ^(.+)$ $scheme://example.com$1 redirect $server_addr 服务器地址，在完成一次系统调用后可以确定这个值，如果要绕开系统调用，则必须在listen中指定地址并且使用bind参数 $server_name 服务器名称 $server_port 请求到达服务器的端口号 $server_protocol 请求使用的协议，通常是 HTTP/1.0、HTTP/1.1或HTTP/2 $uri 请求中的当前 URI(不带请求参数，参数位于 args ) ， 不 同 于 浏 览 器 传 递 的 args)，不同于浏览器传递的 args)，不同于浏览器传递的 request_uri 的值，它可以通过内部重定向，或者使用 index 指令进行修改。不包括协议和主机名，例如 /foo/bar.html 附 nginx 模块 linknginx 模块分类 link 核心模块：nginx 最基本最核心的服务，如进程管理、权限控制、日志记录； 标准 HTTP 模块：nginx 服务器的标准 HTTP 功能； 可选 HTTP 模块：处理特殊的 HTTP 请求 邮件服务模块：邮件服务 第三方模块：作为扩展，完成特殊功能 模块清单 link核心模块：\nngx_core ngx_errlog ngx_conf ngx_events ngx_event_core ngx_epll ngx_regex 标准 HTTP 模块：\nngx_http ngx_http_core #配置端口，URI 分析，服务器相应错误处理，别名控制 (alias) 等 ngx_http_log #自定义 access 日志 ngx_http_upstream #定义一组服务器，可以接受来自 proxy, Fastcgi,Memcache 的重定向；主要用作负载均衡 ngx_http_static ngx_http_autoindex #自动生成目录列表 ngx_http_index #处理以/结尾的请求，如果没有找到 index 页，则看是否开启了random_index；如开启，则用之，否则用 autoindex ngx_http_auth_basic #基于 http 的身份认证 (auth_basic) ngx_http_access #基于 IP 地址的访问控制 (deny,allow) ngx_http_limit_conn #限制来自客户端的连接的响应和处理速率 ngx_http_limit_req #限制来自客户端的请求的响应和处理速率 ngx_http_geo ngx_http_map #创建任意的键值对变量 ngx_http_split_clients ngx_http_referer #过滤 HTTP 头中 Referer 为空的对象 ngx_http_rewrite #通过正则表达式重定向请求 ngx_http_proxy ngx_http_fastcgi #支持 fastcgi ngx_http_uwsgi ngx_http_scgi ngx_http_memcached ngx_http_empty_gif #从内存创建一个 1×1 的透明 gif 图片，可以快速调用 ngx_http_browser #解析 http 请求头部的 User-Agent 值 ngx_http_charset #指定网页编码 ngx_http_upstream_ip_hash ngx_http_upstream_least_conn ngx_http_upstream_keepalive ngx_http_write_filter ngx_http_header_filter ngx_http_chunked_filter ngx_http_range_header ngx_http_gzip_filter ngx_http_postpone_filter ngx_http_ssi_filter ngx_http_charset_filter ngx_http_userid_filter ngx_http_headers_filter #设置 http 响应头 ngx_http_copy_filter ngx_http_range_body_filter ngx_http_not_modified_filter 可选 HTTP 模块:\nngx_http_addition #在响应请求的页面开始或者结尾添加文本信息 ngx_http_degradation #在低内存的情况下允许服务器返回 444 或者 204 错误 ngx_http_perl ngx_http_flv #支持将 Flash 多媒体信息按照流文件传输，可以根据客户端指定的开始位置返回 Flash ngx_http_geoip #支持解析基于 GeoIP 数据库的客户端请求 ngx_google_perftools ngx_http_gzip #gzip 压缩请求的响应 ngx_http_gzip_static #搜索并使用预压缩的以.gz 为后缀的文件代替一般文件响应客户端请求 ngx_http_image_filter #支持改变 png，jpeg，gif 图片的尺寸和旋转方向 ngx_http_mp4 #支持.mp4,.m4v,.m4a 等多媒体信息按照流文件传输，常与 ngx_http_flv 一起使用 ngx_http_random_index #当收到 / 结尾的请求时，在指定目录下随机选择一个文件作为 index ngx_http_secure_link #支持对请求链接的有效性检查 ngx_http_ssl #支持 https ngx_http_stub_status ngx_http_sub_module #使用指定的字符串替换响应中的信息 ngx_http_dav #支持 HTTP 和 WebDAV 协议中的 PUT/DELETE/MKCOL/COPY/MOVE 方法 ngx_http_xslt #将 XML 响应信息使用 XSLT 进行转换 邮件服务模块:\nngx_mail_core ngx_mail_pop3 ngx_mail_imap ngx_mail_smtp ngx_mail_auth_http ngx_mail_proxy ngx_mail_ssl 第三方模块：\necho-nginx-module #支持在 nginx 配置文件中使用 echo/sleep/time/exec 等类 Shell 命令 memc-nginx-module rds-json-nginx-module #使 nginx 支持 json 数据的处理 lua-nginx-module "
            }
        );
    index.add(
            {
                id:  65 ,
                href: "\/docs\/demo\/features\/",
                title: "Features",
                description: "A guide to the core features of the Lotus Docs theme.",
                content: ""
            }
        );
    index.add(
            {
                id:  66 ,
                href: "\/docs\/dev\/golang\/fyne\/project\/",
                title: "项目案例",
                description: "使用Fyne实现几个项目",
                content: ""
            }
        );
    index.add(
            {
                id:  67 ,
                href: "\/docs\/demo\/features\/syntax-highlighting\/",
                title: "Syntax Highlighting",
                description: "How to highlight code in Lotus Docs using the built-in The PrismJS library (or Chroma).",
                content: "Code Highlighters linkLotus Docs supports syntax highlighting by Prism (enabled by default via param.docs.prism in hugo.toml) or Hugo’s built-in code highlighter Chroma.\nFenced code blocks (code enclosed by triple backticks above and below) that specify a code language (declared right of the opening fence), will automatically highlight the code content as HTML e.g. ```html:\n```html Buy cool new product Checkout ``` Result - Prism Highlighter:\nBuy cool new product Checkout Result - Chroma Highlighter (param.docs.prism = false):\nPrism Features linkThe Prism highlighter features the following:\nCopy Code Button linkAll code blocks feature a button which copies the code to the clipboard when clicked. Hover over any code block and the copy button (content_copy) will appear in the top right hand corner.\nCode Block id linkEvery code block on a page has a unique id attribute, an auto-generated value calculated from the sha1 hash of the block’s contents combined with it’s position on the page.\nFor example, the following snippet can be linked via the unique id 80c9335:\npackage main import \"fmt\" func main() { fmt.Println(\"go\" + \"lang\") fmt.Println(\"1+1 =\", 1+1) fmt.Println(\"7.0/3.0 =\", 7.0/3.0) fmt.Println(true \u0026\u0026 false) fmt.Println(true || false) fmt.Println(!true) } Line Anchors linkSpecific sections of code can be linked and highlighted by combining the code block id with the desired line numbers or ranges.\nThe URL format follows, /#{code block id}.{line no. range}.\nFor example, /#80c9335.3,5,7-13 will link to (and highlight) lines 3, 5 and 7-13 in the code block above:\nThemes linkYou can change the Prism theme via the prismTheme parameter under [params.docs] in your config file.\ninfo Additional PrismJS themes will be adapted and added to Lotus Docs periodically. Keep an eye on new releases to know when. hugo.toml hugo.yaml hugo.json [params.docs] prismTheme = \"lotusdocs\" # (optional) - Set theme for PrismJS. Options include: lotusdocs (default), solarized-light, twilight, lucario params: docs: prismTheme: lotusdocs # (optional) - Set theme for PrismJS. Options include: lotusdocs (default), solarized-light, twilight, lucario { \"params\": { \"docs\": { \"prismTheme\": \"lotusdocs\" } } } Choose from the following theme options:\nlotusdocs (default) solarized-light twilight lucario Supported Languages linkBoth Prism \u0026 Chroma support a vast array of languages. See the links below for a complete list of languages supported by each highlighter:\nPrism (≈ 290 languages) Chroma (≈ 200 languages) Code Fence Translations link info For more extensive code highlighting options with Prism, consider using the "
            }
        );
    index.add(
            {
                id:  68 ,
                href: "\/docs\/demo\/features\/katex\/",
                title: "KaTex",
                description: "Fast Tex math rendering for your Lotus Docs site",
                content: "$$ f\\relax{x} = \\int_{-\\infty}^\\infty \\hat f(\\xi)\\ e^{2 \\pi i \\xi x} \\ d\\xi $$\nHow to use KaTex with Lotus Docs linkKaTex support is controlled by the katex parameter in your front matter (line 10 below). Add and set it to true in your front matter to enable KaTex support for that page. This means KaTex support and resources are active only for pages that require it.\n--- weight: 530 title: \"KaTex\" description: \"Fast Tex math rendering for your Lotus Docs site\" icon: \"function\" date: \"2023-08-26T20:43:23+01:00\" lastmod: \"2023-08-26T20:43:23+01:00\" draft: true toc: true katex: true --- Writing LaTex in Markdown linkEquations can be displayed either in block level or inline.\nBlock display linkType an equation using double dollar signs as the delimiter:\n$$ \\int \\frac{1}{x} dx = \\ln \\left| x \\right| + C $$ renders as:\n$$ \\int \\frac{1}{x} dx = \\ln \\left| x \\right| + C $$\nInline display linkType an equation using single dollar signs as the delimiter:\n$ \\int \\frac{1}{x} dx = \\ln \\left| x \\right| + C $ renders as:\n$ \\int \\frac{1}{x} dx = \\ln \\left| x \\right| + C $\nSyntax Rendering Issues linkAs a consequence of Hugo rendering to HTML before KaTex renders to math1, there are some instances in which the KaTex equation syntax requires heavy escaping or alterations before rendering correctly. This can be time-consuming and frustrating (especially for inexperienced users). To avoid this, a "
            }
        );
    index.add(
            {
                id:  69 ,
                href: "\/docs\/demo\/features\/mermaid\/",
                title: "Mermaid",
                description: "How to use the Mermaid diagramming and chart tool with Lotus Docs",
                content: "What is Mermaid? linkMermaid is a JavaScript-based diagramming and charting tool that uses Markdown-inspired text definitions and a renderer to create and modify complex diagrams. The main purpose of Mermaid is to help documentation catch up with development.\nHow to use Mermaid with Lotus Docs linkMermaid is enabled whenever content containing Mermaid diagram syntax is present in a page’s content. You can insert Mermaid diagrams by using the mermaid language identifier with triple backtick codeblocks:\n```mermaid sequenceDiagram Alice-\u003e\u003eJohn: Hello John, how are you? loop Healthcheck John-\u003e\u003eJohn: Fight against hypochondria end Note right of John: Rational thoughts! John--\u003e\u003eAlice: Great! John-\u003e\u003eBob: How about you? Bob--\u003e\u003eJohn: Jolly good! ``` Renders as:\nsequenceDiagram Alice-\u003e\u003eJohn: Hello John, how are you? loop Healthcheck John-\u003e\u003eJohn: Fight against hypochondria end Note right of John: Rational thoughts! John--\u003e\u003eAlice: Great! John-\u003e\u003eBob: How about you? Bob--\u003e\u003eJohn: Jolly good! Other diagram examples linkFlowchart linkflowchart LR A[Hard] --\u003e|Text| B(Round) B --\u003e C{Decision} C --\u003e|One| D[Result 1] C --\u003e|Two| E[Result 2] Gnatt Chart linkgantt section Section Completed :done, des1, 2014-01-06,2014-01-08 Active :active, des2, 2014-01-07, 3d Parallel 1 : des3, after des1, 1d Parallel 2 : des4, after des1, 1d Parallel 3 : des5, after des3, 1d Parallel 4 : des6, after des4, 1d Class diagram linkclassDiagram Class01 \u003c|-- AveryLongClass : Cool \u003c\u003e Class01 Class09 --\u003e C2 : Where am i? Class09 --* C3 Class09 --|\u003e Class07 Class07 : equals() Class07 : Object[] elementData Class01 : size() Class01 : int chimp Class01 : int gorilla class Class10 { \u003e\u003eservice\u003e\u003e int id size() } State diagram linkstateDiagram-v2 [*] --\u003e Still Still --\u003e [*] Still --\u003e Moving Moving --\u003e Still Moving --\u003e Crash Crash --\u003e [*] Pie Chart linkpie \"Dogs\" : 386 \"Cats\" : 85.9 \"Rats\" : 15 Git Graph link gitGraph commit commit branch develop checkout develop commit commit checkout main merge develop commit commit Bar chart (using gantt chart) linkgantt title Git Issues - days since last update dateFormat X axisFormat %s section Issue19062 71 : 0, 71 section Issue19401 36 : 0, 36 section Issue193 34 : 0, 34 section Issue7441 9 : 0, 9 section Issue1300 5 : 0, 5 User Journey diagram link journey title My working day section Go to work Make tea: 5: Me Go upstairs: 3: Me Do work: 1: Me, Cat section Go home Go downstairs: 5: Me Sit down: 3: Me C4 diagram linkC4Context title System Context diagram for Internet Banking System Person(customerA, \"Banking Customer A\", \"A customer of the bank, with personal bank accounts.\") Person(customerB, \"Banking Customer B\") Person_Ext(customerC, \"Banking Customer C\") System(SystemAA, \"Internet Banking System\", \"Allows customers to view information about their bank accounts, and make payments.\") Person(customerD, \"Banking Customer D\", \"A customer of the bank, with personal bank accounts.\") Enterprise_Boundary(b1, \"BankBoundary\") { SystemDb_Ext(SystemE, \"Mainframe Banking System\", \"Stores all of the core banking information about customers, accounts, transactions, etc.\") System_Boundary(b2, \"BankBoundary2\") { System(SystemA, \"Banking System A\") System(SystemB, \"Banking System B\", \"A system of the bank, with personal bank accounts.\") } System_Ext(SystemC, \"E-mail system\", \"The internal Microsoft Exchange e-mail system.\") SystemDb(SystemD, \"Banking System D Database\", \"A system of the bank, with personal bank accounts.\") Boundary(b3, \"BankBoundary3\", \"boundary\") { SystemQueue(SystemF, \"Banking System F Queue\", \"A system of the bank, with personal bank accounts.\") SystemQueue_Ext(SystemG, \"Banking System G Queue\", \"A system of the bank, with personal bank accounts.\") } } BiRel(customerA, SystemAA, \"Uses\") BiRel(SystemAA, SystemE, \"Uses\") Rel(SystemAA, SystemC, \"Sends e-mails\", \"SMTP\") Rel(SystemC, customerA, \"Sends e-mails to\") "
            }
        );
    index.add(
            {
                id:  70 ,
                href: "\/docs\/demo\/shortcodes\/",
                title: "Shortcodes",
                description: "Lotus Docs Custom Shortcodes.",
                content: ""
            }
        );
    index.add(
            {
                id:  71 ,
                href: "\/docs\/demo\/shortcodes\/alerts\/",
                title: "Alerts",
                description: "How to use Alert Shortcodes to render custom page alerts in markdown.",
                content: "Adding a Page Alert linkPage alerts can be added to your markdown using the following shortcode:\n{{\u003c alert text=\"This is the default alert. It consists of a default theme colour and icon.\" /\u003e}} The above code results in the following alert:\nnotifications This is the default alert. It consists of a default theme colour and icon. Alert with Context linkAdd context to an alert via the context parameter:\n{{\u003c alert context=\"info\" text=\"This is an alert with an info context. It consists of the info theme colour and icon.\" /\u003e}} Here’s what is rendered:\ninfo This is an alert with an info context. It consists of the info theme colour and icon. Additional alert contexts include success, danger, warning, primary, light and dark:\ncheck_circle This is an alert with a success context. It consists of the success theme colour and icon. report This is an alert with a danger context. It consists of the danger theme colour and icon. warning This is an alert with a warning context. It consists of the warning theme colour and icon. info This is an alert with a primary context. Its theme and icon colors match those of the current primary theme colour. This is an alert with a light context. It consists of the light theme colour. The light alert has no default icon. This is an alert with a dark context. It consists of the dark theme colour. The dark alert has no default icon. Alert with Custom Emoji Icon linkThe default icon for an alert context can be substituted with an emoji using the icon parameter:\n{{\u003c alert icon=\"🍅\" context=\"info\" text=\"This is an info context alert with a tomato emoji replacing the default icon. The info theme colour remains unchanged.\" /\u003e}} 🍅 This is an info context alert with a tomato emoji replacing the default icon. The info theme colour remains unchanged. Alert with No Icon linkSetting the icon parameter to an empty space, icon=\" \", will render an alert with no icon:\n{{\u003c alert icon=\" \" context=\"info\" text=\"This info context alert has no icon.\" /\u003e}} This info context alert has no icon. warning N.B. The icon parameter must contain a space. Setting it to icon=\"\" will render the default icon.\nRender Markdown \u0026 HTML inside an Alert link warning So % delimited alerts render correctly, ensure you have unsafe = true set under [markup.goldmark.renderer] in your hugo.toml configuration file1.\nUse a paired shortcode with the % delimiter2 to render Markdown and HTML inside an alert:\n{{% alert icon=\"🛒\" context=\"success\" %}} This ***paired shortcode*** alert contains a **markdown** list and header: #### My Shopping List: 1. Tomatoes 2. Bananas 3. Pineapples and a sentence styled using HTML tags such as \\ and \\ {{% /alert %}} 🛒\nThis paired shortcode alert contains a markdown list and header:\nMy Shopping List: link Tomatoes Bananas Pineapples and a sentence styled using HTML tags such as and Markdown alerts do not seem to display background color ↩︎\nShortcodes with Markdown - gohugo.io ↩︎\n"
            }
        );
    index.add(
            {
                id:  72 ,
                href: "\/docs\/demo\/shortcodes\/tables\/",
                title: "Tables",
                description: "How to use the Lotus Docs table shortcode to render great looking markdown tables",
                content: "The table shortcode enables Lotus Docs to take advantage of Bootstrap’s opt-in table styling.\nRegular Tables linkBy default Lotus Docs renders regular Markdown tables with some very basic styling:\n| Tables | Are | Cool | |----------|:-------------:|------:| | col 1 is | left-aligned | $1600 | | col 2 is | centered | $12 | | col 3 is | right-aligned | $1 | Result:\nTables Are Cool col 1 is left-aligned $1600 col 2 is centered $12 col 3 is right-aligned $1 Shortcode Tables linkThe the table shortcode allows you to implement a number of Bootstrap’s table styling classes. The table shortcode without any options will render a basic bordered table with a borderless floating table head:\n{{\u003c table \u003e}} | Animal | Sounds | Legs | |---------|--------|-----| | `Cat` | Meow | 4 | | `Dog` | Woof | 4 | | `Cricket` | Chirp | 6 | {{\u003c /table \u003e}} Animal Sounds Legs Cat Meow 4 Dog Woof 4 Cricket Chirp 6 warning Since the table shortcode works by implementing Bootstrap’s opt-in table styling, not all Bootstrap’s table styles are compatible with Lotus Docs. All compatible options are documented on this page.\nStriped Rows linkUse the table-striped option to add zebra-striping to the table rows.\n{{\u003c table \"table-striped\" \u003e}} ... .. {{\u003c /table \u003e}} Parameter Default Value Description google_fonts N/A An array of Google fonts and sizes to load. e.g.\ngoogle_fonts = [[\"Poppins\", \"300, 400, 600, 700\"],[\"Source Code Pro\", \"500, 700\"]]\nThis will load the Google Poppins and Source Code Pro fonts in the specified sizes. sans_serif_font System Font Set the Sans Serif font. e.g. \"Poppins\" secondary_font System Font Set the Secondary font. e.g. \"Poppins\" Striped Columns linkUse the table-striped-columns option to add zebra-striping to the table columns.\n{{\u003c table \"table-striped-columns\" \u003e}} ... .. {{\u003c /table \u003e}} Parameter Default Value Description google_fonts N/A An array of Google fonts and sizes to load. e.g.\ngoogle_fonts = [[\"Poppins\", \"300, 400, 600, 700\"],[\"Source Code Pro\", \"500, 700\"]]\nThis will load the Google Poppins and Source Code Pro fonts in the specified sizes. sans_serif_font System Font Set the Sans Serif font. e.g. \"Poppins\" secondary_font System Font Set the Secondary font. e.g. \"Poppins\" Hoverable Rows linkUse the table-hover option to enable a hover state on the table rows.\n{{\u003c table \"table-hover\" \u003e}} ... .. {{\u003c /table \u003e}} Parameter Default Value Description google_fonts N/A An array of Google fonts and sizes to load. e.g.\ngoogle_fonts = [[\"Poppins\", \"300, 400, 600, 700\"],[\"Source Code Pro\", \"500, 700\"]]\nThis will load the Google Poppins and Source Code Pro fonts in the specified sizes. sans_serif_font System Font Set the Sans Serif font. e.g. \"Poppins\" secondary_font System Font Set the Secondary font. e.g. \"Poppins\" Tables without borders linkUse the table-borderless option a table without borders.\n{{\u003c table \"table-borderless\" \u003e}} ... .. {{\u003c /table \u003e}} Parameter Default Value Description google_fonts N/A An array of Google fonts and sizes to load. e.g.\ngoogle_fonts = [[\"Poppins\", \"300, 400, 600, 700\"],[\"Source Code Pro\", \"500, 700\"]]\nThis will load the Google Poppins and Source Code Pro fonts in the specified sizes. sans_serif_font System Font Set the Sans Serif font. e.g. \"Poppins\" secondary_font System Font Set the Secondary font. e.g. \"Poppins\" Small Tables linkAdd table-sm or table-xs to make any table more compact by reducing the cell padding.\nParameter Default Value Description google_fonts N/A An array of Google fonts and sizes to load. e.g.\ngoogle_fonts = [[\"Poppins\", \"300, 400, 600, 700\"],[\"Source Code Pro\", \"500, 700\"]]\nThis will load the Google Poppins and Source Code Pro fonts in the specified sizes. sans_serif_font System Font Set the Sans Serif font. e.g. \"Poppins\" secondary_font System Font Set the Secondary font. e.g. \"Poppins\" Parameter Default Value Description google_fonts N/A An array of Google fonts and sizes to load. e.g.\ngoogle_fonts = [[\"Poppins\", \"300, 400, 600, 700\"],[\"Source Code Pro\", \"500, 700\"]]\nThis will load the Google Poppins and Source Code Pro fonts in the specified sizes. sans_serif_font System Font Set the Sans Serif font. e.g. \"Poppins\" secondary_font System Font Set the Secondary font. e.g. \"Poppins\" Responsive Tables linkAdd the table-responsive option to make a table responsive:\nAnimal Sounds Legs Cat Meow 4 Dog Woof 4 Cricket Chirp 6 Combining Table Options linkCombine table shortcode options to create your desired effect:\n{{\u003c table \"table-striped table-sm table-borderless\" \u003e}} ... .. {{\u003c /table \u003e}} Parameter Default Value Description google_fonts N/A An array of Google fonts and sizes to load. e.g.\ngoogle_fonts = [[\"Poppins\", \"300, 400, 600, 700\"],[\"Source Code Pro\", \"500, 700\"]]\nThis will load the Google Poppins and Source Code Pro fonts in the specified sizes. sans_serif_font System Font Set the Sans Serif font. e.g. \"Poppins\" secondary_font System Font Set the Secondary font. e.g. \"Poppins\" "
            }
        );
    index.add(
            {
                id:  73 ,
                href: "\/docs\/demo\/shortcodes\/tabs\/",
                title: "Tabs",
                description: "How to use the Lotus Docs tabs shortcode to render Bootstrap Tabs",
                content: "The tabs shortcode leverages Bootstrap’s Tabs styling to easily add Tabs to your markdown content. The shortcode is actually a combination of two separate shortcodes (tab and tabs) working together.\nYou need a minimum of one tab shortcode nested inside a tabs shortcode for the component to function:\n{{\u003c tabs tabTotal=\"1\"\u003e}} {{% tab tabName=\"Tab 1\" %}} **Tab 1 Content** {{% /tab %}} {{\u003c /tabs \u003e}} Basic Tabs linkThe following example demonstrates how to create a basic multi tab navigation component using the tabs and tab shortcodes.\n{{\u003c tabs tabTotal=\"3\"\u003e}} {{% tab tabName=\"Windows\" %}} **Windows Content** Example content specific to **Windows** operating systems {{% /tab %}} {{% tab tabName=\"MacOS\" %}} **MacOS Content** Example content specific to **Mac** operating systems {{% /tab %}} {{% tab tabName=\"Linux\" %}} **Linux Content** Example content specific to **Linux** operating systems {{% /tab %}} {{\u003c /tabs \u003e}} Renders:\nWindows MacOS Linux Windows Content\nExample content specific to Windows operating systems\nMacOS Content\nExample content specific to Mac operating systems\nLinux Content\nExample content specific to Linux operating systems\nRight Aligned Tabs link {{\u003c tabs tabTotal=\"3\" tabRightAlign=\"2\"\u003e}} {{% tab tabName=\"Tab 1\" %}} **Tab 1 Content** {{% /tab %}} {{% tab tabName=\"Tab 2\" %}} **Tab 2 Content** {{% /tab %}} {{% tab tabName=\"Tab 3\" %}} **Tab 3 Content** {{% /tab %}} {{\u003c /tabs \u003e}} Renders:\nTab 1 Tab 2 Tab 3 Tab 1 Content\nTab 2 Content\nTab 3 Content\nHow does it work? linktabs.html linkThis is the parent shortcode that wraps around all nested tab shortcodes in the tab group and generates the tab navigation.\nVariable Description tabTotal This variable is used to generate the tab navigation. Simply set it to the amount of tab shortcodes you have. In the above example, since there are three nested tab shortcodes, you would set tabTotal to 3. tabRightAlign This is an optional variable that if used will right align the tab number you inputted and all tabs after it. In the above example, since tabRightAlign is set to two, tabs 2 and 3 will be right aligned. tab.html linkThis is a child shortcode that is nested inside tabs shortcodes. Each tab shortcode equals one tab so add as many as you need. Please note, make sure tabTotal in the tabs shortcode is equal to the amount of tab shortcodes you define.\nVariable Description tabName This variable defines the title of the tab. Credit linkBoth tab and tabs shortcodes documented above are a modified versions of the open source Hugo Dynamic Tabs shortcodes. Thank you rvanhorn 👍.\n"
            }
        );
    index.add(
            {
                id:  74 ,
                href: "\/docs\/demo\/shortcodes\/prism\/",
                title: "Prism",
                description: "How to use the Prism Shortcode for syntax highlighting code blocks.",
                content: "Prism Shortcode linkWhen Prism is enabled in hugo.toml syntax highlighting can also be achieved using a paired Prism shortcode. The code language is declared using the lang parameter:\n{{\u003c prism lang=\"html\" \u003e}} Buy cool new product Checkout {{\u003c /prism \u003e}} All code blocks highlighted by Prism feature the Copy to Clipboard Button plugin. Hover over (or tap if on mobile) the examples above and the copy button appears in the top right hand corner of the code block. Click this button to copy the code to your clipboard.\nLine Highlighting linkThe Prism shortcode can highlight specific lines and/or line ranges in code blocks using the line parameter:\n{{\u003c prism lang=\"html\" line=\"2-4,6\" \u003e}} ... {{\u003c /prism \u003e}} See the rendered example below:\nBuy cool new product Checkout Line Numbers linkAdd line numbers to your code with the line-numbers=\"true\" parameter:\nBuy cool new product Checkout The number at which the line starts can be specified by the start parameter. e.g. start=\"48\":\nBuy cool new product Checkout Line Number Anchors linkSpecific lines in highlighted code blocks can be linked when both the line-numbers and linkable-line-numbers options are true:\n{{\u003c prism lang=\"html\" linkable-line-numbers=\"true\" line-numbers=\"true\" \u003e}} ... {{\u003c /prism \u003e}} Rendered code block:\nBuy cool new product Checkout Clicking on any of the line numbers above will update the hash of the current page to link to that specific line.\ninfo All elements of Prism code blocks have an auto-generated id attribute. This id is a combination of the unique hash of the code block content plus it’s unique position on the page. The generated hash can be overridden using a Custom id set via the id option.\nThe url format follows #{hash-id}.{lines}, where {hash-id} is the auto-generated hash value of the code block and {lines} is one or more lines or line ranges that follows the line highlighting format.\nFor example, line 8 in the code block below can be linked using the following anchor #adea9eb.8:\nBuy cool new product Checkout Combined Line Parameters linkPrism’s Line Highlighting \u0026 Line Numbers plugins are compatible with each other. So the line \u0026 line-numbers options can be combined to display both, line numbers and highlight specified lines in a code block:\n{{\u003c prism lang=\"html\" line-numbers=\"true\" line=\"2-4,6\" \u003e}} ... {{\u003c /prism \u003e}} This renders the following code block:\nBuy cool new product Checkout Combining line \u0026 start options requires the use of the line-offset option:\n{{\u003c prism lang=\"html\" line-numbers=\"true\" start=\"48\" line=\"49-51,54\" line-offset=\"48\" \u003e}} ... {{\u003c /prism \u003e}} This renders the following code block:\nBuy cool new product Checkout File Highlight linkExternal files can be fetched and highlighted using the File Highlight option. Use the src parameter to retrieve an external file, like so:\n{{\u003c prism src=\"https://raw.githubusercontent.com/colinwilson/lotusdocs/release/SECURITY.md\" /\u003e}} Result:\nUse the src-range parameter to retrieve a specific line range from an external file. src-range=\"32,46\" will fetch lines 32 to 46 of the file specified by the src parameter:\n{{\u003c prism src-range=\"32,46\" src=\"https://raw.githubusercontent.com/colinwilson/lotusdocs/release/data/landing.yaml\" line-numbers=\"true\" /\u003e}} src-range can be used with the line-numbers option to number the retrieved range. So the above shortcode produces the following code block:\ninfo See Prism’s docs for more info on the File Highlight plugin.\nDisable Prism linkPrism syntax highlighting can be disabled by setting [params.docs.prism] to false in the hugo.toml configuration file.\nCommand Line linkTBC\n"
            }
        );
    index.add(
            {
                id:  75 ,
                href: "\/docs\/demo\/shortcodes\/markdownify\/",
                title: "Markdownify",
                description: "A simple shortcode to render content as Markdown.",
                content: "This shortcode parses its content as markdown.\nUsage linkThe following:\n{{\u003c markdownify \u003e}} **Bold Text**: Above a code block. ```html Hello World {{\u003c /markdownify \u003e}} Renders:\nBold Text: Above a code block.\nHello World Nested Shortcodes linkThe markdownify shortcode is especially useful in cases where you require portions of content nested inside another shortcode be parsed as Markdown.\nFor example, here’s a paragraph of markdown text and a prism shortcode codeblock nested within a tabs shortcode:\n{{\u003c tabs tabTotal=\"1\" \u003e}} {{\u003c tab tabName=\"Tab 1\" \u003e}} {{\u003c markdownify \u003e}} ### Markdownified Text Some `markdownified` text inside a `tabs` shortcode {{\u003c /markdownify \u003e}} {{\u003c prism lang=\"html\" line=\"3,6\" \u003e}} A code block using the Prism Shortcode This shortcode is nested inside a Tabs shortcode {{\u003c /prism \u003e}} {{\u003c /tab \u003e}} {{\u003c /tabs \u003e}} Renders:\nTab 1 Markdownified Text\nSome markdownified text inside a tabs shortcode\nA code block using the Prism Shortcode This shortcode is nested inside a Tabs shortcode "
            }
        );
    index.add(
            {
                id:  76 ,
                href: "\/docs\/demo\/shortcodes\/katex\/",
                title: "KaTex",
                description: "A Shortcode to render KaTex syntax in your Lotus Docs site",
                content: "Lotus Docs has "
            }
        );
    search.addEventListener('input', show_results, true);

    function show_results(){
        const maxResult =  5 ;
        const minlength =  0 ;
        var searchQuery = sanitizeHTML(this.value);
        var results = index.search(searchQuery, {limit: maxResult, enrich: true});

        
        const flatResults = new Map(); 
        for (const result of results.flatMap(r => r.result)) {
        if (flatResults.has(result.doc.href)) continue;
        flatResults.set(result.doc.href, result.doc);
        }

        suggestions.innerHTML = "";
        suggestions.classList.remove('d-none');

        
        if (searchQuery.length < minlength) {
            const minCharMessage = document.createElement('div')
            minCharMessage.innerHTML = `Please type at least <strong>${minlength}</strong> characters`
            minCharMessage.classList.add("suggestion__no-results");
            suggestions.appendChild(minCharMessage);
            return;
        } else {
            
            if (flatResults.size === 0 && searchQuery) {
                const noResultsMessage = document.createElement('div')
                noResultsMessage.innerHTML = "No results for" + ` "<strong>${searchQuery}</strong>"`
                noResultsMessage.classList.add("suggestion__no-results");
                suggestions.appendChild(noResultsMessage);
                return;
            }
        }

        
        for(const [href, doc] of flatResults) {
            const entry = document.createElement('div');
            suggestions.appendChild(entry);

            const a = document.createElement('a');
            a.href = href;
            entry.appendChild(a);

            const title = document.createElement('span');
            title.textContent = doc.title;
            title.classList.add("suggestion__title");
            a.appendChild(title);

            const description = document.createElement('span');
            description.textContent = doc.description;
            description.classList.add("suggestion__description");
            a.appendChild(description);

            suggestions.appendChild(entry);

            if(suggestions.childElementCount == maxResult) break;
        }
    }
    }());
</script>
        
    </body>
</html>