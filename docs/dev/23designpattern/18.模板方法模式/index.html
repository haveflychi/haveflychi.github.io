<!DOCTYPE html>





    
        
    

    
        
    

    

    

<html lang="zh-CN"><head>
    <meta charset="utf-8" />
    <title>18.模板方法模式 | Maxbit Docs</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="模板方法模式（Template Method Pattern）是一种行为型设计模式, 它定义了一个算法的骨架，将**一些步骤的实现延迟到子类。**模板方法模式使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤。">
    <meta name="keywords" content="Documentation, Hugo, Hugo Theme, Bootstrap" />
    <meta name="author" content="Colin Wilson - Lotus Labs" />
    <meta name="email" content="support@aigis.uk" />
    <meta name="website" content="https://lotusdocs.dev" />
    <meta name="Version" content="v0.1.0" />
    
    <link rel="icon" href="https://docs.cakepanit.com/favicon.ico" sizes="any">
<link rel="icon" type="image/svg+xml" href="https://docs.cakepanit.com/favicon.svg">
<link rel="apple-touch-icon" sizes="180x180" href="https://docs.cakepanit.com/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://docs.cakepanit.com/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="https://docs.cakepanit.com/favicon-16x16.png">
<link rel="manifest" crossorigin="use-credentials" href="https://docs.cakepanit.com/site.webmanifest">
<meta property="og:title" content="18.模板方法模式" />
<meta property="og:description" content="模板方法模式（Template Method Pattern）是一种行为型设计模式, 它定义了一个算法的骨架，将**一些步骤的实现延迟到子类。**模板方法模式使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://docs.cakepanit.com/docs/dev/23designpattern/18.%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/" /><meta property="og:image" content="https://docs.cakepanit.com/opengraph/card-base-2_hu06b1a92291a380a0d2e0ec03dab66b2f_17642_filter_17787658038863818920.png"/><meta property="article:section" content="docs" />
<meta property="article:published_time" content="2023-05-03T22:37:22+01:00" />
<meta property="article:modified_time" content="2023-05-03T22:37:22+01:00" /><meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://docs.cakepanit.com/opengraph/card-base-2_hu06b1a92291a380a0d2e0ec03dab66b2f_17642_filter_17787658038863818920.png"/>
<meta name="twitter:title" content="18.模板方法模式"/>
<meta name="twitter:description" content="模板方法模式（Template Method Pattern）是一种行为型设计模式, 它定义了一个算法的骨架，将**一些步骤的实现延迟到子类。**模板方法模式使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤。"/>

    
    <script>(()=>{var t=window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches,e=localStorage.getItem("theme");t&&e===null&&(localStorage.setItem("theme","dark"),document.documentElement.setAttribute("data-dark-mode","")),t&&e==="dark"&&document.documentElement.setAttribute("data-dark-mode",""),e==="dark"&&document.documentElement.setAttribute("data-dark-mode","")})()</script>
    
    
            
                
                <script type="text/javascript" src="https://docs.cakepanit.com/docs/js/flexsearch.bundle.min.249548594cb6843f3060a3cdd3043799676c59ce8db83358a3fc2e4d20598d05dfa6ce4994805d2835cb33b54dc9b9e7.js" integrity="sha384-JJVIWUy2hD8wYKPN0wQ3mWdsWc6NuDNYo/wuTSBZjQXfps5JlIBdKDXLM7VNybnn" crossorigin="anonymous"></script>
                
        
    
    
    
    
        
        
        
        
    
        
        
        
        
    
    
    <link rel="preconnect" href="https://fonts.gstatic.com/" />
    <link rel="preconnect" href="https://fonts.gstatic.com/" crossorigin />
    <link href="https://fonts.googleapis.com/css?family=Inter:300,400,600,700|Fira+Code:500,700&display=block" rel="stylesheet">

    <link rel="stylesheet" href="/docs/scss/style.min.c192029c65686157242dc1ec592017ac3aee67550ca58756b09fc7d0ead882b74a61f12253e9114c8aed414ccfcbf673.css" integrity="sha384-wZICnGVoYVckLcHsWSAXrDruZ1UMpYdWsJ/H0OrYgrdKYfEiU&#43;kRTIrtQUzPy/Zz"crossorigin="anonymous">
    
    
    
    
  
    
      <script async src="https://www.googletagmanager.com/gtag/js?id=G-YZYFSV46F3"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-YZYFSV46F3');
        }
      </script>
    
  

</head><body>
        <div class="content">
            <div class="page-wrapper toggled">
<nav id="sidebar" class="sidebar-wrapper">
    <div class="sidebar-brand">
        <a href='/' aria-label="HomePage" alt="HomePage">
            
                <?xml version="1.0" encoding="UTF-8"?><svg id="Layer_1" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 250 250"><path d="m143,39.5c-18,0-18,18-18,18,0,0,0-18-18-18H22c-2.76,0-5,2.24-5,5v143c0,2.76,2.24,5,5,5h76c7.2,0,8.64,11.52,8.93,16.13.07,1.05.95,1.87,2,1.87h32.14c1.06,0,1.94-.82,2-1.87.29-4.61,1.73-16.13,8.93-16.13h76c2.76,0,5-2.24,5-5V44.5c0-2.76-2.24-5-5-5h-85Zm63,123.5c0,1.38-1.12,2.5-2.5,2.5h-60.5c-18,0-18,18-18,18,0,0,0-18-18-18h-60.5c-1.38,0-2.5-1.12-2.5-2.5v-94c0-1.38,1.12-2.5,2.5-2.5h51.5c7.2,0,8.64,11.52,8.93,16.13.07,1.05.95,1.87,2,1.87h32.14c1.06,0,1.94-.82,2-1.87.29-4.61,1.73-16.13,8.93-16.13h51.5c1.38,0,2.5,1.12,2.5,2.5v94Z" style="fill:#06f;"/></svg>
            
        </a>
    </div>
    <div class="sidebar-content" style="height: calc(100% - 131px);">
        <ul class="sidebar-menu">
            
                
                
                    
                    
                        <li class="sidebar-dropdown  current active">
                            <button class="btn">
                                <i class="material-icons me-2">Code</i>
                                DEV
                            </button>
                            <div class="sidebar-submenu d-block">
                                <ul>
                                    
                                        
                                        
                                            <li class="sidebar-dropdown nested  current active">
                                                <button class="btn">
                                                    
                                                    23种设计模式
                                                </button>
                                                <div class="sidebar-submenu d-block">
                                                    <ul>
                                                        
                                                            
                                                            
                                                                <li class=" "><a class="sidebar-nested-link" href="https://docs.cakepanit.com/docs/dev/23designpattern/1.%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/">1.单例模式</a></li>
                                                            
                                                        
                                                            
                                                            
                                                                <li class=" "><a class="sidebar-nested-link" href="https://docs.cakepanit.com/docs/dev/23designpattern/2.%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/">2.工厂方法模式</a></li>
                                                            
                                                        
                                                            
                                                            
                                                                <li class=" "><a class="sidebar-nested-link" href="https://docs.cakepanit.com/docs/dev/23designpattern/3.%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/">3.抽象工厂模式</a></li>
                                                            
                                                        
                                                            
                                                            
                                                                <li class=" "><a class="sidebar-nested-link" href="https://docs.cakepanit.com/docs/dev/23designpattern/4.%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/">4.建造者模式</a></li>
                                                            
                                                        
                                                            
                                                            
                                                                <li class=" "><a class="sidebar-nested-link" href="https://docs.cakepanit.com/docs/dev/23designpattern/5.%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/">5.原型模式</a></li>
                                                            
                                                        
                                                            
                                                            
                                                                <li class=" "><a class="sidebar-nested-link" href="https://docs.cakepanit.com/docs/dev/23designpattern/6.%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/">6.适配器模式</a></li>
                                                            
                                                        
                                                            
                                                            
                                                                <li class=" "><a class="sidebar-nested-link" href="https://docs.cakepanit.com/docs/dev/23designpattern/7.%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/">7.代理模式</a></li>
                                                            
                                                        
                                                            
                                                            
                                                                <li class=" "><a class="sidebar-nested-link" href="https://docs.cakepanit.com/docs/dev/23designpattern/8.%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/">8.装饰模式</a></li>
                                                            
                                                        
                                                            
                                                            
                                                                <li class=" "><a class="sidebar-nested-link" href="https://docs.cakepanit.com/docs/dev/23designpattern/9.%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/">9.外观模式</a></li>
                                                            
                                                        
                                                            
                                                            
                                                                <li class=" "><a class="sidebar-nested-link" href="https://docs.cakepanit.com/docs/dev/23designpattern/10.%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/">10.桥接模式</a></li>
                                                            
                                                        
                                                            
                                                            
                                                                <li class=" "><a class="sidebar-nested-link" href="https://docs.cakepanit.com/docs/dev/23designpattern/11.%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/">11.组合模式</a></li>
                                                            
                                                        
                                                            
                                                            
                                                                <li class=" "><a class="sidebar-nested-link" href="https://docs.cakepanit.com/docs/dev/23designpattern/12.%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/">12.享元模式</a></li>
                                                            
                                                        
                                                            
                                                            
                                                                <li class=" "><a class="sidebar-nested-link" href="https://docs.cakepanit.com/docs/dev/23designpattern/13.%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/">13.观察者模式</a></li>
                                                            
                                                        
                                                            
                                                            
                                                                <li class=" "><a class="sidebar-nested-link" href="https://docs.cakepanit.com/docs/dev/23designpattern/14.%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/">14.策略模式</a></li>
                                                            
                                                        
                                                            
                                                            
                                                                <li class=" "><a class="sidebar-nested-link" href="https://docs.cakepanit.com/docs/dev/23designpattern/15.%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/">15.命令模式</a></li>
                                                            
                                                        
                                                            
                                                            
                                                                <li class=" "><a class="sidebar-nested-link" href="https://docs.cakepanit.com/docs/dev/23designpattern/16.%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/">16.中介者模式</a></li>
                                                            
                                                        
                                                            
                                                            
                                                                <li class=" "><a class="sidebar-nested-link" href="https://docs.cakepanit.com/docs/dev/23designpattern/17.%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F/">17.备忘录模式</a></li>
                                                            
                                                        
                                                            
                                                            
                                                                <li class="current "><a class="sidebar-nested-link" href="https://docs.cakepanit.com/docs/dev/23designpattern/18.%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/">18.模板方法模式</a></li>
                                                            
                                                        
                                                            
                                                            
                                                                <li class=" "><a class="sidebar-nested-link" href="https://docs.cakepanit.com/docs/dev/23designpattern/19.%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/">19.迭代器模式</a></li>
                                                            
                                                        
                                                            
                                                            
                                                                <li class=" "><a class="sidebar-nested-link" href="https://docs.cakepanit.com/docs/dev/23designpattern/20.%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/">20.状态模式</a></li>
                                                            
                                                        
                                                            
                                                            
                                                                <li class=" "><a class="sidebar-nested-link" href="https://docs.cakepanit.com/docs/dev/23designpattern/21.%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/">21.责任链模式</a></li>
                                                            
                                                        
                                                            
                                                            
                                                                <li class=" "><a class="sidebar-nested-link" href="https://docs.cakepanit.com/docs/dev/23designpattern/22.%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F/">22.解释器模式</a></li>
                                                            
                                                        
                                                            
                                                            
                                                                <li class=" "><a class="sidebar-nested-link" href="https://docs.cakepanit.com/docs/dev/23designpattern/23.%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F/">23.访问者模式</a></li>
                                                            
                                                        
                                                    </ul>
                                                </div>
                                            </li>
                                        
                                    
                                        
                                        
                                            <li class="sidebar-dropdown nested  ">
                                                <button class="btn">
                                                    
                                                    Golang
                                                </button>
                                                <div class="sidebar-submenu ">
                                                    <ul>
                                                        
                                                            
                                                            
                                                                <li class="sidebar-dropdown nested  ">
                                                                    <button class="btn">
                                                                        
                                                                        Fyne
                                                                    </button>
                                                                    <div class="sidebar-submenu ">
                                                                        <ul>
                                                                            
                                                                                
                                                                                
                                                                                    <li class=" "><a class="sidebar-nested-link" href="https://docs.cakepanit.com/docs/dev/golang/fyne/1.%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%AD%A6%E4%B9%A0fyne/">1.为什么要学习Fyne？</a></li>
                                                                                
                                                                            
                                                                                
                                                                                
                                                                                    <li class=" "><a class="sidebar-nested-link" href="https://docs.cakepanit.com/docs/dev/golang/fyne/2.%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%B0%8F%E9%A1%B9%E7%9B%AE/">2.第一个小项目</a></li>
                                                                                
                                                                            
                                                                                
                                                                                
                                                                                    <li class=" "><a class="sidebar-nested-link" href="https://docs.cakepanit.com/docs/dev/golang/fyne/3.%E5%A4%84%E7%90%86%E5%A4%9A%E7%AA%97%E5%8F%A3/">3.处理多窗口问题</a></li>
                                                                                
                                                                            
                                                                                
                                                                                
                                                                                    <li class=" "><a class="sidebar-nested-link" href="https://docs.cakepanit.com/docs/dev/golang/fyne/4.go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%BF%AB%E9%80%9F%E9%80%9A%E5%85%B3/">4.Go基础速通</a></li>
                                                                                
                                                                            
                                                                                
                                                                                
                                                                                    <li class=" "><a class="sidebar-nested-link" href="https://docs.cakepanit.com/docs/dev/golang/fyne/5.%E6%9B%B4%E5%A4%8D%E6%9D%82%E7%9A%84%E9%A1%B9%E7%9B%AE/">5.更复杂的项目</a></li>
                                                                                
                                                                            
                                                                                
                                                                                
                                                                                    <li class="sidebar-dropdown nested  ">
                                                                                        <button class="btn">
                                                                                            
                                                                                            项目案例
                                                                                        </button>
                                                                                        <div class="sidebar-submenu ">
                                                                                            <ul>
                                                                                                
                                                                                                    
                                                                                                    <li class=" "><a class="sidebar-nested-link" href="https://docs.cakepanit.com/docs/dev/golang/fyne/project/1.markdown%E7%BC%96%E8%BE%91%E5%99%A8/">Fyne-Markdown编辑器</a></li>
                                                                                                
                                                                                                    
                                                                                                    <li class=" "><a class="sidebar-nested-link" href="https://docs.cakepanit.com/docs/dev/golang/fyne/project/2.%E8%B6%A3%E5%91%B3%E6%95%B4%E6%B4%BB%E9%A1%B9%E7%9B%AE/">Fyne-趣味整活项目</a></li>
                                                                                                
                                                                                            </ul>
                                                                                        </div>
                                                                                    </li>
                                                                                
                                                                            
                                                                        </ul>
                                                                    </div>
                                                                </li>
                                                            
                                                        
                                                    </ul>
                                                </div>
                                            </li>
                                        
                                    
                                </ul>
                            </div>
                        </li>
                    
                
                    
                    
                        <li class="sidebar-dropdown  ">
                            <button class="btn">
                                <i class="material-icons me-2">cloud_done</i>
                                OPS
                            </button>
                            <div class="sidebar-submenu ">
                                <ul>
                                    
                                        
                                        
                                            <li class="sidebar-dropdown nested  ">
                                                <button class="btn">
                                                    
                                                    Kubernetes
                                                </button>
                                                <div class="sidebar-submenu ">
                                                    <ul>
                                                        
                                                            
                                                            
                                                                <li class=" "><a class="sidebar-nested-link" href="https://docs.cakepanit.com/docs/ops/kubernetes/1.kubernetes-v1.28.3%E4%BA%8C%E8%BF%9B%E5%88%B6%E9%83%A8%E7%BD%B2/">1.Kubernetes-v1.28.3高可用集群二进制部署(IPv4&#43;IPv6双栈)</a></li>
                                                            
                                                        
                                                            
                                                            
                                                                <li class=" "><a class="sidebar-nested-link" href="https://docs.cakepanit.com/docs/ops/kubernetes/2.kubernetes-v1.30.2%E4%BA%8C%E8%BF%9B%E5%88%B6%E9%83%A8%E7%BD%B2/">2.Kubernetes-v1.30.2高可用集群二进制部署(IPv4&#43;IPv6双栈)</a></li>
                                                            
                                                        
                                                            
                                                            
                                                                <li class=" "><a class="sidebar-nested-link" href="https://docs.cakepanit.com/docs/ops/kubernetes/3.%E5%8D%87%E7%BA%A7%E4%BA%8C%E8%BF%9B%E5%88%B6%E9%83%A8%E7%BD%B2%E7%9A%84kubernetes%E9%9B%86%E7%BE%A4/">3.升级二进制部署的kubernetes集群</a></li>
                                                            
                                                        
                                                    </ul>
                                                </div>
                                            </li>
                                        
                                    
                                        
                                        
                                            <li class=" "><a class="sidebar-nested-link" href="https://docs.cakepanit.com/docs/ops/1.nginx%E9%85%8D%E7%BD%AE%E5%B0%8F%E5%85%A8/">1.Nginx配置小全</a></li>
                                        
                                    
                                </ul>
                            </div>
                        </li>
                    
                
                    
                    
                        <li class="sidebar-dropdown  ">
                            <button class="btn">
                                <i class="material-icons me-2">database</i>
                                DBA
                            </button>
                            <div class="sidebar-submenu ">
                                <ul>
                                    
                                        
                                        
                                            <li class=" "><a class="sidebar-nested-link" href="https://docs.cakepanit.com/docs/dba/dome/">第一篇WIKI</a></li>
                                        
                                    
                                </ul>
                            </div>
                        </li>
                    
                
                    
                    
                        <li class="sidebar-dropdown  ">
                            <button class="btn">
                                <i class="material-icons me-2">edit</i>
                                DEMO
                            </button>
                            <div class="sidebar-submenu ">
                                <ul>
                                    
                                        
                                        
                                            <li class="sidebar-dropdown nested  ">
                                                <button class="btn">
                                                    
                                                    Features
                                                </button>
                                                <div class="sidebar-submenu ">
                                                    <ul>
                                                        
                                                            
                                                            
                                                                <li class=" "><a class="sidebar-nested-link" href="https://docs.cakepanit.com/docs/demo/features/syntax-highlighting/">Syntax Highlighting</a></li>
                                                            
                                                        
                                                            
                                                            
                                                                <li class=" "><a class="sidebar-nested-link" href="https://docs.cakepanit.com/docs/demo/features/katex/">KaTex</a></li>
                                                            
                                                        
                                                            
                                                            
                                                                <li class=" "><a class="sidebar-nested-link" href="https://docs.cakepanit.com/docs/demo/features/mermaid/">Mermaid</a></li>
                                                            
                                                        
                                                    </ul>
                                                </div>
                                            </li>
                                        
                                    
                                        
                                        
                                            <li class="sidebar-dropdown nested  ">
                                                <button class="btn">
                                                    
                                                    Shortcodes
                                                </button>
                                                <div class="sidebar-submenu ">
                                                    <ul>
                                                        
                                                            
                                                            
                                                                <li class=" "><a class="sidebar-nested-link" href="https://docs.cakepanit.com/docs/demo/shortcodes/alerts/">Alerts</a></li>
                                                            
                                                        
                                                            
                                                            
                                                                <li class=" "><a class="sidebar-nested-link" href="https://docs.cakepanit.com/docs/demo/shortcodes/tables/">Tables</a></li>
                                                            
                                                        
                                                            
                                                            
                                                                <li class=" "><a class="sidebar-nested-link" href="https://docs.cakepanit.com/docs/demo/shortcodes/tabs/">Tabs</a></li>
                                                            
                                                        
                                                            
                                                            
                                                                <li class=" "><a class="sidebar-nested-link" href="https://docs.cakepanit.com/docs/demo/shortcodes/prism/">Prism</a></li>
                                                            
                                                        
                                                            
                                                            
                                                                <li class=" "><a class="sidebar-nested-link" href="https://docs.cakepanit.com/docs/demo/shortcodes/markdownify/">Markdownify</a></li>
                                                            
                                                        
                                                            
                                                            
                                                                <li class=" "><a class="sidebar-nested-link" href="https://docs.cakepanit.com/docs/demo/shortcodes/katex/">KaTex</a></li>
                                                            
                                                        
                                                    </ul>
                                                </div>
                                            </li>
                                        
                                    
                                </ul>
                            </div>
                        </li>
                    
                
            
        </ul>
        
    </div>
    
        <ul class="sidebar-footer list-unstyled mb-0">
            
        </ul>
    
</nav>

                    <main class="page-content bg-transparent">
                        
<div id="top-header" class="top-header d-print-none">
    <div class="header-bar d-flex justify-content-between">
        <div class="d-flex align-items-center">
            <a href='/' class="logo-icon me-3" aria-label="HomePage" alt="HomePage">
                <div class="small">
                    
                            <?xml version="1.0" encoding="UTF-8"?><svg id="Layer_1" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 250 250"><path d="m143,39.5c-18,0-18,18-18,18,0,0,0-18-18-18H22c-2.76,0-5,2.24-5,5v143c0,2.76,2.24,5,5,5h76c7.2,0,8.64,11.52,8.93,16.13.07,1.05.95,1.87,2,1.87h32.14c1.06,0,1.94-.82,2-1.87.29-4.61,1.73-16.13,8.93-16.13h76c2.76,0,5-2.24,5-5V44.5c0-2.76-2.24-5-5-5h-85Zm63,123.5c0,1.38-1.12,2.5-2.5,2.5h-60.5c-18,0-18,18-18,18,0,0,0-18-18-18h-60.5c-1.38,0-2.5-1.12-2.5-2.5v-94c0-1.38,1.12-2.5,2.5-2.5h51.5c7.2,0,8.64,11.52,8.93,16.13.07,1.05.95,1.87,2,1.87h32.14c1.06,0,1.94-.82,2-1.87.29-4.61,1.73-16.13,8.93-16.13h51.5c1.38,0,2.5,1.12,2.5,2.5v94Z" style="fill:#06f;"/></svg>
                    
                </div>
                <div class="big">
                    
                            <?xml version="1.0" encoding="UTF-8"?><svg id="Layer_1" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 250 250"><path d="m143,39.5c-18,0-18,18-18,18,0,0,0-18-18-18H22c-2.76,0-5,2.24-5,5v143c0,2.76,2.24,5,5,5h76c7.2,0,8.64,11.52,8.93,16.13.07,1.05.95,1.87,2,1.87h32.14c1.06,0,1.94-.82,2-1.87.29-4.61,1.73-16.13,8.93-16.13h76c2.76,0,5-2.24,5-5V44.5c0-2.76-2.24-5-5-5h-85Zm63,123.5c0,1.38-1.12,2.5-2.5,2.5h-60.5c-18,0-18,18-18,18,0,0,0-18-18-18h-60.5c-1.38,0-2.5-1.12-2.5-2.5v-94c0-1.38,1.12-2.5,2.5-2.5h51.5c7.2,0,8.64,11.52,8.93,16.13.07,1.05.95,1.87,2,1.87h32.14c1.06,0,1.94-.82,2-1.87.29-4.61,1.73-16.13,8.93-16.13h51.5c1.38,0,2.5,1.12,2.5,2.5v94Z" style="fill:#06f;"/></svg>
                    
                </div>
            </a>
            <button id="close-sidebar" class="btn btn-icon btn-soft">
                <span class="material-icons size-20 menu-icon align-middle">menu</span>
            </button>
            
            
                    
                    <button id="flexsearch-button" class="ms-3 btn btn-soft" data-bs-toggle="collapse" data-bs-target="#FlexSearchCollapse" aria-expanded="false" aria-controls="FlexSearchCollapse">
                        <span class="material-icons size-20 menu-icon align-middle">search</span>
                        <span class="flexsearch-button-placeholder ms-1 me-2 d-none d-sm-block">Search</span>
                        <div class="d-none d-sm-block">
                            <span class="flexsearch-button-keys">
                                <kbd class="flexsearch-button-cmd-key">
                                    <svg width="44" height="15"><path d="M2.118,11.5A1.519,1.519,0,0,1,1,11.042,1.583,1.583,0,0,1,1,8.815a1.519,1.519,0,0,1,1.113-.458h.715V6.643H2.118A1.519,1.519,0,0,1,1,6.185,1.519,1.519,0,0,1,.547,5.071,1.519,1.519,0,0,1,1,3.958,1.519,1.519,0,0,1,2.118,3.5a1.519,1.519,0,0,1,1.114.458A1.519,1.519,0,0,1,3.69,5.071v.715H5.4V5.071A1.564,1.564,0,0,1,6.976,3.5,1.564,1.564,0,0,1,8.547,5.071,1.564,1.564,0,0,1,6.976,6.643H6.261V8.357h.715a1.575,1.575,0,0,1,1.113,2.685,1.583,1.583,0,0,1-2.227,0A1.519,1.519,0,0,1,5.4,9.929V9.214H3.69v.715a1.519,1.519,0,0,1-.458,1.113A1.519,1.519,0,0,1,2.118,11.5Zm0-.857a.714.714,0,0,0,.715-.714V9.214H2.118a.715.715,0,1,0,0,1.429Zm4.858,0a.715.715,0,1,0,0-1.429H6.261v.715a.714.714,0,0,0,.715.714ZM3.69,8.357H5.4V6.643H3.69ZM2.118,5.786h.715V5.071a.714.714,0,0,0-.715-.714.715.715,0,0,0-.5,1.22A.686.686,0,0,0,2.118,5.786Zm4.143,0h.715a.715.715,0,0,0,.5-1.22.715.715,0,0,0-1.22.5Z" fill="currentColor"></path><path d="M12.4,11.475H11.344l3.879-7.95h1.056Z" fill="currentColor"></path><path d="M25.073,5.384l-.864.576a2.121,2.121,0,0,0-1.786-.923,2.207,2.207,0,0,0-2.266,2.326,2.206,2.206,0,0,0,2.266,2.325,2.1,2.1,0,0,0,1.782-.918l.84.617a3.108,3.108,0,0,1-2.622,1.293,3.217,3.217,0,0,1-3.349-3.317,3.217,3.217,0,0,1,3.349-3.317A3.046,3.046,0,0,1,25.073,5.384Z" fill="currentColor"></path><path d="M30.993,5.142h-2.07v5.419H27.891V5.142h-2.07V4.164h5.172Z" fill="currentColor"></path><path d="M34.67,4.164c1.471,0,2.266.658,2.266,1.851,0,1.087-.832,1.809-2.134,1.855l2.107,2.691h-1.28L33.591,7.87H33.07v2.691H32.038v-6.4Zm-1.6.969v1.8h1.572c.832,0,1.22-.3,1.22-.918s-.411-.882-1.22-.882Z" fill="currentColor"></path><path d="M42.883,10.561H38.31v-6.4h1.033V9.583h3.54Z" fill="currentColor"></path></svg>
                                </kbd>
                                <kbd class="flexsearch-button-key">
                                    <svg width="15" height="15"><path d="M5.926,12.279H4.41L9.073,2.721H10.59Z" fill="currentColor"/></svg>
                                </kbd>
                            </span>
                        </div>
                    </button>
                
            </div>

        <div class="d-flex align-items-center">
            <ul class="list-unstyled mb-0">
                
                
                    
                    <li class="list-inline-item mb-0">
                        <a href=" https://github.com/bingdang " alt="github" rel="noopener noreferrer" target="_blank">
                            <div class="btn btn-icon btn-default border-0">
                                
                                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><title>GitHub</title><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path></svg>
                                
                            </div>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item mb-0">
                        <a href=" https://twitter.com/# " alt="twitter" rel="noopener noreferrer" target="_blank">
                            <div class="btn btn-icon btn-default border-0">
                                
                                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><title>Twitter / X</title><path d="M.088.768l9.266,12.39L.029,23.231h2.1l8.163-8.819,6.6,8.819h7.142L14.242,10.145,22.921.768h-2.1L13.3,8.891,7.229.768ZM3.174,2.314H6.455L20.942,21.685h-3.28Z" fill="currentColor"/></svg>
                                
                            </div>
                        </a>
                    </li>
                    
                
            </ul>
            <button id="mode" class="btn btn-icon btn-default ms-2" type="button" aria-label="Toggle user interface mode">
                <span class="toggle-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" height="30" width="30" viewBox="0 0 48 48" fill="currentColor">
                        <title>Enable dark mode</title>
                        <path d="M24 42q-7.5 0-12.75-5.25T6 24q0-7.5 5.25-12.75T24 6q.4 0 .85.025.45.025 1.15.075-1.8 1.6-2.8 3.95-1 2.35-1 4.95 0 4.5 3.15 7.65Q28.5 25.8 33 25.8q2.6 0 4.95-.925T41.9 22.3q.05.6.075.975Q42 23.65 42 24q0 7.5-5.25 12.75T24 42Zm0-3q5.45 0 9.5-3.375t5.05-7.925q-1.25.55-2.675.825Q34.45 28.8 33 28.8q-5.75 0-9.775-4.025T19.2 15q0-1.2.25-2.575.25-1.375.9-3.125-4.9 1.35-8.125 5.475Q9 18.9 9 24q0 6.25 4.375 10.625T24 39Zm-.2-14.85Z"/>
                    </svg>
                </span>
                <span class="toggle-light">
                    <svg xmlns="http://www.w3.org/2000/svg" height="30" width="30" viewBox="0 0 48 48" fill="currentColor">
                        <title>Enable light mode</title>
                        <path d="M24 31q2.9 0 4.95-2.05Q31 26.9 31 24q0-2.9-2.05-4.95Q26.9 17 24 17q-2.9 0-4.95 2.05Q17 21.1 17 24q0 2.9 2.05 4.95Q21.1 31 24 31Zm0 3q-4.15 0-7.075-2.925T14 24q0-4.15 2.925-7.075T24 14q4.15 0 7.075 2.925T34 24q0 4.15-2.925 7.075T24 34ZM3.5 25.5q-.65 0-1.075-.425Q2 24.65 2 24q0-.65.425-1.075Q2.85 22.5 3.5 22.5h5q.65 0 1.075.425Q10 23.35 10 24q0 .65-.425 1.075-.425.425-1.075.425Zm36 0q-.65 0-1.075-.425Q38 24.65 38 24q0-.65.425-1.075.425-.425 1.075-.425h5q.65 0 1.075.425Q46 23.35 46 24q0 .65-.425 1.075-.425.425-1.075.425ZM24 10q-.65 0-1.075-.425Q22.5 9.15 22.5 8.5v-5q0-.65.425-1.075Q23.35 2 24 2q.65 0 1.075.425.425.425.425 1.075v5q0 .65-.425 1.075Q24.65 10 24 10Zm0 36q-.65 0-1.075-.425-.425-.425-.425-1.075v-5q0-.65.425-1.075Q23.35 38 24 38q.65 0 1.075.425.425.425.425 1.075v5q0 .65-.425 1.075Q24.65 46 24 46ZM12 14.1l-2.85-2.8q-.45-.45-.425-1.075.025-.625.425-1.075.45-.45 1.075-.45t1.075.45L14.1 12q.4.45.4 1.05 0 .6-.4 1-.4.45-1.025.45-.625 0-1.075-.4Zm24.7 24.75L33.9 36q-.4-.45-.4-1.075t.45-1.025q.4-.45 1-.45t1.05.45l2.85 2.8q.45.45.425 1.075-.025.625-.425 1.075-.45.45-1.075.45t-1.075-.45ZM33.9 14.1q-.45-.45-.45-1.05 0-.6.45-1.05l2.8-2.85q.45-.45 1.075-.425.625.025 1.075.425.45.45.45 1.075t-.45 1.075L36 14.1q-.4.4-1.025.4-.625 0-1.075-.4ZM9.15 38.85q-.45-.45-.45-1.075t.45-1.075L12 33.9q.45-.45 1.05-.45.6 0 1.05.45.45.45.45 1.05 0 .6-.45 1.05l-2.8 2.85q-.45.45-1.075.425-.625-.025-1.075-.425ZM24 24Z"/>
                    </svg>
                </span>
            </button>
            
        </div>
    </div>
    
    
            <div class="collapse" id="FlexSearchCollapse">
                <div class="flexsearch-container">
                    <div class="flexsearch-keymap">
                        <li>
                            <kbd class="flexsearch-button-cmd-key"><svg width="15" height="15" aria-label="Arrow down" role="img"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.2"><path d="M7.5 3.5v8M10.5 8.5l-3 3-3-3"></path></g></svg></kbd>
                            <kbd class="flexsearch-button-cmd-key"><svg width="15" height="15" aria-label="Arrow up" role="img"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.2"><path d="M7.5 11.5v-8M10.5 6.5l-3-3-3 3"></path></g></svg></kbd>
                            <span class="flexsearch-key-label">to navigate</span>
                        </li>
                        <li>
                            <kbd class="flexsearch-button-cmd-key"><svg width="15" height="15" aria-label="Enter key" role="img"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.2"><path d="M12 3.53088v3c0 1-1 2-2 2H4M7 11.53088l-3-3 3-3"></path></g></svg></kbd>
                            <span class="flexsearch-key-label">to select</span>
                        </li>
                        <li>
                            <kbd class="flexsearch-button-cmd-key"><svg width="15" height="15" aria-label="Escape key" role="img"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.2"><path d="M13.6167 8.936c-.1065.3583-.6883.962-1.4875.962-.7993 0-1.653-.9165-1.653-2.1258v-.5678c0-1.2548.7896-2.1016 1.653-2.1016.8634 0 1.3601.4778 1.4875 1.0724M9 6c-.1352-.4735-.7506-.9219-1.46-.8972-.7092.0246-1.344.57-1.344 1.2166s.4198.8812 1.3445.9805C8.465 7.3992 8.968 7.9337 9 8.5c.032.5663-.454 1.398-1.4595 1.398C6.6593 9.898 6 9 5.963 8.4851m-1.4748.5368c-.2635.5941-.8099.876-1.5443.876s-1.7073-.6248-1.7073-2.204v-.4603c0-1.0416.721-2.131 1.7073-2.131.9864 0 1.6425 1.031 1.5443 2.2492h-2.956"></path></g></svg></kbd>
                            <span class="flexsearch-key-label">to close</span>
                        </li>
                    </div>
                    <form class="flexsearch position-relative flex-grow-1 ms-2 me-2">
                        <div class="d-flex flex-row">
                            <input id="flexsearch" class="form-control" type="search" placeholder="Search" aria-label="Search" autocomplete="off">
                            <button id="hideFlexsearch" type="button" class="ms-2 btn btn-soft">
                                cancel
                            </button>
                        </div>
                        <div id="suggestions" class="shadow rounded-1 d-none"></div>
                    </form>
                </div>
            </div>
        
    
    
</div>

                            <div class="container-fluid">
                                <div class="layout-spacing">
                                    
                                        <div class="d-md-flex justify-content-between align-items-center"><nav aria-label="breadcrumb" class="d-inline-block pb-2 mt-1 mt-sm-0">
    <ul id="breadcrumbs" class="breadcrumb bg-transparent mb-0" itemscope itemtype="https://schema.org/BreadcrumbList">
        
            
                <li class="breadcrumb-item text-capitalize active" aria-current="page" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem">
                    <a itemprop="item" href="/docs/">
                        <i class="material-icons size-20 align-text-bottom" itemprop="name">Home</i>
                    </a>
                    <meta itemprop="position" content='1' />
                </li>
            
            
                <li class="breadcrumb-item text-capitalize" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem">
                    <a itemprop="item" href="/docs/dev/">
                        <span itemprop="name">DEV</span>
                    </a>
                    <meta itemprop="position" content='2' />
                </li>
            
            
                <li class="breadcrumb-item text-capitalize" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem">
                    <a itemprop="item" href="/docs/dev/23designpattern/">
                        <span itemprop="name">23种设计模式</span>
                    </a>
                    <meta itemprop="position" content='3' />
                </li>
            
        
            <li class="breadcrumb-item text-capitalize active" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem">
                <span itemprop="name">18.模板方法模式</span>
                <meta itemprop="position" content='4' />
            </li>
        
    </ul>
</nav></div>
                                    
                                    <div class="row flex-xl-nowrap">
                                        
                                        <div class="docs-toc col-xl-3    d-xl-block"><toc>
    <div class="fw-bold text-uppercase mb-2">On this page</div>
    <nav id="toc">
  <ul>
    <li>
      <ul>
        <li>
          <ul>
            <li><a href="#需求">需求</a></li>
            <li><a href="#基本概念">基本概念</a></li>
            <li><a href="#基本结构">基本结构</a></li>
            <li><a href="#简易实现">简易实现</a></li>
            <li><a href="#应用场景">应用场景</a></li>
            <li><a href="#本题代码">本题代码</a></li>
          </ul>
        </li>
        <li><a href="#其他语言版本">其他语言版本</a>
          <ul>
            <li><a href="#java">Java</a></li>
            <li><a href="#c">C++</a></li>
            <li><a href="#python">Python</a></li>
            <li><a href="#go">Go</a></li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</nav>
    </toc></div>
                                        
                                        
                                        <div class="docs-toc-mobile    d-print-none d-xl-none">
                                            <button id="toc-dropdown-btn" class="btn-secondary dropdown-toggle" type="button" data-bs-toggle="dropdown" data-bs-offset="0,0" aria-expanded="false">
                                                Table of Contents
                                            </button>
<nav id="toc-mobile">
  <ul class="dropdown-menu">
    <li>
      <ul>
        <li>
          <ul>
            <li><a href="#需求">需求</a></li>
            <li><a href="#基本概念">基本概念</a></li>
            <li><a href="#基本结构">基本结构</a></li>
            <li><a href="#简易实现">简易实现</a></li>
            <li><a href="#应用场景">应用场景</a></li>
            <li><a href="#本题代码">本题代码</a></li>
          </ul>
        </li>
        <li><a href="#其他语言版本">其他语言版本</a>
          <ul>
            <li><a href="#java">Java</a></li>
            <li><a href="#c">C++</a></li>
            <li><a href="#python">Python</a></li>
            <li><a href="#go">Go</a></li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</nav></div>
                                        <div class="docs-content col-12 col-xl-9 mt-0">
                                            <div class="mb-0 d-flex">
                                                
                                                <i class="material-icons title-icon me-2">article</i>
                                                
                                                <h1 class="content-title mb-0">
                                                    18.模板方法模式
                                                    
                                                </h1>
                                            </div>
                                            
                                                <p class="lead mb-3">模板方法模式（Template Method Pattern）是一种行为型设计模式, 它定义了一个算法的骨架，将**一些步骤的实现延迟到子类。**模板方法模式使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤。</p>
                                            
                                            <div id="content" class="main-content" data-bs-spy="scroll" data-bs-root-margin="0px 0px -65%" data-bs-target="#toc-mobile">
                                                
    
    <div data-prismjs-copy="" data-prismjs-copy-success="" data-prismjs-copy-error="">
        <h3 id="需求">需求 <a href="#%e9%9c%80%e6%b1%82" class="anchor" aria-hidden="true"><i class="material-icons align-middle">link</i></a></h3><p>【设计模式专题之模板方法模式】18-咖啡馆</p>
<p><strong>题目描述</strong></p>
<ul>
<li>
<p>小明喜欢品尝不同类型的咖啡，她发现每种咖啡的制作过程有一些相同的步骤，他决定设计一个简单的咖啡制作系统，使用模板方法模式定义咖啡的制作过程。系统支持两种咖啡类型：美式咖啡（American Coffee）和拿铁（Latte）。</p>
</li>
<li>
<p>咖啡制作过程包括以下步骤：</p>
<ol>
<li>研磨咖啡豆 Grinding coffee beans</li>
<li>冲泡咖啡 Brewing coffee</li>
<li>添加调料 Adding condiments</li>
</ol>
</li>
<li>
<p>其中，美式咖啡和拿铁的调料添加方式略有不同, 拿铁在添加调料时需要添加牛奶Adding milk</p>
</li>
</ul>
<p><strong>输入描述</strong></p>
<ul>
<li>多行输入，每行包含一个数字，表示咖啡的选择（1 表示美式咖啡，2 表示拿铁）。</li>
</ul>
<p><strong>输出描述</strong></p>
<ul>
<li>根据每行输入，输出制作咖啡的过程，包括咖啡类型和各个制作步骤，末尾有一个空行。</li>
</ul>
<p><strong>输入示例</strong>






  
      <div class="prism-shortcode">
      <pre id="3357bf0" class="language-auto line-numbers"
        ><code class="language-auto"
        >1
2
</code></pre>
      </div>
  
</p>
<p><strong>输出示例</strong></p>






  
      <div class="prism-shortcode">
      <pre id="914f24f" class="language-auto line-numbers"
        ><code class="language-auto"
        >Making American Coffee:
Grinding coffee beans
Brewing coffee
Adding condiments

Making Latte:
Grinding coffee beans
Brewing coffee
Adding milk
Adding condiments
</code></pre>
      </div>
  

<h3 id="基本概念">基本概念 <a href="#%e5%9f%ba%e6%9c%ac%e6%a6%82%e5%bf%b5" class="anchor" aria-hidden="true"><i class="material-icons align-middle">link</i></a></h3><p>模板方法模式（Template Method Pattern）是一种行为型设计模式, 它定义了一个算法的骨架，将**一些步骤的实现延迟到子类。**模板方法模式使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤。【引用自大话设计第10章】</p>
<p>举个简单的例子，做一道菜通常都需要包含至少三步：</p>
<ul>
<li>准备食材</li>
<li>亨饪过程</li>
<li>上菜</li>
</ul>
<p>不同菜品的亨饪过程是不一样的，但是我们可以先定义一个”骨架”，包含这三个步骤，亨饪过程的过程放到具体的炒菜类中去实现，这样，无论炒什么菜，都可以沿用相同的炒菜算法，只需在子类中实现具体的炒菜步骤，从而提高了代码的复用性。</p>
<h3 id="基本结构">基本结构 <a href="#%e5%9f%ba%e6%9c%ac%e7%bb%93%e6%9e%84" class="anchor" aria-hidden="true"><i class="material-icons align-middle">link</i></a></h3><p>模板方法模式的基本结构包含以下两个角色：</p>
<p>





  



  
    
      <img src="/images/image-20240104144137427.png" alt="image-20240104144137427" width="1862" height="942" loading="lazy">
    
  
</p>
<ul>
<li>模板类<code>AbstractClass</code>：由一个模板方法和若干个基本方法构成，模板方法定义了逻辑的骨架，按照顺序调用包含的基本方法，基本方法通常是一些<strong>抽象方法，这些方法由子类去实现</strong>。基本方法还包含一些具体方法，它们是算法的一部分但已经有默认实现，在具体子类中可以继承或者重写。</li>
<li>具体类<code>ConcreteClass</code>：继承自模板类，实现了在模板类中定义的抽象方法，以完成算法中特定步骤的具体实现。</li>
</ul>
<h3 id="简易实现">简易实现 <a href="#%e7%ae%80%e6%98%93%e5%ae%9e%e7%8e%b0" class="anchor" aria-hidden="true"><i class="material-icons align-middle">link</i></a></h3><p>模板方法模式的简单示例如下：</p>
<ol>
<li>定义模板类，包含模板方法，定义了算法的骨架, 一般都加上<code>final</code>关键字，避免子类重写。</li>
</ol>






  
      <div class="prism-shortcode">
      <pre id="8a84ed0" class="language-java line-numbers"
        ><code class="language-java"
        >// 模板类
abstract class AbstractClass {
    // 模板方法，定义了算法的骨架
    public final void templateMethod() {
        step1();
        step2();
        step3();
    }

    // 抽象方法，由子类实现
    protected abstract void step1();
    protected abstract void step2();
    protected abstract void step3();
}
</code></pre>
      </div>
  

<ol start="2">
<li>定义具体类, 实现模板类中的抽象方法</li>
</ol>






  
      <div class="prism-shortcode">
      <pre id="45c3946" class="language-java line-numbers"
        ><code class="language-java"
        >// 具体类
class ConcreteClass extends AbstractClass {
    @Override
    protected void step1() {
        System.out.println(&#34;Step 1 &#34;);
    }

    @Override
    protected void step2() {
        System.out.println(&#34;Step 2 &#34;);
    }

    @Override
    protected void step3() {
        System.out.println(&#34;Step 3&#34;);
    }
}
</code></pre>
      </div>
  

<ol start="3">
<li>客户端实现</li>
</ol>






  
      <div class="prism-shortcode">
      <pre id="af66d70" class="language-java line-numbers"
        ><code class="language-java"
        >public class Main {
    public static void main(String[] args) {
        AbstractClass concreteTemplate = new ConcreteClass();
        // 触发整个算法的执行
        concreteTemplate.templateMethod();
    }
}
</code></pre>
      </div>
  

<h3 id="应用场景">应用场景 <a href="#%e5%ba%94%e7%94%a8%e5%9c%ba%e6%99%af" class="anchor" aria-hidden="true"><i class="material-icons align-middle">link</i></a></h3><p>模板方法模式将算法的不变部分被封装在模板方法中，而可变部分算法由子类继承实现，这样做可以很好的提高代码的复用性，但是当算法的框架发生变化时，可能需要修改模板类，这也会影响到所有的子类。</p>
<p>总体来说，当算法的整体步骤很固定，但是个别步骤在更详细的层次上的实现可能不同时，通常考虑模板方法模式来处理。在已有的工具和库中， Spring框架中的<code>JdbcTemplate</code>类使用了模板方法模式，其中定义了一些执行数据库操作的模板方法，具体的数据库操作由回调函数提供。而在Java的JDK源码中，<code>AbstractList</code> 类也使用了模板方法模式，它提供了一些通用的方法，其中包括一些模板方法。具体的列表操作由子类实现。</p>
<h3 id="本题代码">本题代码 <a href="#%e6%9c%ac%e9%a2%98%e4%bb%a3%e7%a0%81" class="anchor" aria-hidden="true"><i class="material-icons align-middle">link</i></a></h3>





  
      <div class="prism-shortcode">
      <pre id="12a71df" class="language-java line-numbers"
        ><code class="language-java"
        >import java.util.Scanner;

// 抽象类
abstract class CoffeeMakerTemplate {
    private String coffeeName; // 添加咖啡名称字段

    // 构造函数，接受咖啡名称参数
    public CoffeeMakerTemplate(String coffeeName) {
        this.coffeeName = coffeeName;
    }

    // 模板方法定义咖啡制作过程
    final void makeCoffee() {
        System.out.println(&#34;Making &#34; &#43; coffeeName &#43; &#34;:&#34;);
        grindCoffeeBeans();
        brewCoffee();
        addCondiments();
        System.out.println();
    }

    // 具体步骤的具体实现由子类提供
    abstract void grindCoffeeBeans();
    abstract void brewCoffee();

    // 添加调料的默认实现
    void addCondiments() {
        System.out.println(&#34;Adding condiments&#34;);
    }
}

// 具体的美式咖啡类
class AmericanCoffeeMaker extends CoffeeMakerTemplate {
    // 构造函数传递咖啡名称
    public AmericanCoffeeMaker() {
        super(&#34;American Coffee&#34;);
    }

    @Override
    void grindCoffeeBeans() {
        System.out.println(&#34;Grinding coffee beans&#34;);
    }

    @Override
    void brewCoffee() {
        System.out.println(&#34;Brewing coffee&#34;);
    }
}

// 具体的拿铁咖啡类
class LatteCoffeeMaker extends CoffeeMakerTemplate {
    // 构造函数传递咖啡名称
    public LatteCoffeeMaker() {
        super(&#34;Latte&#34;);
    }

    @Override
    void grindCoffeeBeans() {
        System.out.println(&#34;Grinding coffee beans&#34;);
    }

    @Override
    void brewCoffee() {
        System.out.println(&#34;Brewing coffee&#34;);
    }

    // 添加调料的特定实现
    @Override
    void addCondiments() {
        System.out.println(&#34;Adding milk&#34;);
        System.out.println(&#34;Adding condiments&#34;);
    }
}

// 客户端代码
public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        while (scanner.hasNext()) {
            int coffeeType = scanner.nextInt();

            CoffeeMakerTemplate coffeeMaker = null; 

            if (coffeeType == 1) {
                coffeeMaker = new AmericanCoffeeMaker();
            } else if (coffeeType == 2) {
                coffeeMaker = new LatteCoffeeMaker();
            } else {
                System.out.println(&#34;Invalid coffee type&#34;);
                continue;
            }

            // 制作咖啡
            coffeeMaker.makeCoffee();
        }
    }
}
</code></pre>
      </div>
  

<h2 id="其他语言版本">其他语言版本 <a href="#%e5%85%b6%e4%bb%96%e8%af%ad%e8%a8%80%e7%89%88%e6%9c%ac" class="anchor" aria-hidden="true"><i class="material-icons align-middle">link</i></a></h2><h3 id="java">Java <a href="#java" class="anchor" aria-hidden="true"><i class="material-icons align-middle">link</i></a></h3><p>添加钩子函数，也可由用户来确定是否添加牛奶或其它配料。</p>






  
      <div class="prism-shortcode">
      <pre id="a7309c7" class="language-java line-numbers"
        ><code class="language-java"
        >import java.util.Scanner;

// 抽象类，定义咖啡制作的基本步骤
abstract class CoffeeModel {
    private String coffeeName;

    // 构造函数，接受咖啡名称参数
    public CoffeeModel(String coffeeName) {
        this.coffeeName = coffeeName;
    }

    protected abstract void grind();
    protected abstract void brew();
    protected abstract void addCondiments();
    
    // 添加其他调料可使用该类
    public void addThings(){};

    // 模板方法，定义咖啡制作的流程
    public final void createCoffeeTemplate() {
        System.out.println(&#34;Making &#34; &#43; coffeeName &#43; &#34;:&#34;);
        grind();
        brew();
        //根据情况，是否调用添加更多调料
        if (isAddThings()) {
            addThings(); 
        }
        addCondiments();
        System.out.println();
    }

    // 默认不添加其他调料。如牛奶等
    public boolean isAddThings() {
        return false;
    }
}

//美式咖啡类实现
class CreateAmericanCoffee extends CoffeeModel {
    public CreateAmericanCoffee() {
        super(&#34;American Coffee&#34;);
    }

    @Override
    protected void grind() {
        System.out.println(&#34;Grinding coffee beans&#34;);
    }

    @Override
    protected void brew() {
        System.out.println(&#34;Brewing coffee&#34;);
    }

    @Override
    protected void addCondiments() {
        System.out.println(&#34;Adding condiments&#34;);
    }
    
    // 美式咖啡默认不添加其他调料，如牛奶等
    @Override
    public boolean isAddThings() {
        return false; 
    }
}

//拿铁类实现
class CreateLatte extends CoffeeModel {
    private boolean addThingsFlag = true;

    public CreateLatte() {
        super(&#34;Latte&#34;);
    }

    @Override
    protected void grind() {
        System.out.println(&#34;Grinding coffee beans&#34;);
    }

    @Override
    protected void brew() {
        System.out.println(&#34;Brewing coffee&#34;);
    }

    @Override
    protected void addCondiments() {
        System.out.println(&#34;Adding condiments&#34;);
    }
    
    //需要添加调料，牛奶
    @Override
    public void addThings(){
        System.out.println(&#34;Adding milk&#34;);
    }
    
    // 拿铁默认添加牛奶
    @Override
    public boolean isAddThings() {
        return this.addThingsFlag; 
    }

    // 外部调用以改变是否添加牛奶的状态，钩子函数
    public void setAddThingsFlag(boolean flag) {
        this.addThingsFlag = flag;
    }
}

//客户端
public class Main {
    public static void main(String[] args) {
        try (Scanner scanner = new Scanner(System.in)) {
            while (scanner.hasNextInt()) {
                int input = scanner.nextInt();
                CoffeeModel coffee;
                switch (input) {
                    case 1:
                        coffee = new CreateAmericanCoffee();
                        break;
                    case 2:
                        coffee = new CreateLatte();
                        break;
                    default:
                        System.out.println(&#34;无效选择，请输入1或2&#34;);
                        continue;
                }
                coffee.createCoffeeTemplate();
            }
        }
    }
}
</code></pre>
      </div>
  

<h3 id="c">C++ <a href="#c" class="anchor" aria-hidden="true"><i class="material-icons align-middle">link</i></a></h3>





  
      <div class="prism-shortcode">
      <pre id="7b431ef" class="language-cpp line-numbers"
        ><code class="language-cpp"
        >#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;memory&gt;

// 抽象类
class CoffeeMakerTemplate {
private:
    std::string coffeeName;

public:
    // 构造函数，接受咖啡名称参数
    CoffeeMakerTemplate(const std::string&amp; coffeeName) : coffeeName(coffeeName) {}

    // 模板方法定义咖啡制作过程
    virtual void makeCoffee() {
        std::cout &lt;&lt; &#34;Making &#34; &lt;&lt; coffeeName &lt;&lt; &#34;:\n&#34;;
        grindCoffeeBeans();
        brewCoffee();
        addCondiments();
        std::cout &lt;&lt; &#39;\n&#39;;
    }

    // 具体步骤的具体实现由子类提供
    virtual void grindCoffeeBeans() = 0;
    virtual void brewCoffee() = 0;

    // 添加调料的默认实现
    virtual void addCondiments() {
        std::cout &lt;&lt; &#34;Adding condiments\n&#34;;
    }
};

// 具体的美式咖啡类
class AmericanCoffeeMaker : public CoffeeMakerTemplate {
public:
    // 构造函数传递咖啡名称
    AmericanCoffeeMaker() : CoffeeMakerTemplate(&#34;American Coffee&#34;) {}

    void grindCoffeeBeans() override {
        std::cout &lt;&lt; &#34;Grinding coffee beans\n&#34;;
    }

    void brewCoffee() override {
        std::cout &lt;&lt; &#34;Brewing coffee\n&#34;;
    }
};

// 具体的拿铁咖啡类
class LatteCoffeeMaker : public CoffeeMakerTemplate {
public:
    // 构造函数传递咖啡名称
    LatteCoffeeMaker() : CoffeeMakerTemplate(&#34;Latte&#34;) {}

    void grindCoffeeBeans() override {
        std::cout &lt;&lt; &#34;Grinding coffee beans\n&#34;;
    }

    void brewCoffee() override {
        std::cout &lt;&lt; &#34;Brewing coffee\n&#34;;
    }

    // 添加调料的特定实现
    void addCondiments() override {
        std::cout &lt;&lt; &#34;Adding milk\n&#34;;
        std::cout &lt;&lt; &#34;Adding condiments\n&#34;;
    }
};

int main() {
    std::unique_ptr&lt;CoffeeMakerTemplate&gt; coffeeMaker;

    int coffeeType;
    while (std::cin &gt;&gt; coffeeType) {
        if (coffeeType == 1) {
            coffeeMaker = std::make_unique&lt;AmericanCoffeeMaker&gt;();
        } else if (coffeeType == 2) {
            coffeeMaker = std::make_unique&lt;LatteCoffeeMaker&gt;();
        } else {
            std::cout &lt;&lt; &#34;Invalid coffee type\n&#34;;
            continue;
        }

        // 制作咖啡
        coffeeMaker-&gt;makeCoffee();
    }

    return 0;
}
</code></pre>
      </div>
  

<h3 id="python">Python <a href="#python" class="anchor" aria-hidden="true"><i class="material-icons align-middle">link</i></a></h3>





  
      <div class="prism-shortcode">
      <pre id="0c64b36" class="language-python line-numbers"
        ><code class="language-python"
        >from abc import ABC, abstractmethod

# 抽象类
class CoffeeMakerTemplate(ABC):
    # 构造函数，接受咖啡名称参数
    def __init__(self, coffee_name):
        self.coffee_name = coffee_name

    # 模板方法定义咖啡制作过程
    def make_coffee(self):
        print(f&#34;Making {self.coffee_name}:&#34;)
        self.grind_coffee_beans()
        self.brew_coffee()
        self.add_condiments()
        print()

    # 具体步骤的具体实现由子类提供
    @abstractmethod
    def grind_coffee_beans(self):
        pass

    @abstractmethod
    def brew_coffee(self):
        pass

    # 添加调料的默认实现
    def add_condiments(self):
        print(&#34;Adding condiments&#34;)


# 具体的美式咖啡类
class AmericanCoffeeMaker(CoffeeMakerTemplate):
    # 构造函数传递咖啡名称
    def __init__(self):
        super().__init__(&#34;American Coffee&#34;)

    def grind_coffee_beans(self):
        print(&#34;Grinding coffee beans&#34;)

    def brew_coffee(self):
        print(&#34;Brewing coffee&#34;)


# 具体的拿铁咖啡类
class LatteCoffeeMaker(CoffeeMakerTemplate):
    # 构造函数传递咖啡名称
    def __init__(self):
        super().__init__(&#34;Latte&#34;)

    def grind_coffee_beans(self):
        print(&#34;Grinding coffee beans&#34;)

    def brew_coffee(self):
        print(&#34;Brewing coffee&#34;)

    # 添加调料的特定实现
    def add_condiments(self):
        print(&#34;Adding milk&#34;)
        print(&#34;Adding condiments&#34;)


# 客户端代码
if __name__ == &#34;__main__&#34;:
    while True:
        try:
            coffee_type = int(input())

            coffee_maker = None

            if coffee_type == 1:
                coffee_maker = AmericanCoffeeMaker()
            elif coffee_type == 2:
                coffee_maker = LatteCoffeeMaker()
            else:
                print(&#34;Invalid coffee type&#34;)
                continue

            # 制作咖啡
            coffee_maker.make_coffee()

        except EOFError:
            break
</code></pre>
      </div>
  

<h3 id="go">Go <a href="#go" class="anchor" aria-hidden="true"><i class="material-icons align-middle">link</i></a></h3>





  
      <div class="prism-shortcode">
      <pre id="1f787ac" class="language-go line-numbers"
        ><code class="language-go"
        >package main

import (
	&#34;fmt&#34;
	&#34;os&#34;
)

// 抽象类接口
type CoffeeMakerTemplate interface {
	MakeCoffee()
	GrindCoffeeBeans()
	BrewCoffee()
	AddCondiments()
}

// 具体的美式咖啡类
type AmericanCoffeeMaker struct {
	coffeeName string
}

// 构造函数传递咖啡名称
func NewAmericanCoffeeMaker() *AmericanCoffeeMaker {
	return &amp;AmericanCoffeeMaker{coffeeName: &#34;American Coffee&#34;}
}

// 实现接口
func (a *AmericanCoffeeMaker) MakeCoffee() {
	fmt.Printf(&#34;Making %s:\n&#34;, a.coffeeName)
	a.GrindCoffeeBeans()
	a.BrewCoffee()
	a.AddCondiments()
	fmt.Println()
}

func (a *AmericanCoffeeMaker) GrindCoffeeBeans() {
	fmt.Println(&#34;Grinding coffee beans&#34;)
}

func (a *AmericanCoffeeMaker) BrewCoffee() {
	fmt.Println(&#34;Brewing coffee&#34;)
}

func (a *AmericanCoffeeMaker) AddCondiments() {
	fmt.Println(&#34;Adding condiments&#34;)
}

// 具体的拿铁咖啡类
type LatteCoffeeMaker struct {
	coffeeName string
}

// 构造函数传递咖啡名称
func NewLatteCoffeeMaker() *LatteCoffeeMaker {
	return &amp;LatteCoffeeMaker{coffeeName: &#34;Latte&#34;}
}

// 实现接口
func (l *LatteCoffeeMaker) MakeCoffee() {
	fmt.Printf(&#34;Making %s:\n&#34;, l.coffeeName)
	l.GrindCoffeeBeans()
	l.BrewCoffee()
	l.AddCondiments()
	fmt.Println()
}

func (l *LatteCoffeeMaker) GrindCoffeeBeans() {
	fmt.Println(&#34;Grinding coffee beans&#34;)
}

func (l *LatteCoffeeMaker) BrewCoffee() {
	fmt.Println(&#34;Brewing coffee&#34;)
}

func (l *LatteCoffeeMaker) AddCondiments() {
	fmt.Println(&#34;Adding milk&#34;)
	fmt.Println(&#34;Adding condiments&#34;)
}

func main() {
	for {
		var coffeeType int
		if _, err := fmt.Scan(&amp;coffeeType); err != nil {
			if err.Error() == &#34;expected integer&#34; || err.Error() == &#34;EOF&#34; {
				break
			}
			fmt.Println(err)
			os.Exit(1)
		}

		var coffeeMaker CoffeeMakerTemplate

		switch coffeeType {
		case 1:
			coffeeMaker = NewAmericanCoffeeMaker()
		case 2:
			coffeeMaker = NewLatteCoffeeMaker()
		default:
			fmt.Println(&#34;Invalid coffee type&#34;)
			continue
		}

		// 制作咖啡
		coffeeMaker.MakeCoffee()
	}
}
</code></pre>
      </div>
  


    </div>

    

    
                                            </div>
                                            <div><hr class="doc-hr">
<div id="doc-nav" class="d-print-none">

	<div class="row flex-xl-nowrap ">
	<div class="col-sm-6 pt-2 doc-next">
		<a href="/docs/dev/23designpattern/17.%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F/">
			<div class="card h-100 my-1">
				<div class="card-body py-2">
                    <p class="card-title fs-5 fw-semibold lh-base mb-0"><i class="material-icons align-middle">navigate_before</i> 17.备忘录模式</p>
					<p class="card-text ms-2">备忘录模式（Memento Pattern）是一种行为型设计 …</p>
					
				</div>
			</div>
		</a>
        </div>
	<div class="col-sm-6 pt-2 doc-prev">
		<a class="ms-auto" href="/docs/dev/23designpattern/19.%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/">
			<div class="card h-100 my-1 text-end">
				<div class="card-body py-2">
                    <p class="card-title fs-5 fw-semibold lh-base mb-0">19.迭代器模式 <i class="material-icons align-middle">navigate_next</i></p>
					<p class="card-text me-2">迭代器模式是一种行为设计模式，是一种使用频率非常高的设计模 …</p>
					
				</div>
			</div>
		</a>
        </div>
	</div>
</div></div>
                                        </div>
                                    </div>
                                </div>
                            </div>
<footer class="shadow py-3 d-print-none">
    <div class="container-fluid">
        <div class="row align-items-center">
            <div class="col">
                <div class="text-sm-start text-center mx-md-2">
                    <p class="mb-0">
                        
                        © 2024 <a href="https://cakepanit.com"><strong>Maxbit</strong></a>
                    </p>
                </div>
            </div>
        </div>
    </div>
</footer>
</main>
            </div>
        </div>

        
        
        <button onclick="topFunction()" id="back-to-top" aria-label="Back to Top Button" class="back-to-top fs-5"><svg width="24" height="24"><path d="M12,10.224l-6.3,6.3L4.32,15.152,12,7.472l7.68,7.68L18.3,16.528Z" style="fill:#fff"/></svg></button>
        
        

        
        
            <script>(()=>{var e=document.getElementById("mode");e!==null&&(window.matchMedia("(prefers-color-scheme: dark)").addEventListener("change",e=>{e.matches?(localStorage.setItem("theme","dark"),document.documentElement.setAttribute("data-dark-mode","")):(localStorage.setItem("theme","light"),document.documentElement.removeAttribute("data-dark-mode"))}),e.addEventListener("click",()=>{document.documentElement.toggleAttribute("data-dark-mode"),localStorage.setItem("theme",document.documentElement.hasAttribute("data-dark-mode")?"dark":"light")}),localStorage.getItem("theme")==="dark"?document.documentElement.setAttribute("data-dark-mode",""):document.documentElement.removeAttribute("data-dark-mode"))})()</script>
        




    
        
        
    
    






    

    <script src="/docs/js/bootstrap.eac7ee3f6fa791c684e7a51fc2fd50b6f724271b9e39562e4fe8c3942412df3acbfc4045f043d03399dac70091207507.js" integrity="sha384-6sfuP2&#43;nkcaE56Ufwv1QtvckJxueOVYuT&#43;jDlCQS3zrL/EBF8EPQM5naxwCRIHUH"defer></script>


    <script type="text/javascript" src="https://docs.cakepanit.com/docs/js/bundle.min.439192da4aa99015318b887b8fa242c713dcd7b69074f642b989fc9e7a043d0210c0af413ceccab86df420f2032593b8.js" integrity="sha384-Q5GS2kqpkBUxi4h7j6JCxxPc17aQdPZCuYn8nnoEPQIQwK9BPOzKuG30IPIDJZO4" crossorigin="anonymous" defer></script>
        

        
        <script type="module">
    var suggestions = document.getElementById('suggestions');
    var search = document.getElementById('flexsearch');

    const flexsearchContainer = document.getElementById('FlexSearchCollapse');

    const hideFlexsearchBtn = document.getElementById('hideFlexsearch');

    const configObject = { toggle: false }
    const flexsearchContainerCollapse = new Collapse(flexsearchContainer, configObject) 

    if (search !== null) {
        document.addEventListener('keydown', inputFocus);
        flexsearchContainer.addEventListener('shown.bs.collapse', function () {
            search.focus();
        });
        
        var topHeader = document.getElementById("top-header");
        document.addEventListener('click', function(elem) {
            if (!flexsearchContainer.contains(elem.target) && !topHeader.contains(elem.target))
                flexsearchContainerCollapse.hide();
        });
    }

    hideFlexsearchBtn.addEventListener('click', () =>{
        flexsearchContainerCollapse.hide()
    })

    function inputFocus(e) {
        if (e.ctrlKey && e.key === '/') {
            e.preventDefault();
            flexsearchContainerCollapse.toggle();
        }
        if (e.key === 'Escape' ) {
            search.blur();
            
            flexsearchContainerCollapse.hide();
        }
    };

    document.addEventListener('click', function(event) {

    var isClickInsideElement = suggestions.contains(event.target);

    if (!isClickInsideElement) {
        suggestions.classList.add('d-none');
    }

    });

    


    document.addEventListener('keydown',suggestionFocus);

    function suggestionFocus(e) {
    const suggestionsHidden = suggestions.classList.contains('d-none');
    if (suggestionsHidden) return;

    const focusableSuggestions= [...suggestions.querySelectorAll('a')];
    if (focusableSuggestions.length === 0) return;

    const index = focusableSuggestions.indexOf(document.activeElement);

    if (e.key === "ArrowUp") {
        e.preventDefault();
        const nextIndex = index > 0 ? index - 1 : 0;
        focusableSuggestions[nextIndex].focus();
    }
    else if (e.key === "ArrowDown") {
        e.preventDefault();
        const nextIndex= index + 1 < focusableSuggestions.length ? index + 1 : index;
        focusableSuggestions[nextIndex].focus();
    }

    }

    


    (function(){

    var index = new FlexSearch.Document({
        
        tokenize: "forward",
        minlength:  0 ,
        cache:  100 ,
        optimize:  true ,
        document: {
        id: 'id',
        store: [
            "href", "title", "description"
        ],
        index: ["title", "description", "content"]
        }
    });


    


    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    


    

    

    index.add(
            {
                id:  0 ,
                href: "\/docs\/dev\/23designpattern\/",
                title: "23种设计模式",
                description: "设计模式是一套理论, 由软件界先辈们总结出的一套可以反复使用的经验, 可以帮助开发人员降低代码耦合度、提高代码的重用性、扩展性和系统可维护性，以及巧妙解决一系列逻辑复杂的问题(运用套路)。然而需要注意的是，过度使用设计模式也可能会导致代码过于复杂和晦涩，因此在实际开发中需要根据具体情况进行选择和应用。",
                content: ""
            }
        );
    index.add(
            {
                id:  1 ,
                href: "\/docs\/dev\/",
                title: "DEV",
                description: "编码相关",
                content: ""
            }
        );
    index.add(
            {
                id:  2 ,
                href: "\/docs\/",
                title: "Index",
                description: "仰望星空，脚踏实地",
                content: ""
            }
        );
    index.add(
            {
                id:  3 ,
                href: "\/docs\/ops\/",
                title: "OPS",
                description: "SRE/运维相关",
                content: ""
            }
        );
    index.add(
            {
                id:  4 ,
                href: "\/docs\/dba\/",
                title: "DBA",
                description: "数据库相关",
                content: ""
            }
        );
    index.add(
            {
                id:  5 ,
                href: "\/docs\/dba\/dome\/",
                title: "第一篇WIKI",
                description: "A quickstart guide to creating new content in Lotus Docs",
                content: "Create New Content linkNavigate to the root of your Hugo project and use the hugo new command to create a file in the content/docs directory:\nhugo new docs/examplepage.md "
            }
        );
    index.add(
            {
                id:  6 ,
                href: "\/docs\/demo\/",
                title: "DEMO",
                description: "模版",
                content: ""
            }
        );
    index.add(
            {
                id:  7 ,
                href: "\/docs\/dev\/golang\/",
                title: "Golang",
                description: "Go语言相关文档",
                content: ""
            }
        );
    index.add(
            {
                id:  8 ,
                href: "\/docs\/ops\/kubernetes\/",
                title: "Kubernetes",
                description: "Kubernetes（简称k8s）是Google在2014年6月开源的一个容器集群管理系统，使用Go语言开发，用于管理云平台中多个主机上的容器化的应用，Kubernetes的目标是让部署容器化的应用简单并且高效,Kubernetes提供了资源调度、部署管理、服务发现、扩容缩容、监控，维护等一整套功能。努力成为跨主机集群的自动部署、扩展以及运行应用程序容器的平台。 它支持一系列容器工具。",
                content: ""
            }
        );
    index.add(
            {
                id:  9 ,
                href: "\/docs\/dev\/23designpattern\/1.%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F\/",
                title: "1.单例模式",
                description: "单例模式是一种**创建型设计模式**， 它的核心思想是保证**一个类只有一个实例，并提供一个全局访问点来访问这个实例。**",
                content: "需求 link【设计模式专题之单例模式】1.小明的购物车\n题目描述\n小明去了一家大型商场，拿到了一个购物车，并开始购物。请你设计一个购物车管理器，记录商品添加到购物车的信息（商品名称和购买数量），并在购买结束后打印出商品清单。（在整个购物过程中，小明只有一个购物车实例存在）。 输入描述\n输入包含若干行，每行包含两部分信息，分别是商品名称和购买数量。商品名称和购买数量之间用空格隔开。 输出描述\n输出包含小明购物车中的所有商品及其购买数量。每行输出一种商品的信息，格式为 “商品名称 购买数量”。 输入示例 Apple 3 Banana 2 Orange 5 输出示例 Apple 3 Banana 2 Orange 5 提示信息 本道题目请使用单例设计模式： 使用私有静态变量来保存购物车实例。 使用私有构造函数防止外部直接实例化。 什么是单例设计模式 link单例模式是一种创建型设计模式， 它的核心思想是保证一个类只有一个实例，并提供一个全局访问点来访问这个实例。\n只有一个实例的意思是，在整个应用程序中，只存在该类的一个实例对象，而不是创建多个相同类型的对象。 全局访问点的意思是，为了让其他类能够获取到这个唯一实例，该类提供了一个全局访问点（通常是一个静态方法），通过这个方法就能获得实例。 为什么要使用单例设计模式呢 link简易来说，单例设计模式有以下几个优点让我们考虑使用它：\n全局控制：保证只有一个实例，这样就可以严格的控制客户怎样访问它以及何时访问它，简单的说就是对唯一实例的受控访问（引用自《大话设计模式》第21章） 节省资源：也正是因为只有一个实例存在，就避免多次创建了相同的对象，从而节省了系统资源，而且多个模块还可以通过单例实例共享数据。 懒加载：单例模式可以实现懒加载，只有在需要时才进行实例化，这无疑会提高程序的性能。 单例设计模式的基本要求 link想要实现一个单例设计模式，必须遵循以下规则：\n私有的构造函数：防止外部代码直接创建类的实例 私有的静态实例变量：保存该类的唯一实例 公有的静态方法：通过公有的静态方法来获取类的实例 单例设计模式的实现 link单例模式的实现方式有多种，包括懒汉式、饿汉式等。\n饿汉式指的是在类加载时就已经完成了实例的创建，不管后面创建的实例有没有使用，先创建再说，所以叫做 “饿汉”。\n而懒汉式指的是只有在请求实例时才会创建，如果在首次请求时还没有创建，就创建一个新的实例，如果已经创建，就返回已有的实例，意思就是需要使用了再创建，所以称为“懒汉”。\n在多线程环境下，由于饿汉式在程序启动阶段就完成了实例的初始化，因此不存在多个线程同时尝试初始化实例的问题，但是懒汉式中多个线程同时访问 getInstance() 方法，并且在同一时刻检测到实例没有被创建，就可能会同时创建实例，从而导致多个实例被创建，这种情况下我们可以采用一些同步机制，例如使用互斥锁来确保在任何时刻只有一个线程能够执行实例的创建。\n举个例子，你和小明都发现家里没米了，在你们没有相互通知的情况下，都会去超市买一袋米，这样就重复购买了，违背了单例模式。\n下面以Java的代码作为实例，说明单例设计模式的基本写法：\n饿汉模式：实例在类加载时就被创建, 这种方式的实现相对简单，但是实例有可能没有使用而造成资源浪费。 public class Singleton { private static final Singleton instance = new Singleton(); private Singleton() { // 私有构造方法，防止外部实例化 } public static Singleton getInstance() { return instance; } } 懒汉模式：第一次使用时才创建 public class Singleton { private static Singleton instance; private Singleton() { // 私有构造方法，防止外部实例化 } // 使用了同步关键字来确保线程安全, 可能会影响性能 public static synchronized Singleton getInstance() { if (instance == null) { instance = new Singleton(); } return instance; } } 在懒汉模式的基础上，可以使用双重检查锁来提高性能。\npublic class Singleton { private static volatile Singleton instance; private Singleton() { // 私有构造方法，防止外部实例化 } public static Singleton getInstance() { if (instance == null) { synchronized (Singleton.class) { if (instance == null) { instance = new Singleton(); } } } return instance; } } 什么时候使用单例设计模式 link说了这么多，那在什么场景下应该考虑使用单例设计模式呢？可以结合单例设计模式的优点来看。\n资源共享 多个模块共享某个资源的时候，可以使用单例模式，比如说应用程序需要一个全局的配置管理器来存储和管理配置信息、亦或是使用单例模式管理数据库连接池。\n只有一个实例 当系统中某个类只需要一个实例来协调行为的时候，可以考虑使用单例模式， 比如说管理应用程序中的缓存，确保只有一个缓存实例，避免重复的缓存创建和管理，或者使用单例模式来创建和管理线程池。\n懒加载 如果对象创建本身就比较消耗资源，而且可能在整个程序中都不一定会使用，可以使用单例模式实现懒加载。\n在许多流行的工具和库中，也都使用到了单例设计模式，比如Java中的Runtime类就是一个经典的单例，表示程序的运行时环境。此外 Spring 框架中的应用上下文 (ApplicationContext) 也被设计为单例，以提供对应用程序中所有 bean 的集中式访问点。\n本道题目代码 link import java.util.LinkedHashMap; import java.util.Map; import java.util.Scanner; public class Main { public static void main(String[] args) { ShoppingCartManager cart = ShoppingCartManager.getInstance(); Scanner scanner = new Scanner(System.in); while (scanner.hasNext()) { String itemName = scanner.next(); int quantity = scanner.nextInt(); // 获取购物车实例并添加商品 cart.addToCart(itemName, quantity); } // 输出购物车内容 cart.viewCart(); } } class ShoppingCartManager { // 饿汉模式实现单例 private static final ShoppingCartManager instance = new ShoppingCartManager(); // 购物车存储商品和数量的映射 private Map cart; // 私有构造函数 private ShoppingCartManager() { cart = new LinkedHashMap\u003c\u003e(); } // 获取购物车实例 public static ShoppingCartManager getInstance() { return instance; } // 添加商品到购物车 public void addToCart(String itemName, int quantity) { cart.put(itemName, cart.getOrDefault(itemName, 0) + quantity); } // 查看购物车 public void viewCart() { for (Map.Entry entry : cart.entrySet()) { System.out.println(entry.getKey() + \" \" + entry.getValue()); } } } 其他语言版本 linkJava版本 link懒汉+双重锁检查\nimport java.util.Scanner; import java.util.ArrayList; class ShoppingCart { // 购物车类的单例实例变量，使用volatile关键字确保线程安全 private static volatile ShoppingCart instance; // 存储商品名称 private static ArrayList productNames = new ArrayList\u003c\u003e(); // 存储商品数量 private static ArrayList productQuantities = new ArrayList\u003c\u003e(); // 私有构造函数，防止外部直接创建ShoppingCart对象 private ShoppingCart() { } // 获取购物车单例实例的方法，确保线程安全 public static ShoppingCart getInstance() { if (instance == null) { synchronized (ShoppingCart.class) { if (instance == null) { instance = new ShoppingCart(); } } } return instance; } // 添加商品到购物车的方法 public void Add(String name, int quantity) { productNames.add(name); productQuantities.add(quantity); System.out.println(name + \" \" + quantity); } } public class Main { public static void main(String[] args) { ShoppingCart cart = ShoppingCart.getInstance(); Scanner scanner = new Scanner(System.in); String inputLine; // 循环读取用户输入，直到用户输入\"exit\" while (scanner.hasNextLine()) { inputLine = scanner.nextLine(); if (\"exit\".equalsIgnoreCase(inputLine)) { break; } // 使用空格分割输入的字符串，获取商品名称和数量 String[] parts = inputLine.split(\" \"); // 确保输入格式正确，即包含两个部分：商品名称和数量 if (parts.length == 2) { // 商品名称 String name = parts[0]; // 商品数量 int quantity; try { // 将第二部分转换为整数 quantity = Integer.parseInt(parts[1]); cart.Add(name, quantity); } catch (NumberFormatException e) { // 如果转换失败，输出错误信息 System.out.println(\"转换失败，请重新输入\"); } } else { // 如果输入格式不正确，输出错误信息 System.out.println(\"如果输入格式不正确，请重新输入\"); } } scanner.close(); } } CPP link #include #include using namespace std; class ShoppingCartManager { public: // 获取购物车实例 static ShoppingCartManager\u0026 getInstance() { static ShoppingCartManager instance; return instance; } // 添加商品到购物车 void addToCart(const string\u0026 itemName, int quantity) { cart[itemName] += quantity; } // 查看购物车 void viewCart() const { for (const auto\u0026 item : cart) { cout \u003c\u003c item.first \u003c\u003c \" \" \u003c\u003c item.second \u003c\u003c endl; } } private: // 私有构造函数 ShoppingCartManager() {} // 购物车存储商品和数量的映射 map cart; }; int main() { string itemName; int quantity; while (cin \u003e\u003e itemName \u003e\u003e quantity) { // 获取购物车实例并添加商品 ShoppingCartManager\u0026 cart = ShoppingCartManager::getInstance(); cart.addToCart(itemName, quantity); } // 输出购物车内容 const ShoppingCartManager\u0026 cart = ShoppingCartManager::getInstance(); cart.viewCart(); return 0; } Python link 饿汉模式 3 class Singleton: instance = None def __init__(self): if Singleton.instance is not None: raise Exception(\"Only one instance of Singleton class is allowed\") else: Singleton.instance = self 懒汉模式 3 class Singleton: __instance: Singleton = None @staticmethod def getInstance(): if Singleton.__instance is None: Singleton.__instance = Singleton() return Singleton.__instance 懒汉+双重锁检查 3 import threading class Singleton: __instance = None __lock = threading.Lock() @classmethod def getInstance(cls): if cls.__instance is None: with cls.__lock: if cls.__instance is None: # cls.__instance = super().__new__(cls) cls.__instance = Singleton() return cls.__instance Go link package main import ( \"bufio\" \"fmt\" \"os\" \"strings\" \"sync\" ) // ShoppingCartManager 实现购物车管理 type ShoppingCartManager struct { cart map[string]int keys []string // 用于保存插入顺序的键 mutext sync.Mutex } var once sync.Once var instance *ShoppingCartManager // getInstance 获取购物车实例 func getInstance() *ShoppingCartManager { once.Do(func() { instance = \u0026ShoppingCartManager{ cart: make(map[string]int), } }) return instance } // addToCart 将商品添加到购物车 func (scm *ShoppingCartManager) addToCart(itemName string, quantity int) { scm.mutext.Lock() defer scm.mutext.Unlock() // 检查是否已经存在，不存在则添加到 keys 中 if _, exists := scm.cart[itemName]; !exists { scm.keys = append(scm.keys, itemName) } scm.cart[itemName] += quantity } // viewCart 查看购物车内容并按照插入顺序输出 func (scm *ShoppingCartManager) viewCart() { scm.mutext.Lock() defer scm.mutext.Unlock() for _, itemName := range scm.keys { quantity := scm.cart[itemName] fmt.Printf(\"%s %d\\n\", itemName, quantity) } } func main() { cart := getInstance() scanner := bufio.NewScanner(os.Stdin) for scanner.Scan() { input := scanner.Text() if input == \"\" { break } parts := strings.Fields(input) itemName := parts[0] quantity := 0 if len(parts) \u003e 1 { fmt.Sscanf(parts[1], \"%d\", \u0026quantity) } // 获取购物车实例并添加商品 cart.addToCart(itemName, quantity) } // 输出购物车内容 cart.viewCart() } "
            }
        );
    index.add(
            {
                id:  10 ,
                href: "\/docs\/dev\/23designpattern\/2.%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F\/",
                title: "2.工厂方法模式",
                description: "简单工厂模式的核心思想是将产品的创建过程封装在一个工厂类中，把创建对象的流程集中在这个工厂类里面。",
                content: "需求 link【设计模式专题之工厂方法模式】2.积木工厂\n题目描述\n小明家有两个工厂，一个用于生产圆形积木，一个用于生产方形积木，请你帮他设计一个积木工厂系统，记录积木生产的信息。 输入描述\n输入的第一行是一个整数 N（1 ≤ N ≤ 100），表示生产的次数。 接下来的 N 行，每行输入一个字符串和一个整数，字符串表示积木的类型。积木类型分为 “Circle” 和 “Square” 两种。整数表示该积木生产的数量 输出描述\n对于每个积木，输出一行字符串表示该积木的信息。 输入示例 3 Circle 1 Square 2 Circle 1 输出示例 Circle Block Square Block Square Block Circle Block 提示信息 在示例中，积木工厂生产了3块积木，其中有2块是圆形积木，1块是方形积木。根据输入的类型，每块积木的信息被输出到控制台。\n简单工厂模式 link在了解工厂方法模式之前，有必要对“简单工厂”模式进行一定的了解，简单工厂模式是一种创建型设计模式，但并不属于23种设计模式之一，更多的是一种编程习惯。\n简单工厂模式的核心思想是将产品的创建过程封装在一个工厂类中，把创建对象的流程集中在这个工厂类里面。\n简单工厂模式包括三个主要角色，工厂类、抽象产品、具体产品，下面的图示则展示了工厂类的基本结构。\n抽象产品，比如上图中的Shape 接口，描述产品的通用行为。 具体产品: 实现抽象产品接口或继承抽象产品类，比如上面的Circle类和Square类，具体产品通过简单工厂类的if-else逻辑来实例化。 工厂类：负责创建产品，根据传递的不同参数创建不同的产品示例。 简单工厂类简化了客户端操作，客户端可以调用工厂方法来获取具体产品，而无需直接与具体产品类交互，降低了耦合，但是有一个很大的问题就是不够灵活，如果需要添加新的产品，就需要修改工厂类的代码。\n什么是工厂方法模式 link工厂方法模式也是一种创建型设计模式，简单工厂模式只有一个工厂类，负责创建所有产品，如果要添加新的产品，通常需要修改工厂类的代码。而工厂方法模式引入了抽象工厂和具体工厂的概念，每个具体工厂只负责创建一个具体产品，添加新的产品只需要添加新的工厂类而无需修改原来的代码，这样就使得产品的生产更加灵活，支持扩展，符合开闭原则。\n工厂方法模式分为以下几个角色：\n抽象工厂：一个接口，包含一个抽象的工厂方法（用于创建产品对象）。 具体工厂：实现抽象工厂接口，创建具体的产品。 抽象产品：定义产品的接口。 具体产品：实现抽象产品接口，是工厂创建的对象。 实际上工厂方法模式也很好理解，就拿“手机Phone”这个产品举例，手机是一个抽象产品，小米手机、华为手机、苹果手机是具体的产品实现，而不同品牌的手机在各自的生产厂家生产。\n基本实现 link根据上面的类图，我们可以写出工厂方法模式的基本实现。\n// 抽象产品 interface Shape { void draw(); } // 具体产品 - 圆形 class Circle implements Shape { @Override public void draw() { System.out.println(\"Circle\"); } } // 具体产品 - 正方形 class Square implements Shape { @Override public void draw() { System.out.println(\"Square\"); } } // 抽象工厂 interface ShapeFactory { Shape createShape(); } // 具体工厂 - 创建圆形 class CircleFactory implements ShapeFactory { @Override public Shape createShape() { return new Circle(); } } // 具体工厂 - 创建正方形 class SquareFactory implements ShapeFactory { @Override public Shape createShape() { return new Square(); } } // 客户端代码 public class Client { public static void main(String[] args) { ShapeFactory circleFactory = new CircleFactory(); Shape circle = circleFactory.createShape(); circle.draw(); // 输出：Circle ShapeFactory squareFactory = new SquareFactory(); Shape square = squareFactory.createShape(); square.draw(); // 输出：Square } } 应用场景 link工厂方法模式使得每个工厂类的职责单一，每个工厂只负责创建一种产品，当创建对象涉及一系列复杂的初始化逻辑，而这些逻辑在不同的子类中可能有所不同时，可以使用工厂方法模式将这些初始化逻辑封装在子类的工厂中。在现有的工具、库中，工厂方法模式也有广泛的应用，比如：\nSpring 框架中的 Bean 工厂：通过配置文件或注解，Spring 可以根据配置信息动态地创建和管理对象。 JDBC 中的 Connection 工厂：在 Java 数据库连接中，DriverManager 使用工厂方法模式来创建数据库连接。不同的数据库驱动（如 MySQL、PostgreSQL 等）都有对应的工厂来创建连接。 本题代码 link import java.util.ArrayList; import java.util.List; import java.util.Scanner; // 抽象积木接口 interface Block { void produce(); } // 具体圆形积木实现 class CircleBlock implements Block { @Override public void produce() { System.out.println(\"Circle Block\"); } } // 具体方形积木实现 class SquareBlock implements Block { @Override public void produce() { System.out.println(\"Square Block\"); } } // 抽象积木工厂接口 interface BlockFactory { Block createBlock(); } // 具体圆形积木工厂实现 class CircleBlockFactory implements BlockFactory { @Override public Block createBlock() { return new CircleBlock(); } } // 具体方形积木工厂实现 class SquareBlockFactory implements BlockFactory { @Override public Block createBlock() { return new SquareBlock(); } } // 积木工厂系统 class BlockFactorySystem { private List blocks = new ArrayList\u003c\u003e(); public void produceBlocks(BlockFactory factory, int quantity) { for (int i = 0; i \u003c quantity; i++) { Block block = factory.createBlock(); blocks.add(block); block.produce(); } } public List getBlocks() { return blocks; } } public class Main { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); // 创建积木工厂系统 BlockFactorySystem factorySystem = new BlockFactorySystem(); // 读取生产次数 int productionCount = scanner.nextInt(); scanner.nextLine(); // 读取每次生产的积木类型和数量 for (int i = 0; i \u003c productionCount; i++) { String[] productionInfo = scanner.nextLine().split(\" \"); String blockType = productionInfo[0]; int quantity = Integer.parseInt(productionInfo[1]); if (blockType.equals(\"Circle\")) { factorySystem.produceBlocks(new CircleBlockFactory(), quantity); } else if (blockType.equals(\"Square\")) { factorySystem.produceBlocks(new SquareBlockFactory(), quantity); } } } } 其他语言版本 linkJava link利用反射实现工厂方法 import java.lang.reflect.Constructor; import java.util.Scanner; // 抽象工厂类 abstract class BlocksFactory { public abstract blocks createBlocks(Class c, String str, int num); } //具体工厂实现类 class BlocksFactoryImpl extends BlocksFactory { @Override public blocks createBlocks(Class c, String str, int num) { try { //反射获取blocks类中带有两个参数的构造器 Constructor constructor = c.getConstructor(String.class, int.class); return constructor.newInstance(str, num); } catch (Exception e) { e.printStackTrace(); return null; } } } //定义积木接口 interface blocks { void blockPrint(String str, int num); } //圆形积木 class CircleBlocks implements blocks{ private String str; private int num; public CircleBlocks(String str, int num) { this.str = str; this.num = num; } public void blockPrint(String str,int num){ for(int i=0;i"
            }
        );
    index.add(
            {
                id:  11 ,
                href: "\/docs\/dev\/23designpattern\/3.%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F\/",
                title: "3.抽象工厂模式",
                description: "抽象工厂模式也是一种创建型设计模式，提供了一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类",
                content: "需求 link【设计模式专题之抽象工厂模式】3. 家具工厂\n题目描述\n小明家新开了两个工厂用来生产家具，一个生产现代风格的沙发和椅子，一个生产古典风格的沙发和椅子，现在工厂收到了一笔订单，请你帮他设计一个系统，描述订单需要生产家具的信息。 输入描述\n输入的第一行是一个整数 N（1 ≤ N ≤ 100），表示订单的数量。 接下来的 N 行，每行输入一个字符串，字符串表示家具的类型。家具类型分为 “modern” 和 “classical” 两种。 输出描述\n对于每笔订单，输出字符串表示该订单需要生产家具的信息。 modern订单会输出下面两行字符串 modern chair modern sofa classical订单会输出下面两行字符串 classical chair classical soft 输入示例 3 modern classical modern 输出示例 modern chair modern sofa classical chair classical sofa modern chair modern sofa 提示信息 在示例中，工厂收到了3笔订单，其中有2笔要求生产modern风格，1笔要求生产classical风格。根据输入的类型，每次订单生产的家具信息被输出到控制台上。\n什么是抽象工厂模式 link抽象工厂模式也是一种创建型设计模式，提供了一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类【引用自大话设计模式第15章】\n这样的描述似乎理解起来很困难，我们可以把它与【工厂方法模式】联系起来看。\n之前我们已经介绍了“工厂方法模式”，那为什么还有要抽象工厂模式呢？\n这就涉及到创建“多类”对象了，在工厂方法模式中，每个具体工厂只负责创建单一的产品。但是如果有多类产品呢，比如说“手机”，一个品牌的手机有高端机、中低端机之分，这些具体的产品都需要建立一个单独的工厂类，但是它们都是相互关联的，都共同属于同一个品牌，这就可以使用到【抽象工厂模式】。\n抽象工厂模式可以确保一系列相关的产品被一起创建，这些产品能够相互配合使用，再举个例子，有一些家具，比如沙发、茶几、椅子，都具有古典风格的和现代风格的，抽象工厂模式可以将生产现代风格的家具放在一个工厂类中，将生产古典风格的家具放在另一个工厂类中，这样每个工厂类就可以生产一系列的家具。\n基本结构 link抽象工厂模式包含多个抽象产品接口，多个具体产品类，一个抽象工厂接口和多个具体工厂，每个具体工厂负责创建一组相关的产品。\n抽象产品接口AbstractProduct: 定义产品的接口，可以定义多个抽象产品接口，比如说沙发、椅子、茶几都是抽象产品。 具体产品类ConcreteProduct: 实现抽象产品接口，产品的具体实现，古典风格和沙发和现代风格的沙发都是具体产品。 抽象工厂接口AbstractFactory: 声明一组用于创建产品的方法，每个方法对应一个产品。 具体工厂类ConcreteFactory： 实现抽象工厂接口，负责创建一组具体产品的对象，在本例中，生产古典风格的工厂和生产现代风格的工厂都是具体实例。 在上面的图示中：AbstractProductA/B/C 就是抽象产品，ConcreteProductA2/A2/B1/B2/C1/C2就是抽象产品的实现，AbstractFactory定义了抽象工厂接口，接口里的方法用于创建具体的产品，而ConcreteFactory就是具体工厂类，可以创建一组相关的产品。\n基本实现 link想要实现抽象工厂模式，需要遵循以下步骤：\n定义抽象产品接口（可以有多个），接口中声明产品的公共方法。 实现具体产品类，在类中实现抽象产品接口中的方法。 定义抽象工厂接口，声明一组用于创建产品的方法。 实现具体工厂类，分别实现抽象工厂接口中的方法，每个方法负责创建一组相关的产品。 在客户端中使用抽象工厂和抽象产品，而不直接使用具体产品的类名。 // 1. 定义抽象产品 // 抽象产品A interface ProductA { void display(); } // 抽象产品B interface ProductB { void show(); } // 2. 实现具体产品类 // 具体产品A1 class ConcreteProductA1 implements ProductA { @Override public void display() { System.out.println(\"Concrete Product A1\"); } } // 具体产品A2 class ConcreteProductA2 implements ProductA { @Override public void display() { System.out.println(\"Concrete Product A2\"); } } // 具体产品B1 class ConcreteProductB1 implements ProductB { @Override public void show() { System.out.println(\"Concrete Product B1\"); } } // 具体产品B2 class ConcreteProductB2 implements ProductB { @Override public void show() { System.out.println(\"Concrete Product B2\"); } } // 3. 定义抽象工厂接口 interface AbstractFactory { ProductA createProductA(); ProductB createProductB(); } // 4. 实现具体工厂类 // 具体工厂1，生产产品A1和B1 class ConcreteFactory1 implements AbstractFactory { @Override public ProductA createProductA() { return new ConcreteProductA1(); } @Override public ProductB createProductB() { return new ConcreteProductB1(); } } // 具体工厂2,生产产品A2和B2 class ConcreteFactory2 implements AbstractFactory { @Override public ProductA createProductA() { return new ConcreteProductA2(); } @Override public ProductB createProductB() { return new ConcreteProductB2(); } } // 客户端代码 public class AbstractFactoryExample { public static void main(String[] args) { // 使用工厂1创建产品A1和产品B1 AbstractFactory factory1 = new ConcreteFactory1(); ProductA productA1 = factory1.createProductA(); ProductB productB1 = factory1.createProductB(); productA1.display(); productB1.show(); // 使用工厂2创建产品A2和产品B2 AbstractFactory factory2 = new ConcreteFactory2(); ProductA productA2 = factory2.createProductA(); ProductB productB2 = factory2.createProductB(); productA2.display(); productB2.show(); } } 应用场景 link抽象工厂模式能够保证一系列相关的产品一起使用，并且在不修改客户端代码的情况下，可以方便地替换整个产品系列。但是当需要增加新的产品类时，除了要增加新的具体产品类，还需要修改抽象工厂接口及其所有的具体工厂类，扩展性相对较差。因此抽象工厂模式特别适用于一系列相关或相互依赖的产品被一起创建的情况，典型的应用场景是使用抽象工厂模式来创建与不同数据库的连接对象。\n简单工厂、工厂方法、抽象工厂的区别 link 简单工厂模式：一个工厂方法创建所有具体产品\n工厂方法模式：一个工厂方法创建一个具体产品\n抽象工厂模式：一个工厂方法可以创建一类具体产品\n本题代码 link import java.util.Scanner; // 抽象椅子接口 interface Chair { void showInfo(); } // 具体现代风格椅子 class ModernChair implements Chair { @Override public void showInfo() { System.out.println(\"modern chair\"); } } // 具体古典风格椅子 class ClassicalChair implements Chair { @Override public void showInfo() { System.out.println(\"classical chair\"); } } // 抽象沙发接口 interface Sofa { void displayInfo(); } // 具体现代风格沙发 class ModernSofa implements Sofa { @Override public void displayInfo() { System.out.println(\"modern sofa\"); } } // 具体古典风格沙发 class ClassicalSofa implements Sofa { @Override public void displayInfo() { System.out.println(\"classical sofa\"); } } // 抽象家居工厂接口 interface FurnitureFactory { Chair createChair(); Sofa createSofa(); } // 具体现代风格家居工厂 class ModernFurnitureFactory implements FurnitureFactory { @Override public Chair createChair() { return new ModernChair(); } @Override public Sofa createSofa() { return new ModernSofa(); } } // 具体古典风格家居工厂 class ClassicalFurnitureFactory implements FurnitureFactory { @Override public Chair createChair() { return new ClassicalChair(); } @Override public Sofa createSofa() { return new ClassicalSofa(); } } public class Main { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); // 读取订单数量 int N = scanner.nextInt(); // 处理每个订单 for (int i = 0; i \u003c N; i++) { // 读取家具类型 String furnitureType = scanner.next(); // 创建相应风格的家居装饰品工厂 FurnitureFactory factory = null; if (furnitureType.equals(\"modern\")) { factory = new ModernFurnitureFactory(); } else if (furnitureType.equals(\"classical\")) { factory = new ClassicalFurnitureFactory(); } // 根据工厂生产椅子和沙发 Chair chair = factory.createChair(); Sofa sofa = factory.createSofa(); // 输出家具信息 chair.showInfo(); sofa.displayInfo(); } } } 其他语言代码 linkJava link三元运算符简化工厂选择的逻辑。\nimport java.util.Scanner; // 定义一个家具工厂接口，可以创建椅子和沙发 interface FurnitureFactory{ Chair createChair(); Sofa createSofa(); } // 实现古典家具工厂，生产古典风格的椅子和沙发 class ClassicalFurnitureFactory implements FurnitureFactory{ @Override public Chair createChair(){ return new ClassicalChair(); } @Override public Sofa createSofa(){ return new ClassicalSofa(); } } // 实现现代家具工厂，生产现代风格的椅子和沙发 class ModernFurnitureFactory implements FurnitureFactory{ @Override public Chair createChair(){ return new ModernChair(); } @Override public Sofa createSofa(){ return new ModernSofa(); } } // 定义椅子接口，包含生产椅子的方法 interface Chair{ void produceChair(); } // 实现古典椅子类，继承椅子接口 class ClassicalChair implements Chair{ @Override public void produceChair(){ System.out.println(\"classical chair\"); } } // 实现现代椅子类，继承椅子接口 class ModernChair implements Chair{ @Override public void produceChair(){ System.out.println(\"modern chair\"); } } // 定义沙发接口，包含生产沙发的方法 interface Sofa{ void produceSofa(); } // 实现古典沙发类，继承沙发接口 class ClassicalSofa implements Sofa{ @Override public void produceSofa(){ System.out.println(\"classical sofa\"); } } // 实现现代沙发类，继承沙发接口 class ModernSofa implements Sofa{ @Override public void produceSofa(){ System.out.println(\"modern sofa\"); } } //主程序类 public class Main{ public static void main (String[] args) { Scanner scanner = new Scanner(System.in); // 创建古典和现代家具工厂实例 FurnitureFactory classicalFurnitureFactory = new ClassicalFurnitureFactory(); FurnitureFactory modernFurnitureFactory = new ModernFurnitureFactory(); // 读取生产次数 int productionCount = scanner.nextInt(); scanner.nextLine(); for (int i = 0; i \u003c productionCount; i++) { String type = scanner.nextLine(); // 根据用户输入选择相应的家具工厂，并创建家具 FurnitureFactory factory = (type.equals(\"modern\")) ? modernFurnitureFactory : classicalFurnitureFactory; Chair chair = factory.createChair(); chair.produceChair(); Sofa sofa = factory.createSofa(); sofa.produceSofa(); } scanner.close(); } } Cpp link #include #include // 抽象椅子接口 class Chair { public: virtual void showInfo() = 0; }; // 具体现代风格椅子 class ModernChair : public Chair { public: void showInfo() override { std::cout \u003c\u003c \"modern chair\" \u003c\u003c std::endl; } }; // 具体古典风格椅子 class ClassicalChair : public Chair { public: void showInfo() override { std::cout \u003c\u003c \"classical chair\" \u003c\u003c std::endl; } }; // 抽象沙发接口 class Sofa { public: virtual void displayInfo() = 0; }; // 具体现代风格沙发 class ModernSofa : public Sofa { public: void displayInfo() override { std::cout \u003c\u003c \"modern sofa\" \u003c\u003c std::endl; } }; // 具体古典风格沙发 class ClassicalSofa : public Sofa { public: void displayInfo() override { std::cout \u003c\u003c \"classical sofa\" \u003c\u003c std::endl; } }; // 抽象家居工厂接口 class FurnitureFactory { public: virtual Chair* createChair() = 0; virtual Sofa* createSofa() = 0; }; // 具体现代风格家居工厂 class ModernFurnitureFactory : public FurnitureFactory { public: Chair* createChair() override { return new ModernChair(); } Sofa* createSofa() override { return new ModernSofa(); } }; // 具体古典风格家居工厂 class ClassicalFurnitureFactory : public FurnitureFactory { public: Chair* createChair() override { return new ClassicalChair(); } Sofa* createSofa() override { return new ClassicalSofa(); } }; int main() { // 读取订单数量 int N; std::cin \u003e\u003e N; // 处理每个订单 for (int i = 0; i \u003c N; i++) { // 读取家具类型 std::string furnitureType; std::cin \u003e\u003e furnitureType; // 创建相应风格的家居装饰品工厂 FurnitureFactory* factory = nullptr; if (furnitureType == \"modern\") { factory = new ModernFurnitureFactory(); } else if (furnitureType == \"classical\") { factory = new ClassicalFurnitureFactory(); } // 根据工厂生产椅子和沙发 Chair* chair = factory-\u003ecreateChair(); Sofa* sofa = factory-\u003ecreateSofa(); // 输出家具信息 chair-\u003eshowInfo(); sofa-\u003edisplayInfo(); // 释放动态分配的对象 delete chair; delete sofa; delete factory; } return 0; } Python link from abc import ABC, abstractmethod # 抽象椅子接口 class Chair(ABC): @abstractmethod def show_info(self): pass # 具体现代风格椅子 class ModernChair(Chair): def show_info(self): print(\"modern chair\") # 具体古典风格椅子 class ClassicalChair(Chair): def show_info(self): print(\"classical chair\") # 抽象沙发接口 class Sofa(ABC): @abstractmethod def display_info(self): pass # 具体现代风格沙发 class ModernSofa(Sofa): def display_info(self): print(\"modern sofa\") # 具体古典风格沙发 class ClassicalSofa(Sofa): def display_info(self): print(\"classical sofa\") # 抽象家居工厂接口 class FurnitureFactory(ABC): @abstractmethod def create_chair(self): pass @abstractmethod def create_sofa(self): pass # 具体现代风格家居工厂 class ModernFurnitureFactory(FurnitureFactory): def create_chair(self): return ModernChair() def create_sofa(self): return ModernSofa() # 具体古典风格家居工厂 class ClassicalFurnitureFactory(FurnitureFactory): def create_chair(self): return ClassicalChair() def create_sofa(self): return ClassicalSofa() def main(): # 读取订单数量 N = int(input()) # 处理每个订单 for _ in range(N): # 读取家具类型 furniture_type = input() # 创建相应风格的家居装饰品工厂 factory = None if furniture_type == \"modern\": factory = ModernFurnitureFactory() elif furniture_type == \"classical\": factory = ClassicalFurnitureFactory() # 根据工厂生产椅子和沙发 chair = factory.create_chair() sofa = factory.create_sofa() # 输出家具信息 chair.show_info() sofa.display_info() if __name__ == \"__main__\": main() Go link package main import \"fmt\" // 抽象椅子接口 type Chair interface { showInfo() } // 具体现代风格椅子 type ModernChair struct{} func (mc *ModernChair) showInfo() { fmt.Println(\"modern chair\") } // 具体古典风格椅子 type ClassicalChair struct{} func (cc *ClassicalChair) showInfo() { fmt.Println(\"classical chair\") } // 抽象沙发接口 type Sofa interface { displayInfo() } // 具体现代风格沙发 type ModernSofa struct{} func (ms *ModernSofa) displayInfo() { fmt.Println(\"modern sofa\") } // 具体古典风格沙发 type ClassicalSofa struct{} func (cs *ClassicalSofa) displayInfo() { fmt.Println(\"classical sofa\") } // 抽象家居工厂接口 type FurnitureFactory interface { createChair() Chair createSofa() Sofa } // 具体现代风格家居工厂 type ModernFurnitureFactory struct{} func (mf *ModernFurnitureFactory) createChair() Chair { return \u0026ModernChair{} } func (mf *ModernFurnitureFactory) createSofa() Sofa { return \u0026ModernSofa{} } // 具体古典风格家居工厂 type ClassicalFurnitureFactory struct{} func (cf *ClassicalFurnitureFactory) createChair() Chair { return \u0026ClassicalChair{} } func (cf *ClassicalFurnitureFactory) createSofa() Sofa { return \u0026ClassicalSofa{} } func main() { // 读取订单数量 var N int fmt.Scan(\u0026N) // 处理每个订单 for i := 0; i \u003c N; i++ { // 读取家具类型 var furnitureType string fmt.Scan(\u0026furnitureType) // 创建相应风格的家居装饰品工厂 var factory FurnitureFactory if furnitureType == \"modern\" { factory = \u0026ModernFurnitureFactory{} } else if furnitureType == \"classical\" { factory = \u0026ClassicalFurnitureFactory{} } // 根据工厂生产椅子和沙发 chair := factory.createChair() sofa := factory.createSofa() // 输出家具信息 chair.showInfo() sofa.displayInfo() } } "
            }
        );
    index.add(
            {
                id:  12 ,
                href: "\/docs\/dev\/golang\/fyne\/",
                title: "Fyne",
                description: "用Golang-Fyne开发GUI程序",
                content: ""
            }
        );
    index.add(
            {
                id:  13 ,
                href: "\/docs\/dev\/23designpattern\/4.%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F\/",
                title: "4.建造者模式",
                description: "将对象的构建过程分为多个步骤，并为每个步骤定义一个抽象的接口。具体的构建过程由实现了这些接口的具体建造者类来完成。",
                content: "需求 link【设计模式专题之建造者模式】4. 自行车加工\n题目描述\n小明家新开了一家自行车工厂，用于使用自行车配件（车架 frame 和车轮 tires ）进行组装定制不同的自行车，包括山地车和公路车。 山地车使用的是Aluminum Frame（铝制车架）和 Knobby Tires（可抓地轮胎），公路车使用的是 Carbon Frame （碳车架）和 Slim Tries。 现在它收到了一笔订单，要求定制一批自行车，请你使用【建造者模式】告诉小明这笔订单需要使用那些自行车配置吧。 输入描述\n输入的第一行是一个整数 N（1 ≤ N ≤ 100），表示订单的数量。 接下来的 N 行，每行输入一个字符串，字符串表示客户的自行车需求。 字符串可以包含关键词 “mountain” 或 “road”，表示客户需要山地自行车或公路自行车。 **输出描述 对于每笔订单，输出该订单定制的自行车配置。\n输入示例 3 mountain road mountain 输出示例\nAluminum Frame Knobby Tires Carbon Frame Slim Tires Aluminum Frame Knobby Tires 提示信息 在本例中：产品为自行车，可以有两个建造者：山地车建造者和公路车建造者。\n什么是建造者模式 link建造者模式（也被成为生成器模式），是一种创建型设计模式，软件开发过程中有的时候需要创建很复杂的对象，而建造者模式的主要思想是**将对象的构建过程分为多个步骤，并为每个步骤定义一个抽象的接口。具体的构建过程由实现了这些接口的具体建造者类来完成。**同时有一个指导者类负责协调建造者的工作，按照一定的顺序或逻辑来执行构建步骤，最终生成产品。\n举个例子，假如我们要创建一个计算机对象，计算机由很多组件组成，例如 CPU、内存、硬盘、显卡等。每个组件可能有不同的型号、配置和制造，这个时候计算机就可以被视为一个复杂对象，构建过程相对复杂，而我们使用建造者模式将计算机的构建过程封装在一个具体的建造者类中，而指导者类则负责指导构建的步骤和顺序。每个具体的建造者类可以负责构建不同型号或配置的计算机，客户端代码可以通过选择不同的建造者来创建不同类型的计算机，这样就可以根据需要构建不同表示的复杂对象，更加灵活。\n基本结构 link建造者模式有下面几个关键角色：\n产品Product：被构建的复杂对象, 包含多个组成部分。 抽象建造者Builder: 定义构建产品各个部分的抽象接口和一个返回复杂产品的方法getResult 具体建造者Concrete Builder：实现抽象建造者接口，构建产品的各个组成部分，并提供一个方法返回最终的产品。 指导者Director：调用具体建造者的方法，按照一定的顺序或逻辑来构建产品。 在客户端中，通过指导者来构建产品，而并不和具体建造者进行直接的交互。\n简易实现 link建造者模式的实现步骤通常包括以下几个阶段\n定义产品类：产品类应该包含多个组成部分，这些部分的属性和方法构成了产品的接口 // 产品类 class Product { private String part1; private String part2; public void setPart1(String part1) { this.part1 = part1; } public void setPart2(String part2) { this.part2 = part2; } // 其他属性和方法 } 定义抽象建造者接口：创建一个接口，包含构建产品各个部分的抽象方法。这些方法通常用于设置产品的各个属性。 // 抽象建造者接口 interface Builder { void buildPart1(String part1); void buildPart2(String part2); Product getResult(); } 创建具体建造者：实现抽象建造者接口，构建具体的产品。 // 具体建造者类 class ConcreteBuilder implements Builder { private Product product = new Product(); @Override public void buildPart1(String part1) { product.setPart1(part1); } @Override public void buildPart2(String part2) { product.setPart2(part2); } @Override public Product getResult() { return product; } } 定义Director类： 指导者类来控制构建产品的顺序和步骤。 // 指导者类 class Director { private Builder builder; public Director(Builder builder) { this.builder = builder; } // 调用方法构建产品 public void construct() { builder.buildPart1(\"Part1\"); builder.buildPart2(\"Part2\"); } } 客户端使用建造者模式：在客户端中创建【具体建造者对象】和【指导者对象】，通过指导者来构建产品。 // 客户端代码 public class Main{ public static void main(String[] args) { // 创建具体建造者 Builder builder = new ConcreteBuilder(); // 创建指导者 Director director = new Director(builder); // 指导者构建产品 director.construct(); // 获取构建好的产品 Product product = builder.getResult(); // 输出产品信息 System.out.println(product); } } 使用场景 link使用建造者模式有下面几处优点：\n使用建造者模式可以**将一个复杂对象的构建与其表示分离，**通过将构建复杂对象的过程抽象出来，可以使客户端代码与具体的构建过程解耦\n同样的构建过程可以创建不同的表示，可以有多个具体的建造者(相互独立），可以更加灵活地创建不同组合的对象。\n对应的，建造者模式适用于复杂对象的创建，当对象构建过程相对复杂时可以考虑使用建造者模式，但是当产品的构建过程发生变化时，可能需要同时修改指导类和建造者类，这就使得重构变得相对困难。\n建造者模式在现有的工具和库中也有着广泛的应用，比如JUnit 中的测试构建器TestBuilder就采用了建造者模式，用于构建测试对象。\n本题代码 link import java.util.Scanner; // 自行车产品 class Bike { private String frame; private String tires; public void setFrame(String frame) { this.frame = frame; } public void setTires(String tires) { this.tires = tires; } @Override public String toString() { return frame + \" \" + tires; } } // 自行车建造者接口 interface BikeBuilder { void buildFrame(); void buildTires(); Bike getResult(); } // 山地自行车建造者 class MountainBikeBuilder implements BikeBuilder { private Bike bike; public MountainBikeBuilder() { this.bike = new Bike(); } @Override public void buildFrame() { bike.setFrame(\"Aluminum Frame\"); } @Override public void buildTires() { bike.setTires(\"Knobby Tires\"); } @Override public Bike getResult() { return bike; } } // 公路自行车建造者 class RoadBikeBuilder implements BikeBuilder { private Bike bike; public RoadBikeBuilder() { this.bike = new Bike(); } @Override public void buildFrame() { bike.setFrame(\"Carbon Frame\"); } @Override public void buildTires() { bike.setTires(\"Slim Tires\"); } @Override public Bike getResult() { return bike; } } // 自行车Director，负责构建自行车 class BikeDirector { public Bike construct(BikeBuilder builder) { builder.buildFrame(); builder.buildTires(); return builder.getResult(); } } public class Main { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); int N = scanner.nextInt(); // 订单数量 scanner.nextLine(); BikeDirector director = new BikeDirector(); for (int i = 0; i \u003c N; i++) { String bikeType = scanner.nextLine(); BikeBuilder builder; // 根据输入类别，创建不同类型的具体建造者 if (bikeType.equals(\"mountain\")) { builder = new MountainBikeBuilder(); } else { builder = new RoadBikeBuilder(); } // Director负责指导生产产品 Bike bike = director.construct(builder); System.out.println(bike); } } } 其他语言代码 linkJava link使用模版方法模式和建造者模式实现自行车工厂。\nimport java.util.ArrayList; import java.util.Scanner; //抽象类，模版方法模式创建 abstract class Bicycle{ private ArrayList fittingsList = new ArrayList(); //选用不同配件的方法 protected void useAluminumFrame(){}; protected void useKnobbyTires(){}; protected void useCarbonFrame(){}; protected void useSlimTires(){}; //设置配件列表 public final void setFittingsList(ArrayList list){ this.fittingsList = list; } //选用配件，构建自行车 public final void maker(){ for (String fitting : fittingsList) { switch (fitting) { case \"useAluminumFrame\": useAluminumFrame(); break; case \"useKnobbyTires\": useKnobbyTires(); break; case \"useCarbonFrame\": useCarbonFrame(); break; case \"useSlimTires\": useSlimTires(); break; default: System.out.println(\"不清楚的配件：\" + fitting + \"请重新输入！\"); } } } } //山地自行车类，并重写父类方法 class MountainBicycle extends Bicycle{ @Override protected void useAluminumFrame(){ System.out.print(\"Aluminum Frame \"); } @Override protected void useKnobbyTires(){ System.out.println(\"Knobby Tires \"); } } //公路自行车类，并重写父类方法 class RoadBicycle extends Bicycle{ @Override protected void useCarbonFrame(){ System.out.print(\"Carbon Frame \"); } @Override protected void useSlimTires(){ System.out.println(\"Slim Tires \"); } } //定义建造者接口 interface Builder{ void setFittingList(ArrayList list); Bicycle getBicycle(); } //山地自行车建造类 class MountainBicycleBuilder implements Builder{ private MountainBicycle mountainBicycle = new MountainBicycle(); public void setFittingList(ArrayList list){ this.mountainBicycle.setFittingsList(list); } public Bicycle getBicycle(){ return this.mountainBicycle; } } //公路自行车建造者类 class RoadBicycleBuilder implements Builder{ private RoadBicycle roadBicycle = new RoadBicycle(); public void setFittingList(ArrayList list){ this.roadBicycle.setFittingsList(list); } public Bicycle getBicycle(){ return this.roadBicycle; } } //导演类 class Director{ private ArrayList arrayList = new ArrayList(); private MountainBicycleBuilder mountainBicycleBuilder = new MountainBicycleBuilder(); private RoadBicycleBuilder roadBicycleBuilder = new RoadBicycleBuilder(); public MountainBicycle getMountainBicycle(){ //清理场景 this.arrayList.clear(); //选用配件 this.arrayList.add(\"useAluminumFrame\"); this.arrayList.add(\"useKnobbyTires\"); this.mountainBicycleBuilder.setFittingList(this.arrayList); return (MountainBicycle)this.mountainBicycleBuilder.getBicycle(); } public RoadBicycle getRoadBicycle(){ //清理场景 this.arrayList.clear(); //选用配件 this.arrayList.add(\"useCarbonFrame\"); this.arrayList.add(\"useSlimTires\"); this.roadBicycleBuilder.setFittingList(this.arrayList); return (RoadBicycle)this.roadBicycleBuilder.getBicycle(); } } //主程序类 public class Main{ public static void main (String[] args) { Scanner scanner = new Scanner(System.in); try { int num = scanner.nextInt(); scanner.nextLine(); Director director = new Director(); for (int i = 0; i \u003c num; i++) { String type = scanner.nextLine().toLowerCase().trim(); Bicycle bicycle; if (\"mountain\".equals(type)) { bicycle = director.getMountainBicycle(); } else if (\"road\".equals(type)) { bicycle = director.getRoadBicycle(); } else { System.out.println(\"无效输入. 请输入 'mountain' 或 'road'.\"); continue; } bicycle.maker(); } } catch (Exception e) { System.out.println(\"An error occurred: \" + e.getMessage()); } finally { scanner.close(); } } } Cpp link #include #include // 自行车产品 class Bike { public: std::string frame; std::string tires; void setFrame(const std::string\u0026 frame) { this-\u003eframe = frame; } void setTires(const std::string\u0026 tires) { this-\u003etires = tires; } friend std::ostream\u0026 operator\u003c\u003c(std::ostream\u0026 os, const Bike\u0026 bike) { os \u003c\u003c bike.frame \u003c\u003c \" \" \u003c\u003c bike.tires; return os; } }; // 自行车建造者接口 class BikeBuilder { public: virtual void buildFrame() = 0; virtual void buildTires() = 0; virtual Bike getResult() = 0; }; // 山地自行车建造者 class MountainBikeBuilder : public BikeBuilder { private: Bike bike; public: void buildFrame() override { bike.setFrame(\"Aluminum Frame\"); } void buildTires() override { bike.setTires(\"Knobby Tires\"); } Bike getResult() override { return bike; } }; // 公路自行车建造者 class RoadBikeBuilder : public BikeBuilder { private: Bike bike; public: void buildFrame() override { bike.setFrame(\"Carbon Frame\"); } void buildTires() override { bike.setTires(\"Slim Tires\"); } Bike getResult() override { return bike; } }; // 自行车Director，负责构建自行车 class BikeDirector { public: Bike construct(BikeBuilder\u0026 builder) { builder.buildFrame(); builder.buildTires(); return builder.getResult(); } }; int main() { int N; std::cin \u003e\u003e N; // 订单数量 BikeDirector director; for (int i = 0; i \u003c N; i++) { std::string bikeType; std::cin \u003e\u003e bikeType; BikeBuilder* builder; // 根据输入类别，创建不同类型的具体建造者 if (bikeType == \"mountain\") { builder = new MountainBikeBuilder(); } else { builder = new RoadBikeBuilder(); } // Director负责指导生产产品 Bike bike = director.construct(*builder); std::cout \u003c\u003c bike \u003c\u003c std::endl; // 释放动态分配的对象 delete builder; } return 0; } Python link # 自行车产品 class Bike: def __init__(self): self.frame = None self.tires = None def set_frame(self, frame): self.frame = frame def set_tires(self, tires): self.tires = tires def __str__(self): return f\"{self.frame} {self.tires}\" # 自行车建造者接口 class BikeBuilder: def build_frame(self): pass def build_tires(self): pass def get_result(self): pass # 山地自行车建造者 class MountainBikeBuilder(BikeBuilder): def __init__(self): self.bike = Bike() def build_frame(self): self.bike.set_frame(\"Aluminum Frame\") def build_tires(self): self.bike.set_tires(\"Knobby Tires\") def get_result(self): return self.bike # 公路自行车建造者 class RoadBikeBuilder(BikeBuilder): def __init__(self): self.bike = Bike() def build_frame(self): self.bike.set_frame(\"Carbon Frame\") def build_tires(self): self.bike.set_tires(\"Slim Tires\") def get_result(self): return self.bike # 自行车Director，负责构建自行车 class BikeDirector: def construct(self, builder): builder.build_frame() builder.build_tires() return builder.get_result() def main(): N = int(input()) # 订单数量 director = BikeDirector() for _ in range(N): bike_type = input() # 根据输入类别，创建不同类型的具体建造者 if bike_type == \"mountain\": builder = MountainBikeBuilder() else: builder = RoadBikeBuilder() # Director负责指导生产产品 bike = director.construct(builder) print(bike) if __name__ == \"__main__\": main() Go link package main import \"fmt\" // 自行车产品 type Bike struct { frame string tires string } func (b *Bike) setFrame(frame string) { b.frame = frame } func (b *Bike) setTires(tires string) { b.tires = tires } func (b *Bike) String() string { return b.frame + \" \" + b.tires } // 自行车建造者接口 type BikeBuilder interface { buildFrame() buildTires() getResult() *Bike } // 山地自行车建造者 type MountainBikeBuilder struct { bike *Bike } func NewMountainBikeBuilder() *MountainBikeBuilder { return \u0026MountainBikeBuilder{ bike: \u0026Bike{}, } } func (mbb *MountainBikeBuilder) buildFrame() { mbb.bike.setFrame(\"Aluminum Frame\") } func (mbb *MountainBikeBuilder) buildTires() { mbb.bike.setTires(\"Knobby Tires\") } func (mbb *MountainBikeBuilder) getResult() *Bike { return mbb.bike } // 公路自行车建造者 type RoadBikeBuilder struct { bike *Bike } func NewRoadBikeBuilder() *RoadBikeBuilder { return \u0026RoadBikeBuilder{ bike: \u0026Bike{}, } } func (rbb *RoadBikeBuilder) buildFrame() { rbb.bike.setFrame(\"Carbon Frame\") } func (rbb *RoadBikeBuilder) buildTires() { rbb.bike.setTires(\"Slim Tires\") } func (rbb *RoadBikeBuilder) getResult() *Bike { return rbb.bike } // 自行车Director，负责构建自行车 type BikeDirector struct{} func (bd *BikeDirector) construct(builder BikeBuilder) *Bike { builder.buildFrame() builder.buildTires() return builder.getResult() } func main() { var N int fmt.Scan(\u0026N) // 订单数量 director := \u0026BikeDirector{} for i := 0; i \u003c N; i++ { var bikeType string fmt.Scan(\u0026bikeType) var builder BikeBuilder // 根据输入类别，创建不同类型的具体建造者 if bikeType == \"mountain\" { builder = NewMountainBikeBuilder() } else { builder = NewRoadBikeBuilder() } // Director负责指导生产产品 bike := director.construct(builder) fmt.Println(bike) } } "
            }
        );
    index.add(
            {
                id:  14 ,
                href: "\/docs\/dev\/23designpattern\/5.%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F\/",
                title: "5.原型模式",
                description: "原型模式一种创建型设计模式，该模式的核心思想是基于现有的对象创建新的对象，而不是从头开始创建。",
                content: "需求 link【设计模式专题之原型模式】5. 矩形原型\n题目描述\n公司正在开发一个图形设计软件，其中有一个常用的图形元素是矩形。设计师在工作时可能需要频繁地创建相似的矩形，而这些矩形的基本属性是相同的（颜色、宽度、高度），为了提高设计师的工作效率，请你使用原型模式设计一个矩形对象的原型。使用该原型可以快速克隆生成新的矩形对象。 输入描述\n首先输入一个字符串，表示矩形的基本属性信息，包括颜色、长度和宽度，用空格分隔，例如 “Red 10 5”。 然后输入一个整数 N（1 ≤ N ≤ 100），表示使用原型创建的矩形数量。 输出描述\n对于每个矩形，输出一行字符串表示矩形的详细信息，如 “Color: Red, Width: 10,Height: 5”。 输入示例 Red 10 5 3 输出示例 Color: Red, Width: 10, Height: 5 Color: Red, Width: 10, Height: 5 Color: Red, Width: 10, Height: 5 提示信息 使用原型模式中的克隆方法实现矩形对象的创建。\n什么是原型模式 link原型模式一种创建型设计模式，该模式的核心思想是基于现有的对象创建新的对象，而不是从头开始创建。\n在原型模式中，通常有一个原型对象，它被用作创建新对象的模板。新对象通过复制原型对象的属性和状态来创建，而无需知道具体的创建细节。\n为什么要使用原型模式 link如果一个对象的创建过程比较复杂时（比如需要经过一系列的计算和资源消耗），那每次创建该对象都需要消耗资源，而通过原型模式就可以复制现有的一个对象来迅速创建/克隆一个新对象，不必关心具体的创建细节，可以降低对象创建的成本。\n下面是一个简短的Python代码示例了模拟了上面的问题：\nimport copy class ComplexObject: def __init__(self, data): # 耗时的资源型操作 self.data = data def clone(self): # 复制 return copy.deepcopy(self) # 创建原型对象 original_object = ComplexObject(data=\"large date\") # 创建新对象，直接拷贝原对象 new_object = original_object.clone() 原型模式的基本结构 link实现原型模式需要给【原型对象】声明一个克隆方法，执行该方法会创建一个当前类的新对象，并将原始对象中的成员变量复制到新生成的对象中，而不必实例化。并且在这个过程中只需要调用原型对象的克隆方法，而无需知道原型对象的具体类型。\n原型模式包含两个重点模块：\n抽象原型接口prototype: 声明一个克隆自身的方法clone 具体原型类ConcretePrototype: 实现clone方法，复制当前对象并返回一个新对象。 在客户端代码中，可以声明一个具体原型类的对象，然后调用clone()方法复制原对象生成一个新的对象。\n原型模式的基本实现 link原型模式的实现过程即上面描述模块的实现过程：\n创建一个抽象类或接口，声明一个克隆方法clone 实现具体原型类，重写克隆方法 客户端中实例化具体原型类的对象，并调用其克隆方法来创建新的对象。 // 1. 定义抽象原型类 public abstract class Prototype implements Cloneable { public abstract Prototype clone(); } // 2. 创建具体原型类 public class ConcretePrototype extends Prototype { private String data; public ConcretePrototype(String data) { this.data = data; } @Override public Prototype clone() { return new ConcretePrototype(this.data); } public String getData() { return data; } } // 3. 客户端代码 public class Client { public static void main(String[] args) { // 创建原型对象 Prototype original = new ConcretePrototype(\"Original Data\"); // 克隆原型对象 Prototype clone = original.clone(); // 输出克隆对象的数据 System.out.println(\"Clone Data: \" + ((ConcretePrototype) clone).getData()); } } 什么时候实现原型模式 link相比于直接实例化对象，通过原型模式复制对象可以减少资源消耗，提高性能，尤其在对象的创建过程复杂或对象的创建代价较大的情况下。当需要频繁创建相似对象、并且可以通过克隆避免重复初始化工作的场景时可以考虑使用原型模式，在克隆对象的时候还可以动态地添加或删除原型对象的属性，创造出相似但不完全相同的对象，提高了灵活性。\n但是使用原型模式也需要考虑到如果对象的内部状态包含了引用类型的成员变量，那么实现深拷贝就会变得较为复杂，需要考虑引用类型对象的克隆问题。\n原型模式在现有的很多语言中都有应用，比如以下几个经典例子。\nJava 提供了 Object 类的 clone() 方法，可以实现对象的浅拷贝。类需要实现 Cloneable 接口并重写 clone() 方法。\n在 .NET 中，ICloneable 接口提供了 Clone 方法，可以用于实现对象的克隆。\nSpring 框架中的 Bean 的作用域之一是原型作用域（Prototype Scope），在这个作用域下，Spring 框架会为每次请求创建一个新的 Bean 实例，类似于原型模式。\n本题代码 link import java.util.Scanner; // 抽象原型类 abstract class Prototype implements Cloneable { public abstract Prototype clone(); public abstract String getDetails(); // 公共的 clone 方法 public Prototype clonePrototype() { try { return (Prototype) super.clone(); } catch (CloneNotSupportedException e) { e.printStackTrace(); return null; } } } // 具体矩形原型类 class RectanglePrototype extends Prototype { private String color; private int width; private int height; // 构造方法 public RectanglePrototype(String color, int width, int height) { this.color = color; this.width = width; this.height = height; } // 克隆方法 @Override public Prototype clone() { return clonePrototype(); } // 获取矩形的详细信息 @Override public String getDetails() { return \"Color: \" + color + \", Width: \" + width + \", Height: \" + height; } } // 客户端程序 public class Main { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); // 读取需要创建的矩形数量 int N = scanner.nextInt(); // 读取每个矩形的属性信息并创建矩形对象 for (int i = 0; i \u003c N; i++) { String color = scanner.next(); int width = scanner.nextInt(); int height = scanner.nextInt(); // 创建原型对象 Prototype originalRectangle = new RectanglePrototype(color, width, height); // 克隆对象并输出详细信息 Prototype clonedRectangle = originalRectangle.clone(); System.out.println(clonedRectangle.getDetails()); } } } 其他语言代码 linkJava link使用原型注册表来实现 import java.util.HashMap; import java.util.Map; import java.util.Scanner; // 原型模式抽象类Shape，表示形状的基类 abstract class Shape { protected int height; protected int width; protected String color; public Shape() {} public Shape(int height, int width, String color) { this.height = height; this.width = width; this.color = color; } // 抽象方法 clone，用于克隆形状 public abstract Shape clone(); //get、set方法。 public int getHeight() { return height; } public void setHeight(int height) { this.height = height; } public int getWidth() { return width; } public void setWidth(int width) { this.width = width; } public String getColor() { return color; } public void setColor(String color) { this.color = color; } } // Rectangle 类，继承自 Shape 表示矩形 class Rectangle extends Shape { public Rectangle(int height, int width, String color) { super(height, width, color); } // 克隆方法，返回一个新的矩形对象 @Override public Shape clone() { return new Rectangle(this.height, this.width, this.color); } } // 原型注册表类，用于存储和管理形状 class ShapeRegistry { private Map shapeMap = new HashMap\u003c\u003e(); // 注册形状，使用形状 ID 作为键 public void registerShape(String shapeId, Shape shape) { shapeMap.put(shapeId, shape); } // 获取形状，通过克隆返回一个新的对象 public Shape getShape(String shapeId) { Shape shape = shapeMap.get(shapeId); return shape != null ? shape.clone() : null; } } public class Main { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); ShapeRegistry shapeRegistry = new ShapeRegistry(); // 注册一个默认的矩形形状 shapeRegistry.registerShape(\"defaultRectangle\", new Rectangle(10, 20, \"red\")); String input = scanner.nextLine(); String[] parts = input.split(\" \"); if (parts.length == 3) { String color = parts[0]; try { int width = Integer.parseInt(parts[1]); int height = Integer.parseInt(parts[2]); //创建并注册一个新的矩形 Shape newRectangle = new Rectangle(height, width, color); shapeRegistry.registerShape(\"userRectangle\", newRectangle); int num = scanner.nextInt(); for (int i = 0; i \u003c num; i++) { Shape clonedShape = shapeRegistry.getShape(\"userRectangle\"); if (clonedShape != null) { System.out.println(\"Color: \" + clonedShape.getColor() + \", Width: \" + clonedShape.getWidth() + \", Height: \" + clonedShape.getHeight()); } else { System.out.println(\"在注册表中找不到形状.\"); } } } catch (NumberFormatException e) { System.out.println(\"输入错误，请重新输入.\"); } } else { System.out.println(\"输入格式错误，请按格式输入：颜色 宽度 高度.\"); } scanner.close(); } } C++ link #include #include #include // 抽象原型类 class Prototype { public: virtual Prototype* clone() const = 0; virtual std::string getDetails() const = 0; virtual ~Prototype() {} }; // 具体矩形原型类 class RectanglePrototype : public Prototype { private: std::string color; int width; int height; public: // 构造方法 RectanglePrototype(std::string color, int width, int height) : color(color), width(width), height(height) {} // 克隆方法 Prototype* clone() const override { return new RectanglePrototype(*this); } // 获取矩形的详细信息 std::string getDetails() const override { return \"Color: \" + color + \", Width: \" + std::to_string(width) + \", Height: \" + std::to_string(height); } }; // 客户端程序 int main() { std::vector rectangles; // 读取需要创建的矩形数量 int N; std::cin \u003e\u003e N; // 读取每个矩形的属性信息并创建矩形对象 for (int i = 0; i \u003c N; i++) { std::string color; int width, height; std::cin \u003e\u003e color \u003e\u003e width \u003e\u003e height; // 创建原型对象 Prototype* originalRectangle = new RectanglePrototype(color, width, height); // 将原型对象保存到向量中 rectangles.push_back(originalRectangle); } // 克隆对象并输出详细信息 for (const auto\u0026 rectangle : rectangles) { Prototype* clonedRectangle = rectangle-\u003eclone(); std::cout \u003c\u003c clonedRectangle-\u003egetDetails() \u003c\u003c std::endl; // 释放克隆对象的内存 delete clonedRectangle; } // 释放原型对象的内存 for (const auto\u0026 rectangle : rectangles) { delete rectangle; } return 0; } Python link from abc import ABC, abstractmethod # 抽象原型类 class Prototype(ABC): @abstractmethod def clone(self): pass @abstractmethod def get_details(self): pass # 公共的 clone 方法 def clone_prototype(self): try: return self.clone() except Exception as e: print(e) return None # 具体矩形原型类 class RectanglePrototype(Prototype): def __init__(self, color, width, height): self.color = color self.width = width self.height = height # 克隆方法 def clone(self): return RectanglePrototype(self.color, self.width, self.height) # 获取矩形的详细信息 def get_details(self): return f\"Color: {self.color}, Width: {self.width}, Height: {self.height}\" # 客户端程序 if __name__ == \"__main__\": # 读取需要创建的矩形数量 N = int(input()) # 读取每个矩形的属性信息并创建矩形对象 for _ in range(N): line = input() parts = line.split() color = parts[0] width = int(parts[1]) height = int(parts[2]) # 创建原型对象 original_rectangle = RectanglePrototype(color, width, height) # 克隆对象并输出详细信息 cloned_rectangle = original_rectangle.clone() print(cloned_rectangle.get_details()) Go link package main import ( \"fmt\" ) // 抽象原型类 type Prototype interface { clone() Prototype getDetails() string } // 具体矩形原型类 type RectanglePrototype struct { color string width int height int } // 构造方法 func NewRectanglePrototype(color string, width, height int) *RectanglePrototype { return \u0026RectanglePrototype{ color: color, width: width, height: height, } } // 实现 Prototype 接口的 clone 方法 func (r *RectanglePrototype) clone() Prototype { return \u0026RectanglePrototype{ color: r.color, width: r.width, height: r.height, } } // 获取矩形的详细信息 func (r *RectanglePrototype) getDetails() string { return fmt.Sprintf(\"Color: %s, Width: %d, Height: %d\", r.color, r.width, r.height) } // 客户端程序 func main() { // 读取需要创建的矩形数量 var N int fmt.Scan(\u0026N) // 读取每个矩形的属性信息并创建矩形对象 for i := 0; i \u003c N; i++ { var color string var width, height int fmt.Scan(\u0026color, \u0026width, \u0026height) // 创建原型对象 originalRectangle := NewRectanglePrototype(color, width, height) // 克隆对象并输出详细信息 clonedRectangle := originalRectangle.clone() fmt.Println(clonedRectangle.getDetails()) } } "
            }
        );
    index.add(
            {
                id:  15 ,
                href: "\/docs\/dev\/23designpattern\/6.%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F\/",
                title: "6.适配器模式",
                description: "它可以将一个类的接口转换成客户希望的另一个接口，主要目的是充当两个不同接口之间的桥梁，使得原本接口不兼容的类能够一起工作。",
                content: "需求 link【设计模式专题之适配器模式】6. 扩展坞\n题目描述\n小明购买了一台新电脑，该电脑使用 TypeC 接口，他已经有了一个USB接口的充电器和数据线，为了确保新电脑可以使用现有的USB接口充电器和数据线，他购买了一个TypeC到USB的扩展坞。 请你使用适配器模式设计并实现这个扩展坞系统，确保小明的新电脑既可以通过扩展坞使用现有的USB接口充电线和数据线，也可以使用TypeC接口充电。 输入描述\n题目包含多行输入，第一行输入一个数字 N （1 \u003c N \u003c= 20)，表示后面有N组测试数据。 之后N行都是一个整数，1表示使用电脑本身的TypeC接口，2表示使用扩展坞的USB接口充电。 输入示例 3 1 2 1 输出示例 TypeC USB Adapter TypeC 什么是适配器 link适配器模式Adapter是一种结构型设计模式，它可以将一个类的接口转换成客户希望的另一个接口，主要目的是充当两个不同接口之间的桥梁，使得原本接口不兼容的类能够一起工作。\n基本结构 link适配器模式分为以下几个基本角色：\n可以把适配器模式理解成拓展坞，起到转接的作用，原有的接口是USB，但是客户端需要使用type-c， 便使用拓展坞提供一个type-c接口给客户端使用\n目标接口Target: 客户端希望使用的接口 适配器类Adapter: 实现客户端使用的目标接口，持有一个需要适配的类实例。 被适配者Adaptee: 需要被适配的类 这样，客户端就可以使用目标接口，而不需要对原来的Adaptee进行修改，Adapter起到一个转接扩展的作用。\n基本实现 link // 目标接口 interface Target { void request(); } // 被适配者类 class Adaptee { void specificRequest() { System.out.println(\"Specific request\"); } } // 适配器类 class Adapter implements Target { // 持有一个被适配者实例 private Adaptee adaptee; public Adapter(Adaptee adaptee) { this.adaptee = adaptee; } @Override public void request() { // 调用被适配者类的方法 adaptee.specificRequest(); } } // 客户端代码 public class Client { public static void main(String[] args) { Target target = new Adapter(new Adaptee()); target.request(); } } 应用场景 link在开发过程中，适配器模式往往扮演者“补救”和“扩展”的角色：\n当使用一个已经存在的类，但是它的接口与你的代码不兼容时，可以使用适配器模式。\n在系统扩展阶段需要增加新的类时，并且类的接口和系统现有的类不一致时，可以使用适配器模式。\n使用适配器模式可以将客户端代码与具体的类解耦，客户端不需要知道被适配者的细节，客户端代码也不需要修改，这使得它具有良好的扩展性，但是这也势必导致系统变得更加复杂。\n具体来说，适配器模式有着以下应用：\n不同的项目和库可能使用不同的日志框架，不同的日志框架提供的API也不同，因此引入了适配器模式使得不同的API适配为统一接口。\nSpring MVC中，HandlerAdapter 接口是适配器模式的一种应用。它负责将处理器（Handler）适配到框架中，使得不同类型的处理器能够统一处理请求。\n在.NET中，DataAdapter 用于在数据源（如数据库）和 DataSet 之间建立适配器，将数据从数据源适配到 DataSet 中，以便在.NET应用程序中使用。\n本题代码 link // 测试程序 import java.util.Scanner; // USB 接口 interface USB { void charge(); } // TypeC 接口 interface TypeC { void chargeWithTypeC(); } // 适配器类 class TypeCAdapter implements USB { private TypeC typeC; public TypeCAdapter(TypeC typeC) { this.typeC = typeC; } @Override public void charge() { typeC.chargeWithTypeC(); } } // 新电脑类，使用 TypeC 接口 class NewComputer implements TypeC { @Override public void chargeWithTypeC() { System.out.println(\"TypeC\"); } } // 适配器充电器类，使用 USB 接口 class AdapterCharger implements USB { @Override public void charge() { System.out.println(\"USB Adapter\"); } } public class Main { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); // 读取连接次数 int N = scanner.nextInt(); scanner.nextLine(); // 消耗换行符 for (int i = 0; i \u003c N; i++) { // 读取用户选择 int choice = scanner.nextInt(); // 根据用户的选择创建相应对象 if (choice == 1) { TypeC newComputer = new NewComputer(); newComputer.chargeWithTypeC(); } else if (choice == 2) { USB usbAdapter = new AdapterCharger(); usbAdapter.charge(); } } scanner.close(); } } 其他语言代码 linkJava link类适配器模式代码：\nimport java.util.*; // 定义计算机端口接口 interface ComputerPort { void connect(); } // TypeC端口类实现ComputerPort接口 class TypeCPort implements ComputerPort { @Override public void connect() { System.out.println(\"TypeC\"); } } // USB设备类 class USBDevice { public void connectUSB() { System.out.println(\"USB Adapter\"); } } // TypeC到USB适配器类 class TypeCToUSBAdapter extends USBDevice implements ComputerPort { @Override public void connect() { super.connectUSB(); } } public class Main{ public static void main(String[] args) { Scanner inputScanner = new Scanner(System.in); Map connectionModes = new HashMap\u003c\u003e(); connectionModes.put(1, new TypeCPort()); connectionModes.put(2, new TypeCToUSBAdapter()); int totalConnections = inputScanner.nextInt(); inputScanner.nextLine(); while (inputScanner.hasNextInt()) { int choice = inputScanner.nextInt(); connectionModes.getOrDefault(choice, () -\u003e System.out.println(\"\")).connect(); } inputScanner.close(); } } C++ link #include // USB 接口 class USB { public: virtual void charge() = 0; }; // TypeC 接口 class TypeC { public: virtual void chargeWithTypeC() = 0; }; // 适配器类 class TypeCAdapter : public USB { private: TypeC* typeC; public: TypeCAdapter(TypeC* typeC) : typeC(typeC) {} void charge() override { typeC-\u003echargeWithTypeC(); } }; // 新电脑类，使用 TypeC 接口 class NewComputer : public TypeC { public: void chargeWithTypeC() override { std::cout \u003c\u003c \"TypeC\" \u003c\u003c std::endl; } }; // 适配器充电器类，使用 USB 接口 class AdapterCharger : public USB { public: void charge() override { std::cout \u003c\u003c \"USB Adapter\" \u003c\u003c std::endl; } }; int main() { // 读取连接次数 int N; std::cin \u003e\u003e N; std::cin.ignore(); // 消耗换行符 for (int i = 0; i \u003c N; i++) { // 读取用户选择 int choice; std::cin \u003e\u003e choice; // 根据用户的选择创建相应对象 if (choice == 1) { TypeC* newComputer = new NewComputer(); newComputer-\u003echargeWithTypeC(); delete newComputer; } else if (choice == 2) { USB* usbAdapter = new AdapterCharger(); usbAdapter-\u003echarge(); delete usbAdapter; } } return 0; } Python link # USB 接口 class USB: def charge(self): pass # TypeC 接口 class TypeC: def charge_with_type_c(self): pass # 适配器类 class TypeCAdapter(USB): def __init__(self, type_c): self.type_c = type_c def charge(self): self.type_c.charge_with_type_c() # 新电脑类，使用 TypeC 接口 class NewComputer(TypeC): def charge_with_type_c(self): print(\"TypeC\") # 适配器充电器类，使用 USB 接口 class AdapterCharger(USB): def charge(self): print(\"USB Adapter\") if __name__ == \"__main__\": # 读取连接次数 N = int(input()) for _ in range(N): # 读取用户选择 choice = int(input()) # 根据用户的选择创建相应对象 if choice == 1: new_computer = NewComputer() new_computer.charge_with_type_c() elif choice == 2: usb_adapter = AdapterCharger() usb_adapter.charge() Go link package main import \"fmt\" // USB 接口 type USB interface { charge() } // TypeC 接口 type TypeC interface { chargeWithTypeC() } // 适配器类 type TypeCAdapter struct { typeC TypeC } func (tca *TypeCAdapter) charge() { tca.typeC.chargeWithTypeC() } // 新电脑类，使用 TypeC 接口 type NewComputer struct{} func (nc *NewComputer) chargeWithTypeC() { fmt.Println(\"TypeC\") } // 适配器充电器类，使用 USB 接口 type AdapterCharger struct{} func (ac *AdapterCharger) charge() { fmt.Println(\"USB Adapter\") } func main() { var N int fmt.Scan(\u0026N) // 读取连接次数 for i := 0; i \u003c N; i++ { var choice int fmt.Scan(\u0026choice) // 读取用户选择 // 根据用户的选择创建相应对象 if choice == 1 { newComputer := \u0026NewComputer{} adapter := \u0026TypeCAdapter{typeC: newComputer} adapter.charge() } else if choice == 2 { usbAdapter := \u0026AdapterCharger{} usbAdapter.charge() } } } "
            }
        );
    index.add(
            {
                id:  16 ,
                href: "\/docs\/dev\/23designpattern\/7.%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F\/",
                title: "7.代理模式",
                description: "代理模式中，允许一个对象（代理）充当另一个对象（真实对象）的接口，以控制对这个对象的访问。",
                content: "需求 link【设计模式专题之代理模式】7-小明买房子\n题目描述\n小明想要购买一套房子，他决定寻求一家房屋中介来帮助他找到一个面积超过100平方米的房子，只有符合条件的房子才会被传递给小明查看。 输入描述\n第一行是一个整数 N（1 ≤ N ≤ 100），表示可供查看的房子的数量。 接下来的 N 行，每行包含一个整数，表示对应房子的房屋面积。 输出描述\n对于每个房子，输出一行，表示是否符合购房条件。如果房屋面积超过100平方米，输出 “YES”；否则输出 “NO”。 输入示例 3 120 80 110 输出示例 YES NO YES 基本概念 link代理模式Proxy Pattern是一种结构型设计模式，用于控制对其他对象的访问。\n在代理模式中，允许一个对象（代理）充当另一个对象（真实对象）的接口，以控制对这个对象的访问。通常用于在访问某个对象时引入一些间接层(中介的作用)，这样可以在访问对象时添加额外的控制逻辑，比如限制访问权限，延迟加载。\n比如说有一个文件加载的场景，为了避免直接访问“文件”对象，我们可以新增一个代理对象，代理对象中有一个对“文件对象”的引用，在代理对象的 load 方法中，可以在访问真实的文件对象之前进行一些操作，比如权限检查，然后调用真实文件对象的 load 方法，最后在访问真实对象后进行其他操作，比如记录访问日志。\n基本结构 link代理模式的主要角色有：\nSubject（抽象主题）： 抽象类，通过接口或抽象类声明真实主题和代理对象实现的业务方法。\nRealSubject（真实主题）：定义了Proxy所代表的真实对象，是客户端最终要访问的对象。\nProxy（代理）：包含一个引用，该引用可以是RealSubject的实例，控制对RealSubject的访问，并可能负责创建和删除RealSubject的实例。\n实现方式 link代理模式的基本实现分为以下几个步骤：\n定义抽象主题, 一般是接口或者抽象类，声明真实主题和代理对象实现的业务方法。 // 1. 定义抽象主题 interface Subject { void request(); } 定义真实主题，实现抽象主题中的具体业务 // 2. 定义真实主题 class RealSubject implements Subject { @Override public void request() { System.out.println(\"RealSubject handles the request.\"); } } 定义代理类，包含对RealSubject的引用，并提供和真实主题相同的接口，这样代理就可以替代真实主题，并对真实主题进行功能扩展。 // 3. 定义代理 class Proxy implements Subject { // 包含一个引用 private RealSubject realSubject; @Override public void request() { // 在访问真实主题之前可以添加额外的逻辑 if (realSubject == null) { realSubject = new RealSubject(); } // 调用真实主题的方法 realSubject.request(); // 在访问真实主题之后可以添加额外的逻辑 } } 客户端使用代理 // 4. 客户端使用代理 public class Main { public static void main(String[] args) { // 使用代理 Subject proxy = new Proxy(); proxy.request(); } } 使用场景 link代理模式可以控制客户端对真实对象的访问，从而限制某些客户端的访问权限，此外代理模式还常用在访问真实对象之前或之后执行一些额外的操作（比如记录日志），对功能进行扩展。\n以上特性决定了代理模式在以下几个场景中有着广泛的应用：\n虚拟代理：当一个对象的创建和初始化比较昂贵时，可以使用虚拟代理，虚拟代理可以延迟对象的实际创建和初始化，只有在需要时才真正创建并初始化对象。 安全代理：安全代理可以根据访问者的权限决定是否允许访问真实对象的方法。 但是代理模式涉及到多个对象之间的交互，引入代理模式会增加系统的复杂性，在需要频繁访问真实对象时，还可能会有一些性能问题。\n代理模式在许多工具和库中也有应用：\nSpring 框架的 AOP 模块使用了代理模式来实现切面编程。通过代理，Spring 能够在目标对象的方法执行前、执行后或抛出异常时插入切面逻辑，而不需要修改原始代码。 Java 提供了动态代理机制，允许在运行时生成代理类。 Android中的Glide框架使用了代理模式来实现图片的延迟加载。 本题代码 link import java.util.Scanner; // 抽象主题 interface HomePurchase { void requestPurchase(int area); } //真实主题 class HomeBuyer implements HomePurchase { @Override public void requestPurchase(int area) { System.out.println(\"YES\"); } } // 代理类 class HomeAgentProxy implements HomePurchase { private HomeBuyer homeBuyer = new HomeBuyer(); @Override public void requestPurchase(int area) { if (area \u003e 100) { homeBuyer.requestPurchase(area); } else { System.out.println(\"NO\"); } } } public class Main { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); HomePurchase buyerProxy = new HomeAgentProxy(); int n = scanner.nextInt(); for (int i = 0; i \u003c n; i++) { int area = scanner.nextInt(); buyerProxy.requestPurchase(area); } scanner.close(); } } 扩展：代理模式和适配器模式有什么区别 link代理模式的主要目的是控制对对象的访问。通常用于在访问真实对象时引入一些额外的控制逻辑，如权限控制、延迟加载等。\n适配器模式的主要目的是使接口不兼容的对象能够协同工作。适配器模式允许将一个类的接口转换成另一个类的接口，使得不同接口的类可以协同工作。\n其他语言代码 linkC++ link #include // 抽象主题 class HomePurchase { public: virtual void requestPurchase(int area) = 0; }; // 真实主题 class HomeBuyer : public HomePurchase { public: void requestPurchase(int area) override { std::cout \u003c\u003c \"YES\" \u003c\u003c std::endl; } }; // 代理类 class HomeAgentProxy : public HomePurchase { private: HomeBuyer homeBuyer; public: void requestPurchase(int area) override { if (area \u003e 100) { homeBuyer.requestPurchase(area); } else { std::cout \u003c\u003c \"NO\" \u003c\u003c std::endl; } } }; int main() { HomePurchase* buyerProxy = new HomeAgentProxy(); int n; std::cin \u003e\u003e n; for (int i = 0; i \u003c n; i++) { int area; std::cin \u003e\u003e area; buyerProxy-\u003erequestPurchase(area); } delete buyerProxy; return 0; } Python link # 抽象主题 class HomePurchase: def request_purchase(self, area): pass # 真实主题 class HomeBuyer(HomePurchase): def request_purchase(self, area): print(\"YES\") # 代理类 class HomeAgentProxy(HomePurchase): def __init__(self): self.home_buyer = HomeBuyer() def request_purchase(self, area): if area \u003e 100: self.home_buyer.request_purchase(area) else: print(\"NO\") if __name__ == \"__main__\": buyer_proxy = HomeAgentProxy() n = int(input()) for _ in range(n): area = int(input()) buyer_proxy.request_purchase(area) Go link package main import \"fmt\" // 抽象主题 type HomePurchase interface { requestPurchase(area int) } // 真实主题 type HomeBuyer struct{} func (hb *HomeBuyer) requestPurchase(area int) { fmt.Println(\"YES\") } // 代理类 type HomeAgentProxy struct { homeBuyer HomePurchase } func (hap *HomeAgentProxy) requestPurchase(area int) { if area \u003e 100 { hap.homeBuyer.requestPurchase(area) } else { fmt.Println(\"NO\") } } func main() { var buyerProxy HomePurchase = \u0026HomeAgentProxy{homeBuyer: \u0026HomeBuyer{}} var n int fmt.Scan(\u0026n) for i := 0; i \u003c n; i++ { var area int fmt.Scan(\u0026area) buyerProxy.requestPurchase(area) } } "
            }
        );
    index.add(
            {
                id:  17 ,
                href: "\/docs\/dev\/23designpattern\/8.%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F\/",
                title: "8.装饰模式",
                description: " 通常情况下，扩展类的功能可以通过继承实现，但是扩展越多，子类越多，装饰模式可以在**不定义子类的情况下动态的给对象添加一些额外的功能。**",
                content: "需求 link【设计模式专题装饰模式】8-咖啡加糖\n题目描述\n小明喜欢品尝不同口味的咖啡，他发现每种咖啡都可以加入不同的调料，比如牛奶、糖和巧克力。他决定使用装饰者模式制作自己喜欢的咖啡。 请设计一个简单的咖啡制作系统，使用装饰者模式为咖啡添加不同的调料。系统支持两种咖啡类型：黑咖啡（Black Coffee）和拿铁（Latte）。 输入描述\n多行输入，每行包含两个数字。第一个数字表示咖啡的选择（1 表示黑咖啡，2 表示拿铁），第二个数字表示要添加的调料类型（1 表示牛奶，2 表示糖）。 输出描述\n根据每行输入，输出制作咖啡的过程，包括咖啡类型和添加的调料。 输入示例 1 1 2 2 输出示例 Brewing Black Coffee Adding Milk Brewing Latte Adding Sugar 基本概念 link通常情况下，扩展类的功能可以通过继承实现，但是扩展越多，子类越多，装饰模式（Decorator Pattern, 结构型设计模式）可以在**不定义子类的情况下动态的给对象添加一些额外的功能。**具体的做法是将原始对象放入包含行为的特殊封装类(装饰类)，从而为原始对象动态添加新的行为，而无需修改其代码。\n举个简单的例子，假设你有一个基础的图形类，你想要为图形类添加颜色、边框、阴影等功能，如果每个功能都实现一个子类，就会导致产生大量的类，这时就可以考虑使用装饰模式来动态地添加，而不需要修改图形类本身的代码，这样可以使得代码更加灵活、更容易维护和扩展。\n基本结构： link装饰模式包含以下四个主要角色：\n组件Component：通常是抽象类或者接口，是具体组件和装饰者的父类，定义了具体组件需要实现的方法，比如说我们定义Coffee为组件。 具体组件ConcreteComponent: 实现了Component接口的具体类，是被装饰的对象。 装饰类Decorator: 一个抽象类，给具体组件添加功能，但是具体的功能由其子类具体装饰者完成，持有一个指向Component对象的引用。 具体装饰类ConcreteDecorator: 扩展Decorator类，负责向Component对象添加新的行为，加牛奶的咖啡是一个具体装饰类，加糖的咖啡也是一个具体装饰类。 基本实现 link装饰模式的实现包括以下步骤：\n定义Component接口 // 组件接口 public interface Component { void operation(); } 实现 ConcreteComponent // 具体组件 public class ConcreteComponent implements Component { @Override public void operation() { System.out.println(\"ConcreteComponent operation\"); } } 定义Decorator装饰类，继承自Component // 定义一个抽象的装饰者类，继承自Component public abstract class Decorator implements Component { protected Component component; public Decorator(Component component) { this.component = component; } @Override public void operation() { component.operation(); } } 定义具体的装饰者实现，给具体组件对象添加功能。 // 具体的装饰者实现 public class ConcreteDecorator extends Decorator { public ConcreteDecorator(Component component) { super(component); } // 根据需要添加额外的方法 @Override public void operation() { // 可以在调用前后添加额外的行为 System.out.println(\"Before operation in ConcreteDecorator\"); super.operation(); System.out.println(\"After operation in ConcreteDecorator\"); } } 在客户端使用 public class Main { public static void main(String[] args) { // 创建具体组件 Component concreteComponent = new ConcreteComponent(); // 使用具体装饰者包装具体组件 Decorator decorator = new ConcreteDecorator(concreteComponent); // 调用操作 decorator.operation(); } } 应用场景 link装饰模式通常在以下几种情况使用：\n当需要给一个现有类添加附加功能，但由于某些原因不能使用继承来生成子类进行扩充时，可以使用装饰模式。\n动态的添加和覆盖功能：当对象的功能要求可以动态地添加，也可以再动态地撤销时可以使用装饰模式。\n在Java的I/O库中，装饰者模式被广泛用于增强I/O流的功能。例如，BufferedInputStream和BufferedOutputStream这两个类提供了缓冲区的支持，通过在底层的输入流和输出流上添加缓冲区，提高了读写的效率，它们都是InputStream和OutputStream的装饰器。BufferedReader和BufferedWriter这两个类与BufferedInputStream和BufferedOutputStream类似，提供了字符流的缓冲功能，是Reader和Writer的装饰者。\n本题代码 link import java.util.Scanner; // 咖啡接口 interface Coffee { void brew(); } // 具体的黑咖啡类 class BlackCoffee implements Coffee { @Override public void brew() { System.out.println(\"Brewing Black Coffee\"); } } // 具体的拿铁类 class Latte implements Coffee { @Override public void brew() { System.out.println(\"Brewing Latte\"); } } // 装饰者抽象类 abstract class Decorator implements Coffee { protected Coffee coffee; public Decorator(Coffee coffee) { this.coffee = coffee; } @Override public void brew() { coffee.brew(); } } // 具体的牛奶装饰者类 class MilkDecorator extends Decorator { public MilkDecorator(Coffee coffee) { super(coffee); } @Override public void brew() { super.brew(); System.out.println(\"Adding Milk\"); } } // 具体的糖装饰者类 class SugarDecorator extends Decorator { public SugarDecorator(Coffee coffee) { super(coffee); } @Override public void brew() { super.brew(); System.out.println(\"Adding Sugar\"); } } // 客户端代码 public class Main { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); while (scanner.hasNext()) { int coffeeType = scanner.nextInt(); int condimentType = scanner.nextInt(); // 根据输入制作咖啡 Coffee coffee; if (coffeeType == 1) { coffee = new BlackCoffee(); } else if (coffeeType == 2) { coffee = new Latte(); } else { System.out.println(\"Invalid coffee type\"); continue; } // 根据输入添加调料 if (condimentType == 1) { coffee = new MilkDecorator(coffee); } else if (condimentType == 2) { coffee = new SugarDecorator(coffee); } else { System.out.println(\"Invalid condiment type\"); continue; } // 输出制作过程 coffee.brew(); } } } 其他语言版本 linkJava link将处理输入和创建对象的逻辑分离到方法中。\nimport java.util.Scanner; // 定义咖啡接口 interface Coffee { void execute(); } // 黑咖啡类，实现咖啡接口 class BrewingBlackCoffee implements Coffee { @Override public void execute() { System.out.println(\"Brewing Black Coffee\"); } } // 拿铁类，实现咖啡接口 class BrewingLatte implements Coffee { @Override public void execute() { System.out.println(\"Brewing Latte\"); } } // 咖啡装饰器抽象类，实现咖啡接口 abstract class Decorator implements Coffee { private Coffee coffee; public Decorator(Coffee coffee) { this.coffee = coffee; } @Override public void execute() { coffee.execute(); } } // 牛奶装饰器类，继承自装饰器类 class MilkDecorator extends Decorator { public MilkDecorator(Coffee coffee) { super(coffee); } @Override public void execute() { super.execute(); System.out.println(\"Adding Milk\"); } } // 糖装饰器类，继承自装饰器类 class SugarDecorator extends Decorator { public SugarDecorator(Coffee coffee) { super(coffee); } @Override public void execute() { super.execute(); System.out.println(\"Adding Sugar\"); } } public class Main { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); try { String input; while (scanner.hasNextLine()) { input = scanner.nextLine(); if (input.equalsIgnoreCase(\"exit\")) { break; } processInput(input); } } catch (NumberFormatException e) { System.out.println(\"输入格式无效：\" + e.getMessage()); } finally { scanner.close(); } } // 处理输入的方法 private static void processInput(String input) { String[] parts = input.split(\" \"); if (parts.length != 2) { System.out.println(\"输入格式无效。请提供两个数字，中间用空格分隔。\"); return; } try { int type1 = Integer.parseInt(parts[0]); int type2 = Integer.parseInt(parts[1]); Coffee coffee = createCoffee(type1); if (coffee == null) { System.out.println(\"咖啡类型无效。请输入1（黑咖啡）或2（拿铁）。\"); return; } coffee = decorateCoffee(coffee, type2); if (coffee == null) { System.out.println(\"装饰类型无效。请输入1（牛奶）或2（糖）。\"); return; } coffee.execute(); } catch (NumberFormatException e) { System.out.println(\"输入格式无效：两个输入都必须是数字。\"); } } // 创建咖啡对象的方法 private static Coffee createCoffee(int type) { switch (type) { case 1: return new BrewingBlackCoffee(); case 2: return new BrewingLatte(); default: return null; } } // 添加装饰器的方法 private static Coffee decorateCoffee(Coffee coffee, int type) { switch (type) { case 1: return new MilkDecorator(coffee); case 2: return new SugarDecorator(coffee); default: return null; } } } C++ link #include #include // 咖啡接口 class Coffee { public: virtual ~Coffee() {} virtual void brew() = 0; }; // 具体的黑咖啡类 class BlackCoffee : public Coffee { public: void brew() override { std::cout \u003c\u003c \"Brewing Black Coffee\" \u003c\u003c std::endl; } }; // 具体的拿铁类 class Latte : public Coffee { public: void brew() override { std::cout \u003c\u003c \"Brewing Latte\" \u003c\u003c std::endl; } }; // 装饰者抽象类 class Decorator : public Coffee { protected: std::unique_ptr coffee; public: Decorator(std::unique_ptr coffee) : coffee(std::move(coffee)) {} void brew() override { if (coffee) { coffee-\u003ebrew(); } } }; // 具体的牛奶装饰者类 class MilkDecorator : public Decorator { public: MilkDecorator(std::unique_ptr coffee) : Decorator(std::move(coffee)) {} void brew() override { Decorator::brew(); std::cout \u003c\u003c \"Adding Milk\" \u003c\u003c std::endl; } }; // 具体的糖装饰者类 class SugarDecorator : public Decorator { public: SugarDecorator(std::unique_ptr coffee) : Decorator(std::move(coffee)) {} void brew() override { Decorator::brew(); std::cout \u003c\u003c \"Adding Sugar\" \u003c\u003c std::endl; } }; // 客户端代码 int main() { int coffeeType, condimentType; while (std::cin \u003e\u003e coffeeType \u003e\u003e condimentType) { // 根据输入制作咖啡 std::unique_ptr coffee; if (coffeeType == 1) { coffee = std::make_unique(); } else if (coffeeType == 2) { coffee = std::make_unique(); } else { std::cout \u003c\u003c \"Invalid coffee type\" \u003c\u003c std::endl; continue; } // 根据输入添加调料 if (condimentType == 1) { coffee = std::make_unique(std::move(coffee)); } else if (condimentType == 2) { coffee = std::make_unique(std::move(coffee)); } else { std::cout \u003c\u003c \"Invalid condiment type\" \u003c\u003c std::endl; continue; } // 输出制作过程 coffee-\u003ebrew(); } return 0; } Python link from abc import ABC, abstractmethod from typing import Type # 咖啡接口 class Coffee(ABC): @abstractmethod def brew(self): pass # 具体的黑咖啡类 class BlackCoffee(Coffee): def brew(self): print(\"Brewing Black Coffee\") # 具体的拿铁类 class Latte(Coffee): def brew(self): print(\"Brewing Latte\") # 装饰者抽象类 class Decorator(Coffee, ABC): def __init__(self, coffee: Type[Coffee]): self._coffee = coffee def brew(self): self._coffee.brew() # 具体的牛奶装饰者类 class MilkDecorator(Decorator): def brew(self): super().brew() print(\"Adding Milk\") # 具体的糖装饰者类 class SugarDecorator(Decorator): def brew(self): super().brew() print(\"Adding Sugar\") # 客户端代码 if __name__ == \"__main__\": try: while True: coffee_type, condiment_type = map(int, input().split()) # 根据输入制作咖啡 if coffee_type == 1: coffee = BlackCoffee() elif coffee_type == 2: coffee = Latte() else: print(\"Invalid coffee type\") continue # 根据输入添加调料 if condiment_type == 1: coffee = MilkDecorator(coffee) elif condiment_type == 2: coffee = SugarDecorator(coffee) else: print(\"Invalid condiment type\") continue # 输出制作过程 coffee.brew() except EOFError: pass Go link package main import \"fmt\" // 咖啡接口 type Coffee interface { brew() } // 具体的黑咖啡类 type BlackCoffee struct{} func (bc *BlackCoffee) brew() { fmt.Println(\"Brewing Black Coffee\") } // 具体的拿铁类 type Latte struct{} func (l *Latte) brew() { fmt.Println(\"Brewing Latte\") } // 装饰者抽象类 type Decorator struct { coffee Coffee } func (d *Decorator) brew() { d.coffee.brew() } // 具体的牛奶装饰者类 type MilkDecorator struct { Decorator } func (md *MilkDecorator) brew() { md.Decorator.brew() fmt.Println(\"Adding Milk\") } // 具体的糖装饰者类 type SugarDecorator struct { Decorator } func (sd *SugarDecorator) brew() { sd.Decorator.brew() fmt.Println(\"Adding Sugar\") } func main() { for { var coffeeType, condimentType int if _, err := fmt.Scan(\u0026coffeeType, \u0026condimentType); err != nil { break } // 根据输入制作咖啡 var coffee Coffee if coffeeType == 1 { coffee = \u0026BlackCoffee{} } else if coffeeType == 2 { coffee = \u0026Latte{} } else { fmt.Println(\"Invalid coffee type\") continue } // 根据输入添加调料 if condimentType == 1 { coffee = \u0026MilkDecorator{Decorator: Decorator{coffee: coffee}} } else if condimentType == 2 { coffee = \u0026SugarDecorator{Decorator: Decorator{coffee: coffee}} } else { fmt.Println(\"Invalid condiment type\") continue } // 输出制作过程 coffee.brew() } } "
            }
        );
    index.add(
            {
                id:  18 ,
                href: "\/docs\/dev\/23designpattern\/9.%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F\/",
                title: "9.外观模式",
                description: "外观模式`Facade Pattern`,  也被称为“门面模式”，是一种结构型设计模式，外观模式定义了一个高层接口，这个接口使得子系统更容易使用，同时也隐藏了子系统的复杂性。",
                content: "需求 link【设计模式专题之外观模式】9-电源开关\n题目描述\n小明家的电源总开关控制了家里的三个设备：空调、台灯和电视机。每个设备都有独立的开关密码，分别用数字1、2和3表示。即输入1时，空调关闭，输入2时，台灯关闭，输入3时，电视机关闭，当输入为4时，表示要关闭所有设备。请你使用外观模式编写程序来描述电源总开关的操作。 输入描述\n第一行是一个整数 N（1 \u003c= N \u003c= 100），表示后面有 N 行输入。 接下来的 N 行，每行包含一个数字，表示对应设备的开关操作（1表示关闭空调，2表示关闭台灯，3表示关闭电视机，4表示关闭所有设备）。 输出描述\n输出关闭所有设备后的状态，当输入的数字不在1-4范围内时，输出Invalid device code. 输入示例 4 1 2 3 4 输出示例 Air Conditioner is turned off. Desk Lamp is turned off. Television is turned off. All devices are off. 基本概念 link外观模式Facade Pattern, 也被称为“门面模式”，是一种结构型设计模式，外观模式定义了一个高层接口，这个接口使得子系统更容易使用，同时也隐藏了子系统的复杂性。\n门面模式可以将子系统关在“门里”隐藏起来，客户端只需要通过外观接口与外观对象进行交互，而不需要直接和多个子系统交互，无论子系统多么复杂，对于外部来说是隐藏的，这样可以降低系统的耦合度。\n举个例子，假设你正在编写的一个模块用来处理文件读取、解析、存储，我们可以将这个过程拆成三部分，然后创建一个外观类，将文件系统操作、数据解析和存储操作封装在外观类中，为客户端提供一个简化的接口，如果后续需要修改文件处理的流程或替换底层子系统，也只需在外观类中进行调整，不会影响客户端代码。\n基本结构 link外观模式的基本结构比较简单，只包括“外观”和“子系统类”\n外观类：对外提供一个统一的高层次接口，使复杂的子系统变得更易使用。 子系统类：实现子系统的功能，处理外观类指派的任务。 简易实现 link下面使用Java代码实现外观模式的通用结构\n// 子系统A class SubsystemA { public void operationA() { System.out.println(\"SubsystemA operation\"); } } // 子系统B class SubsystemB { public void operationB() { System.out.println(\"SubsystemB operation\"); } } // 子系统C class SubsystemC { public void operationC() { System.out.println(\"SubsystemC operation\"); } } // 外观类 class Facade { private SubsystemA subsystemA; private SubsystemB subsystemB; private SubsystemC subsystemC; public Facade() { this.subsystemA = new SubsystemA(); this.subsystemB = new SubsystemB(); this.subsystemC = new SubsystemC(); } // 外观方法，封装了对子系统的操作 public void facadeOperation() { subsystemA.operationA(); subsystemB.operationB(); subsystemC.operationC(); } } // 客户端 public class Main { public static void main(String[] args) { // 创建外观对象 Facade facade = new Facade(); // 客户端通过外观类调用子系统的操作 facade.facadeOperation(); } } 在上面的代码中，Facade 类是外观类，封装了对三个子系统SubSystem的操作。客户端通过调用外观类的方法来实现对子系统的访问，而不需要直接调用子系统的方法。\n优缺点和使用场景 link外观模式通过提供一个简化的接口，隐藏了系统的复杂性，降低了客户端和子系统之间的耦合度，客户端不需要了解系统的内部实现细节，也不需要直接和多个子系统交互，只需要通过外观接口与外观对象进行交互。\n但是如果需要添加新的子系统或修改子系统的行为，就可能需要修改外观类，这违背了“开闭原则”。\n外观模式的应用也十分普遍，下面几种情况都使用了外观模式来进行简化。\nSpring框架是一个广泛使用外观模式的例子。Spring框架提供了一个大量的功能，包括依赖注入、面向切面编程（AOP）、事务管理等。Spring的ApplicationContext可以看作是外观，隐藏了底层组件的复杂性，使得开发者可以更轻松地使用Spring的功能。 JDBC提供了一个用于与数据库交互的接口。DriverManager类可以看作是外观，它简化了数据库驱动的加载和连接的过程，隐藏了底层数据库连接的复杂性。 Android系统的API中也使用了外观模式。例如，Activity类提供了一个外观，使得开发者可以更容易地管理应用的生命周期，而无需关心底层的事件和状态管理。 本题代码 link import java.util.Scanner; class AirConditioner { public void turnOff() { System.out.println(\"Air Conditioner is turned off.\"); } } class DeskLamp { public void turnOff() { System.out.println(\"Desk Lamp is turned off.\"); } } class Television { public void turnOff() { System.out.println(\"Television is turned off.\"); } } class PowerSwitchFacade { private DeskLamp deskLamp; private AirConditioner airConditioner; private Television television; public PowerSwitchFacade() { this.deskLamp = new DeskLamp(); this.airConditioner = new AirConditioner(); this.television = new Television(); } public void turnOffDevice(int deviceCode) { switch (deviceCode) { case 1: airConditioner.turnOff(); break; case 2: deskLamp.turnOff(); break; case 3: television.turnOff(); break; case 4: System.out.println(\"All devices are off.\"); break; default: System.out.println(\"Invalid device code.\"); } } } public class Main { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); // 读取输入 int n = scanner.nextInt(); int[] input = new int[n]; for (int i = 0; i \u003c n; i++) { input[i] = scanner.nextInt(); } // 创建电源总开关外观 PowerSwitchFacade powerSwitch = new PowerSwitchFacade(); // 执行操作 for (int i = 0; i \u003c n; i++) { powerSwitch.turnOffDevice(input[i]); } } } 其他语言版本 linkC++ link #include #include class AirConditioner { public: void turnOff() { std::cout \u003c\u003c \"Air Conditioner is turned off.\" \u003c\u003c std::endl; } }; class DeskLamp { public: void turnOff() { std::cout \u003c\u003c \"Desk Lamp is turned off.\" \u003c\u003c std::endl; } }; class Television { public: void turnOff() { std::cout \u003c\u003c \"Television is turned off.\" \u003c\u003c std::endl; } }; class PowerSwitchFacade { private: DeskLamp deskLamp; AirConditioner airConditioner; Television television; public: PowerSwitchFacade() { } void turnOffDevice(int deviceCode) { switch (deviceCode) { case 1: airConditioner.turnOff(); break; case 2: deskLamp.turnOff(); break; case 3: television.turnOff(); break; case 4: std::cout \u003c\u003c \"All devices are off.\" \u003c\u003c std::endl; break; default: std::cout \u003c\u003c \"Invalid device code.\" \u003c\u003c std::endl; } } }; int main() { // 读取输入 int n; std::cin \u003e\u003e n; std::vector input(n); for (int i = 0; i \u003c n; i++) { std::cin \u003e\u003e input[i]; } // 创建电源总开关外观 PowerSwitchFacade powerSwitch; // 执行操作 for (int i = 0; i \u003c n; i++) { powerSwitch.turnOffDevice(input[i]); } return 0; } Python link class AirConditioner: def turn_off(self): print(\"Air Conditioner is turned off.\") class DeskLamp: def turn_off(self): print(\"Desk Lamp is turned off.\") class Television: def turn_off(self): print(\"Television is turned off.\") class PowerSwitchFacade: def __init__(self): self.desk_lamp = DeskLamp() self.air_conditioner = AirConditioner() self.television = Television() def turn_off_device(self, device_code): if device_code == 1: self.air_conditioner.turn_off() elif device_code == 2: self.desk_lamp.turn_off() elif device_code == 3: self.television.turn_off() elif device_code == 4: print(\"All devices are off.\") else: print(\"Invalid device code.\") if __name__ == \"__main__\": # 读取输入 n = int(input()) input_data = [int(input()) for _ in range(n)] # 创建电源总开关外观 power_switch = PowerSwitchFacade() # 执行操作 for device_code in input_data: power_switch.turn_off_device(device_code) Go link package main import \"fmt\" // AirConditioner 类 type AirConditioner struct{} func (ac *AirConditioner) turnOff() { fmt.Println(\"Air Conditioner is turned off.\") } // DeskLamp 类 type DeskLamp struct{} func (dl *DeskLamp) turnOff() { fmt.Println(\"Desk Lamp is turned off.\") } // Television 类 type Television struct{} func (tv *Television) turnOff() { fmt.Println(\"Television is turned off.\") } // PowerSwitchFacade 类 type PowerSwitchFacade struct { deskLamp DeskLamp airConditioner AirConditioner television Television } func (psf *PowerSwitchFacade) turnOffDevice(deviceCode int) { switch deviceCode { case 1: psf.airConditioner.turnOff() case 2: psf.deskLamp.turnOff() case 3: psf.television.turnOff() case 4: fmt.Println(\"All devices are off.\") default: fmt.Println(\"Invalid device code.\") } } func main() { var n int fmt.Scan(\u0026n) // 读取输入 input := make([]int, n) for i := 0; i \u003c n; i++ { fmt.Scan(\u0026input[i]) } // 创建电源总开关外观 powerSwitch := PowerSwitchFacade{} // 执行操作 for i := 0; i \u003c n; i++ { powerSwitch.turnOffDevice(input[i]) } } "
            }
        );
    index.add(
            {
                id:  19 ,
                href: "\/docs\/dev\/23designpattern\/10.%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F\/",
                title: "10.桥接模式",
                description: "桥接模式是一种结构型设计模式，它的UML图很像一座桥，它通过将【抽象部分】与【实现部分】分离，使它们可以独立变化，从而达到降低系统耦合度的目的。",
                content: "需求 link【设计模式专题之桥接模式】10-万能遥控器\n**题目描述\n小明家有一个万能遥控器，能够支持多个品牌的电视。每个电视可以执行开机、关机和切换频道的操作，请你使用桥接模式模拟这个操作。 **输入描述\n第一行是一个整数 N（1 \u003c= N \u003c= 100），表示后面有 N 行输入。 接下来的 N 行，每行包含两个数字。第一个数字表示创建某个品牌的遥控和电视，第二个数字表示执行的操作。 其中，0 表示创建 Sony 品牌的电视，1 表示创建 TCL 品牌的遥控和电视； 2 表示开启电视、3表示关闭电视，4表示切换频道。 输入示例 6 0 2 1 2 0 4 0 3 1 4 1 3 输出示例\nSony TV is ON TCL TV is ON Switching Sony TV channel Sony TV is OFF Switching TCL TV channel TCL TV is OFF 基本概念 link桥接模式（Bridge Pattern）是一种结构型设计模式，它的UML图很像一座桥，它通过将【抽象部分】与【实现部分】分离，使它们可以独立变化，从而达到降低系统耦合度的目的。桥接模式的主要目的是通过组合建立两个类之间的联系，而不是继承的方式。\n举个简单的例子，图形编辑器中，每一种图形都需要蓝色、红色、黄色不同的颜色，如果不使用桥接模式，可能需要为每一种图形类型和每一种颜色都创建一个具体的子类，而使用桥接模式可以将图形和颜色两个维度分离，两个维度都可以独立进行变化和扩展，如果要新增其他颜色，只需添加新的 Color 子类，不影响图形类；反之亦然。\n基本结构 link桥接模式的基本结构分为以下几个角色：\n抽象Abstraction：一般是抽象类，定义抽象部分的接口，维护一个对【实现】的引用。 修正抽象RefinedAbstaction：对抽象接口进行扩展，通常对抽象化的不同维度进行变化或定制。 实现Implementor： 定义实现部分的接口，提供具体的实现。这个接口通常是抽象化接口的实现。 具体实现ConcreteImplementor：实现实现化接口的具体类。这些类负责实现实现化接口定义的具体操作。 再举个例子，遥控器就是抽象接口，它具有开关电视的功能，修正抽象就是遥控器的实例，对遥控器的功能进行实现和扩展，而电视就是实现接口，具体品牌的电视机是具体实现，遥控器中包含一个对电视接口的引用，通过这种方式，遥控器和电视的实现被分离，我们可以创建多个遥控器，每个遥控器控制一个品牌的电视机，它们之间独立操作，不受电视品牌的影响，可以独立变化。\n简易实现 link下面是实现桥接模式的基本步骤：\n创建实现接口 interface Implementation { void operationImpl(); } 以电视举例, 具有开关和切换频道的功能。\ninterface TV { void on(); void off(); void tuneChannel(); } 创建具体实现类：实际提供服务的对象。 class ConcreteImplementationA implements Implementation { @Override public void operationImpl() { // 具体实现A } } class ConcreteImplementationB implements Implementation { @Override public void operationImpl() { // 具体实现B } } 以电视举例，创建具体实现类\nclass ATV implements TV { @Override public void on() { System.out.println(\"A TV is ON\"); } @Override public void off() { System.out.println(\"A TV is OFF\"); } @Override public void tuneChannel() { System.out.println(\"Tuning A TV channel\"); } } class BTV implements TV { @Override public void on() { System.out.println(\"B TV is ON\"); } @Override public void off() { System.out.println(\"B TV is OFF\"); } @Override public void tuneChannel() { System.out.println(\"Tuning B TV channel\"); } } 创建抽象接口：包含一个对实现化接口的引用。 public abstract class Abstraction { protected IImplementor mImplementor; public Abstraction(IImplementor implementor) { this.mImplementor = implementor; } public void operation() { this.mImplementor.operationImpl(); } } abstract class RemoteControl { // 持有一个实现化接口的引用 protected TV tv; public RemoteControl(TV tv) { this.tv = tv; } abstract void turnOn(); abstract void turnOff(); abstract void changeChannel(); } 实现抽象接口，创建RefinedAbstaction类 class RefinedAbstraction implements Abstraction { private Implementation implementation; public RefinedAbstraction(Implementation implementation) { this.implementation = implementation; } @Override public void operation() { // 委托给实现部分的具体类 implementation.operationImpl(); } } class BasicRemoteControl extends RemoteControl { public BasicRemoteControl(TV tv) { super(tv); } @Override void turnOn() { tv.on(); } @Override void turnOff() { tv.off(); } @Override void changeChannel() { tv.tuneChannel(); } } 客户端使用 // 客户端代码 public class Main { public static void main(String[] args) { // 创建具体实现化对象 Implementation implementationA = new ConcreteImplementationA(); Implementation implementationB = new ConcreteImplementationB(); // 使用扩充抽象化对象，将实现化对象传递进去 Abstraction abstractionA = new RefinedAbstraction(implementationA); Abstraction abstractionB = new RefinedAbstraction(implementationB); // 调用抽象化的操作 abstractionA.operation(); abstractionB.operation(); } } public class Main { public static void main(String[] args) { TV aTV = new ATV(); TV bTV = new BTV(); RemoteControl basicRemoteForA = new BasicRemoteControl(aTV); RemoteControl basicRemoteForB = new BasicRemoteControl(bTV); basicRemoteForA.turnOn(); // A TV is ON basicRemoteForA.changeChannel(); // Tuning A TV channel basicRemoteForA.turnOff(); // A TV is OFF basicRemoteForB.turnOn(); // B TV is ON basicRemoteForB.changeChannel(); // Tuning B TV channel basicRemoteForB.turnOff(); // B TV is OFF } } 使用场景 link桥接模式在日常开发中使用的并不是特别多，通常在以下情况下使用：\n当一个类存在两个独立变化的维度，而且这两个维度都需要进行扩展时，使用桥接模式可以使它们独立变化，减少耦合。\n不希望使用继承，或继承导致类爆炸性增长\n总体而言，桥接模式适用于那些有多个独立变化维度、需要灵活扩展的系统。\n本题代码 link import java.util.Scanner; // 步骤1: 创建实现化接口 interface TV { void turnOn(); void turnOff(); void switchChannel(); } // 步骤2: 创建具体实现化类 class SonyTV implements TV { @Override public void turnOn() { System.out.println(\"Sony TV is ON\"); } @Override public void turnOff() { System.out.println(\"Sony TV is OFF\"); } @Override public void switchChannel() { System.out.println(\"Switching Sony TV channel\"); } } class TCLTV implements TV { @Override public void turnOn() { System.out.println(\"TCL TV is ON\"); } @Override public void turnOff() { System.out.println(\"TCL TV is OFF\"); } @Override public void switchChannel() { System.out.println(\"Switching TCL TV channel\"); } } // 步骤3: 创建抽象化接口 abstract class RemoteControl { protected TV tv; public RemoteControl(TV tv) { this.tv = tv; } abstract void performOperation(); } // 步骤4: 创建扩充抽象化类 class PowerOperation extends RemoteControl { public PowerOperation(TV tv) { super(tv); } @Override void performOperation() { tv.turnOn(); } } class OffOperation extends RemoteControl { public OffOperation(TV tv) { super(tv); } @Override void performOperation() { tv.turnOff(); } } class ChannelSwitchOperation extends RemoteControl { public ChannelSwitchOperation(TV tv) { super(tv); } @Override void performOperation() { tv.switchChannel(); } } // 步骤5: 客户端代码 public class Main { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); int N = scanner.nextInt(); scanner.nextLine(); for (int i = 0; i \u003c N; i++) { String[] input = scanner.nextLine().split(\" \"); int brand = Integer.parseInt(input[0]); int operation = Integer.parseInt(input[1]); TV tv; if (brand == 0) { tv = new SonyTV(); } else { tv = new TCLTV(); } RemoteControl remoteControl; if (operation == 2) { remoteControl = new PowerOperation(tv); } else if (operation == 3) { remoteControl = new OffOperation(tv); } else { remoteControl = new ChannelSwitchOperation(tv); } remoteControl.performOperation(); } scanner.close(); } } 其他语言版本 linkC++ link #include #include #include // 步骤1: 创建实现化接口 class TV { public: virtual void turnOn() = 0; virtual void turnOff() = 0; virtual void switchChannel() = 0; }; // 步骤2: 创建具体实现化类 class SonyTV : public TV { public: void turnOn() override { std::cout \u003c\u003c \"Sony TV is ON\" \u003c\u003c std::endl; } void turnOff() override { std::cout \u003c\u003c \"Sony TV is OFF\" \u003c\u003c std::endl; } void switchChannel() override { std::cout \u003c\u003c \"Switching Sony TV channel\" \u003c\u003c std::endl; } }; class TCLTV : public TV { public: void turnOn() override { std::cout \u003c\u003c \"TCL TV is ON\" \u003c\u003c std::endl; } void turnOff() override { std::cout \u003c\u003c \"TCL TV is OFF\" \u003c\u003c std::endl; } void switchChannel() override { std::cout \u003c\u003c \"Switching TCL TV channel\" \u003c\u003c std::endl; } }; // 步骤3: 创建抽象化接口 class RemoteControl { protected: TV* tv; public: RemoteControl(TV* tv) : tv(tv) {} virtual void performOperation() = 0; }; // 步骤4: 创建扩充抽象化类 class PowerOperation : public RemoteControl { public: PowerOperation(TV* tv) : RemoteControl(tv) {} void performOperation() override { tv-\u003eturnOn(); } }; class OffOperation : public RemoteControl { public: OffOperation(TV* tv) : RemoteControl(tv) {} void performOperation() override { tv-\u003eturnOff(); } }; class ChannelSwitchOperation : public RemoteControl { public: ChannelSwitchOperation(TV* tv) : RemoteControl(tv) {} void performOperation() override { tv-\u003eswitchChannel(); } }; // 步骤5: 客户端代码 int main() { int N; std::cin \u003e\u003e N; std::cin.ignore(); for (int i = 0; i \u003c N; i++) { std::string input; std::getline(std::cin, input); std::istringstream iss(input); int brand, operation; iss \u003e\u003e brand \u003e\u003e operation; TV* tv; if (brand == 0) { tv = new SonyTV(); } else { tv = new TCLTV(); } RemoteControl* remoteControl; if (operation == 2) { remoteControl = new PowerOperation(tv); } else if (operation == 3) { remoteControl = new OffOperation(tv); } else { remoteControl = new ChannelSwitchOperation(tv); } remoteControl-\u003eperformOperation(); delete tv; delete remoteControl; } return 0; } Python link # 步骤1: 创建实现化接口 class TV: def turn_on(self): pass def turn_off(self): pass def switch_channel(self): pass # 步骤2: 创建具体实现化类 class SonyTV(TV): def turn_on(self): print(\"Sony TV is ON\") def turn_off(self): print(\"Sony TV is OFF\") def switch_channel(self): print(\"Switching Sony TV channel\") class TCLTV(TV): def turn_on(self): print(\"TCL TV is ON\") def turn_off(self): print(\"TCL TV is OFF\") def switch_channel(self): print(\"Switching TCL TV channel\") # 步骤3: 创建抽象化接口 class RemoteControl: def __init__(self, tv): self.tv = tv def perform_operation(self): pass # 步骤4: 创建扩充抽象化类 class PowerOperation(RemoteControl): def perform_operation(self): self.tv.turn_on() class OffOperation(RemoteControl): def perform_operation(self): self.tv.turn_off() class ChannelSwitchOperation(RemoteControl): def perform_operation(self): self.tv.switch_channel() # 步骤5: 客户端代码 if __name__ == \"__main__\": N = int(input()) for _ in range(N): input_data = input().split(\" \") brand = int(input_data[0]) operation = int(input_data[1]) if brand == 0: tv = SonyTV() else: tv = TCLTV() if operation == 2: remote_control = PowerOperation(tv) elif operation == 3: remote_control = OffOperation(tv) else: remote_control = ChannelSwitchOperation(tv) remote_control.perform_operation() Go link package main import \"fmt\" // 步骤1: 创建实现化接口 type TV interface { TurnOn() TurnOff() SwitchChannel() } // 步骤2: 创建具体实现化类 type SonyTV struct{} func (st *SonyTV) TurnOn() { fmt.Println(\"Sony TV is ON\") } func (st *SonyTV) TurnOff() { fmt.Println(\"Sony TV is OFF\") } func (st *SonyTV) SwitchChannel() { fmt.Println(\"Switching Sony TV channel\") } type TCLTV struct{} func (tt *TCLTV) TurnOn() { fmt.Println(\"TCL TV is ON\") } func (tt *TCLTV) TurnOff() { fmt.Println(\"TCL TV is OFF\") } func (tt *TCLTV) SwitchChannel() { fmt.Println(\"Switching TCL TV channel\") } // 步骤3: 创建抽象化接口 type RemoteControl interface { PerformOperation() } // 步骤4: 创建扩充抽象化类 type PowerOperation struct { tv TV } func (po *PowerOperation) PerformOperation() { po.tv.TurnOn() } type OffOperation struct { tv TV } func (oo *OffOperation) PerformOperation() { oo.tv.TurnOff() } type ChannelSwitchOperation struct { tv TV } func (cso *ChannelSwitchOperation) PerformOperation() { cso.tv.SwitchChannel() } // 步骤5: 客户端代码 func main() { var N int fmt.Scan(\u0026N) for i := 0; i \u003c N; i++ { var brand, operation int fmt.Scan(\u0026brand, \u0026operation) var tv TV if brand == 0 { tv = \u0026SonyTV{} } else { tv = \u0026TCLTV{} } var remoteControl RemoteControl switch operation { case 2: remoteControl = \u0026PowerOperation{tv: tv} case 3: remoteControl = \u0026OffOperation{tv: tv} case 4: remoteControl = \u0026ChannelSwitchOperation{tv: tv} } remoteControl.PerformOperation() } } "
            }
        );
    index.add(
            {
                id:  20 ,
                href: "\/docs\/dev\/23designpattern\/11.%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F\/",
                title: "11.组合模式",
                description: "组合模式是一种结构型设计模式，它**将对象组合成树状结构**来表示“部分-整体”的层次关系。组合模式使得客户端可以**统一处理单个对象和对象的组 合**，而无需区分它们的具体类型。",
                content: "需求 link【设计模式专题之组合模式】11-公司组织架构\n题目描述\n小明所在的公司内部有多个部门，每个部门下可能有不同的子部门或者员工。 请你设计一个组合模式来管理这些部门和员工，实现对公司组织结构的统一操作。部门和员工都具有一个通用的接口，可以获取他们的名称以及展示公司组织结构。 输入描述\n第一行是一个整数 N（1 \u003c= N \u003c= 100），表示后面有 N 行输入。 接下来的 N 行，每行描述一个部门或员工的信息。部门的信息格式为 D 部门名称，员工的信息格式为 E 员工名称，其中 D 或 E 表示部门或员工。 输出描述\n输出公司的组织结构，展示每个部门下的子部门和员工 输入示例 MyCompany 8 D HR E HRManager D Finance E AccountantA E AccountantB D IT E DeveloperA E DeveloperB 输出示例 Company Structure: MyCompany HR HRManager Finance AccountantA AccountantB IT DeveloperA DeveloperB 基本概念 link组合模式是一种结构型设计模式，它将对象组合成树状结构来表示“部分-整体”的层次关系。组合模式使得客户端可以统一处理单个对象和对象的组合，而无需区分它们的具体类型。\n基本结构 link组合模式包括下面几个角色：\n理解起来比较抽象，我们用“省份-城市”举个例子，省份中包含了多个城市，如果将之比喻成一个树形结构，城市就是叶子节点，它是省份的组成部分，而“省份”就是合成节点，可以包含其他城市，形成一个整体，省份和城市都是组件，它们都有一个共同的操作，比如获取信息。\nComponent组件： 组合模式的“根节点”，定义组合中所有对象的通用接口，可以是抽象类或接口。该类中定义了子类的共性内容。 Leaf叶子：实现了Component接口的叶子节点，表示组合中的叶子对象，叶子节点没有子节点。 Composite合成： 作用是存储子部件，并且在Composite中实现了对子部件的相关操作，比如添加、删除、获取子组件等。 通过组合模式，整个省份的获取信息操作可以一次性地执行，而无需关心省份中的具体城市。这样就实现了对国家省份和城市的管理和操作。\n简易实现 link // 组件接口 interface Component { void operation(); } // 叶子节点 class Leaf implements Component { @Override public void operation() { System.out.println(\"Leaf operation\"); } } // 组合节点：包含叶子节点的操作行为 class Composite implements Component { private List components = new ArrayList\u003c\u003e(); public void add(Component component) { components.add(component); } public void remove(Component component) { components.remove(component); } @Override public void operation() { System.out.println(\"Composite operation\"); for (Component component : components) { component.operation(); } } } // 客户端代码 public class Client { public static void main(String[] args) { // 创建叶子节点 Leaf leaf = new Leaf(); // 创建组合节点，并添加叶子节点 Composite composite = new Composite(); composite.add(leaf); composite.operation(); // 统一调用 } } 使用场景 link组合模式可以使得客户端可以统一处理单个对象和组合对象，无需区分它们之间的差异，比如在图形编辑器中，图形对象可以是简单的线、圆形，也可以是复杂的组合图形，这个时候可以对组合节点添加统一的操作。\n总的来说，组合模式适用于任何需要构建具有部分-整体层次结构的场景，比如组织架构管理、文件系统的文件和文件夹组织等。\n本题代码 link import java.util.ArrayList; import java.util.List; import java.util.Scanner; interface Component { void display(int depth); } class Department implements Component { private String name; private List children; public Department(String name) { this.name = name; this.children = new ArrayList\u003c\u003e(); } public void add(Component component) { children.add(component); } @Override public void display(int depth) { StringBuilder indent = new StringBuilder(); for (int i = 0; i \u003c depth; i++) { indent.append(\" \"); } System.out.println(indent + name); for (Component component : children) { component.display(depth + 1); } } } class Employee implements Component { private String name; public Employee(String name) { this.name = name; } @Override public void display(int depth) { StringBuilder indent = new StringBuilder(); for (int i = 0; i \u003c depth; i++) { indent.append(\" \"); } System.out.println(indent + \" \" + name); } } class Company { private String name; private Department root; public Company(String name) { this.name = name; this.root = new Department(name); } public void add(Component component) { root.add(component); } public void display() { System.out.println(\"Company Structure:\"); root.display(0); // 从 1 开始，以适配指定的缩进格式 } } public class Main { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); // 读取公司名称 String companyName = scanner.nextLine(); Company company = new Company(companyName); // 读取部门和员工数量 int n = scanner.nextInt(); scanner.nextLine(); // 读取部门和员工信息 for (int i = 0; i \u003c n; i++) { String type = scanner.next(); String name = scanner.nextLine().trim(); if (\"D\".equals(type)) { Department department = new Department(name); company.add(department); } else if (\"E\".equals(type)) { Employee employee = new Employee(name); company.add(employee); } } // 输出公司组织结构 company.display(); } } 其他语言版本 linkC++ link #include #include #include class Component { public: virtual void display(int depth) = 0; }; class Department : public Component { private: std::string name; std::vector children; public: Department(const std::string\u0026 name) : name(name) {} void add(Component* component) { children.push_back(component); } void display(int depth) override { std::string indent(depth * 2, ' '); std::cout \u003c\u003c indent \u003c\u003c name \u003c\u003c std::endl; for (Component* component : children) { component-\u003edisplay(depth + 1); } } }; class Employee : public Component { private: std::string name; public: Employee(const std::string\u0026 name) : name(name) {} void display(int depth) override { std::string indent((depth + 1) * 2, ' '); std::cout \u003c\u003c indent \u003c\u003c name \u003c\u003c std::endl; } }; class Company { private: std::string name; Department* root; public: Company(const std::string\u0026 name) : name(name), root(new Department(name)) {} void add(Component* component) { root-\u003eadd(component); } void display() { std::cout \u003c\u003c \"Company Structure:\" \u003c\u003c std::endl; root-\u003edisplay(0); } }; int main() { std::string companyName; std::getline(std::cin, companyName); Company company(companyName); int n; std::cin \u003e\u003e n; std::cin.ignore(); for (int i = 0; i \u003c n; i++) { std::string type, name; std::cin \u003e\u003e type; std::getline(std::cin \u003e\u003e std::ws, name); if (type == \"D\") { Department* department = new Department(name); company.add(department); } else if (type == \"E\") { Employee* employee = new Employee(name); company.add(employee); } } company.display(); return 0; } Python link from typing import List # 步骤1: 创建实现化接口 class Component: def display(self, depth: int): pass # 步骤2: 创建具体实现化类 class Department(Component): def __init__(self, name: str): self.name = name self.children: List[Component] = [] def add(self, component: Component): self.children.append(component) def display(self, depth: int): indent = \" \" * depth print(indent + self.name) for component in self.children: component.display(depth + 1) class Employee(Component): def __init__(self, name: str): self.name = name def display(self, depth: int): indent = \" \" * depth print(indent + \" \" + self.name) class Company: def __init__(self, name: str): self.name = name self.root = Department(name) def add(self, component: Component): self.root.add(component) def display(self): print(\"Company Structure:\") self.root.display(0) if __name__ == \"__main__\": # 读取公司名称 company_name = input() company = Company(company_name) # 读取部门和员工数量 n = int(input()) # 读取部门和员工信息 for _ in range(n): type_str, name = input().split(maxsplit=1) if type_str == \"D\": department = Department(name.strip()) company.add(department) elif type_str == \"E\": employee = Employee(name.strip()) company.add(employee) # 输出公司组织结构 company.display() Go link package main import ( \"bufio\" \"fmt\" \"os\" \"strings\" ) // 步骤1: 创建组件接口 type Component interface { display(depth int) } // 步骤2: 创建部门类实现组件接口 type Department struct { name string children []Component } func NewDepartment(name string) *Department { return \u0026Department{ name: name, children: make([]Component, 0), } } func (d *Department) add(component Component) { d.children = append(d.children, component) } func (d *Department) display(depth int) { indent := strings.Repeat(\" \", depth*2) fmt.Println(indent + d.name) for _, child := range d.children { child.display(depth + 1) } } // 步骤3: 创建员工类实现组件接口 type Employee struct { name string } func NewEmployee(name string) *Employee { return \u0026Employee{ name: name, } } func (e *Employee) display(depth int) { indent := strings.Repeat(\" \", depth*2) fmt.Println(indent + \" \" + e.name) } // 步骤4: 创建公司类 type Company struct { name string root *Department } func NewCompany(name string) *Company { return \u0026Company{ name: name, root: NewDepartment(name), } } func (c *Company) add(component Component) { c.root.add(component) } func (c *Company) display() { fmt.Println(\"Company Structure:\") c.root.display(0) // 从 0 开始，以适配指定的缩进格式 } func main() { scanner := bufio.NewScanner(os.Stdin) // 读取公司名称 scanner.Scan() companyName := scanner.Text() company := NewCompany(companyName) // 读取部门和员工数量 scanner.Scan() n := 0 fmt.Sscanf(scanner.Text(), \"%d\", \u0026n) // 读取部门和员工信息 var currentDepartment *Department for i := 0; i \u003c n; i++ { scanner.Scan() line := scanner.Text() fields := strings.Fields(line) if len(fields) \u003c 2 { continue } typeStr := fields[0] name := strings.Join(fields[1:], \" \") if typeStr == \"D\" { department := NewDepartment(name) company.add(department) currentDepartment = department } else if typeStr == \"E\" { employee := NewEmployee(name) currentDepartment.add(employee) } } // 输出公司组织结构 company.display() } "
            }
        );
    index.add(
            {
                id:  21 ,
                href: "\/docs\/dev\/23designpattern\/12.%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F\/",
                title: "12.享元模式",
                description: "享元模式是一种结构型设计模式，在享元模式中，对象被设计为可共享的，可以被多个上下文使用，而不必在每个上下文中都创建新的对象。",
                content: "需求 link【设计模式专题之享元模式】12-图形编辑器\n题目描述\n在一个图形编辑器中，用户可以绘制不同类型的图形，包括圆形（CIRCLE）、矩形（RECTANGLE）、三角形（TRIANGLE）等。现在，请你实现一个图形绘制程序，要求能够共享相同类型的图形对象，以减少内存占用。 输入描述 输入包含多行，每行表示一个绘制命令。每个命令包括两部分：\n图形类型（Circle、Rectangle 或 Triangle） 绘制的坐标位置（两个整数，分别表示 x 和 y） 输出描述\n对于每个绘制命令，输出相应图形被绘制的位置信息。如果图形是首次绘制，输出 “drawn at”，否则输出 “shared at”。 输入示例 CIRCLE 10 20 RECTANGLE 30 40 CIRCLE 15 25 TRIANGLE 5 15 CIRCLE 10 20 RECTANGLE 30 40 输出示例 CIRCLE drawn at (10, 20) RECTANGLE drawn at (30, 40) CIRCLE shared at (15, 25) TRIANGLE drawn at (5, 15) CIRCLE shared at (10, 20) RECTANGLE shared at (30, 40) 基础概念 link享元模式是一种结构型设计模式，在享元模式中，对象被设计为可共享的，可以被多个上下文使用，而不必在每个上下文中都创建新的对象。\n想要了解享元模式，就必须要区分什么是内部状态，什么是外部状态。\n内部状态是指那些可以被多个对象共享的状态，它存储在享元对象内部，并且对于所有享元对象都是相同的，这部分状态通常是不变的。\n而外部状态是享元对象依赖的、可能变化的部分。这部分状态不存储在享元对象内部，而是在使用享元对象时通过参数传递给对象。\n举个例子，图书馆中有很多相同的书籍，但每本书都可以被多个人借阅，图书馆里的书就是内部状态，人就是外部状态。\n再举个开发中的例子，假设我们在构建一个简单的图形编辑器，用户可以在画布上绘制不同类型的图形，而图形就是所有图形对象的内部状态（不变的），而图形的坐标位置就是图形对象的外部状态（变化的）。\n如果图形编辑器中有成千上万的图形对象，每个图形对象都独立创建并存储其内部状态，那么系统的内存占用可能会很大，在这种情况下，享元模式共享相同类型的图形对象，每种类型的图形对象只需创建一个共享实例，然后通过设置不同的坐标位置个性化每个对象，通过共享相同的内部状态，降低了对象的创建和内存占用成本。\n基本结构 link享元模式包括以下几个重要角色：\n享元接口Flyweight: 所有具体享元类的共享接口，通常包含对外部状态的操作。 具体享元类ConcreteFlyweight: 继承Flyweight类或实现享元接口，包含内部状态。 享元工厂类FlyweightFactory: 创建并管理享元对象，当用户请求时，提供已创建的实例或者创建一个。 客户端Client: 维护外部状态，在使用享元对象时，将外部状态传递给享元对象。 简易实现 link享元模式的实现通常涉及以下步骤：\n定义享元接口，接受外部状态作为参数并进行处理。 // 步骤 1: 定义享元接口 interface Flyweight { // 操作外部状态 void operation(String externalState); } 实现具体享元类, 存储内部状态。 // 步骤 2: 实现具体享元类 class ConcreteFlyweight implements Flyweight { private String intrinsicState; // 内部状态 public ConcreteFlyweight(String intrinsicState) { this.intrinsicState = intrinsicState; } @Override public void operation(String externalState) { System.out.println(\"Intrinsic State: \" + intrinsicState + \", External State: \" + externalState); } } 创建享元工厂类，创建并管理Flyweight对象，当用户请求一个Flyweight时，享元工厂会提供一个已经创建的实例或者创建一个。 class FlyweightFactory { private Map flyweights = new HashMap\u003c\u003e(); public Flyweight getFlyweight(String key) { if (!flyweights.containsKey(key)) { flyweights.put(key, new ConcreteFlyweight(key)); } return flyweights.get(key); } } 客户端使用享元模式 public class Main { public static void main(String[] args) { FlyweightFactory factory = new FlyweightFactory(); // 获取或创建享元对象，并传递外部状态 Flyweight flyweight1 = factory.getFlyweight(\"A\"); flyweight1.operation(\"External State 1\"); Flyweight flyweight2 = factory.getFlyweight(\"B\"); flyweight2.operation(\"External State 2\"); Flyweight flyweight3 = factory.getFlyweight(\"A\"); // 重复使用已存在的享元对象 flyweight3.operation(\"External State 3\"); } } 使用场景 link使用享元模式的关键在于包含大量相似对象，并且这些对象的内部状态可以共享。具体的应用场景包括文本编辑器，图形编辑器，游戏中的角色创建，这些对象的内部状态比较固定(外观，技能，形状)，但是外部状态变化比较大时，可以使用。\n本题代码 link import java.util.HashMap; import java.util.Map; import java.util.Scanner; enum ShapeType { CIRCLE, RECTANGLE, TRIANGLE } class Position { private int x; private int y; public Position(int x, int y) { this.x = x; this.y = y; } public int getX() { return x; } public int getY() { return y; } } interface Shape { void draw(Position position); } class ConcreteShape implements Shape { private ShapeType shapeType; public ConcreteShape(ShapeType shapeType) { this.shapeType = shapeType; } @Override public void draw(Position position) { System.out.println(shapeType + (isFirstTime ? \" drawn\" : \" shared\") + \" at (\" + position.getX() + \", \" + position.getY() + \")\"); } private boolean isFirstTime = true; public void setFirstTime(boolean firstTime) { isFirstTime = firstTime; } } class ShapeFactory { private Map shapes = new HashMap\u003c\u003e(); public Shape getShape(ShapeType type) { if (!shapes.containsKey(type)) { shapes.put(type, new ConcreteShape(type)); } return shapes.get(type); } } public class Main { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); ShapeFactory factory = new ShapeFactory(); while (scanner.hasNext()) { String command = scanner.nextLine(); processCommand(factory, command); } } private static void processCommand(ShapeFactory factory, String command) { String[] parts = command.split(\" \"); ShapeType type = ShapeType.valueOf(parts[0]); int x = Integer.parseInt(parts[1]); int y = Integer.parseInt(parts[2]); Shape shape = factory.getShape(type); shape.draw(new Position(x, y)); ((ConcreteShape) shape).setFirstTime(false); } } 其他语言版本 linkC++ link #include #include #include #include enum ShapeType { CIRCLE, RECTANGLE, TRIANGLE }; std::string shapeTypeToString(ShapeType type) { switch (type) { case CIRCLE: return \"CIRCLE\"; case RECTANGLE: return \"RECTANGLE\"; case TRIANGLE: return \"TRIANGLE\"; default: return \"UNKNOWN\"; } } class Position { private: int x; int y; public: Position(int x, int y) : x(x), y(y) {} int getX() const { return x; } int getY() const { return y; } }; class Shape { public: virtual void draw(const Position \u0026position) = 0; virtual ~Shape() {} }; class ConcreteShape : public Shape { private: ShapeType shapeType; bool isFirstTime; public: ConcreteShape(ShapeType shapeType) : shapeType(shapeType), isFirstTime(true) {} void draw(const Position \u0026position) override { std::cout \u003c\u003c shapeTypeToString(shapeType) \u003c\u003c (isFirstTime ? \" drawn\" : \" shared\") \u003c\u003c \" at (\" \u003c\u003c position.getX() \u003c\u003c \", \" \u003c\u003c position.getY() \u003c\u003c \")\\n\"; } void setFirstTime(bool firstTime) { isFirstTime = firstTime; } }; class ShapeFactory { private: std::unordered_map shapes; public: Shape *getShape(ShapeType type) { if (shapes.find(type) == shapes.end()) { shapes[type] = new ConcreteShape(type); } return shapes[type]; } ~ShapeFactory() { for (const auto \u0026entry : shapes) { delete entry.second; } } }; void processCommand(ShapeFactory \u0026factory, const std::string \u0026command); int main() { ShapeFactory factory; std::string command; while (std::getline(std::cin, command)) { processCommand(factory, command); } return 0; } void processCommand(ShapeFactory \u0026factory, const std::string \u0026command) { std::istringstream iss(command); std::string shapeTypeStr; int x, y; iss \u003e\u003e shapeTypeStr \u003e\u003e x \u003e\u003e y; ShapeType type; if (shapeTypeStr == \"CIRCLE\") { type = CIRCLE; } else if (shapeTypeStr == \"RECTANGLE\") { type = RECTANGLE; } else if (shapeTypeStr == \"TRIANGLE\") { type = TRIANGLE; } else { std::cerr \u003c\u003c \"Invalid shape type: \" \u003c\u003c shapeTypeStr \u003c\u003c std::endl; return; } Shape *shape = factory.getShape(type); shape-\u003edraw(Position(x, y)); dynamic_cast(shape)-\u003esetFirstTime(false); } Python link from enum import Enum from typing import Dict class ShapeType(Enum): CIRCLE = \"CIRCLE\" RECTANGLE = \"RECTANGLE\" TRIANGLE = \"TRIANGLE\" class Position: def __init__(self, x, y): self.x = x self.y = y class Shape: def draw(self, position: Position): pass class ConcreteShape(Shape): def __init__(self, shape_type: ShapeType): self.shape_type = shape_type self.is_first_time = True def draw(self, position: Position): print(f\"{self.shape_type.value}{' drawn' if self.is_first_time else ' shared'} at ({position.x}, {position.y})\") def set_first_time(self, first_time: bool): self.is_first_time = first_time class ShapeFactory: def __init__(self): self.shapes: Dict[ShapeType, Shape] = {} def get_shape(self, shape_type: ShapeType) -\u003e Shape: if shape_type not in self.shapes: self.shapes[shape_type] = ConcreteShape(shape_type) return self.shapes[shape_type] def process_command(factory: ShapeFactory, command: str): parts = command.split(\" \") shape_type = ShapeType(parts[0]) x = int(parts[1]) y = int(parts[2]) shape = factory.get_shape(shape_type) shape.draw(Position(x, y)) shape.set_first_time(False) if __name__ == \"__main__\": factory = ShapeFactory() while True: try: command = input() process_command(factory, command) except EOFError: break Go link package main import ( \"bufio\" \"fmt\" \"os\" \"strconv\" \"strings\" ) type ShapeType int const ( CIRCLE ShapeType = iota RECTANGLE TRIANGLE ) var shapeTypeStrings = [...]string{ \"CIRCLE\", \"RECTANGLE\", \"TRIANGLE\", } type Position struct { X, Y int } type Shape interface { Draw(Position) } type ConcreteShape struct { ShapeType ShapeType IsFirstTime bool } func NewConcreteShape(shapeType ShapeType) *ConcreteShape { return \u0026ConcreteShape{ ShapeType: shapeType, IsFirstTime: true, } } func (s *ConcreteShape) Draw(position Position) { fmt.Printf(\"%s %s at (%d, %d)\\n\", s.ShapeType.String(), s.getTimeDescription(), position.X, position.Y) } func (s *ConcreteShape) setFirstTime(firstTime bool) { s.IsFirstTime = firstTime } func (s *ConcreteShape) getTimeDescription() string { if s.IsFirstTime { return \"drawn\" } return \"shared\" } func (st ShapeType) String() string { if st \u003e= 0 \u0026\u0026 int(st) \u003c len(shapeTypeStrings) { return shapeTypeStrings[st] } return \"UNKNOWN\" } type ShapeFactory struct { shapes map[ShapeType]Shape } func NewShapeFactory() *ShapeFactory { return \u0026ShapeFactory{ shapes: make(map[ShapeType]Shape), } } func (f *ShapeFactory) getShape(shapeType ShapeType) Shape { if _, exists := f.shapes[shapeType]; !exists { f.shapes[shapeType] = NewConcreteShape(shapeType) } return f.shapes[shapeType] } func main() { var factory = NewShapeFactory() scanner := bufio.NewScanner(os.Stdin) for scanner.Scan() { command := scanner.Text() processCommand(factory, command) } if err := scanner.Err(); err != nil { fmt.Println(\"Error reading standard input:\", err) } } func processCommand(factory *ShapeFactory, command string) { parts := splitCommand(command) shapeType := ShapeTypeFromString(parts[0]) x, _ := strconv.Atoi(parts[1]) y, _ := strconv.Atoi(parts[2]) shape := factory.getShape(shapeType) shape.Draw(Position{X: x, Y: y}) concreteShape, ok := shape.(*ConcreteShape) if ok { concreteShape.setFirstTime(false) } } func splitCommand(command string) []string { return splitWithoutEmpty(command, ' ') } func splitWithoutEmpty(s string, sep byte) []string { parts := strings.FieldsFunc(s, func(r rune) bool { return r == rune(sep) }) return parts } func ShapeTypeFromString(s string) ShapeType { for i, str := range shapeTypeStrings { if str == s { return ShapeType(i) } } return CIRCLE } "
            }
        );
    index.add(
            {
                id:  22 ,
                href: "\/docs\/dev\/23designpattern\/13.%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F\/",
                title: "13.观察者模式",
                description: "观察者模式（发布-订阅模式）属于行为型模式，定义了一种一对多的依赖关系，让多个观察者对象同时监听一个主题对象，当主题对象的状态发生变化时，所有依赖于它的观察者都得到通知并被自动更新。",
                content: "需求 link【设计模式专题之观察者模式】13. 时间观察者\n题目描述\n小明所在的学校有一个时钟（主题），每到整点时，它就会通知所有的学生（观察者）当前的时间，请你使用观察者模式实现这个时钟通知系统。 注意点：时间从 0 开始，并每隔一个小时更新一次。 输入描述\n输入的第一行是一个整数 N（1 ≤ N ≤ 20），表示学生的数量。 接下来的 N 行，每行包含一个字符串，表示学生的姓名。 最后一行是一个整数，表示时钟更新的次数。 输出描述\n对于每一次时钟更新，输出每个学生的姓名和当前的时间。 输入示例 2 Alice Bob 3 输出示例 Alice 1 Bob 1 Alice 2 Bob 2 Alice 3 Bob 3 提示信息\n初始时钟时间为0（12:00 AM）。 第一次更新后，时钟变为1（1:00 AM），然后通知每个学生，输出学生名称和时钟点数。 第二次更新后，时钟变为2（2:00 AM），然后再次通知每个学生，输出学生名称和时钟点数 第三次更新后，时钟变为3（3:00 AM），然后再次通知每个学生，输出学生名称和时钟点数。 什么是观察者模式 link观察者模式（发布-订阅模式）属于行为型模式，定义了一种一对多的依赖关系，让多个观察者对象同时监听一个主题对象，当主题对象的状态发生变化时，所有依赖于它的观察者都得到通知并被自动更新。\n观察者模式依赖两个模块：\nSubject(主题)：也就是被观察的对象，它可以维护一组观察者，当主题本身发生改变时就会通知观察者。 Observer(观察者)：观察主题的对象，当“被观察”的主题发生变化时，观察者就会得到通知并执行相应的处理。 使用观察者模式有很多好处，比如说观察者模式将主题和观察者之间的关系解耦，主题只需要关注自己的状态变化，而观察者只需要关注在主题状态变化时需要执行的操作，两者互不干扰，并且由于观察者和主题是相互独立的，可以轻松的增加和删除观察者，这样实现的系统更容易扩展和维护。\n观察者模式的结构 link观察者模式依赖主题和观察者，但是一般有4个组成部分：\n主题Subject， 一般会定义成一个接口，提供方法用于注册、删除和通知观察者，通常也包含一个状态，当状态发生改变时，通知所有的观察者。 观察者Observer: 观察者也需要实现一个接口，包含一个更新方法，在接收主题通知时执行对应的操作。 具体主题ConcreteSubject: 主题的具体实现, 维护一个观察者列表，包含了观察者的注册、删除和通知方法。 具体观察者ConcreteObserver: 观察者接口的具体实现，每个具体观察者都注册到具体主题中，当主题状态变化并通知到具体观察者，具体观察者进行处理。 观察者模式的基本实现 link根据上面的类图，我们可以写出观察者模式的基本实现\n// 主题接口 （主题） interface Subject { // 注册观察者 void registerObserver(Observer observer); // 移除观察者 void removeObserver(Observer observer); // 通知观察者 void notifyObservers(); } // 观察者接口 (观察者) interface Observer { // 更新方法 void update(String message); } // 具体主题实现 class ConcreteSubject implements Subject { // 观察者列表 private List observers = new ArrayList\u003c\u003e(); // 状态 private String state; // 注册观察者 @Override public void registerObserver(Observer observer) { observers.add(observer); } // 移除观察者 @Override public void removeObserver(Observer observer) { observers.remove(observer); } // 通知观察者 @Override public void notifyObservers() { for (Observer observer : observers) { // 观察者根据传递的信息进行处理 observer.update(state); } } // 更新状态 public void setState(String state) { this.state = state; notifyObservers(); } } // 具体观察者实现 class ConcreteObserver implements Observer { // 更新方法 @Override public void update(String message) { } } 什么时候使用观察者模式 link观察者模式特别适用于一个对象的状态变化会影响到其他对象，并且希望这些对象在状态变化时能够自动更新的情况。 比如说在图形用户界面中，按钮、滑动条等组件的状态变化可能需要通知其他组件更新，这使得观察者模式被广泛应用于GUI框架，比如Java的Swing框架。\n此外，观察者模式在前端开发和分布式系统中也有应用，比较典型的例子是前端框架Vue, 当数据发生变化时，视图会自动更新。而在分布式系统中，观察者模式可以用于实现节点之间的消息通知机制，节点的状态变化将通知其他相关节点。\n本题代码 link import java.util.ArrayList; import java.util.List; import java.util.Scanner; // 观察者接口 interface Observer { void update(int hour); } // 主题接口 interface Subject { void registerObserver(Observer observer); void removeObserver(Observer observer); void notifyObservers(); } // 具体主题实现 class Clock implements Subject { private List observers = new ArrayList\u003c\u003e(); private int hour = 0; @Override public void registerObserver(Observer observer) { observers.add(observer); } @Override public void removeObserver(Observer observer) { observers.remove(observer); } @Override public void notifyObservers() { for (Observer observer : observers) { observer.update(hour); } } public void tick() { hour = (hour + 1) % 24; // 模拟时间的推移 notifyObservers(); } } // 具体观察者实现 class Student implements Observer { private String name; public Student(String name) { this.name = name; } @Override public void update(int hour) { System.out.println(name + \" \" + hour); } } public class Main { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); // 读取学生数量 int N = scanner.nextInt(); // 创建时钟 Clock clock = new Clock(); // 注册学生观察者 for (int i = 0; i \u003c N; i++) { String studentName = scanner.next(); clock.registerObserver(new Student(studentName)); } // 读取时钟更新次数 int updates = scanner.nextInt(); // 模拟时钟每隔一个小时更新一次 for (int i = 0; i \u003c updates; i++) { clock.tick(); } } } 其他语言版本 linkC++ link #include #include #include // 观察者接口 class Observer { public: virtual void update(int hour) = 0; virtual ~Observer() = default; // 添加虚析构函数 }; // 主题接口 class Subject { public: virtual void registerObserver(Observer* observer) = 0; virtual void removeObserver(Observer* observer) = 0; virtual void notifyObservers() = 0; virtual ~Subject() = default; // 添加虚析构函数 }; // 具体主题实现 class Clock : public Subject { private: std::vector observers; int hour; public: Clock() : hour(0) {} void registerObserver(Observer* observer) override { observers.push_back(observer); } void removeObserver(Observer* observer) override { auto it = std::find(observers.begin(), observers.end(), observer); if (it != observers.end()) { observers.erase(it); } } void notifyObservers() override { for (Observer* observer : observers) { observer-\u003eupdate(hour); } } // 添加获取观察者的函数 const std::vector\u0026 getObservers() const { return observers; } void tick() { hour = (hour + 1) % 24; // 模拟时间的推移 notifyObservers(); } }; // 具体观察者实现 class Student : public Observer { private: std::string name; public: Student(const std::string\u0026 name) : name(name) {} void update(int hour) override { std::cout \u003c\u003c name \u003c\u003c \" \" \u003c\u003c hour \u003c\u003c std::endl; } }; int main() { // 读取学生数量 int N; std::cin \u003e\u003e N; // 创建时钟 Clock clock; // 注册学生观察者 for (int i = 0; i \u003c N; i++) { std::string studentName; std::cin \u003e\u003e studentName; clock.registerObserver(new Student(studentName)); } // 读取时钟更新次数 int updates; std::cin \u003e\u003e updates; // 模拟时钟每隔一个小时更新一次 for (int i = 0; i \u003c updates; i++) { clock.tick(); } // 释放动态分配的观察者对象 for (Observer* observer : clock.getObservers()) { delete observer; } return 0; } Python link from typing import List # 观察者接口 class Observer: def update(self, hour: int): pass # 主题接口 class Subject: def register_observer(self, observer: Observer): pass def remove_observer(self, observer: Observer): pass def notify_observers(self): pass # 具体主题实现 class Clock(Subject): def __init__(self): self.observers: List[Observer] = [] self.hour = 0 def register_observer(self, observer: Observer): self.observers.append(observer) def remove_observer(self, observer: Observer): self.observers.remove(observer) def notify_observers(self): for observer in self.observers: observer.update(self.hour) def tick(self): self.hour = (self.hour + 1) % 24 # 模拟时间的推移 self.notify_observers() # 具体观察者实现 class Student(Observer): def __init__(self, name: str): self.name = name def update(self, hour: int): print(f\"{self.name} {hour}\") if __name__ == \"__main__\": # 读取学生数量 N = int(input()) # 创建时钟 clock = Clock() # 注册学生观察者 for _ in range(N): student_name = input() clock.register_observer(Student(student_name)) # 读取时钟更新次数 updates = int(input()) # 模拟时钟每隔一个小时更新一次 for _ in range(updates): clock.tick() GO link package main import ( \"fmt\" ) // 观察者接口 type Observer interface { Update(hour int) } // 主题接口 type Subject interface { RegisterObserver(observer Observer) RemoveObserver(observer Observer) NotifyObservers() } // 具体主题实现 type Clock struct { observers []Observer hour int } func (c *Clock) RegisterObserver(observer Observer) { c.observers = append(c.observers, observer) } func (c *Clock) RemoveObserver(observer Observer) { for i, obs := range c.observers { if obs == observer { c.observers = append(c.observers[:i], c.observers[i+1:]...) break } } } func (c *Clock) NotifyObservers() { for _, observer := range c.observers { observer.Update(c.hour) } } func (c *Clock) Tick() { c.hour = (c.hour + 1) % 24 // 模拟时间的推移 c.NotifyObservers() } // 具体观察者实现 type Student struct { name string } func NewStudent(name string) *Student { return \u0026Student{name: name} } func (s *Student) Update(hour int) { fmt.Println(s.name, hour) } func main() { // 读取学生数量 var N int fmt.Scan(\u0026N) // 创建时钟 clock := \u0026Clock{} // 注册学生观察者 for i := 0; i \u003c N; i++ { var studentName string fmt.Scan(\u0026studentName) clock.RegisterObserver(NewStudent(studentName)) } // 读取时钟更新次数 var updates int fmt.Scan(\u0026updates) // 模拟时钟每隔一个小时更新一次 for i := 0; i \u003c updates; i++ { clock.Tick() } } "
            }
        );
    index.add(
            {
                id:  23 ,
                href: "\/docs\/dev\/23designpattern\/14.%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F\/",
                title: "14.策略模式",
                description: "策略模式是一种行为型设计模式，它定义了一系列算法（这些算法完成的是相同的工作，只是实现不同），并将每个算法封装起来，使它们可以相互替换，而且算法的变化不会影响使用算法的客户。",
                content: "需求 link【设计模式专题之策略模式】14. 超市打折\n题目描述\n小明家的超市推出了不同的购物优惠策略，你可以根据自己的需求选择不同的优惠方式。其中，有两种主要的优惠策略： 九折优惠策略：原价的90%。 满减优惠策略：购物满一定金额时，可以享受相应的减免优惠。 具体的满减规则如下： 满100元减5元 满150元减15元 满200元减25元 满300元减40元 请你设计一个购物优惠系统，用户输入商品的原价和选择的优惠策略编号，系统输出计算后的价格。 输入描述\n输入的第一行是一个整数 N（1 ≤ N ≤ 20），表示需要计算优惠的次数。 接下来的 N 行，每行输入两个整数，第一个整数M( 0 \u003c M \u003c 400) 表示商品的价格, 第二个整数表示优惠策略，1表示九折优惠策略，2表示满减优惠策略 输入示例 4 100 1 200 2 300 1 300 2 输出示例 90 175 270 260 什么是策略模式 link策略模式是一种行为型设计模式，它定义了一系列算法（这些算法完成的是相同的工作，只是实现不同），并将每个算法封装起来，使它们可以相互替换，而且算法的变化不会影响使用算法的客户。\n举个例子，电商网站对于商品的折扣策略有不同的算法，比如新用户满减优惠，不同等级会员的打折情况不同，这种情况下会产生大量的if-else语句, 并且如果优惠政策修改时，还需要修改原来的代码，不符合开闭原则。\n这就可以将不同的优惠算法封装成独立的类来避免大量的条件语句，如果新增优惠算法，可以添加新的策略类来实现，客户端在运行时选择不同的具体策略，而不必修改客户端代码改变优惠策略。\n基本结构 link策略模式包含下面几个结构：\n策略类Strategy: 定义所有支持的算法的公共接口。 具体策略类ConcreteStrategy: 实现了策略接口，提供具体的算法实现。 上下文类Context: 包含一个策略实例，并在需要时调用策略对象的方法。 简单实现 link下面是一个简单的策略模式的基本实现:\n// 1. 抽象策略抽象类 abstract class Strategy { // 抽象方法 public abstract void algorithmInterface(); } // 2. 具体策略类1 class ConcreteStrategyA extends Strategy { @Override public void algorithmInterface() { System.out.println(\"Strategy A\"); // 具体的策略1执行逻辑 } } // 3. 具体策略类2 class ConcreteStrategyB extends Strategy { @Override public void algorithmInterface() { System.out.println(\"Strategy B\"); // 具体的策略2执行逻辑 } } // 4. 上下文类 class Context { private Strategy strategy; // 设置具体的策略 public Context(Strategy strategy) { this.strategy = strategy; } // 执行策略 public void contextInterface() { strategy.algorithmlnterface(); } } // 5. 客户端代码 public class Main{ public static void main(String[] args) { // 创建上下文对象，并设置具体的策略 Context contextA = new Context(new ConcreteStrategyA()); // 执行策略 contextA.contextInterface(); Context contextB = new Context(new ConcreteStrategyB()); contextB.contextInterface();u } } 使用场景 link那什么时候可以考虑使用策略模式呢？\n当一个系统根据业务场景需要动态地在几种算法中选择一种时，可以使用策略模式。例如，根据用户的行为选择不同的计费策略。\n当代码中存在大量条件判断，条件判断的区别仅仅在于行为，也可以通过策略模式来消除这些条件语句。\n在已有的工具库中，Java 标准库中的 Comparator 接口就使用了策略模式，通过实现这个接口，可以创建不同的比较器（指定不同的排序策略）来满足不同的排序需求。\n本题代码 link import java.util.Scanner; // 抽象购物优惠策略接口 interface DiscountStrategy { int applyDiscount(int originalPrice); } // 九折优惠策略 class DiscountStrategy1 implements DiscountStrategy { @Override public int applyDiscount(int originalPrice) { return (int) Math.round(originalPrice * 0.9); } } // 满减优惠策略 class DiscountStrategy2 implements DiscountStrategy { private int[] thresholds = {100, 150, 200, 300}; private int[] discounts = {5, 15, 25, 40}; @Override public int applyDiscount(int originalPrice) { for (int i = thresholds.length - 1; i \u003e= 0; i--) { if (originalPrice \u003e= thresholds[i]) { return originalPrice - discounts[i]; } } return originalPrice; } } // 上下文类 class DiscountContext { private DiscountStrategy discountStrategy; public void setDiscountStrategy(DiscountStrategy discountStrategy) { this.discountStrategy = discountStrategy; } public int applyDiscount(int originalPrice) { return discountStrategy.applyDiscount(originalPrice); } } public class Main { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); // 读取需要计算优惠的次数 int N = Integer.parseInt(scanner.nextLine()); for (int i = 0; i \u003c N; i++) { // 读取商品价格和优惠策略 String[] input = scanner.nextLine().split(\" \"); int M = Integer.parseInt(input[0]); int strategyType = Integer.parseInt(input[1]); // 根据优惠策略设置相应的打折策略 DiscountStrategy discountStrategy; switch (strategyType) { case 1: discountStrategy = new DiscountStrategy1(); break; case 2: discountStrategy = new DiscountStrategy2(); break; default: // 处理未知策略类型 System.out.println(\"Unknown strategy type\"); return; } // 设置打折策略 DiscountContext context = new DiscountContext(); context.setDiscountStrategy(discountStrategy); // 应用打折策略并输出优惠后的价格 int discountedPrice = context.applyDiscount(M); System.out.println(discountedPrice); } } } 其他语言版本 linkJava link使用策略枚举类实现 import java.util.Scanner; interface Strategy { void preferentialMethod(int price); } //策略枚举类 enum DiscountStrategy implements Strategy { STRATEGY1 { @Override public void preferentialMethod(int price) { double discountedPrice = 0.9 * price; System.out.println((int) discountedPrice); } }, STRATEGY2 { @Override public void preferentialMethod(int price) { int[][] discountRules = { {300, 40}, {200, 25}, {150, 15}, {100, 5} }; for (int[] rule : discountRules) { if (price \u003e= rule[0]) { price -= rule[1]; break; } } System.out.println(price); } }; public static DiscountStrategy fromType(int type) { switch (type) { case 1: return STRATEGY1; case 2: return STRATEGY2; default: throw new IllegalArgumentException(\"无效选择，请输入1或2\"); } } } class Context { private Strategy strategy; public Context(Strategy strategy) { this.strategy = strategy; } public void executeStrategy(int price) { strategy.preferentialMethod(price); } } public class Main { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); try { int num = scanner.nextInt(); scanner.nextLine(); for (int i = 0; i \u003c num; i++) { try { String input = scanner.nextLine(); String[] parts = input.split(\" \"); if (parts.length != 2) { System.out.println(\"输入错误！\"); continue; } int price = Integer.parseInt(parts[0]); int type = Integer.parseInt(parts[1]); DiscountStrategy strategy = DiscountStrategy.fromType(type); Context context = new Context(strategy); context.executeStrategy(price); } catch (NumberFormatException e) { System.out.println(\"输入格式错误，请输入有效的价格和类型！\"); } catch (IllegalArgumentException e) { System.out.println(e.getMessage()); } } } catch (Exception e) { System.out.println(\"An error occurred: \" + e.getMessage()); } finally { scanner.close(); } } } C++ link #include #include #include // 抽象购物优惠策略接口 class DiscountStrategy { public: virtual int applyDiscount(int originalPrice) = 0; virtual ~DiscountStrategy() = default; // 添加虚析构函数 }; // 九折优惠策略 class DiscountStrategy1 : public DiscountStrategy { public: int applyDiscount(int originalPrice) override { return static_cast(std::round(originalPrice * 0.9)); } }; // 满减优惠策略 class DiscountStrategy2 : public DiscountStrategy { private: int thresholds[4] = {100, 150, 200, 300}; int discounts[4] = {5, 15, 25, 40}; public: int applyDiscount(int originalPrice) override { for (int i = sizeof(thresholds) / sizeof(thresholds[0]) - 1; i \u003e= 0; i--) { if (originalPrice \u003e= thresholds[i]) { return originalPrice - discounts[i]; } } return originalPrice; } }; // 上下文类 class DiscountContext { private: DiscountStrategy* discountStrategy; public: void setDiscountStrategy(DiscountStrategy* discountStrategy) { this-\u003ediscountStrategy = discountStrategy; } int applyDiscount(int originalPrice) { return discountStrategy-\u003eapplyDiscount(originalPrice); } }; int main() { // 读取需要计算优惠的次数 int N; std::cin \u003e\u003e N; std::cin.ignore(); // 忽略换行符 for (int i = 0; i \u003c N; i++) { // 读取商品价格和优惠策略 int M, strategyType; std::cin \u003e\u003e M \u003e\u003e strategyType; // 根据优惠策略设置相应的打折策略 DiscountStrategy* discountStrategy; switch (strategyType) { case 1: discountStrategy = new DiscountStrategy1(); break; case 2: discountStrategy = new DiscountStrategy2(); break; default: // 处理未知策略类型 std::cout \u003c\u003c \"Unknown strategy type\" \u003c\u003c std::endl; return 1; } // 设置打折策略 DiscountContext context; context.setDiscountStrategy(discountStrategy); // 应用打折策略并输出优惠后的价格 int discountedPrice = context.applyDiscount(M); std::cout \u003c\u003c discountedPrice \u003c\u003c std::endl; // 释放动态分配的打折策略对象 delete discountStrategy; } return 0; } Python link class DiscountStrategy: def apply_discount(self, original_price): pass class DiscountStrategy1(DiscountStrategy): def apply_discount(self, original_price): return round(original_price * 0.9) class DiscountStrategy2(DiscountStrategy): def __init__(self): self.thresholds = [100, 150, 200, 300] self.discounts = [5, 15, 25, 40] def apply_discount(self, original_price): for threshold, discount in zip(reversed(self.thresholds), reversed(self.discounts)): if original_price \u003e= threshold: return original_price - discount return original_price class DiscountContext: def __init__(self): self.discount_strategy = None def set_discount_strategy(self, discount_strategy): self.discount_strategy = discount_strategy def apply_discount(self, original_price): return self.discount_strategy.apply_discount(original_price) if __name__ == \"__main__\": # 读取需要计算优惠的次数 N = int(input()) for _ in range(N): # 读取商品价格和优惠策略 input_data = input().split(\" \") M = int(input_data[0]) strategy_type = int(input_data[1]) # 根据优惠策略设置相应的打折策略 if strategy_type == 1: discount_strategy = DiscountStrategy1() elif strategy_type == 2: discount_strategy = DiscountStrategy2() else: # 处理未知策略类型 print(\"Unknown strategy type\") break # 设置打折策略 context = DiscountContext() context.set_discount_strategy(discount_strategy) # 应用打折策略并输出优惠后的价格 discounted_price = context.apply_discount(M) print(discounted_price) Go link package main import \"fmt\" // 抽象购物优惠策略接口 type DiscountStrategy interface { applyDiscount(originalPrice int) int } // 九折优惠策略 type DiscountStrategy1 struct{} func (d *DiscountStrategy1) applyDiscount(originalPrice int) int { return int(float64(originalPrice) * 0.9) } // 满减优惠策略 type DiscountStrategy2 struct { thresholds []int discounts []int } func (d *DiscountStrategy2) applyDiscount(originalPrice int) int { for i := len(d.thresholds) - 1; i \u003e= 0; i-- { if originalPrice \u003e= d.thresholds[i] { return originalPrice - d.discounts[i] } } return originalPrice } // 上下文类 type DiscountContext struct { discountStrategy DiscountStrategy } func (d *DiscountContext) setDiscountStrategy(discountStrategy DiscountStrategy) { d.discountStrategy = discountStrategy } func (d *DiscountContext) applyDiscount(originalPrice int) int { return d.discountStrategy.applyDiscount(originalPrice) } func main() { // 读取需要计算优惠的次数 var N int fmt.Scan(\u0026N) for i := 0; i \u003c N; i++ { // 读取商品价格和优惠策略 var M, strategyType int fmt.Scan(\u0026M, \u0026strategyType) // 根据优惠策略设置相应的打折策略 var discountStrategy DiscountStrategy switch strategyType { case 1: discountStrategy = \u0026DiscountStrategy1{} case 2: discountStrategy = \u0026DiscountStrategy2{ thresholds: []int{100, 150, 200, 300}, discounts: []int{5, 15, 25, 40}, } default: // 处理未知策略类型 fmt.Println(\"Unknown strategy type\") return } // 设置打折策略 context := \u0026DiscountContext{} context.setDiscountStrategy(discountStrategy) // 应用打折策略并输出优惠后的价格 discountedPrice := context.applyDiscount(M) fmt.Println(discountedPrice) } } "
            }
        );
    index.add(
            {
                id:  24 ,
                href: "\/docs\/dev\/23designpattern\/15.%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F\/",
                title: "15.命令模式",
                description: "命令模式是一种行为型设计模式，其允许**将请求封装成一个对象**(命令对象，包含执行操作所需的所有信息)，**并将命令对象按照一定的顺序存储在队列中，然后再逐一调用执行，这些命令也可以支持反向操作，进行撤销和重做。**",
                content: "需求 link【设计模式专题之命令模式】15-自助点餐机\n题目描述\n小明去奶茶店买奶茶，他可以通过在自助点餐机上来点不同的饮品，请你使用命令模式设计一个程序，模拟这个自助点餐系统的功能。 输入描述\n第一行是一个整数 n（1 ≤ n ≤ 100），表示点单的数量。 接下来的 n 行，每行包含一个字符串，表示点餐的饮品名称。 输出描述\n输出执行完所有点单后的制作情况，每行输出一种饮品的制作情况。如果制作完成，输出 “XXX is ready!\"，其中 XXX 表示饮品名称。 输入示例 4 MilkTea Coffee Cola MilkTea 输出示例 MilkTea is ready! Coffee is ready! Cola is ready! MilkTea is ready! 基本概念 link命令模式是一种行为型设计模式，其允许将请求封装成一个对象(命令对象，包含执行操作所需的所有信息)，并将命令对象按照一定的顺序存储在队列中，然后再逐一调用执行，这些命令也可以支持反向操作，进行撤销和重做。\n这样一来，发送者只需要触发命令就可以完成操作，不需要知道接受者的具体操作，从而实现两者间的解耦。\n举个现实中的应用场景，遥控器可以控制不同的设备，在命令模式中，可以假定每个按钮都是一个命令对象，包含执行特定操作的命令，不同设备对同一命令的具体操作也不同，这样就可以方便的添加设备和命令对象。\n基本结构 link命令模式包含以下几个基本角色：\n命令接口Command：接口或者抽象类，定义执行操作的接口。 具体命令类ConcreteCommand: 实现命令接口，执行具体操作，在调用execute方法时使“接收者对象”根据命令完成具体的任务，比如遥控器中的“开机”，“关机”命令。 接收者类Receiver: 接受并执行命令的对象，可以是任何对象，遥控器可以控制空调，也可以控制电视机，电视机和空调负责执行具体操作，是接收者。 调用者类Invoker: 发起请求的对象，有一个将命令作为参数传递的方法。它不关心命令的具体实现，只负责调用命令对象的 execute() 方法来传递请求，在本例中，控制遥控器的“人”就是调用者。 客户端：创建具体的命令对象和接收者对象，然后将它们组装起来。 简易实现 link 定义执行操作的接口：包含一个execute方法。有的时候还会包括unExecute方法，表示撤销命令。 public interface Command { void execute(); } 实现命令接口，执行具体的操作。 public class ConcreteCommand implements Command { // 接收者对象 private Receiver receiver; public ConcreteCommand(Receiver receiver) { this.receiver = receiver; } @Override public void execute() { // 调用接收者相应的操作 receiver.action(); } } 定义接受者类，知道如何实施与执行一个请求相关的操作。 public class Receiver { public void action() { // 执行操作 } } 定义调用者类，调用命令对象执行请求。 public class Invoker { private Command command; public Invoker(Command command) { this.command = command; } public void executeCommand() { command.execute(); } } 调用者类中可以维护一个命令队列或者“撤销栈”，以支持批处理和撤销命令。\nimport java.util.LinkedList; import java.util.Queue; import java.util.Stack; // 调用者类：命令队列和撤销请求 class Invoker { private Queue commandQueue; // 命令队列 private Stack undoStack; // 撤销栈 public Invoker() { this.commandQueue = new LinkedList\u003c\u003e(); this.undoStack = new Stack\u003c\u003e(); } // 设置命令并执行 public void setAndExecuteCommand(Command command) { command.execute(); commandQueue.offer(command); undoStack.push(command); } // 撤销上一个命令 public void undoLastCommand() { if (!undoStack.isEmpty()) { Command lastCommand = undoStack.pop(); lastCommand.undo(); // 需要命令类实现 undo 方法 commandQueue.remove(lastCommand); } else { System.out.println(\"No command to undo.\"); } } // 执行命令队列中的所有命令 public void executeCommandsInQueue() { for (Command command : commandQueue) { command.execute(); } } } 客户端使用，创建具体的命令对象和接收者对象，然后进行组装。 public class Main { public static void main(String[] args) { Receiver receiver = new Receiver(); Command command = new ConcreteCommand(receiver); Invoker invoker = new Invoker(command); invoker.executeCommand(); } } 优缺点和使用场景 link命令模式在需要将请求封装成对象、支持撤销和重做、设计命令队列等情况下，都是一个有效的设计模式。\n撤销操作： 需要支持撤销操作，命令模式可以存储历史命令，轻松实现撤销功能。 队列请求： 命令模式可以将请求排队，形成一个命令队列，依次执行命令。 可扩展性： 可以很容易地添加新的命令类和接收者类，而不影响现有的代码。新增命令不需要修改现有代码，符合开闭原则。 但是对于每个命令，都会有一个具体命令类，这可能导致类的数量急剧增加，增加了系统的复杂性。\n命令模式同样有着很多现实场景的应用，比如Git中的很多操作，如提交（commit）、合并（merge）等，都可以看作是命令模式的应用，用户通过执行相应的命令来操作版本库。Java的GUI编程中，很多事件处理机制也都使用了命令模式。例如，每个按钮都有一个关联的 Action，它代表一个命令，按钮的点击触发 Action 的执行。\n本题代码 link import java.util.Scanner; // 命令接口 interface Command { void execute(); } // 具体命令类 - 点餐命令 class OrderCommand implements Command { private String drinkName; private DrinkMaker receiver; public OrderCommand(String drinkName, DrinkMaker receiver) { this.drinkName = drinkName; this.receiver = receiver; } @Override public void execute() { receiver.makeDrink(drinkName); } } // 接收者类 - 制作饮品 class DrinkMaker { public void makeDrink(String drinkName) { System.out.println(drinkName + \" is ready!\"); } } // 调用者类 - 点餐机 class OrderMachine { private Command command; public void setCommand(Command command) { this.command = command; } public void executeOrder() { command.execute(); } } public class Main { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); // 创建接收者和命令对象 DrinkMaker drinkMaker = new DrinkMaker(); // 读取命令数量 int n = scanner.nextInt(); scanner.nextLine(); while (n-- \u003e 0) { // 读取命令 String drinkName = scanner.next(); // 创建命令对象 Command command = new OrderCommand(drinkName, drinkMaker); // 执行命令 OrderMachine orderMachine = new OrderMachine(); orderMachine.setCommand(command); orderMachine.executeOrder(); } scanner.close(); } } 其他语言版本 linkJava link使用命令模式+工厂模式，进一步将程序进行解耦，主程序不需要知道具体命令类的实现细节，后续增加新命令或饮料类型时，只需修改工厂类，不会影响主程序的结构。\nimport java.util.Scanner; // 命令接口 interface Command { void execute(); } // 具体命令类 - 点餐命令 class OrderCommand implements Command { private String drinkName; private DrinkMaker receiver; public OrderCommand(String drinkName, DrinkMaker receiver) { this.drinkName = drinkName; this.receiver = receiver; } @Override public void execute() { receiver.makeDrink(drinkName); } } // 接收者类 - 制作饮品 class DrinkMaker { public void makeDrink(String drinkName) { System.out.println(drinkName + \" is ready!\"); } } // 调用者类 - 点餐机 class OrderMachine { private Command command; public void setCommand(Command command) { this.command = command; } public void executeOrder() { if (command != null) { command.execute(); } else { System.out.println(\"未设置命令.\"); } } } // 命令工厂类 class CommandFactory { private DrinkMaker drinkMaker; public CommandFactory(DrinkMaker drinkMaker) { this.drinkMaker = drinkMaker; } public Command createCommand(String drinkName) { return new OrderCommand(drinkName, drinkMaker); } } // 主类 public class Main { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); // 创建接收者和工厂对象 DrinkMaker drinkMaker = new DrinkMaker(); CommandFactory commandFactory = new CommandFactory(drinkMaker); OrderMachine orderMachine = new OrderMachine(); // 读取命令数量 int n = scanner.nextInt(); scanner.nextLine(); while (n-- \u003e 0) { // 读取命令 String drinkName = scanner.nextLine().trim(); if (drinkName.isEmpty()) { System.out.println(\"无效输入，请输入饮品名.\"); continue; } // 使用工厂创建命令对象 Command command = commandFactory.createCommand(drinkName); // 设置命令并执行 orderMachine.setCommand(command); orderMachine.executeOrder(); } scanner.close(); } } C++ link #include #include #include class DrinkMaker; // 前向声明 // 命令接口 class Command { public: virtual void execute() = 0; virtual ~Command() = default; // 添加虚析构函数 }; // 具体命令类 - 点餐命令 class OrderCommand : public Command { private: std::string drinkName; DrinkMaker* receiver; // 使用前向声明 public: OrderCommand(const std::string\u0026 drinkName, DrinkMaker* receiver); void execute() override; }; // 接收者类 - 制作饮品 class DrinkMaker { public: void makeDrink(const std::string\u0026 drinkName) { std::cout \u003c\u003c drinkName \u003c\u003c \" is ready!\" \u003c\u003c std::endl; } }; // 实现 OrderCommand 的构造函数和 execute 函数 OrderCommand::OrderCommand(const std::string\u0026 drinkName, DrinkMaker* receiver) : drinkName(drinkName), receiver(receiver) {} void OrderCommand::execute() { receiver-\u003emakeDrink(drinkName); } // 调用者类 - 点餐机 class OrderMachine { private: Command* command; public: void setCommand(Command* command) { this-\u003ecommand = command; } void executeOrder() { command-\u003eexecute(); } }; int main() { // 创建接收者和命令对象 DrinkMaker drinkMaker; // 读取命令数量 int n; std::cin \u003e\u003e n; std::cin.ignore(); // 消耗掉换行符 while (n-- \u003e 0) { // 读取命令 std::string drinkName; std::cin \u003e\u003e drinkName; // 创建命令对象 Command* command = new OrderCommand(drinkName, \u0026drinkMaker); // 执行命令 OrderMachine orderMachine; orderMachine.setCommand(command); orderMachine.executeOrder(); // 释放动态分配的命令对象 delete command; } return 0; } Python link from abc import ABC, abstractmethod # 命令接口 class Command(ABC): @abstractmethod def execute(self): pass # 具体命令类 - 点餐命令 class OrderCommand(Command): def __init__(self, drink_name, receiver): self.drink_name = drink_name self.receiver = receiver def execute(self): self.receiver.make_drink(self.drink_name) # 接收者类 - 制作饮品 class DrinkMaker: def make_drink(self, drink_name): print(f\"{drink_name} is ready!\") # 调用者类 - 点餐机 class OrderMachine: def __init__(self): self.command = None def set_command(self, command): self.command = command def execute_order(self): self.command.execute() if __name__ == \"__main__\": # 创建接收者和命令对象 drink_maker = DrinkMaker() # 读取命令数量 n = int(input()) for _ in range(n): # 读取命令 drink_name = input() # 创建命令对象 command = OrderCommand(drink_name, drink_maker) # 执行命令 order_machine = OrderMachine() order_machine.set_command(command) order_machine.execute_order() Go link package main import \"fmt\" // Command 接口 type Command interface { Execute() } // OrderCommand 具体命令类 - 点餐命令 type OrderCommand struct { DrinkName string Receiver *DrinkMaker } func (oc *OrderCommand) Execute() { oc.Receiver.MakeDrink(oc.DrinkName) } // DrinkMaker 接收者类 - 制作饮品 type DrinkMaker struct{} func (dm *DrinkMaker) MakeDrink(drinkName string) { fmt.Println(drinkName + \" is ready!\") } // OrderMachine 调用者类 - 点餐机 type OrderMachine struct { Command Command } func (om *OrderMachine) SetCommand(command Command) { om.Command = command } func (om *OrderMachine) ExecuteOrder() { om.Command.Execute() } func main() { // 创建接收者和命令对象 drinkMaker := \u0026DrinkMaker{} // 读取命令数量 var n int fmt.Scan(\u0026n) for i := 0; i \u003c n; i++ { // 读取命令 var drinkName string fmt.Scan(\u0026drinkName) // 创建命令对象 command := \u0026OrderCommand{DrinkName: drinkName, Receiver: drinkMaker} // 执行命令 orderMachine := \u0026OrderMachine{} orderMachine.SetCommand(command) orderMachine.ExecuteOrder() } } "
            }
        );
    index.add(
            {
                id:  25 ,
                href: "\/docs\/dev\/23designpattern\/16.%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F\/",
                title: "16.中介者模式",
                description: "中介者模式（Mediator Pattern）也被称为调停者模式，是一种行为型设计模式，它通过一个中介对象来封装一组对象之间的交互，从而使这些对象不需要直接相互引用。这样可以降低对象之间的耦合度，使系统更容易维护和扩展。",
                content: "需求 link【设计模式专题之中介者模式】16-简易聊天室\n题目描述\n小明正在设计一个简单的多人聊天室系统，有多个用户和一个聊天室中介者，用户通过中介者进行聊天，请你帮他完成这个系统的设计。 输入描述\n第一行包括一个整数N,表示用户的数量（1 \u003c= N \u003c= 100) 第二行是N个用户，比如User1 User2 User3，用空格分隔。第三行开始，每行包含两个字符串，表示消息的发出者和消息内容，用空格分隔 输出描述 对于每个用户，输出一行，包含该用户收到的所有消息内容。\n输入示例 3 User1 User2 User3 User1 Hello_All! User2 Hi_User1! User3 How_is_everyone? 输出示例 User2 received: Hello_All! User3 received: Hello_All! User1 received: Hi_User1! User3 received: Hi_User1! User1 received: How_is_everyone? User2 received: How_is_everyone? 基本概念 link中介者模式（Mediator Pattern）也被称为调停者模式，是一种行为型设计模式，它通过一个中介对象来封装一组对象之间的交互，从而使这些对象不需要直接相互引用。这样可以降低对象之间的耦合度，使系统更容易维护和扩展。\n当一个系统中的对象有很多且多个对象之间有复杂的相互依赖关系时，其结构图可能是下面这样的。\n这种依赖关系很难理清，这时我们可以引入一个中介者对象来进行协调和交互。中介者模式可以使得系统的网状结构变成以中介者为中心的星形结构，每个具体对象不再通过直接的联系与另一个对象发生相互作用，而是通过“中介者”对象与另一个对象发生相互作用。\n基本结构 link中介者模式包括以下几个重要角色：\n抽象中介者（Mediator）： 定义中介者的接口，用于各个具体同事对象之间的通信。\n具体中介者（Concrete Mediator）： 实现抽象中介者接口，负责协调各个具体同事对象的交互关系，它需要知道所有具体同事类，并从具体同事接收消息，向具体同事对象发出命令。\n抽象同事类（Colleague）： 定义同事类的接口，维护一个对中介者对象的引用，用于通信。\n具体同事类（Concrete Colleague）： 实现抽象同事类接口，每个具体同事类只知道自己的行为，而不了解其他同事类的情况，因为它们都需要与中介者通信，通过中介者协调与其他同事对象的交互。\n简易实现 link // 抽象中介者 public abstract class Mediator { void register(Colleague colleague); // 定义一个抽象的发送消息方法 public abstract void send(String message, Player player); } // 具体中介者 public class ConcreteMediator extends Mediator { private List colleagues = new ArrayList\u003c\u003e(); public void register((Colleague colleague) { colleagues.add(colleague); } @Override public void send(String message, Colleague colleague) { for (Colleague c : colleagues) { // 排除发送消息的同事对象 if (c != colleague) { c.receive(message); } } } } // 同事对象 abstract class Colleague { protected Mediator mediator; public Colleague(Mediator mediator) { this.mediator = mediator; } // 发送消息 public abstract void send(String message); // 接收消息 public abstract void receive(String message); } // 具体同事对象1 class ConcreteColleague1 extends Colleague { public ConcreteColleague1(Mediator mediator) { super(mediator); } @Override public void send(String message) { mediator.send(message, this); } @Override public void receive(String message) { System.out.println(\"ConcreteColleague1 received: \" + message); } } // 具体同事对象2 class ConcreteColleague2 extends Colleague { public ConcreteColleague2(Mediator mediator) { super(mediator); } @Override public void send(String message) { mediator.send(message, this); } @Override public void receive(String message) { System.out.println(\"ConcreteColleague2 received: \" + message); } } // 客户端 public class Main{ public static void main(String[] args) { // 创建中介者 Mediator mediator = new ConcreteMediator(); // 创建同事对象 Colleague colleague1 = new ConcreteColleague1(mediator); Colleague colleague2 = new ConcreteColleague2(mediator); // 注册同事对象到中介者 mediator.register(colleague1); mediator.register(colleague2); // 同事对象之间发送消息 colleague1.send(\"Hello from Colleague1!\"); colleague2.send(\"Hi from Colleague2!\"); } } 使用场景 link中介者模式使得同事对象不需要知道彼此的细节，只需要与中介者进行通信，简化了系统的复杂度，也降低了各对象之间的耦合度，但是这也会使得中介者对象变得过于庞大和复杂，如果中介者对象出现问题，整个系统可能会受到影响。\n中介者模式适用于当系统对象之间存在复杂的交互关系或者系统需要在不同对象之间进行灵活的通信时使用，可以使得问题简化，\n本题代码 link import java.util.*; // 抽象中介者 interface ChatRoomMediator { void sendMessage(String sender, String message); void addUser(ChatUser user); Map getUsers(); } // 具体中介者 class ChatRoomMediatorImpl implements ChatRoomMediator { private Map users = new LinkedHashMap\u003c\u003e(); @Override public void sendMessage(String sender, String message) { for (ChatUser user : users.values()) { if (!user.getName().equals(sender)) { user.receiveMessage(sender, message); } } } @Override public void addUser(ChatUser user) { users.put(user.getName(), user); } @Override public Map getUsers() { return users; } } // 抽象同事类 abstract class ChatUser { private String name; private ChatRoomMediator mediator; private List receivedMessages = new ArrayList\u003c\u003e(); public ChatUser(String name, ChatRoomMediator mediator) { this.name = name; this.mediator = mediator; mediator.addUser(this); } public String getName() { return name; } public void sendMessage(String message) { mediator.sendMessage(name, message); } public abstract void receiveMessage(String sender, String message); public List getReceivedMessages() { return receivedMessages; } protected void addReceivedMessage(String message) { receivedMessages.add(message); } } // 具体同事类 class ConcreteChatUser extends ChatUser { public ConcreteChatUser(String name, ChatRoomMediator mediator) { super(name, mediator); } @Override public void receiveMessage(String sender, String message) { String receivedMessage = getName() + \" received: \" + message; addReceivedMessage(receivedMessage); System.out.println(receivedMessage); } } // 客户端 public class Main { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); int N = scanner.nextInt(); List userNames = new ArrayList\u003c\u003e(); for (int i = 0; i \u003c N; i++) { userNames.add(scanner.next()); } ChatRoomMediator mediator = new ChatRoomMediatorImpl(); // 创建用户对象 for (String userName : userNames) { new ConcreteChatUser(userName, mediator); } // 发送消息并输出 while (scanner.hasNext()) { String sender = scanner.next(); String message = scanner.next(); ChatUser user = mediator.getUsers().get(sender); if (user != null) { user.sendMessage(message); } } scanner.close(); } } 扩展：和代理模式的区别 link中介者模式（Mediator Pattern）和代理模式（Proxy Pattern) 在某些表述上有些类似，但是他们是完全不同的两个设计模式，中介者模式的目的是降低系统中各个对象之间的直接耦合，通过引入一个中介者对象，使对象之间的通信集中在中介者上。而在代理模式中，客户端通过代理与目标对象进行通信。代理可以在调用目标对象的方法前后进行一些额外的操作，其目的是控制对对象的访问，它们分别解决了不同类型的问题。\n其他语言版本 linkC++ link #include #include #include #include // 抽象中介者 class ChatRoomMediator; // 抽象同事类 class ChatUser { private: std::string name; ChatRoomMediator* mediator; std::list receivedMessages; public: ChatUser(const std::string\u0026 name, ChatRoomMediator* mediator); std::string getName() const { return name; } void sendMessage(const std::string\u0026 message); virtual void receiveMessage(const std::string\u0026 sender, const std::string\u0026 message) = 0; std::list getReceivedMessages() const { return receivedMessages; } protected: void addReceivedMessage(const std::string\u0026 message) { receivedMessages.push_back(message); } }; // 具体同事类 class ConcreteChatUser : public ChatUser { public: ConcreteChatUser(const std::string\u0026 name, ChatRoomMediator* mediator); void receiveMessage(const std::string\u0026 sender, const std::string\u0026 message) override; }; // 抽象中介者 class ChatRoomMediator { public: virtual void sendMessage(const std::string\u0026 sender, const std::string\u0026 message) = 0; virtual void addUser(ChatUser* user) = 0; virtual std::map getUsers() = 0; virtual ~ChatRoomMediator() = default; }; // 具体中介者 class ChatRoomMediatorImpl : public ChatRoomMediator { private: std::map users; public: void sendMessage(const std::string\u0026 sender, const std::string\u0026 message) override { for (const auto\u0026 userPair : users) { if (userPair.first != sender) { userPair.second-\u003ereceiveMessage(sender, message); } } } void addUser(ChatUser* user) override { users[user-\u003egetName()] = user; } std::map getUsers() override { return users; } }; // 实现 ChatUser 类的成员函数 ChatUser::ChatUser(const std::string\u0026 name, ChatRoomMediator* mediator) : name(name), mediator(mediator) { mediator-\u003eaddUser(this); } void ChatUser::sendMessage(const std::string\u0026 message) { mediator-\u003esendMessage(name, message); } // 实现 ConcreteChatUser 类的成员函数 ConcreteChatUser::ConcreteChatUser(const std::string\u0026 name, ChatRoomMediator* mediator) : ChatUser(name, mediator) {} void ConcreteChatUser::receiveMessage(const std::string\u0026 sender, const std::string\u0026 message) { std::string receivedMessage = getName() + \" received: \" + message; addReceivedMessage(receivedMessage); std::cout \u003c\u003c receivedMessage \u003c\u003c std::endl; } int main() { std::vector userNames; int N; std::cin \u003e\u003e N; for (int i = 0; i \u003c N; i++) { std::string userName; std::cin \u003e\u003e userName; userNames.push_back(userName); } ChatRoomMediator* mediator = new ChatRoomMediatorImpl(); // 创建用户对象 for (const auto\u0026 userName : userNames) { new ConcreteChatUser(userName, mediator); } // 发送消息并输出 std::string sender, message; while (std::cin \u003e\u003e sender \u003e\u003e message) { ChatUser* user = mediator-\u003egetUsers()[sender]; if (user != nullptr) { user-\u003esendMessage(message); } } delete mediator; // 释放中介者对象 return 0; } Python link class ChatRoomMediator: def __init__(self): self.users = {} def send_message(self, sender, message): for user in self.users.values(): if user.name != sender: user.receive_message(sender, message) def add_user(self, user): self.users[user.name] = user class ChatUser: def __init__(self, name, mediator): self.name = name self.mediator = mediator self.received_messages = [] def send_message(self, message): self.mediator.send_message(self.name, message) def receive_message(self, sender, message): received_message = f\"{self.name} received: {message}\" self.received_messages.append(received_message) print(received_message) if __name__ == \"__main__\": # 读取用户数量 N = int(input()) # 读取用户列表 user_names = input().split() # 创建中介者 mediator = ChatRoomMediator() # 创建用户对象并注册到中介者 for user_name in user_names: user = ChatUser(user_name, mediator) mediator.add_user(user) # 处理消息输入 while True: try: sender, message = input().split() user = mediator.users.get(sender) if user: user.send_message(message) except EOFError: break Go link package main import \"fmt\" type ChatRoomMediator struct { users map[string]*ChatUser } func NewChatRoomMediator() *ChatRoomMediator { return \u0026ChatRoomMediator{ users: make(map[string]*ChatUser), } } func (m *ChatRoomMediator) SendMessage(sender, message string) { for _, user := range m.users { if user.name != sender { user.ReceiveMessage(sender, message) } } } func (m *ChatRoomMediator) AddUser(user *ChatUser) { m.users[user.name] = user } type ChatUser struct { name string mediator *ChatRoomMediator receivedMessages []string } func NewChatUser(name string, mediator *ChatRoomMediator) *ChatUser { return \u0026ChatUser{ name: name, mediator: mediator, receivedMessages: make([]string, 0), } } func (u *ChatUser) SendMessage(message string) { u.mediator.SendMessage(u.name, message) } func (u *ChatUser) ReceiveMessage(sender, message string) { receivedMessage := fmt.Sprintf(\"%s received: %s\", u.name, message) u.receivedMessages = append(u.receivedMessages, receivedMessage) fmt.Println(receivedMessage) } func main() { var N int fmt.Scan(\u0026N) userNames := make([]string, N) for i := 0; i \u003c N; i++ { fmt.Scan(\u0026userNames[i]) } mediator := NewChatRoomMediator() for _, userName := range userNames { user := NewChatUser(userName, mediator) mediator.AddUser(user) } for { var sender, message string _, err := fmt.Scan(\u0026sender, \u0026message) if err != nil { break } user, ok := mediator.users[sender] if ok { user.SendMessage(message) } } } "
            }
        );
    index.add(
            {
                id:  26 ,
                href: "\/docs\/dev\/23designpattern\/17.%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F\/",
                title: "17.备忘录模式",
                description: "备忘录模式（Memento Pattern）是一种行为型设计模式，它允许在**不暴露对象实现的情况下捕获对象的内部状态**并**在对象之外保存这个状态**，以 便稍后可以将其还原到先前的状态。",
                content: "需求 link【设计模式专题之备忘录模式】17-redo计数器应用\n题目描述 小明正在设计一个简单的计数器应用，支持增加（Increment）和减少（Decrement）操作，以及撤销（Undo）和重做（Redo）操作，请你使用备忘录模式帮他实现。\n输入描述\n输入包含若干行，每行包含一个字符串，表示计数器应用的操作，操作包括 “Increment”、“Decrement”、“Undo” 和 “Redo”。 输出描述\n对于每个 “Increment” 和 “Decrement” 操作，输出当前计数器的值，计数器数值从0开始 对于每个 “Undo” 操作，输出撤销后的计数器值。 对于每个 “Redo” 操作，输出重做后的计数器值。 输入示例 Increment Increment Decrement Undo Redo Increment 输出示例 1 2 1 2 1 2 基本概念 link备忘录模式（Memento Pattern）是一种行为型设计模式，它允许在不暴露对象实现的情况下捕获对象的内部状态并在对象之外保存这个状态，以便稍后可以将其还原到先前的状态。\n基本结构 link备忘录模式包括以下几个重要角色：\n发起人Originator： 需要还原状态的那个对象，负责创建一个【备忘录】，并使用备忘录记录当前时刻的内部状态。\n备忘录Memento: 存储发起人对象的内部状态，它可以包含发起人的部分或全部状态信息，但是对外部是不可见的，只有发起人能够访问备忘录对象的状态。\n备忘录有两个接口，发起人能够通过宽接口访问数据，管理者只能看到窄接口，并将备忘录传递给其他对象。\n管理者Caretaker: 负责存储备忘录对象，但并不了解其内部结构，管理者可以存储多个备忘录对象。\n客户端：在需要恢复状态时，客户端可以从管理者那里获取备忘录对象，并将其传递给发起人进行状态的恢复。\n基本实现 link 创建发起人类：可以创建备忘录对象 class Originator { private String state; public void setState(String state) { this.state = state; } public String getState() { return state; } // 创建备忘录对象 public Memento createMemento() { return new Memento(state); } // 通过备忘录对象恢复状态 public void restoreFromMemento(Memento memento) { state = memento.getState(); } } 创建备忘录类：保存发起人对象的状态 class Memento { private String state; // 保存发起人的状态 public Memento(String state) { this.state = state; } public String getState() { return state; } } 创建管理者：维护一组备忘录对象 class Caretaker { private List mementos = new ArrayList\u003c\u003e(); public void addMemento(Memento memento) { mementos.add(memento); } public Memento getMemento(int index) { return mementos.get(index); } } 客户端使用备忘录模式 public class Main { public static void main(String[] args) { // 创建发起人对象 Originator originator = new Originator(); originator.setState(\"State 1\"); // 创建管理者对象 Caretaker caretaker = new Caretaker(); // 保存当前状态 caretaker.addMemento(originator.createMemento()); // 修改状态 originator.setState(\"State 2\"); // 再次保存当前状态 caretaker.addMemento(originator.createMemento()); // 恢复到先前状态 originator.restoreFromMemento(caretaker.getMemento(0)); System.out.println(\"Current State: \" + originator.getState()); } } 使用场景 link备忘录模式在保证了对象内部状态的封装和私有性前提下可以轻松地添加新的备忘录和发起人，实现“备份”，不过 备份对象往往会消耗较多的内存，资源消耗增加。\n备忘录模式常常用来实现撤销和重做功能，比如在Java Swing GUI编程中，javax.swing.undo包中的撤销（undo）和重做（redo）机制使用了备忘录模式。UndoManager和UndoableEdit接口是与备忘录模式相关的主要类和接口。\n本题代码 link import java.util.Scanner; import java.util.Stack; // 备忘录 class Memento { private int value; public Memento(int value) { this.value = value; } public int getValue() { return value; } } // 发起人（Originator） class Counter { private int value; private Stack undoStack = new Stack\u003c\u003e(); private Stack redoStack = new Stack\u003c\u003e(); public void increment() { redoStack.clear(); undoStack.push(new Memento(value)); value++; } public void decrement() { redoStack.clear(); undoStack.push(new Memento(value)); value--; } public void undo() { if (!undoStack.isEmpty()) { redoStack.push(new Memento(value)); value = undoStack.pop().getValue(); } } public void redo() { if (!redoStack.isEmpty()) { undoStack.push(new Memento(value)); value = redoStack.pop().getValue(); } } public int getValue() { return value; } } // 客户端 public class Main { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); Counter counter = new Counter(); // 处理计数器应用的输入 while (scanner.hasNext()) { String operation = scanner.next(); switch (operation) { case \"Increment\": counter.increment(); break; case \"Decrement\": counter.decrement(); break; case \"Undo\": counter.undo(); break; case \"Redo\": counter.redo(); break; } // 输出当前计数器的值 System.out.println(counter.getValue()); } scanner.close(); } } 其他语言版本 linkC++ link #include #include // 备忘录 class Memento { private: int value; public: Memento(int val) : value(val) {} int getValue() const { return value; } }; // 发起人（Originator） class Counter { private: int value; std::stack undoStack; std::stack redoStack; public: void increment() { redoStack = std::stack(); // 清空 redoStack undoStack.push(Memento(value)); value++; } void decrement() { redoStack = std::stack(); // 清空 redoStack undoStack.push(Memento(value)); value--; } void undo() { if (!undoStack.empty()) { redoStack.push(Memento(value)); value = undoStack.top().getValue(); undoStack.pop(); } } void redo() { if (!redoStack.empty()) { undoStack.push(Memento(value)); value = redoStack.top().getValue(); redoStack.pop(); } } int getValue() const { return value; } }; int main() { Counter counter; // 处理计数器应用的输入 std::string operation; while (std::cin \u003e\u003e operation) { if (operation == \"Increment\") { counter.increment(); } else if (operation == \"Decrement\") { counter.decrement(); } else if (operation == \"Undo\") { counter.undo(); } else if (operation == \"Redo\") { counter.redo(); } // 输出当前计数器的值 std::cout \u003c\u003c counter.getValue() \u003c\u003c std::endl; } return 0; } Python link import sys class Memento: def __init__(self, value): self.value = value def get_value(self): return self.value class Counter: def __init__(self): self.value = 0 self.undo_stack = [] self.redo_stack = [] def increment(self): self.redo_stack = [] # 清空 redo_stack self.undo_stack.append(Memento(self.value)) self.value += 1 def decrement(self): self.redo_stack = [] # 清空 redo_stack self.undo_stack.append(Memento(self.value)) self.value -= 1 def undo(self): if self.undo_stack: self.redo_stack.append(Memento(self.value)) self.value = self.undo_stack.pop().get_value() def redo(self): if self.redo_stack: self.undo_stack.append(Memento(self.value)) self.value = self.redo_stack.pop().get_value() def get_value(self): return self.value # 客户端 counter = Counter() # 处理计数器应用的输入 for line in sys.stdin: operation = line.strip() if operation == \"Increment\": counter.increment() elif operation == \"Decrement\": counter.decrement() elif operation == \"Undo\": counter.undo() elif operation == \"Redo\": counter.redo() # 输出当前计数器的值 print(counter.get_value()) Go link package main import ( \"bufio\" \"fmt\" \"os\" ) // 备忘录 type Memento struct { value int } // 发起人（Originator） type Counter struct { value int undoStack []*Memento redoStack []*Memento } func (c *Counter) increment() { c.redoStack = nil c.undoStack = append(c.undoStack, \u0026Memento{value: c.value}) c.value++ } func (c *Counter) decrement() { c.redoStack = nil c.undoStack = append(c.undoStack, \u0026Memento{value: c.value}) c.value-- } func (c *Counter) undo() { if len(c.undoStack) \u003e 0 { c.redoStack = append(c.redoStack, \u0026Memento{value: c.value}) c.value = c.undoStack[len(c.undoStack)-1].value c.undoStack = c.undoStack[:len(c.undoStack)-1] } } func (c *Counter) redo() { if len(c.redoStack) \u003e 0 { c.undoStack = append(c.undoStack, \u0026Memento{value: c.value}) c.value = c.redoStack[len(c.redoStack)-1].value c.redoStack = c.redoStack[:len(c.redoStack)-1] } } func (c *Counter) getValue() int { return c.value } // 客户端 func main() { scanner := bufio.NewScanner(os.Stdin) counter := \u0026Counter{} // 处理计数器应用的输入 for scanner.Scan() { operation := scanner.Text() switch operation { case \"Increment\": counter.increment() case \"Decrement\": counter.decrement() case \"Undo\": counter.undo() case \"Redo\": counter.redo() } // 输出当前计数器的值 fmt.Println(counter.getValue()) } if err := scanner.Err(); err != nil { fmt.Fprintln(os.Stderr, \"reading standard input:\", err) } } "
            }
        );
    index.add(
            {
                id:  27 ,
                href: "\/docs\/dev\/23designpattern\/18.%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F\/",
                title: "18.模板方法模式",
                description: "模板方法模式（Template Method Pattern）是一种行为型设计模式, 它定义了一个算法的骨架，将**一些步骤的实现延迟到子类。**模板方法模式使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤。",
                content: "需求 link【设计模式专题之模板方法模式】18-咖啡馆\n题目描述\n小明喜欢品尝不同类型的咖啡，她发现每种咖啡的制作过程有一些相同的步骤，他决定设计一个简单的咖啡制作系统，使用模板方法模式定义咖啡的制作过程。系统支持两种咖啡类型：美式咖啡（American Coffee）和拿铁（Latte）。\n咖啡制作过程包括以下步骤：\n研磨咖啡豆 Grinding coffee beans 冲泡咖啡 Brewing coffee 添加调料 Adding condiments 其中，美式咖啡和拿铁的调料添加方式略有不同, 拿铁在添加调料时需要添加牛奶Adding milk\n输入描述\n多行输入，每行包含一个数字，表示咖啡的选择（1 表示美式咖啡，2 表示拿铁）。 输出描述\n根据每行输入，输出制作咖啡的过程，包括咖啡类型和各个制作步骤，末尾有一个空行。 输入示例 1 2 输出示例\nMaking American Coffee: Grinding coffee beans Brewing coffee Adding condiments Making Latte: Grinding coffee beans Brewing coffee Adding milk Adding condiments 基本概念 link模板方法模式（Template Method Pattern）是一种行为型设计模式, 它定义了一个算法的骨架，将**一些步骤的实现延迟到子类。**模板方法模式使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤。【引用自大话设计第10章】\n举个简单的例子，做一道菜通常都需要包含至少三步：\n准备食材 亨饪过程 上菜 不同菜品的亨饪过程是不一样的，但是我们可以先定义一个”骨架”，包含这三个步骤，亨饪过程的过程放到具体的炒菜类中去实现，这样，无论炒什么菜，都可以沿用相同的炒菜算法，只需在子类中实现具体的炒菜步骤，从而提高了代码的复用性。\n基本结构 link模板方法模式的基本结构包含以下两个角色：\n模板类AbstractClass：由一个模板方法和若干个基本方法构成，模板方法定义了逻辑的骨架，按照顺序调用包含的基本方法，基本方法通常是一些抽象方法，这些方法由子类去实现。基本方法还包含一些具体方法，它们是算法的一部分但已经有默认实现，在具体子类中可以继承或者重写。 具体类ConcreteClass：继承自模板类，实现了在模板类中定义的抽象方法，以完成算法中特定步骤的具体实现。 简易实现 link模板方法模式的简单示例如下：\n定义模板类，包含模板方法，定义了算法的骨架, 一般都加上final关键字，避免子类重写。 // 模板类 abstract class AbstractClass { // 模板方法，定义了算法的骨架 public final void templateMethod() { step1(); step2(); step3(); } // 抽象方法，由子类实现 protected abstract void step1(); protected abstract void step2(); protected abstract void step3(); } 定义具体类, 实现模板类中的抽象方法 // 具体类 class ConcreteClass extends AbstractClass { @Override protected void step1() { System.out.println(\"Step 1 \"); } @Override protected void step2() { System.out.println(\"Step 2 \"); } @Override protected void step3() { System.out.println(\"Step 3\"); } } 客户端实现 public class Main { public static void main(String[] args) { AbstractClass concreteTemplate = new ConcreteClass(); // 触发整个算法的执行 concreteTemplate.templateMethod(); } } 应用场景 link模板方法模式将算法的不变部分被封装在模板方法中，而可变部分算法由子类继承实现，这样做可以很好的提高代码的复用性，但是当算法的框架发生变化时，可能需要修改模板类，这也会影响到所有的子类。\n总体来说，当算法的整体步骤很固定，但是个别步骤在更详细的层次上的实现可能不同时，通常考虑模板方法模式来处理。在已有的工具和库中， Spring框架中的JdbcTemplate类使用了模板方法模式，其中定义了一些执行数据库操作的模板方法，具体的数据库操作由回调函数提供。而在Java的JDK源码中，AbstractList 类也使用了模板方法模式，它提供了一些通用的方法，其中包括一些模板方法。具体的列表操作由子类实现。\n本题代码 link import java.util.Scanner; // 抽象类 abstract class CoffeeMakerTemplate { private String coffeeName; // 添加咖啡名称字段 // 构造函数，接受咖啡名称参数 public CoffeeMakerTemplate(String coffeeName) { this.coffeeName = coffeeName; } // 模板方法定义咖啡制作过程 final void makeCoffee() { System.out.println(\"Making \" + coffeeName + \":\"); grindCoffeeBeans(); brewCoffee(); addCondiments(); System.out.println(); } // 具体步骤的具体实现由子类提供 abstract void grindCoffeeBeans(); abstract void brewCoffee(); // 添加调料的默认实现 void addCondiments() { System.out.println(\"Adding condiments\"); } } // 具体的美式咖啡类 class AmericanCoffeeMaker extends CoffeeMakerTemplate { // 构造函数传递咖啡名称 public AmericanCoffeeMaker() { super(\"American Coffee\"); } @Override void grindCoffeeBeans() { System.out.println(\"Grinding coffee beans\"); } @Override void brewCoffee() { System.out.println(\"Brewing coffee\"); } } // 具体的拿铁咖啡类 class LatteCoffeeMaker extends CoffeeMakerTemplate { // 构造函数传递咖啡名称 public LatteCoffeeMaker() { super(\"Latte\"); } @Override void grindCoffeeBeans() { System.out.println(\"Grinding coffee beans\"); } @Override void brewCoffee() { System.out.println(\"Brewing coffee\"); } // 添加调料的特定实现 @Override void addCondiments() { System.out.println(\"Adding milk\"); System.out.println(\"Adding condiments\"); } } // 客户端代码 public class Main { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); while (scanner.hasNext()) { int coffeeType = scanner.nextInt(); CoffeeMakerTemplate coffeeMaker = null; if (coffeeType == 1) { coffeeMaker = new AmericanCoffeeMaker(); } else if (coffeeType == 2) { coffeeMaker = new LatteCoffeeMaker(); } else { System.out.println(\"Invalid coffee type\"); continue; } // 制作咖啡 coffeeMaker.makeCoffee(); } } } 其他语言版本 linkJava link添加钩子函数，也可由用户来确定是否添加牛奶或其它配料。\nimport java.util.Scanner; // 抽象类，定义咖啡制作的基本步骤 abstract class CoffeeModel { private String coffeeName; // 构造函数，接受咖啡名称参数 public CoffeeModel(String coffeeName) { this.coffeeName = coffeeName; } protected abstract void grind(); protected abstract void brew(); protected abstract void addCondiments(); // 添加其他调料可使用该类 public void addThings(){}; // 模板方法，定义咖啡制作的流程 public final void createCoffeeTemplate() { System.out.println(\"Making \" + coffeeName + \":\"); grind(); brew(); //根据情况，是否调用添加更多调料 if (isAddThings()) { addThings(); } addCondiments(); System.out.println(); } // 默认不添加其他调料。如牛奶等 public boolean isAddThings() { return false; } } //美式咖啡类实现 class CreateAmericanCoffee extends CoffeeModel { public CreateAmericanCoffee() { super(\"American Coffee\"); } @Override protected void grind() { System.out.println(\"Grinding coffee beans\"); } @Override protected void brew() { System.out.println(\"Brewing coffee\"); } @Override protected void addCondiments() { System.out.println(\"Adding condiments\"); } // 美式咖啡默认不添加其他调料，如牛奶等 @Override public boolean isAddThings() { return false; } } //拿铁类实现 class CreateLatte extends CoffeeModel { private boolean addThingsFlag = true; public CreateLatte() { super(\"Latte\"); } @Override protected void grind() { System.out.println(\"Grinding coffee beans\"); } @Override protected void brew() { System.out.println(\"Brewing coffee\"); } @Override protected void addCondiments() { System.out.println(\"Adding condiments\"); } //需要添加调料，牛奶 @Override public void addThings(){ System.out.println(\"Adding milk\"); } // 拿铁默认添加牛奶 @Override public boolean isAddThings() { return this.addThingsFlag; } // 外部调用以改变是否添加牛奶的状态，钩子函数 public void setAddThingsFlag(boolean flag) { this.addThingsFlag = flag; } } //客户端 public class Main { public static void main(String[] args) { try (Scanner scanner = new Scanner(System.in)) { while (scanner.hasNextInt()) { int input = scanner.nextInt(); CoffeeModel coffee; switch (input) { case 1: coffee = new CreateAmericanCoffee(); break; case 2: coffee = new CreateLatte(); break; default: System.out.println(\"无效选择，请输入1或2\"); continue; } coffee.createCoffeeTemplate(); } } } } C++ link #include #include #include // 抽象类 class CoffeeMakerTemplate { private: std::string coffeeName; public: // 构造函数，接受咖啡名称参数 CoffeeMakerTemplate(const std::string\u0026 coffeeName) : coffeeName(coffeeName) {} // 模板方法定义咖啡制作过程 virtual void makeCoffee() { std::cout \u003c\u003c \"Making \" \u003c\u003c coffeeName \u003c\u003c \":\\n\"; grindCoffeeBeans(); brewCoffee(); addCondiments(); std::cout \u003c\u003c '\\n'; } // 具体步骤的具体实现由子类提供 virtual void grindCoffeeBeans() = 0; virtual void brewCoffee() = 0; // 添加调料的默认实现 virtual void addCondiments() { std::cout \u003c\u003c \"Adding condiments\\n\"; } }; // 具体的美式咖啡类 class AmericanCoffeeMaker : public CoffeeMakerTemplate { public: // 构造函数传递咖啡名称 AmericanCoffeeMaker() : CoffeeMakerTemplate(\"American Coffee\") {} void grindCoffeeBeans() override { std::cout \u003c\u003c \"Grinding coffee beans\\n\"; } void brewCoffee() override { std::cout \u003c\u003c \"Brewing coffee\\n\"; } }; // 具体的拿铁咖啡类 class LatteCoffeeMaker : public CoffeeMakerTemplate { public: // 构造函数传递咖啡名称 LatteCoffeeMaker() : CoffeeMakerTemplate(\"Latte\") {} void grindCoffeeBeans() override { std::cout \u003c\u003c \"Grinding coffee beans\\n\"; } void brewCoffee() override { std::cout \u003c\u003c \"Brewing coffee\\n\"; } // 添加调料的特定实现 void addCondiments() override { std::cout \u003c\u003c \"Adding milk\\n\"; std::cout \u003c\u003c \"Adding condiments\\n\"; } }; int main() { std::unique_ptr coffeeMaker; int coffeeType; while (std::cin \u003e\u003e coffeeType) { if (coffeeType == 1) { coffeeMaker = std::make_unique(); } else if (coffeeType == 2) { coffeeMaker = std::make_unique(); } else { std::cout \u003c\u003c \"Invalid coffee type\\n\"; continue; } // 制作咖啡 coffeeMaker-\u003emakeCoffee(); } return 0; } Python link from abc import ABC, abstractmethod # 抽象类 class CoffeeMakerTemplate(ABC): # 构造函数，接受咖啡名称参数 def __init__(self, coffee_name): self.coffee_name = coffee_name # 模板方法定义咖啡制作过程 def make_coffee(self): print(f\"Making {self.coffee_name}:\") self.grind_coffee_beans() self.brew_coffee() self.add_condiments() print() # 具体步骤的具体实现由子类提供 @abstractmethod def grind_coffee_beans(self): pass @abstractmethod def brew_coffee(self): pass # 添加调料的默认实现 def add_condiments(self): print(\"Adding condiments\") # 具体的美式咖啡类 class AmericanCoffeeMaker(CoffeeMakerTemplate): # 构造函数传递咖啡名称 def __init__(self): super().__init__(\"American Coffee\") def grind_coffee_beans(self): print(\"Grinding coffee beans\") def brew_coffee(self): print(\"Brewing coffee\") # 具体的拿铁咖啡类 class LatteCoffeeMaker(CoffeeMakerTemplate): # 构造函数传递咖啡名称 def __init__(self): super().__init__(\"Latte\") def grind_coffee_beans(self): print(\"Grinding coffee beans\") def brew_coffee(self): print(\"Brewing coffee\") # 添加调料的特定实现 def add_condiments(self): print(\"Adding milk\") print(\"Adding condiments\") # 客户端代码 if __name__ == \"__main__\": while True: try: coffee_type = int(input()) coffee_maker = None if coffee_type == 1: coffee_maker = AmericanCoffeeMaker() elif coffee_type == 2: coffee_maker = LatteCoffeeMaker() else: print(\"Invalid coffee type\") continue # 制作咖啡 coffee_maker.make_coffee() except EOFError: break Go link package main import ( \"fmt\" \"os\" ) // 抽象类接口 type CoffeeMakerTemplate interface { MakeCoffee() GrindCoffeeBeans() BrewCoffee() AddCondiments() } // 具体的美式咖啡类 type AmericanCoffeeMaker struct { coffeeName string } // 构造函数传递咖啡名称 func NewAmericanCoffeeMaker() *AmericanCoffeeMaker { return \u0026AmericanCoffeeMaker{coffeeName: \"American Coffee\"} } // 实现接口 func (a *AmericanCoffeeMaker) MakeCoffee() { fmt.Printf(\"Making %s:\\n\", a.coffeeName) a.GrindCoffeeBeans() a.BrewCoffee() a.AddCondiments() fmt.Println() } func (a *AmericanCoffeeMaker) GrindCoffeeBeans() { fmt.Println(\"Grinding coffee beans\") } func (a *AmericanCoffeeMaker) BrewCoffee() { fmt.Println(\"Brewing coffee\") } func (a *AmericanCoffeeMaker) AddCondiments() { fmt.Println(\"Adding condiments\") } // 具体的拿铁咖啡类 type LatteCoffeeMaker struct { coffeeName string } // 构造函数传递咖啡名称 func NewLatteCoffeeMaker() *LatteCoffeeMaker { return \u0026LatteCoffeeMaker{coffeeName: \"Latte\"} } // 实现接口 func (l *LatteCoffeeMaker) MakeCoffee() { fmt.Printf(\"Making %s:\\n\", l.coffeeName) l.GrindCoffeeBeans() l.BrewCoffee() l.AddCondiments() fmt.Println() } func (l *LatteCoffeeMaker) GrindCoffeeBeans() { fmt.Println(\"Grinding coffee beans\") } func (l *LatteCoffeeMaker) BrewCoffee() { fmt.Println(\"Brewing coffee\") } func (l *LatteCoffeeMaker) AddCondiments() { fmt.Println(\"Adding milk\") fmt.Println(\"Adding condiments\") } func main() { for { var coffeeType int if _, err := fmt.Scan(\u0026coffeeType); err != nil { if err.Error() == \"expected integer\" || err.Error() == \"EOF\" { break } fmt.Println(err) os.Exit(1) } var coffeeMaker CoffeeMakerTemplate switch coffeeType { case 1: coffeeMaker = NewAmericanCoffeeMaker() case 2: coffeeMaker = NewLatteCoffeeMaker() default: fmt.Println(\"Invalid coffee type\") continue } // 制作咖啡 coffeeMaker.MakeCoffee() } } "
            }
        );
    index.add(
            {
                id:  28 ,
                href: "\/docs\/dev\/23designpattern\/19.%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F\/",
                title: "19.迭代器模式",
                description: "迭代器模式是一种行为设计模式，是一种使用频率非常高的设计模式，在各个语言中都有应用，其主要目的是**提供一种统一的方式来访问一个聚合对象中的各个元素，**而不需要暴露该对象的内部表示。通过迭代器，客户端可以顺序访问聚合对象的元素，而无需了解底层数据结构。",
                content: "需求 link【设计模式专题之迭代器模式】19-学生名单\n题目描述\n小明是一位老师，在进行班级点名时，希望有一个学生名单系统，请你实现迭代器模式提供一个迭代器使得可以按顺序遍历学生列表。 输入描述\n第一行是一个整数 N （1 \u003c= N \u003c= 100), 表示学生的数量。 接下来的 N 行，每行包含一个学生的信息，格式为 姓名 学号 输出描述\n输出班级点名的结果，即按顺序遍历学生列表，输出学生的姓名和学号 输入示例 3 Alice 1001 Bob 1002 Charlie 1003 输出示例 Alice 1001 Bob 1002 Charlie 1003 基本概念 link迭代器模式是一种行为设计模式，是一种使用频率非常高的设计模式，在各个语言中都有应用，其主要目的是**提供一种统一的方式来访问一个聚合对象中的各个元素，**而不需要暴露该对象的内部表示。通过迭代器，客户端可以顺序访问聚合对象的元素，而无需了解底层数据结构。\n迭代器模式应用广泛，但是大多数语言都已经内置了迭代器接口，不需要自己实现。\n基本结构 link迭代器模式包括以下几个重要角色\n迭代器接口Iterator：定义访问和遍历元素的接口, 通常会包括hasNext()方法用于检查是否还有下一个元素，以及next()方法用于获取下一个元素。有的还会实现获取第一个元素以及获取当前元素的方法。 具体迭代器ConcreateIterator：实现迭代器接口，实现遍历逻辑对聚合对象进行遍历。 抽象聚合类：定义了创建迭代器的接口，包括一个createIterator方法用于创建一个迭代器对象。 具体聚合类：实现在抽象聚合类中声明的createIterator() 方法，返回一个与具体聚合对应的具体迭代器 简易实现 link 定义迭代器接口：通常会有检查是否还有下一个元素以及获取下一个元素的方法。 // 迭代器接口 public interface Iterator{ // 检查是否还会有下一个元素 boolean hasNext(); // 获取下一个元素 Object next(); } 定义具体迭代器：实现迭代器接口，遍历集合。 public class ConcreteIterator implements Iterator { private int index; private List elements; // 构造函数初始化迭代器 public ConcreteIterator(List elements) { this.elements = elements; this.index = 0; } @Override public boolean hasNext() { return index \u003c elements.size(); } @Override public Object next() { if (hasNext()) { return elements.get(index++); } return null; } } 定义聚合接口：通常包括createIterator()方法，用于创建迭代器 public interface Iterable { Iterator createIterator(); } 实现具体聚合：创建具体的迭代器 // 具体聚合 public class ConcreteIterable implements Iterable { private List elements; // 构造函数初始化可迭代对象 public ConcreteIterable(List elements) { this.elements = elements; } @Override public Iterator createIterator() { return new ConcreteIterator(elements); } } 客户端使用 import java.util.ArrayList; import java.util.List; public class IteratorPatternExample { public static void main(String[] args) { List elements = new ArrayList\u003c\u003e(); elements.add(\"Element 1\"); elements.add(\"Element 2\"); elements.add(\"Element 3\"); Iterable iterable = new ConcreteIterable(elements); Iterator iterator = iterable.createIterator(); while (iterator.hasNext()) { System.out.println(iterator.next()); } } } 使用场景 link迭代器模式是一种通用的设计模式，其封装性强，简化了客户端代码，客户端不需要知道集合的内部结构，只需要关心迭代器和迭代接口就可以完成元素的访问。但是引入迭代器模式会增加额外的类，每增加一个集合类，都需要增加该集合对应的迭代器，这也会使得代码结构变得更加复杂。\n许多编程语言和框架都使用了这个模式提供一致的遍历和访问集合元素的机制。下面是几种常见语言迭代器模式的实现。\nJava语言：集合类（如ArrayList、LinkedList), 通过Iterator接口，可以遍历集合中的元素。 List list = new ArrayList\u003c\u003e(); list.add(\"Item 1\"); list.add(\"Item 2\"); list.add(\"Item 3\"); Iterator iterator = list.iterator(); while (iterator.hasNext()) { System.out.println(iterator.next()); } Python语言：使用迭代器和生成器来实现迭代模式，iter()和next()函数可以用于创建和访问迭代器。 elements = [\"Element 1\", \"Element 2\", \"Element 3\"] iterator = iter(elements) while True: try: element = next(iterator) print(element) except StopIteration: break C++语言：C++中的STL提供了迭代器的支持，begin()和end()函数可以用于获取容器的起始和结束迭代器。 #include #include int main() { std::vector elements = {\"Element 1\", \"Element 2\", \"Element 3\"}; for (auto it = elements.begin(); it != elements.end(); ++it) { std::cout \u003c\u003c *it \u003c\u003c std::endl; } return 0; } JavaScript语言：ES6中新增了迭代器协议，使得遍历和访问集合元素变得更加方便。 script // 可迭代对象实现可迭代协议 class IterableObject { constructor() { this.elements = []; } addElement(element) { this.elements.push(element); } [Symbol.iterator]() { let index = 0; // 迭代器对象实现迭代器协议 return { next: () =\u003e { if (index \u003c this.elements.length) { return { value: this.elements[index++], done: false }; } else { return { done: true }; } } }; } } // 使用迭代器遍历可迭代对象 const iterableObject = new IterableObject(); iterableObject.addElement(\"Element 1\"); iterableObject.addElement(\"Element 2\"); iterableObject.addElement(\"Element 3\"); for (const element of iterableObject) { console.log(element); } 本题代码 link import java.util.ArrayList; import java.util.List; import java.util.Scanner; // 可迭代对象接口 interface StudentCollection { java.util.Iterator iterator(); } // 具体可迭代对象 class ConcreteStudentCollection implements StudentCollection { private List students = new ArrayList\u003c\u003e(); public void addStudent(Student student) { students.add(student); } @Override public java.util.Iterator iterator() { return new ConcreteStudentIterator(students); } } // 迭代器接口 interface Iterator { boolean hasNext(); T next(); } // 具体迭代器 class ConcreteStudentIterator implements java.util.Iterator { private List students; private int currentIndex = 0; public ConcreteStudentIterator(List students) { this.students = students; } @Override public boolean hasNext() { return currentIndex \u003c students.size(); } @Override public Student next() { if (hasNext()) { Student student = students.get(currentIndex); currentIndex++; return student; } return null; } } // 学生类 class Student { private String name; private String studentId; public Student(String name, String studentId) { this.name = name; this.studentId = studentId; } public String getName() { return name; } public String getStudentId() { return studentId; } } public class Main { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); // 读取学生数量 int n = scanner.nextInt(); scanner.nextLine(); // 读取换行符 // 创建具体可迭代对象 ConcreteStudentCollection studentCollection = new ConcreteStudentCollection(); // 读取学生信息并添加到集合 for (int i = 0; i \u003c n; i++) { String[] input = scanner.nextLine().split(\" \"); if (input.length == 2) { String name = input[0]; String studentId = input[1]; Student student = new Student(name, studentId); studentCollection.addStudent(student); } else { System.out.println(\"Invalid input\"); return; } } // 使用迭代器遍历学生集合 java.util.Iterator iterator = studentCollection.iterator(); while (iterator.hasNext()) { Student student = iterator.next(); System.out.println(student.getName() + \" \" + student.getStudentId()); } } } 其他版本代码 linkJava linkJava 内置的 List 接口的 iterator() 方法实现。 import java.util.*; // 学生类 class Student { String name; String id; Student(String name, String id) { this.name = name; this.id = id; } String getInfo() { return name + \" \" + id; } } // 学生列表系统 class StudentListSystem { private List students = new ArrayList\u003c\u003e(); void addStudent(String name, String id) { students.add(new Student(name, id)); } Iterator iterator() { return students.iterator(); } } public class Main { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); StudentListSystem studentList = new StudentListSystem(); int n = scanner.nextInt(); scanner.nextLine(); for (int i = 0; i \u003c n; i++) { String[] s = scanner.nextLine().split(\" \"); studentList.addStudent(s[0], s[1]); } Iterator iterator = studentList.iterator(); while (iterator.hasNext()) { Student student = iterator.next(); System.out.println(student.getInfo()); } scanner.close(); } } C++ link #include #include // 学生类 class Student { public: Student(const std::string\u0026 name, const std::string\u0026 studentId) : name(name), studentId(studentId) {} std::string getName() const { return name; } std::string getStudentId() const { return studentId; } private: std::string name; std::string studentId; }; // 可迭代对象接口 class StudentCollection { public: virtual ~StudentCollection() = default; virtual std::vector::iterator begin() = 0; virtual std::vector::iterator end() = 0; }; // 具体可迭代对象 class ConcreteStudentCollection : public StudentCollection { public: void addStudent(const Student\u0026 student) { students.push_back(student); } std::vector::iterator begin() override { return students.begin(); } std::vector::iterator end() override { return students.end(); } private: std::vector students; }; int main() { int n; std::cin \u003e\u003e n; std::cin.ignore(); // 忽略换行符 ConcreteStudentCollection studentCollection; for (int i = 0; i \u003c n; ++i) { std::string name, studentId; std::cin \u003e\u003e name \u003e\u003e studentId; studentCollection.addStudent(Student(name, studentId)); } // 使用迭代器遍历学生集合 for (auto it = studentCollection.begin(); it != studentCollection.end(); ++it) { const Student\u0026 student = *it; std::cout \u003c\u003c student.getName() \u003c\u003c \" \" \u003c\u003c student.getStudentId() \u003c\u003c std::endl; } return 0; } Python link class Student: def __init__(self, name, student_id): self.name = name self.student_id = student_id def get_name(self): return self.name def get_student_id(self): return self.student_id class StudentCollection: def __init__(self): self.students = [] def add_student(self, student): self.students.append(student) def __iter__(self): return iter(self.students) def main(): n = int(input()) student_collection = StudentCollection() for _ in range(n): inputs = input().split() if len(inputs) == 2: name, student_id = inputs student = Student(name, student_id) student_collection.add_student(student) else: print(\"Invalid input\") return # 使用迭代器遍历学生集合 for student in student_collection: print(student.get_name(), student.get_student_id()) if __name__ == \"__main__\": main() Go link package main import ( \"fmt\" \"bufio\" \"os\" \"strings\" ) // 可迭代对象接口 type StudentCollection interface { Iterator() Iterator } // 具体可迭代对象 type ConcreteStudentCollection struct { students []Student } func NewConcreteStudentCollection() *ConcreteStudentCollection { return \u0026ConcreteStudentCollection{ students: make([]Student, 0), } } func (c *ConcreteStudentCollection) AddStudent(student Student) { c.students = append(c.students, student) } func (c *ConcreteStudentCollection) Iterator() Iterator { return NewConcreteStudentIterator(c.students) } // 迭代器接口 type Iterator interface { HasNext() bool Next() Student } // 具体迭代器 type ConcreteStudentIterator struct { students []Student currentIndex int } func NewConcreteStudentIterator(students []Student) *ConcreteStudentIterator { return \u0026ConcreteStudentIterator{ students: students, currentIndex: 0, } } func (i *ConcreteStudentIterator) HasNext() bool { return i.currentIndex \u003c len(i.students) } func (i *ConcreteStudentIterator) Next() Student { if i.HasNext() { student := i.students[i.currentIndex] i.currentIndex++ return student } return Student{} } // 学生类 type Student struct { Name string StudentID string } // 主函数 func main() { scanner := bufio.NewScanner(os.Stdin) // 读取学生数量 scanner.Scan() n := 0 fmt.Sscanf(scanner.Text(), \"%d\", \u0026n) // 创建具体可迭代对象 studentCollection := NewConcreteStudentCollection() // 读取学生信息并添加到集合 for i := 0; i \u003c n; i++ { scanner.Scan() input := strings.Fields(scanner.Text()) if len(input) == 2 { name := input[0] studentID := input[1] student := Student{Name: name, StudentID: studentID} studentCollection.AddStudent(student) } else { fmt.Println(\"Invalid input\") return } } // 使用迭代器遍历学生集合 iterator := studentCollection.Iterator() for iterator.HasNext() { student := iterator.Next() fmt.Printf(\"%s %s\\n\", student.Name, student.StudentID) } } "
            }
        );
    index.add(
            {
                id:  29 ,
                href: "\/docs\/dev\/23designpattern\/20.%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F\/",
                title: "20.状态模式",
                description: "状态模式（State Pattern）是一种行为型设计模式，它适用于一个对象在在不同的状态下有不同的行为时，比如说电灯的开、关、闪烁是不停的状态，状态不同时，对应的行为也不同，在没有状态模式的情况下，为了添加新的状态或修改现有的状态，往往**需要修改已有的代码**，这违背了开闭原则，而且如果对象的状态切换逻辑和各个状态的行为都在同一个类中实现，就可能导致该类的职责过重，不符合单一职责原则。",
                content: "需求 link【设计模式专题之状态模式】20-开关台灯\n题目描述\n小明家有一个灯泡，刚开始为关闭状态（OffState）。台灯可以接收一系列的指令，包括打开（“ON”）、关闭（“OFF”）和闪烁（“blink”）。每次接收到一个指令后，台灯会执行相应的操作，并输出当前灯泡的状态。请设计一个程序模拟这个灯泡系统。 输入描述\n第一行是一个整数 n（1 \u003c= n \u003c= 1000），表示接收的命令数量。 接下来的 n 行，每行包含一个字符串 s，表示一个命令（“ON”、“OFF\"或\"blink”）。 输出描述\n对于每个命令，输出一行，表示执行该命令后灯泡的状态。 输入示例 5 ON OFF BLINK OFF ON 输出示例 Light is ON Light is OFF Light is Blinking Light is OFF Light is ON 基本结构 link状态模式（State Pattern）是一种行为型设计模式，它适用于一个对象在在不同的状态下有不同的行为时，比如说电灯的开、关、闪烁是不停的状态，状态不同时，对应的行为也不同，在没有状态模式的情况下，为了添加新的状态或修改现有的状态，往往需要修改已有的代码，这违背了开闭原则，而且如果对象的状态切换逻辑和各个状态的行为都在同一个类中实现，就可能导致该类的职责过重，不符合单一职责原则。\n而状态模式将每个状态的行为封装在一个具体状态类中，使得每个状态类相对独立，并将对象在不同状态下的行为进行委托，从而使得对象的状态可以在运行时动态改变，每个状态的实现也不会影响其他状态。\n基本结构： link状态模式包括以下几个重要角色：\nState（状态）： 定义一个接口，用于封装与Context的一个特定状态相关的行为。\nConcreteState（具体状态）： 负责处理Context在状态改变时的行为, 每一个具体状态子类实现一个与Context的一个状态相关的行为。\nContext（上下文）: 维护一个具体状态子类的实例，这个实例定义当前的状态。\n基本使用 link 定义状态接口：创建一个状态接口，该接口声明了对象可能的各种状态对应的方法。 // 状态接口 public interface State { void handle(); } 实现具体状态类： 为对象可能的每种状态创建具体的状态类，实现状态接口中定义的方法。 // 具体状态类1 public class ConcreteState1 implements State { @Override public void handle() { // 执行在状态1下的操作 } } // 具体状态类2 public class ConcreteState2 implements State { @Override public void handle() { // 执行在状态2下的操作 } } 创建上下文类：该类包含对状态的引用，并在需要时调用当前状态的方法。 // 上下文类 public class Context { private State currentState; public void setState(State state) { this.currentState = state; } public void request() { currentState.handle(); } } 客户端使用：创建具体的状态对象和上下文对象，并通过上下文对象调用相应的方法。通过改变状态，可以改变上下文对象的行为 public class Client { public static void main(String[] args) { Context context = new Context(); State state1 = new ConcreteState1(); State state2 = new ConcreteState2(); context.setState(state1); context.request(); // 执行在状态1下的操作 context.setState(state2); context.request(); // 执行在状态2下的操作 } } 使用场景 link状态模式将每个状态的实现都封装在一个类中，每个状态类的实现相对独立，使得添加新状态或修改现有状态变得更加容易，避免了使用大量的条件语句来控制对象的行为。但是如果状态过多，会导致类的数量增加，可能会使得代码结构复杂。\n总的来说，状态模式适用于有限状态机的场景，其中对象的行为在运行时可以根据内部状态的改变而改变，在游戏开发中，Unity3D 的 Animator 控制器就是一个状态机。它允许开发人员定义不同的状态（动画状态），并通过状态转换来实现角色的动画控制和行为切换。\n本题代码 link import java.util.Scanner; // 状态接口 interface State { String handle(); // // 处理状态的方法 } // 具体状态类 class OnState implements State { @Override public String handle() { return \"Light is ON\"; } } class OffState implements State { @Override public String handle() { return \"Light is OFF\"; } } class BlinkState implements State { @Override public String handle() { return \"Light is Blinking\"; } } // 上下文类 class Light { private State state; // 当前状态 public Light() { this.state = new OffState(); // 初始状态为关闭 } public void setState(State state) { // 设置新的状态 this.state = state; } public String performOperation() { // 执行当前状态的操作 return state.handle(); } } public class Main { public static void main(String[] args) { // 创建一个Scanner对象以读取用户输入 Scanner scanner = new Scanner(System.in); int n = scanner.nextInt(); scanner.nextLine(); Light light = new Light(); // 处理用户输入 for (int i = 0; i \u003c n; i++) { String command = scanner.nextLine().trim(); // 根据输入修改灯的状态 switch (command) { case \"ON\": light.setState(new OnState()); break; case \"OFF\": light.setState(new OffState()); break; case \"BLINK\": light.setState(new BlinkState()); break; default: System.out.println(\"Invalid command: \" + command); break; } // 显示灯的当前状态 System.out.println(light.performOperation()); } } } 其他语言版本 linkC++ link #include #include #include // 状态接口 class State { public: virtual std::string handle() = 0; // 处理状态的方法 }; // 具体状态类 class OnState : public State { public: std::string handle() override { return \"Light is ON\"; } }; class OffState : public State { public: std::string handle() override { return \"Light is OFF\"; } }; class BlinkState : public State { public: std::string handle() override { return \"Light is Blinking\"; } }; // 上下文类 class Light { private: State* state; // 当前状态 public: Light() : state(new OffState()) {} // 初始状态为关闭 void setState(State* newState) { // 设置新的状态 delete state; // 释放之前的状态对象 state = newState; } std::string performOperation() { // 执行当前状态的操作 return state-\u003ehandle(); } ~Light() { delete state; // 释放内存 } }; int main() { // 读取要输入的命令数量 int n; std::cin \u003e\u003e n; std::cin.ignore(); // 消耗掉整数后的换行符 // 创建一个Light对象 Light light; // 处理用户输入的每个命令 for (int i = 0; i \u003c n; i++) { // 读取命令并去掉首尾空白字符 std::string command; std::getline(std::cin, command); // 根据命令执行相应的操作 if (command == \"ON\") { light.setState(new OnState()); } else if (command == \"OFF\") { light.setState(new OffState()); } else if (command == \"BLINK\") { light.setState(new BlinkState()); } else { // 处理无效命令 std::cout \u003c\u003c \"Invalid command: \" \u003c\u003c command \u003c\u003c std::endl; } // 在每个命令后显示灯的当前状态 std::cout \u003c\u003c light.performOperation() \u003c\u003c std::endl; } return 0; } Python link # 状态接口 class State: def handle(self): pass # 具体状态类 class OnState(State): def handle(self): return \"Light is ON\" class OffState(State): def handle(self): return \"Light is OFF\" class BlinkState(State): def handle(self): return \"Light is Blinking\" # 上下文类 class Light: def __init__(self): self.state = OffState() # 初始状态为关闭 def set_state(self, new_state): self.state = new_state # 设置新的状态 def perform_operation(self): return self.state.handle() # 执行当前状态的操作 # 处理用户输入 def main(): # 读取要输入的命令数量 n = int(input().strip()) # 创建一个Light对象 light = Light() # 处理用户输入的每个命令 for _ in range(n): # 读取命令并去掉首尾空白字符 command = input().strip() # 根据命令执行相应的操作 if command == \"ON\": light.set_state(OnState()) elif command == \"OFF\": light.set_state(OffState()) elif command == \"BLINK\": light.set_state(BlinkState()) else: # 处理无效命令 print(\"Invalid command:\", command) # 在每个命令后显示灯的当前状态 print(light.perform_operation()) if __name__ == \"__main__\": main() Go link package main import ( \"fmt\" \"bufio\" \"os\" \"strings\" ) // 状态接口 type State interface { Handle() string // 处理状态的方法 } // 具体状态类 type OnState struct{} func (s *OnState) Handle() string { return \"Light is ON\" } type OffState struct{} func (s *OffState) Handle() string { return \"Light is OFF\" } type BlinkState struct{} func (s *BlinkState) Handle() string { return \"Light is Blinking\" } // 上下文类 type Light struct { state State // 当前状态 } func NewLight() *Light { return \u0026Light{state: \u0026OffState{}} // 初始状态为关闭 } func (l *Light) SetState(state State) { // 设置新的状态 l.state = state } func (l *Light) PerformOperation() string { // 执行当前状态的操作 return l.state.Handle() } // 主函数 func main() { scanner := bufio.NewScanner(os.Stdin) // 读取用户输入 scanner.Scan() var n int fmt.Sscanf(scanner.Text(), \"%d\", \u0026n) light := NewLight() // 处理用户输入 for i := 0; i \u003c n; i++ { scanner.Scan() command := strings.TrimSpace(scanner.Text()) // 根据输入修改灯的状态 switch command { case \"ON\": light.SetState(\u0026OnState{}) case \"OFF\": light.SetState(\u0026OffState{}) case \"BLINK\": light.SetState(\u0026BlinkState{}) default: fmt.Println(\"Invalid command:\", command) continue } // 显示灯的当前状态 fmt.Println(light.PerformOperation()) } } "
            }
        );
    index.add(
            {
                id:  30 ,
                href: "\/docs\/dev\/23designpattern\/21.%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F\/",
                title: "21.责任链模式",
                description: "责任链模式是一种行为型设计模式，它允许你构建一个对象链，让请求从链的一端进入，然后沿着链上的对象依次处理，直到链上的某个对象能够处理该请求为止。",
                content: "需求 link【设计模式专题之责任链模式】21-请假审批\n题目描述\n小明所在的公司请假需要在OA系统上发布申请，整个请求流程包括多个处理者，每个处理者负责处理不同范围的请假天数，如果一个处理者不能处理请求，就会将请求传递给下一个处理者，请你实现责任链模式，可以根据请求天数找到对应的处理者。 审批责任链由主管(Supervisor), 经理(Manager)和董事（Director)组成，他们分别能够处理3天、7天和10天的请假天数。如果超过10天，则进行否决。 输入描述\n第一行是一个整数N（1 \u003c= N \u003c= 100), 表示请求申请的数量。 接下来的N行，每行包括一个请求申请的信息，格式为\"姓名 请假天数\" 输出描述\n对于每个请假请求，输出一行，表示该请求是否被批准。如果被批准/否决，输出被哪一个职级的人批准/否决。 输入示例 4 Alice 2 Bob 5 Tom 10 Jerry 12 输出示例 Alice Approved by Supervisor. Bob Approved by Manager. Tom Approved by Director. Jerry Denied by Director. 基本概念 link责任链模式是一种行为型设计模式，它允许你构建一个对象链，让请求从链的一端进入，然后沿着链上的对象依次处理，直到链上的某个对象能够处理该请求为止。\n职责链上的处理者就是一个对象，可以对请求进行处理或者将请求转发给下一个节点，这个场景在生活中很常见，就是一个逐层向上递交的过程，最终的请求要么被处理者所处理，要么处理不了，这也因此可能导致请求无法被处理。\n组成结构 link责任链模式包括以下几个基本结构：\n处理者Handler ：定义一个处理请求的接口，包含一个处理请求的抽象方法和一个指向下一个处理者的链接。 具体处理者ConcreteHandler: 实现处理请求的方法，并判断能否处理请求，如果能够处理请求则进行处理，否则将请求传递给下一个处理者。 客户端：创建并组装处理者对象链，并将请求发送到链上的第一个处理者。 简易实现 link 处理者：定义处理请求的接口 interface Handler { // 处理请求的方法 void handleRequest(double amount); // 设置下一个处理者的方法 void setNextHandler(Handler nextHandler); } 具体处理者：实现处理请求 class ConcreteHandler implements Handler { private Handler nextHandler; @Override public void handleRequest(Request request) { // 根据具体情况处理请求，如果无法处理则交给下一个处理者 if (canHandle(request)) { // 处理请求的逻辑 } else if (nextHandler != null) { // 交给下一个处理者处理 nextHandler.handleRequest(request); } else { // 无法处理请求的逻辑 } } @Override public void setNextHandler(Handler nextHandler) { this.nextHandler = nextHandler; } // 具体处理者自己的判断条件 private boolean canHandle(Request request) { // 根据具体情况判断是否能够处理请求 return /* 判断条件 */; } } 客户端创建并组装处理者对象链，将请求发送给链上第一个处理者 public class Main { public static void main(String[] args) { // 创建处理者实例 Handler handler1 = new ConcreteHandler(); Handler handler2 = new ConcreteHandler(); // ... // 构建责任链 handler1.setNextHandler(handler2); // ... // 发送请求 Request request = new Request(/* 请求参数 */); handler1.handleRequest(request); } } 使用场景 link责任链模式具有下面几个优点：\n降低耦合度：将请求的发送者和接收者解耦，每个具体处理者都只负责处理与自己相关的请求，客户端不需要知道具体是哪个处理者处理请求。 增强灵活性：可以动态地添加或删除处理者，改变处理者之间的顺序以满足不同需求。 但是由于一个请求可能会经过多个处理者，这可能会导致一些性能问题，并且如果整个链上也没有合适的处理者来处理请求，就会导致请求无法被处理。\n责任链模式是设计模式中简单且常见的设计模式，在日常中也会经常使用到，比如Java开发中过滤器的链式处理，以及Spring框架中的拦截器，都组装成一个处理链对请求、响应进行处理。\n本题代码 link import java.util.Scanner; // 处理者：定义接口 interface LeaveHandler { void handleRequest(LeaveRequest request); } // 具体处理者：可以有多个，负责具体处理，这里分为 Supervisor、Manager、Director class Supervisor implements LeaveHandler { private static final int MAX_DAYS_SUPERVISOR_CAN_APPROVE = 3; private LeaveHandler nextHandler; public Supervisor(LeaveHandler nextHandler) { this.nextHandler = nextHandler; } @Override public void handleRequest(LeaveRequest request) { if (request.getDays() \u003c= MAX_DAYS_SUPERVISOR_CAN_APPROVE) { System.out.println(request.getName() + \" Approved by Supervisor.\"); } else if (nextHandler != null) { nextHandler.handleRequest(request); } else { System.out.println(request.getName() + \" Denied by Supervisor.\"); } } } class Manager implements LeaveHandler { private static final int MAX_DAYS_MANAGER_CAN_APPROVE = 7; private LeaveHandler nextHandler; public Manager(LeaveHandler nextHandler) { this.nextHandler = nextHandler; } @Override public void handleRequest(LeaveRequest request) { if (request.getDays() \u003c= MAX_DAYS_MANAGER_CAN_APPROVE) { System.out.println(request.getName() + \" Approved by Manager.\"); } else if (nextHandler != null) { nextHandler.handleRequest(request); } else { System.out.println(request.getName() + \" Denied by Manager.\"); } } } class Director implements LeaveHandler { private static final int MAX_DAYS_DIRECTOR_CAN_APPROVE = 10; @Override public void handleRequest(LeaveRequest request) { if (request.getDays() \u003c= MAX_DAYS_DIRECTOR_CAN_APPROVE) { System.out.println(request.getName() + \" Approved by Director.\"); } else { System.out.println(request.getName() + \" Denied by Director.\"); } } } // 请求类 class LeaveRequest { private String name; private int days; public LeaveRequest(String name, int days) { this.name = name; this.days = days; } public String getName() { return name; } public int getDays() { return days; } } public class Main { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); int n = scanner.nextInt(); scanner.nextLine(); // 组装职责链 LeaveHandler director = new Director(); LeaveHandler manager = new Manager(director); LeaveHandler supervisor = new Supervisor(manager); for (int i = 0; i \u003c n; i++) { String[] input = scanner.nextLine().split(\" \"); if (input.length == 2) { String name = input[0]; int days = Integer.parseInt(input[1]); LeaveRequest request = new LeaveRequest(name, days); supervisor.handleRequest(request); } else { System.out.println(\"Invalid input\"); return; } } } } 其他语言版本 linkJava link使用枚举封装了请求级别的逻辑，方便未来的修改和扩展。\nimport java.util.Scanner; // 抽象处理器类，定义了责任链的基本结构 abstract class Handler { public final static int SUPERVISOR_LEVEL_REQUEST = 1; public final static int MANAGER_LEVEL_REQUEST = 2; public final static int DIRECTOR_LEVEL_REQUEST = 3; private Handler nextHandler; private int level = 0; // 构造函数，设置处理器的级别 public Handler(int _level) { this.level = _level; } // 处理请求的方法 public final Response handleMessage(Request request) { if (this.level == request.getRequestLevel()) { return this.response(request); } else { if (this.nextHandler != null) { return this.nextHandler.handleMessage(request); } else { return new Response(\"Request denied\"); } } } // 设置下一个处理器 public void setNext(Handler _handler) { this.nextHandler = _handler; } protected abstract Response response(Request request); } // 主管处理 class SupervisorHandler extends Handler { public SupervisorHandler() { super(Handler.SUPERVISOR_LEVEL_REQUEST); } @Override protected Response response(Request request) { System.out.println(request.getName() + \" Approved by Supervisor.\"); return new Response(\"Approved by Supervisor\"); } } // 经理处理 class ManagerHandler extends Handler { public ManagerHandler() { super(Handler.MANAGER_LEVEL_REQUEST); } @Override protected Response response(Request request) { System.out.println(request.getName() + \" Approved by Manager.\"); return new Response(\"Approved by Manager\"); } } // 董事处理 class DirectorHandler extends Handler { public DirectorHandler() { super(Handler.DIRECTOR_LEVEL_REQUEST); } @Override protected Response response(Request request) { System.out.println(request.getName() + \" Approved by Director.\"); return new Response(\"Approved by Director\"); } } // 请求级别的枚举，定义了不同级别的请假天数范围 enum RequestLevel { SUPERVISOR(1, 3), MANAGER(4, 5), DIRECTOR(6, 10); private final int minDays; private final int maxDays; RequestLevel(int minDays, int maxDays) { this.minDays = minDays; this.maxDays = maxDays; } // 根据天数确定请求级别 public static RequestLevel fromDays(int days) { for (RequestLevel level : values()) { if (days \u003e= level.minDays \u0026\u0026 days \u003c= level.maxDays) { return level; } } return null; } public int getValue() { return ordinal() + 1; } } // 请求类，包含请求的详细信息 class Request { private String name; private int level; private int nums; public Request(String name, int nums) { this.name = name; this.nums = nums; RequestLevel requestLevel = RequestLevel.fromDays(nums); this.level = (requestLevel != null) ? requestLevel.getValue() : -1; } public int getRequestLevel() { return this.level; } public String getName() { return this.name; } public int getNums() { return this.nums; } } // 响应类，包含处理结果 class Response { private String message; public Response(String message) { this.message = message; } public String getMessage() { return this.message; } } // 主类 public class Main { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); // 创建处理器链 SupervisorHandler supervisorHandler = new SupervisorHandler(); ManagerHandler managerHandler = new ManagerHandler(); DirectorHandler directorHandler = new DirectorHandler(); // 设置处理器链的顺序 supervisorHandler.setNext(managerHandler); managerHandler.setNext(directorHandler); int n = scanner.nextInt(); scanner.nextLine(); // 处理每个请求 while (n-- \u003e 0) { String[] s = scanner.nextLine().split(\" \"); Request request = new Request(s[0], Integer.parseInt(s[1])); Response response = supervisorHandler.handleMessage(request); if (request.getRequestLevel() == -1) { System.out.println(request.getName() + \" Denied by Director.\"); } } scanner.close(); } } C++ link #include #include class LeaveHandler { public: virtual void handleRequest(const std::string\u0026 name, int days) = 0; }; class Supervisor : public LeaveHandler { private: static const int MAX_DAYS_SUPERVISOR_CAN_APPROVE = 3; LeaveHandler* nextHandler; public: Supervisor(LeaveHandler* nextHandler) : nextHandler(nextHandler) {} void handleRequest(const std::string\u0026 name, int days) override { if (days \u003c= MAX_DAYS_SUPERVISOR_CAN_APPROVE) { std::cout \u003c\u003c name \u003c\u003c \" Approved by Supervisor.\" \u003c\u003c std::endl; } else if (nextHandler != nullptr) { nextHandler-\u003ehandleRequest(name, days); } else { std::cout \u003c\u003c name \u003c\u003c \" Denied by Supervisor.\" \u003c\u003c std::endl; } } }; class Manager : public LeaveHandler { private: static const int MAX_DAYS_MANAGER_CAN_APPROVE = 7; LeaveHandler* nextHandler; public: Manager(LeaveHandler* nextHandler) : nextHandler(nextHandler) {} void handleRequest(const std::string\u0026 name, int days) override { if (days \u003c= MAX_DAYS_MANAGER_CAN_APPROVE) { std::cout \u003c\u003c name \u003c\u003c \" Approved by Manager.\" \u003c\u003c std::endl; } else if (nextHandler != nullptr) { nextHandler-\u003ehandleRequest(name, days); } else { std::cout \u003c\u003c name \u003c\u003c \" Denied by Manager.\" \u003c\u003c std::endl; } } }; class Director : public LeaveHandler { private: static const int MAX_DAYS_DIRECTOR_CAN_APPROVE = 10; public: void handleRequest(const std::string\u0026 name, int days) override { if (days \u003c= MAX_DAYS_DIRECTOR_CAN_APPROVE) { std::cout \u003c\u003c name \u003c\u003c \" Approved by Director.\" \u003c\u003c std::endl; } else { std::cout \u003c\u003c name \u003c\u003c \" Denied by Director.\" \u003c\u003c std::endl; } } }; class LeaveRequest { private: std::string name; int days; public: LeaveRequest(const std::string\u0026 name, int days) : name(name), days(days) {} std::string getName() const { return name; } int getDays() const { return days; } }; int main() { int n; std::cin \u003e\u003e n; std::cin.ignore(); LeaveHandler* director = new Director(); LeaveHandler* manager = new Manager(director); LeaveHandler* supervisor = new Supervisor(manager); for (int i = 0; i \u003c n; i++) { std::string input; std::getline(std::cin, input); std::istringstream iss(input); std::string name; int days; if (iss \u003e\u003e name \u003e\u003e days) { LeaveRequest request(name, days); supervisor-\u003ehandleRequest(name, days); } else { std::cout \u003c\u003c \"Invalid input\" \u003c\u003c std::endl; return 1; } } delete supervisor; delete manager; delete director; return 0; } Python link class LeaveHandler: def handle_request(self, name, days): pass class Supervisor(LeaveHandler): MAX_DAYS_SUPERVISOR_CAN_APPROVE = 3 def __init__(self, next_handler=None): self.next_handler = next_handler def handle_request(self, name, days): if days \u003c= self.MAX_DAYS_SUPERVISOR_CAN_APPROVE: print(f\"{name} Approved by Supervisor.\") elif self.next_handler: self.next_handler.handle_request(name, days) else: print(f\"{name} Denied by Supervisor.\") class Manager(LeaveHandler): MAX_DAYS_MANAGER_CAN_APPROVE = 7 def __init__(self, next_handler=None): self.next_handler = next_handler def handle_request(self, name, days): if days \u003c= self.MAX_DAYS_MANAGER_CAN_APPROVE: print(f\"{name} Approved by Manager.\") elif self.next_handler: self.next_handler.handle_request(name, days) else: print(f\"{name} Denied by Manager.\") class Director(LeaveHandler): MAX_DAYS_DIRECTOR_CAN_APPROVE = 10 def handle_request(self, name, days): if days \u003c= self.MAX_DAYS_DIRECTOR_CAN_APPROVE: print(f\"{name} Approved by Director.\") else: print(f\"{name} Denied by Director.\") class LeaveRequest: def __init__(self, name, days): self.name = name self.days = days def get_name(self): return self.name def get_days(self): return self.days if __name__ == \"__main__\": n = int(input()) director = Director() manager = Manager(director) supervisor = Supervisor(manager) for _ in range(n): input_data = input().split() if len(input_data) == 2: name, days = input_data days = int(days) request = LeaveRequest(name, days) supervisor.handle_request(name, days) else: print(\"Invalid input\") exit(1) Go link package main import ( \"fmt\" \"bufio\" \"os\" \"strconv\" \"strings\" ) // 处理者：定义接口 type LeaveHandler interface { HandleRequest(request LeaveRequest) } // 具体处理者：可以有多个，负责具体处理，这里分为 Supervisor、Manager、Director type Supervisor struct { nextHandler LeaveHandler } const maxDaysSupervisorCanApprove = 3 func NewSupervisor(nextHandler LeaveHandler) *Supervisor { return \u0026Supervisor{nextHandler: nextHandler} } func (s *Supervisor) HandleRequest(request LeaveRequest) { if request.Days \u003c= maxDaysSupervisorCanApprove { fmt.Println(request.Name + \" Approved by Supervisor.\") } else if s.nextHandler != nil { s.nextHandler.HandleRequest(request) } else { fmt.Println(request.Name + \" Denied by Supervisor.\") } } type Manager struct { nextHandler LeaveHandler } const maxDaysManagerCanApprove = 7 func NewManager(nextHandler LeaveHandler) *Manager { return \u0026Manager{nextHandler: nextHandler} } func (m *Manager) HandleRequest(request LeaveRequest) { if request.Days \u003c= maxDaysManagerCanApprove { fmt.Println(request.Name + \" Approved by Manager.\") } else if m.nextHandler != nil { m.nextHandler.HandleRequest(request) } else { fmt.Println(request.Name + \" Denied by Manager.\") } } type Director struct{} const maxDaysDirectorCanApprove = 10 func (d *Director) HandleRequest(request LeaveRequest) { if request.Days \u003c= maxDaysDirectorCanApprove { fmt.Println(request.Name + \" Approved by Director.\") } else { fmt.Println(request.Name + \" Denied by Director.\") } } // 请求类 type LeaveRequest struct { Name string Days int } // 主函数 func main() { scanner := bufio.NewScanner(os.Stdin) // 读取用户输入 scanner.Scan() var n int fmt.Sscanf(scanner.Text(), \"%d\", \u0026n) // 组装职责链 director := \u0026Director{} manager := NewManager(director) supervisor := NewSupervisor(manager) for i := 0; i \u003c n; i++ { scanner.Scan() input := strings.Fields(scanner.Text()) if len(input) == 2 { name := input[0] days, err := strconv.Atoi(input[1]) if err != nil { fmt.Println(\"Invalid input\") return } request := LeaveRequest{Name: name, Days: days} supervisor.HandleRequest(request) } else { fmt.Println(\"Invalid input\") return } } } "
            }
        );
    index.add(
            {
                id:  31 ,
                href: "\/docs\/dev\/23designpattern\/22.%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F\/",
                title: "22.解释器模式",
                description: "解释器模式（Interpreter Pattern）是一种行为型设计模式，它定义了一个语言的文法，并且建立一个【解释器】来解释该语言中的句子。",
                content: "需求 link【设计模式专题之解释器模式】22-数学表达式\n题目描述\n小明正在设计一个计算器，用于解释用户输入的简单数学表达式，每个表达式都是由整数、加法操作符+、乘法操作符组成的，表达式中的元素之间用空格分隔，请你使用解释器模式帮他实现这个系统。 输入描述\n每行包含一个数学表达式，表达式中包含整数、加法操作符（+）和乘法操作符（*）。 表达式中的元素之间用空格分隔。 输出描述\n对于每个输入的数学表达式，每行输出一个整数，表示对应表达式的计算结果。 输入示例 2 + 3 5 * 2 3 + 4 * 2 输出示例 5 10 11 基本概念 link解释器模式（Interpreter Pattern）是一种行为型设计模式，它定义了一个语言的文法，并且建立一个【解释器】来解释该语言中的句子。\n比如说SQL语法、正则表达式，这些内容比较简短，但是表达的内容可不仅仅是字面上的那些符号，计算机想要理解这些语法，就需要解释这个语法规则，因此解释器模式常用于实现编程语言解释器、正则表达式处理等场景。\n组成结构 link解释器模式主要包含以下几个角色：\n抽象表达式（Abstract Expression）： 定义了解释器的接口，包含了解释器的方法 interpret。 终结符表达式（Terminal Expression）： 在语法中不能再分解为更小单元的符号。 非终结符表达式（Non-terminal Expression）： 文法中的复杂表达式，它由终结符和其他非终结符组成。 上下文（Context）： 包含解释器之外的一些全局信息，可以存储解释器中间结果，也可以用于向解释器传递信息。 举例来说，表达式 “3 + 5 * 2”，数字 “3” 和 “5”， “2” 是终结符，而运算符 “+”, “*“都需要两个操作数, 属于非终结符。\n简易实现 link 创建抽象表达式接口： 定义解释器的接口，声明一个 interpret 方法，用于解释语言中的表达式。 // 抽象表达式接口 public interface Expression { int interpret(); } 创建具体的表达式类： 实现抽象表达式接口，用于表示语言中的具体表达式。 public class TerminalExpression implements Expression { private int value; public TerminalExpression(int value) { this.value = value; } @Override public int interpret() { return value; } } 非终结符表达式：抽象表达式的一种，用于表示语言中的非终结符表达式，通常包含其他表达式。 public class AddExpression implements Expression { private Expression left; private Expression right; public AddExpression(Expression left, Expression right) { this.left = left; this.right = right; } @Override public int interpret() { return left.interpret() + right.interpret(); } } 上下文：包含解释器需要的一些全局信息或状态。 public class Context { // 可以在上下文中存储一些全局信息或状态 } 客户端：构建并组合表达式，然后解释表达式。 public class Main { public static void main(String[] args) { Context context = new Context(); Expression expression = new AddExpression( new TerminalExpression(1), new TerminalExpression(2) ); int result = expression.interpret(); System.out.println(\"Result: \" + result); } } 使用场景 link当需要解释和执行特定领域或业务规则的语言时，可以使用解释器模式。例如，SQL解释器、正则表达式解释器等。但是需要注意的是解释器模式可能会导致类的层次结构较为复杂，同时也可能不够灵活，使用要慎重。\n本题代码 link import java.util.Scanner; import java.util.Stack; // 抽象表达式接口 interface Expression { int interpret(); } // 终结符表达式类 - 数字 class NumberExpression implements Expression { private int number; public NumberExpression(int number) { this.number = number; } @Override public int interpret() { return number; } } // 非终结符表达式类 - 加法 class AddExpression implements Expression { private Expression left; private Expression right; public AddExpression(Expression left, Expression right) { this.left = left; this.right = right; } @Override public int interpret() { return left.interpret() + right.interpret(); } } // 非终结符表达式类 - 乘法 class MultiplyExpression implements Expression { private Expression left; private Expression right; public MultiplyExpression(Expression left, Expression right) { this.left = left; this.right = right; } @Override public int interpret() { return left.interpret() * right.interpret(); } } // 上下文类 class Context { private Stack expressionStack = new Stack\u003c\u003e(); public void pushExpression(Expression expression) { expressionStack.push(expression); } public Expression popExpression() { return expressionStack.pop(); } } public class Main{ public static void main(String[] args) { Scanner scanner = new Scanner(System.in); Context context = new Context(); // 处理用户输入的数学表达式 while (scanner.hasNextLine()) { String userInput = scanner.nextLine(); Expression expression = parseExpression(userInput); if (expression != null) { context.pushExpression(expression); System.out.println(expression.interpret()); } else { System.out.println(\"Invalid expression.\"); } } scanner.close(); } // 解析用户输入的数学表达式并返回相应的抽象表达式类 private static Expression parseExpression(String userInput) { try { Stack expressionStack = new Stack\u003c\u003e(); char[] tokens = userInput.toCharArray(); for (int i = 0; i \u003c tokens.length; i++) { char token = tokens[i]; if (Character.isDigit(token)) { expressionStack.push(new NumberExpression(Character.getNumericValue(token))); // 如果下一个字符不是数字，且栈中有两个以上的元素，说明可以进行运算 if (i + 1 \u003c tokens.length \u0026\u0026 !Character.isDigit(tokens[i + 1]) \u0026\u0026 expressionStack.size() \u003e= 2) { Expression right = expressionStack.pop(); Expression left = expressionStack.pop(); char operator = tokens[i + 1]; if (operator == '+') { expressionStack.push(new AddExpression(left, right)); } else if (operator == '*') { expressionStack.push(new MultiplyExpression(left, right)); } i++; // 跳过下一个字符，因为已经处理过了 } } else { return null; } } return expressionStack.pop(); } catch (Exception e) { return null; } } } 其他语言版本 linkC++ link #include #include #include #include #include #include #include // 抽象表达式类 class Expression { public: virtual int interpret() = 0; virtual ~Expression() {} }; // 终结符表达式类 - 数字 class NumberExpression : public Expression { private: int value; public: NumberExpression(int val) : value(val) {} int interpret() override { return value; } }; // 非终结符表达式类 - 加法操作 class AddExpression : public Expression { private: Expression* left; Expression* right; public: AddExpression(Expression* l, Expression* r) : left(l), right(r) {} int interpret() override { return left-\u003einterpret() + right-\u003einterpret(); } }; // 非终结符表达式类 - 乘法操作 class MultiplyExpression : public Expression { private: Expression* left; Expression* right; public: MultiplyExpression(Expression* l, Expression* r) : left(l), right(r) {} int interpret() override { return left-\u003einterpret() * right-\u003einterpret(); } }; // 非终结符表达式类 - 操作符 class OperatorExpression : public Expression { private: std::string oper; public: OperatorExpression(const std::string\u0026 op) : oper(op) {} int interpret() override { throw std::runtime_error(\"OperatorExpression does not support interpretation\"); } std::string getOperator() const { return oper; } }; // 解析表达式字符串 int parseExpression(const std::string\u0026 expressionStr) { std::istringstream iss(expressionStr); std::vector elements(std::istream_iterator{iss}, std::istream_iterator()); std::stack stack; for (const auto\u0026 element : elements) { if (std::regex_match(element, std::regex(\"\\\\d+\"))) { stack.push(new NumberExpression(std::stoi(element))); } else if (element == \"+\" || element == \"*\") { stack.push(new OperatorExpression(element)); } else { throw std::invalid_argument(\"Invalid element in expression: \" + element); } } while (stack.size() \u003e 1) { Expression* right = stack.top(); stack.pop(); Expression* operatorExp = stack.top(); stack.pop(); Expression* left = stack.top(); stack.pop(); if (auto* opExp = dynamic_cast(operatorExp)) { std::string op = opExp-\u003egetOperator(); if (op == \"+\") { stack.push(new AddExpression(left, right)); } else if (op == \"*\") { stack.push(new MultiplyExpression(left, right)); } } else { throw std::invalid_argument(\"Invalid operator type in expression\"); } } int result = stack.top()-\u003einterpret(); delete stack.top(); return result; } int main() { std::vector input_lines; std::string line; while (std::getline(std::cin, line) \u0026\u0026 !line.empty()) { input_lines.push_back(line); } for (size_t i = 0; i \u003c input_lines.size(); ++i) { try { int result = parseExpression(input_lines[i]); std::cout \u003c\u003c result \u003c\u003c std::endl; } catch (const std::exception\u0026 e) { std::cout \u003c\u003c \"Error - \" \u003c\u003c e.what() \u003c\u003c std::endl; } } return 0; } Python link # 抽象表达式类 class Expression: def interpret(self): pass # 终结符表达式类 - 数字 class NumberExpression(Expression): def __init__(self, value): self.value = int(value) def interpret(self): return self.value # 非终结符表达式类 - 加法操作 class AddExpression(Expression): def __init__(self, left, right): self.left = left self.right = right def interpret(self): return self.left.interpret() + self.right.interpret() # 非终结符表达式类 - 乘法操作 class MultiplyExpression(Expression): def __init__(self, left, right): self.left = left self.right = right def interpret(self): return self.left.interpret() * self.right.interpret() # 客户端代码 def parse_expression(expression_str): elements = expression_str.split() stack = [] for element in elements: if element.isdigit(): stack.append(NumberExpression(element)) elif element == '+': if len(stack) \u003c 2: raise ValueError(\"Invalid expression format\") right = stack.pop() left = stack.pop() stack.append(AddExpression(left, right)) elif element == '*': if len(stack) \u003c 2: raise ValueError(\"Invalid expression format\") right = stack.pop() left = stack.pop() stack.append(MultiplyExpression(left, right)) else: raise ValueError(f\"Invalid element in expression: {element}\") if len(stack) != 1: raise ValueError(\"Invalid expression format\") return str(stack.pop().interpret()) # 从标准输入读取输入 input_lines = [] while True: try: line = input().strip() if not line: break input_lines.append(line) except EOFError: break # 输出计算结果到标准输出 for i, input_line in enumerate(input_lines, start=1): try: result = parse_expression(input_line) print(f\"Case {i}: {result}\") except ValueError as e: print(f\"Case {i}: Error - {e}\") Go link package main import ( \"bufio\" \"fmt\" \"os\" \"regexp\" \"strconv\" \"strings\" ) // 抽象表达式类 type Expression interface { interpret() int } // 终结符表达式类 - 数字 type NumberExpression struct { value int } func NewNumberExpression(val int) *NumberExpression { return \u0026NumberExpression{value: val} } func (n *NumberExpression) interpret() int { return n.value } // 非终结符表达式类 - 加法操作 type AddExpression struct { left Expression right Expression } func NewAddExpression(left, right Expression) *AddExpression { return \u0026AddExpression{left, right} } func (a *AddExpression) interpret() int { return a.left.interpret() + a.right.interpret() } // 非终结符表达式类 - 乘法操作 type MultiplyExpression struct { left Expression right Expression } func NewMultiplyExpression(left, right Expression) *MultiplyExpression { return \u0026MultiplyExpression{left, right} } func (m *MultiplyExpression) interpret() int { return m.left.interpret() * m.right.interpret() } // 非终结符表达式类 - 操作符 type OperatorExpression struct { oper string } func NewOperatorExpression(op string) *OperatorExpression { return \u0026OperatorExpression{oper: op} } func (o *OperatorExpression) interpret() int { panic(\"OperatorExpression does not support interpretation\") } func (o *OperatorExpression) getOperator() string { return o.oper } // 解析表达式字符串 func parseExpression(expressionStr string) (int, error) { elements := strings.Fields(expressionStr) stack := make([]Expression, 0) for _, element := range elements { if regexp.MustCompile(`^\\d+$`).MatchString(element) { val, _ := strconv.Atoi(element) stack = append(stack, NewNumberExpression(val)) } else if element == \"+\" || element == \"*\" { stack = append(stack, NewOperatorExpression(element)) } else { return 0, fmt.Errorf(\"Invalid element in expression: %s\", element) } } for len(stack) \u003e 1 { right := stack[len(stack)-1] stack = stack[:len(stack)-1] operatorExp := stack[len(stack)-1] stack = stack[:len(stack)-1] left := stack[len(stack)-1] stack = stack[:len(stack)-1] if opExp, ok := operatorExp.(*OperatorExpression); ok { op := opExp.getOperator() if op == \"+\" { stack = append(stack, NewAddExpression(left, right)) } else if op == \"*\" { stack = append(stack, NewMultiplyExpression(left, right)) } } else { return 0, fmt.Errorf(\"Invalid operator type in expression\") } } result := stack[0].interpret() return result, nil } func main() { scanner := bufio.NewScanner(os.Stdin) for scanner.Scan() { expression := scanner.Text() if expression == \"\" { continue } result, err := parseExpression(expression) if err != nil { fmt.Printf(\"Error - %s\\n\", err) } else { fmt.Println(result) } } if err := scanner.Err(); err != nil { fmt.Println(\"Error reading standard input:\", err) } } "
            }
        );
    index.add(
            {
                id:  32 ,
                href: "\/docs\/dev\/23designpattern\/23.%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F\/",
                title: "23.访问者模式",
                description: "访问者模式（Visitor Pattern）是一种行为型设计模式，可以在不改变对象结构的前提下，对对象中的元素进行新的操作。",
                content: "需求 link【设计模式专题之访问者模式】23-图形的面积\n题目描述\n小明家有一些圆形和长方形面积的土地，请你帮他实现一个访问者模式，使得可以通过访问者计算每块土地的面积。 图形的面积计算规则如下： 圆形的面积计算公式为：3.14 * 半径 * 半径 矩形的面积计算公式为：长 * 宽 输入描述\n第一行是一个整数 n（1 \u003c= n \u003c= 1000），表示图形的数量。 接下来的 n 行，每行描述一个图形，格式为 “Circle r” 或 “Rectangle width height”，其中 r、width、height 是正整数。 输出描述\n对于每个图形，输出一行，表示该图形的面积。 输入示例 3 Circle 5 Rectangle 3 4 Circle 2 输出示例 78.5 12 12.56 基本概念 link访问者模式（Visitor Pattern）是一种行为型设计模式，可以在不改变对象结构的前提下，对对象中的元素进行新的操作。\n举个例子，假设有一个动物园，里面有不同种类的动物，比如狮子、大象、猴子等。每个动物都会被医生检查身体，被管理员投喂，被游客观看，医生，游客，管理员都属于访问者。\n// 定义动物接口 interface Animal { void accept(Visitor visitor); } // 具体元素类：狮子 class Lion implements Element { @Override public void accept(Visitor visitor) { visitor.visit(this); } } // 具体元素类：大象 class Elephant implements Element { @Override public void accept(Visitor visitor) { visitor.visit(this); } } // 具体元素类：猴子 class Monkey implements Element { @Override public void accept(Visitor visitor) { visitor.visit(this); } } 如果你想对动物园中的每个动物执行一些操作，比如医生健康检查、管理员喂食、游客观赏等。就可以使用访问者模式来实现这些操作。\n// 定义访问者接口 interface Visitor { void visit(Animal animal); } // 具体访问者类：医生 class Vet implements Visitor { @Override public void visit(Animal animal) { } } // 具体访问者类：管理员 class Zookeeper implements Visitor { @Override public void visit(Animal animal) { } } // 具体访问者类：游客 class VisitorPerson implements Visitor { @Override public void visit(Animal animal) { } } 将这些访问者应用到动物园的每个动物上\npublic class Main { public static void main(String[] args) { Animal lion = new Lion(); Animal elephant = new Elephant(); Animal monkey = new Monkey(); Visitor vet = new Vet(); Visitor zookeeper = new Zookeeper(); Visitor visitorPerson = new VisitorPerson(); // 动物接受访问者的访问 lion.accept(vet); elephant.accept(zookeeper); monkey.accept(visitorPerson); } } 基本结构： link访问者模式包括以下几个基本角色：\n抽象访问者（Visitor）： 声明了访问者可以访问哪些元素，以及如何访问它们的方法visit。\n具体访问者（ConcreteVisitor）： 实现了抽象访问者定义的方法，不同的元素类型可能有不同的访问行为。医生、管理员、游客都属于具体的访问者，它们的访问行为不同。\n抽象元素（Element）： 定义了一个accept方法，用于接受访问者的访问。\n具体元素（ConcreteElement）： 实现了accept方法，是访问者访问的目标。\n对象结构（Object Structure）： 包含元素的集合，可以是一个列表、一个集合或者其他数据结构。负责遍历元素，并调用元素的接受方法。\n简易实现： link 定义抽象访问者: 声明那些元素可以访问 // 抽象访问者 interface Visitor { void visit(ConcreteElementA element); void visit(ConcreteElementB element); } 实现具体访问者：实现具体的访问逻辑 // 具体访问者A class ConcreteVisitorA implements Visitor { @Override public void visit(ConcreteElementA element) { System.out.println(\"ConcreteVisitorA Visit ConcreteElementA\"); } @Override public void visit(ConcreteElementB element) { System.out.println(\"ConcreteVisitorA Visit ConcreteElementB\"); } } // 具体访问者B class ConcreteVisitorB implements Visitor { @Override public void visit(ConcreteElementA element) { System.out.println(\"ConcreteVisitorB Visit ConcreteElementA\"); } @Override public void visit(ConcreteElementB element) { System.out.println(\"ConcreteVisitorB Visit ConcreteElementB\"); } } 定义元素接口：声明接收访问者的方法。 // 抽象元素 interface Element { void accept(Visitor visitor); } 实现具体元素：实现接受访问者的方法 // 具体元素A class ConcreteElementA implements Element { @Override public void accept(Visitor visitor) { visitor.visit(this); } } // 具体元素B class ConcreteElementB implements Element { @Override public void accept(Visitor visitor) { visitor.visit(this); } } 创建对象结构：提供一个接口让访问者访问它的元素。 // 对象结构 class ObjectStructure { private List elements = new ArrayList\u003c\u003e(); public void attach(Element element) { elements.add(element); } public void detach(Element element) { elements.remove(element); } public void accept(Visitor visitor) { for (Element element : elements) { element.accept(visitor); } } } 客户端调用 public class Main { public static void main(String[] args) { ObjectStructure objectStructure = new ObjectStructure(); objectStructure.attach(new ConcreteElementA()); objectStructure.attach(new ConcreteElementB()); Visitor visitorA = new ConcreteVisitorA(); Visitor visitorB = new ConcreteVisitorB(); objectStructure.accept(visitorA); objectStructure.accept(visitorB); } } 使用场景 link访问者模式结构较为复杂，但是访问者模式将同一类操作封装在一个访问者中，使得相关的操作彼此集中，提高了代码的可读性和维护性。它常用于对象结构比较稳定，但经常需要在此对象结构上定义新的操作，这样就无需修改现有的元素类，只需要定义新的访问者来添加新的操作。\n本题代码 link import java.util.Scanner; // 元素接口 interface Shape { void accept(Visitor visitor); } // 具体元素类 class Circle implements Shape { private int radius; public Circle(int radius) { this.radius = radius; } public int getRadius() { return radius; } @Override public void accept(Visitor visitor) { visitor.visit(this); } } class Rectangle implements Shape { private int width; private int height; public Rectangle(int width, int height) { this.width = width; this.height = height; } public int getWidth() { return width; } public int getHeight() { return height; } @Override public void accept(Visitor visitor) { visitor.visit(this); } } // 访问者接口 interface Visitor { void visit(Circle circle); void visit(Rectangle rectangle); } // 具体访问者类 class AreaCalculator implements Visitor { @Override public void visit(Circle circle) { double area = 3.14 * Math.pow(circle.getRadius(), 2); System.out.println(area); } @Override public void visit(Rectangle rectangle) { int area = rectangle.getWidth() * rectangle.getHeight(); System.out.println(area); } } // 对象结构类 class Drawing { private Shape[] shapes; public Drawing(Shape[] shapes) { this.shapes = shapes; } public void accept(Visitor visitor) { for (Shape shape : shapes) { shape.accept(visitor); } } } public class Main { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); int n = scanner.nextInt(); scanner.nextLine(); // 创建一个数组来存储图形对象 Shape[] shapes = new Shape[n]; // 根据用户输入创建不同类型的图形对象 for (int i = 0; i \u003c n; i++) { String[] input = scanner.nextLine().split(\" \"); if (input[0].equals(\"Circle\")) { int radius = Integer.parseInt(input[1]); shapes[i] = new Circle(radius); } else if (input[0].equals(\"Rectangle\")) { int width = Integer.parseInt(input[1]); int height = Integer.parseInt(input[2]); shapes[i] = new Rectangle(width, height); } else { System.out.println(\"Invalid input\"); return; } } // 创建一个图形集合 Drawing drawing = new Drawing(shapes); // 创建一个面积计算访问者 Visitor areaCalculator = new AreaCalculator(); // 访问图形集合并计算面积 drawing.accept(areaCalculator); } } 其他语言版本 linkC++ link #include #include #include class Shape; // 访问者接口 class Visitor { public: virtual void visit(class Circle\u0026 circle) = 0; virtual void visit(class Rectangle\u0026 rectangle) = 0; }; // 元素接口 class Shape { public: virtual ~Shape() {} // 添加虚析构函数 virtual void accept(Visitor\u0026 visitor) = 0; }; // 具体元素类 class Circle : public Shape { private: int radius; public: Circle(int radius) : radius(radius) {} int getRadius() const { return radius; } void accept(Visitor\u0026 visitor) override; }; // 具体元素类 class Rectangle : public Shape { private: int width; int height; public: Rectangle(int width, int height) : width(width), height(height) {} int getWidth() const { return width; } int getHeight() const { return height; } void accept(Visitor\u0026 visitor) override; }; // 具体访问者类 class AreaCalculator : public Visitor { public: void visit(Circle\u0026 circle) override; void visit(Rectangle\u0026 rectangle) override; }; // 对象结构类 class Drawing { private: std::vector shapes; public: Drawing(const std::vector\u0026 shapes) : shapes(shapes) {} void accept(Visitor\u0026 visitor) { for (Shape* shape : shapes) { shape-\u003eaccept(visitor); } } }; // 实现 accept 函数 void Circle::accept(Visitor\u0026 visitor) { visitor.visit(*this); } void Rectangle::accept(Visitor\u0026 visitor) { visitor.visit(*this); } // 实现 visit 函数 void AreaCalculator::visit(Circle\u0026 circle) { double area = 3.14 * std::pow(circle.getRadius(), 2); std::cout \u003c\u003c area \u003c\u003c std::endl; } void AreaCalculator::visit(Rectangle\u0026 rectangle) { int area = rectangle.getWidth() * rectangle.getHeight(); std::cout \u003c\u003c area \u003c\u003c std::endl; } int main() { int n; std::cin \u003e\u003e n; std::vector shapes; for (int i = 0; i \u003c n; i++) { std::string type; std::cin \u003e\u003e type; if (type == \"Circle\") { int radius; std::cin \u003e\u003e radius; shapes.push_back(new Circle(radius)); } else if (type == \"Rectangle\") { int width, height; std::cin \u003e\u003e width \u003e\u003e height; shapes.push_back(new Rectangle(width, height)); } else { // 处理无效输入 std::cout \u003c\u003c \"Invalid input\" \u003c\u003c std::endl; return 1; } } Drawing drawing(shapes); AreaCalculator areaCalculator; drawing.accept(areaCalculator); // 释放动态分配的内存 for (Shape* shape : shapes) { delete shape; } return 0; } Python link from abc import ABC, abstractmethod # 访问者接口 class Visitor(ABC): @abstractmethod def visit_circle(self, circle): pass @abstractmethod def visit_rectangle(self, rectangle): pass # 元素接口 class Shape(ABC): @abstractmethod def accept(self, visitor): pass # 具体元素类 class Circle(Shape): def __init__(self, radius): self.radius = radius def get_radius(self): return self.radius def accept(self, visitor): visitor.visit_circle(self) # 具体元素类 class Rectangle(Shape): def __init__(self, width, height): self.width = width self.height = height def get_width(self): return self.width def get_height(self): return self.height def accept(self, visitor): visitor.visit_rectangle(self) # 具体访问者类 class AreaCalculator(Visitor): def visit_circle(self, circle): area = 3.14 * circle.get_radius()**2 print(area) def visit_rectangle(self, rectangle): area = rectangle.get_width() * rectangle.get_height() print(area) # 对象结构类 class Drawing: def __init__(self, shapes): self.shapes = shapes def accept(self, visitor): for shape in self.shapes: shape.accept(visitor) # 示例用法 if __name__ == \"__main__\": n = int(input()) shapes = [] for _ in range(n): shape_type, *params = input().split() if shape_type == \"Circle\": radius = int(params[0]) shapes.append(Circle(radius)) elif shape_type == \"Rectangle\": width, height = map(int, params) shapes.append(Rectangle(width, height)) else: print(\"invalid input\") exit(1) drawing = Drawing(shapes) area_calculator = AreaCalculator() drawing.accept(area_calculator) Go link package main import ( \"bufio\" \"fmt\" \"os\" \"math\" \"strconv\" \"strings\" ) // 元素接口 type Shape interface { accept(Visitor) } // 具体元素类 type Circle struct { radius int } func NewCircle(radius int) *Circle { return \u0026Circle{radius} } func (c *Circle) getRadius() int { return c.radius } func (c *Circle) accept(visitor Visitor) { visitor.visit(c) } type Rectangle struct { width, height int } func NewRectangle(width, height int) *Rectangle { return \u0026Rectangle{width, height} } func (r *Rectangle) getWidth() int { return r.width } func (r *Rectangle) getHeight() int { return r.height } func (r *Rectangle) accept(visitor Visitor) { visitor.visit(r) } // 访问者接口 type Visitor interface { visit(shape Shape) } // 具体访问者类 type AreaCalculator struct{} func (ac *AreaCalculator) visit(shape Shape) { switch concreteShape := shape.(type) { case *Circle: area := 3.14 * math.Pow(float64(concreteShape.getRadius()), 2) fmt.Println(area) case *Rectangle: area := concreteShape.getWidth() * concreteShape.getHeight() fmt.Println(area) } } // 对象结构类 type Drawing struct { shapes []Shape } func NewDrawing(shapes []Shape) *Drawing { return \u0026Drawing{shapes} } func (d *Drawing) accept(visitor Visitor) { for _, shape := range d.shapes { shape.accept(visitor) } } func main() { var n int fmt.Scan(\u0026n) shapes := make([]Shape, n) scanner := bufio.NewScanner(os.Stdin) for i := 0; i \u003c n; i++ { scanner.Scan() input := strings.Split(scanner.Text(), \" \") if input[0] == \"Circle\" { radius, _ := strconv.Atoi(input[1]) shapes[i] = NewCircle(radius) } else if input[0] == \"Rectangle\" { width, _ := strconv.Atoi(input[1]) height, _ := strconv.Atoi(input[2]) shapes[i] = NewRectangle(width, height) } else { fmt.Println(\"Invalid input\") return } } drawing := NewDrawing(shapes) areaCalculator := \u0026AreaCalculator{} drawing.accept(areaCalculator) } "
            }
        );
    index.add(
            {
                id:  33 ,
                href: "\/docs\/dev\/golang\/fyne\/1.%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%AD%A6%E4%B9%A0fyne\/",
                title: "1.为什么要学习Fyne？",
                description: "Fyne 是一个纯Golang 的跨平台GUI 库..",
                content: "GUI Application 的定义 linkGUI(Graphical User Interface/图形用户界面)程序是指使用图形界面与用户进行交互的软件应用程序。图形界面通常包括窗口、图标、按钮、文本框、菜单等可视化元素, 使用户可以通过直观的操作(如点击、拖动, 输入内容)与程序进行交互, 而不需要通过如命令行进行操作。\n例子: 好比 VS Code 就是。\n使用 Fyne 开发 GUI(图形用户界面)程序有许多优势, 我们简单地和 Electron 比较一下。\n1. 轻量 link Fyne：Fyne 是一个轻量级的 GUI 框架, 应用程序的体积相对较小, 占用的系统资源也较少。 Electron：Electron 打包了整个 Chromium 和 Node.js, 导致应用程序的体积较大, 并且在运行时占用不少内存。 2. 性能 link Fyne：Fyne 应用是用 Go 语言编写的, Go 语言本身以其高效和快速的性能而闻名。Fyne 应用在启动和运行时的性能通常优于 Electron 应用。 Electron：由于 Electron 依赖于 Chromium 和 Node.js, 其性能受限于这些底层技术的性能。Electron 应用启动较慢, 运行时占用较多的内存和 CPU 资源。 3. 资源消耗 link Fyne：Fyne 应用程序消耗的系统资源较少, 特别是在内存和 CPU 使用方面。这使得 Fyne 应用在低配置的系统上也能顺畅运行。 Electron：Electron 应用通常消耗更多的内存和 CPU 资源, 特别是在打开多个窗口或运行复杂的应用时, 这在低配置系统上可能会导致性能问题。 4. 开发语言 link Fyne：Fyne 使用 Go 语言开发。Go 语言以其简洁、高效和强大的并发支持而著称, 非常适合开发高性能的服务器和桌面应用。 Electron：Electron对于 Web 开发者而言则非常熟悉。 5. 其它优势 link Fyne 提供了一套统一的、现代的用户界面, 能够在各个平台上看起来一致。其设计风格和用户体验都非常优雅。而得益于 Go 语言的编译特性，Fyne 应用在编译成二进制文件后，更难被逆向工程破解，从而在一定程度上增强了应用的安全性。 6. Fyne 也有一些问题 link Fyne 是一个相对较新的框架,虽然社区也在飞速发展, 但是肯定不能和 Electron 比, Electron 早已有了一个成熟的生态系统。 适用场景 link Fyne：适合开发轻量级、高性能、跨平台的桌面应用，尤其是在对资源消耗和性能要求较高的场景下。\nElectron：适合快速开发跨平台的桌面应用，尤其是已经有 Web 应用或有大量现成 Web 组件的场景。\n对于本教程 link本频道一直对于 Go 很重视, 有很多朋友对于 Go 的 Fyne 学习很有兴趣, 同时, Fyne 也很适合 Go 语言新手上手, 开发出一个不错的 GUI 程序。\n关于热重载(Hot Reload) link定义: Hot Reload 允许开发者在不重新启动整个应用程序的情况下立即看到代码更改的效果。\n通过热重载, 开发者可以大大提高效率。而 Fyne 框架本身不直接内置热重载功能\n快速理解例子:\n如 Vue.js 中，运行 npm run dev, 此命令启动了一个开发服务器, 监视项目中的文件变化, 并在检测到变化时自动重新编译, 而无需重新启动服务器。\n配置基本环境 link略\n项目代码: https://github.com/haveflychi/Fyne-study\n"
            }
        );
    index.add(
            {
                id:  34 ,
                href: "\/docs\/dev\/golang\/fyne\/2.%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%B0%8F%E9%A1%B9%E7%9B%AE\/",
                title: "2.第一个小项目",
                description: "fyne编写第一个小项目",
                content: "基本命令\ngo mod init fyneTest01 fyneTest01可以随便写。\ngo get fyne.io/fyne/v2 GOPATH 介绍说明\n$GOPATH 是一个环境变量，它指定了你的 Go 工作空间的位置。工作空间中往往包含编译后的包文件和可执行文件。\n如何找到它?\ngo env GOPATH 即可。\n成品代码\npackage main import ( \"fmt\" \"fyne.io/fyne/v2/app\" \"fyne.io/fyne/v2/widget\" ) func main() { a:= app.New() w:= a.NewWindow(\"Gofer gogogo\") w.SetContent(widget.NewLabel(\"Gofer gogogo\")) w.ShowAndRun() fmt.Println(\"close!\") } Go 要点: go mod tidy linkgo mod tidy 命令会清理 go.mod 文件，移除不再需要的依赖，并确保所有实际使用的依赖都在文件中声明。同时，它还会更新 go.sum 文件，确保其中的记录是最新的和完整的。\ngo mod tidy 运行程序\ngo run . 即可\nGo 要点: go run . link参考文档 https://shellytw.medium.com/golang-learning-journey-from-an-ex-javascript-developer-1-go-run-and-packages-d107fdff147\n这里的解释简单但是到位。 本教程将都使用这个命令。\nFyne 要点: w.ShowAndRun() linkSyntactic Sugar, 亦可以写成\nw.Show() a.Run() a.run将开启事件循环(Eventloop)\n测试代码\nfmt.Println(\"close!\") Fyne, 你不能同时有两个事件循环, 这是因为事件循环负责处理所有的事件(如用户输入)并协调应用程序中的所有组件和窗口。如果你尝试在同一个应用程序中运行多个事件循环,会导致不一致的状态 只能有一个事件循环。\n"
            }
        );
    index.add(
            {
                id:  35 ,
                href: "\/docs\/dev\/golang\/fyne\/3.%E5%A4%84%E7%90%86%E5%A4%9A%E7%AA%97%E5%8F%A3\/",
                title: "3.处理多窗口问题",
                description: "Fyne支持单个事件循环中管理多个窗口",
                content: "代码案例 link package main import ( \"fyne.io/fyne/v2/app\" \"fyne.io/fyne/v2/container\" \"fyne.io/fyne/v2/widget\" ) func main() { a := app.New() w1 := a.NewWindow(\"Window 1\") w1.SetContent(container.NewVBox( widget.NewLabel(\"Test01\"), )) w2 := a.NewWindow(\"Window 2\") w2.SetContent(container.NewVBox( widget.NewLabel(\"Test02\"), )) w1.Show() w2.Show() a.Run() } "
            }
        );
    index.add(
            {
                id:  36 ,
                href: "\/docs\/dev\/golang\/fyne\/4.go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%BF%AB%E9%80%9F%E9%80%9A%E5%85%B3\/",
                title: "4.Go基础速通",
                description: "有Go基础的同学可以跳过",
                content: "代码案例 01 link type Person struct{ Name string Age int Email string } func main() { p := Person{ Name: \"Inkka\", Age: 17, Email: \"inkkaplumbilibili@example.com\", } // 访问结构体字段 fmt.Println(\"Name:\", p.Name) fmt.Println(\"Age:\", p.Age) fmt.Println(\"Email:\", p.Email) // 修改结构体字段 p.Age = 18 fmt.Println(\"Updated Age:\", p.Age) } 代码案例 02 link package main import \"fmt\" func main() { // 初始化一个整数变量 i i := 114514 // 将 i 的值赋给 j j := i // 修改 j 的值 j = 1919810 // 打印 i 和 j 的值 fmt.Println(\"i:\", i) // 输出: i: 114514 fmt.Println(\"j:\", j) // 输出: j: 1919810 } Go 没有引用类型\nhttps://github.com/golang/go/commit/b34f0551387fcf043d65cd7d96a0214956578f94\n代码案例 03 link package main import \"fmt\" func main(){ a := 12 b := \u0026a *b = 13 fmt.Println(a, *b) } 代码案例 04 link type MyStruct struct { Name string age int } func NewMyStruct(name string, age int) *MyStruct { return \u0026MyStruct{ Name: name, age: age, } } 公式\nfunc (接收者变量 接收者类型) 方法名(参数列表) 返回类型 { 函数体 } 代码案例 05 link package main import \"fmt\" type Person struct { name string age int } func main() { p := NewPerson(\"Gopher\", 17) p.Activity() } func NewPerson(name string, age int) *Person { return \u0026Person{ name: name, age: age, } } func (p Person) Activity() { fmt.Println(p.name, p.age) } 代码案例 06 link package main import \"fmt\" type Person struct { name string } func main() { person1 := Person{name: \"Gopher\"} person1.SetName() person1.Activity() } func (p *Person) SetName() { p.name = \"Inkka\" } func (p Person) Activity() { fmt.Println(p.name + \"在写代码\") } TypeScript 参考例:\nsetName(newName: string) { this.name = newName; // 实例属性赋值 } 参考图(图源 Yandex)\n代码案例 07 link package main import \"fmt\" // 定义一个函数，接受一个 int 类型指针参数并修改它 func incrementByReference(val *int) { fmt.Println(1, val) *val++ fmt.Println(\"Inside incrementByReference:\", *val) // 输出: 11 } func main() { num := 10 fmt.Println(2, \u0026num) incrementByReference(\u0026num) fmt.Println(\"Outside incrementByReference:\", num) // 输出: 11 } 代码案例 08 link package main import \"fmt\" // 定义一个函数，接受一个 int 类型参数并试图修改它 func incrementByValue(val int) { val++ fmt.Println(\"Inside incrementByValue:\", val) // 输出: 11 } func main() { num := 10 incrementByValue(num) fmt.Println(\"Outside incrementByValue:\", num) // 输出: 10 } 代码案例 09 link type Animal interface { Speak() string } type Animal interface { Speak(string) string } //补充: 这也可以 type Animal interface { Speak(s string) string } 代码案例 10 link package main import \"fmt\" // 定义 Animal 接口 type Animal interface { Speak() string } // 定义 Dog 结构体 type Dog struct { name string } // 定义 Cat 结构体 type Cat struct { name string } // Dog 实现 Animal 接口的 Speak 方法 func (d Dog) Speak() string { return \"Woof!\" } // Cat 实现 Animal 接口的 Speak 方法 func (c Cat) Speak() string { return \"Nya!\" } // 一个函数，接受 Animal 类型的参数 func MakeAnimalSpeak(a Animal) { fmt.Println(a.Speak()) } func main() { dog := Dog{name: \"Inu\"} cat := Cat{name: \"Neko\"} // Dog 和 Cat 类型都实现了 Animal 接口 MakeAnimalSpeak(dog) // 输出: Woof! MakeAnimalSpeak(cat) // 输出: Nya! } "
            }
        );
    index.add(
            {
                id:  37 ,
                href: "\/docs\/dev\/golang\/fyne\/5.%E6%9B%B4%E5%A4%8D%E6%9D%82%E7%9A%84%E9%A1%B9%E7%9B%AE\/",
                title: "5.更复杂的项目",
                description: "再一次体验 Container, 点击按钮能够实现对应的效果。",
                content: "要求和最终效果 link参考任意一篇 Fyne 官方文档, 可以看到写法:\nfunc makeUI() (*widget.Label, *widget.Entry) { return widget.NewLabel(\"Hello world!\"), widget.NewEntry() } func main() { a := app.New() w := a.NewWindow(\"Hello Person\") w.SetContent(container.NewVBox(makeUI())) w.ShowAndRun() } 所以, 我们也会写makeUI()。\n优势 link 逻辑清晰 便于测试 读法的小提示 link*... 可以读成Pointer to ...。\n成品代码 link package main import ( \"fmt\" \"fyne.io/fyne/v2\" \"fyne.io/fyne/v2/app\" \"fyne.io/fyne/v2/container\" \"fyne.io/fyne/v2/widget\" ) type App struct{ output *widget.Label } var myApp App func (app *App) makeUI()(*widget.Label, *widget.Entry, *widget.Button, *widget.Label, *widget.Button ){ output := widget.NewLabel(\"Gopher Go go go\") entry:= widget.NewEntry() btn := widget.NewButton(\"Click!\", func() { output.SetText(entry.Text) }) app.output = output btn.Importance = widget.HighImportance number := 0 count := widget.NewLabel(fmt.Sprintf(\"Current Number: %d\", number)) incrementbtn := widget.NewButton(\"Click again!\", func() { number++ count.SetText(fmt.Sprintf(\"Current Number: %d\", number)) }) incrementbtn.Importance = widget.DangerImportance return output, entry, btn, count, incrementbtn } func main() { a := app.New() w := a.NewWindow(\"Gopher Go go go!02\") output, entry, btn, count, incrementbtn := myApp.makeUI() w.SetContent(container.NewVBox(output, entry, btn, count, incrementbtn)) w.Resize(fyne.Size{Width: 1600, Height: 1000}) w.ShowAndRun() } "
            }
        );
    index.add(
            {
                id:  38 ,
                href: "\/docs\/dev\/golang\/fyne\/project\/1.markdown%E7%BC%96%E8%BE%91%E5%99%A8\/",
                title: "Fyne-Markdown编辑器",
                description: "Markdown 编辑器\n此项目的要求和最终效果 link能够支持中文, 程序窗口左半边写 markdown, 右边则显示富文本, 也就是现在我们 Vs code 里面的 Preview(プレビュー)\n解决语言问题 linkFyne 默认字体不支持中文, 我们可以复制一下下面的测试文本, 基于我们第一个案例, 会发现是乱码。\npackage main import ( \"fmt\" \"fyne.io/fyne/v2/app\" \"fyne.io/fyne/v2/widget\" ) func main() { a:= app.New() w:= a.NewWindow(\"让我们一起来学习Go语言吧!\") w.SetContent(widget.NewLabel(\"让我们一起来学习Go语言吧!\")) w.ShowAndRun() fmt.Println(\"close!\") } 在项目文件夹中(必要文件), 找到字体文件(NotoSansHans-Regular.ttf)或者亦可以用你喜好的字体。将项目文件夹中的theme.go和util.go复制到项目目录下。\n然后, 在项目中添加如下代码:\ncustomFont := fyne.NewStaticResource(\"NotoSansHans.ttf\", loadFont(\"NotoSansHans-Regular.ttf\")) a.Settings().SetTheme(\u0026myTheme{font: customFont}) 只需要改loadFont内的内容即可。\n实战 Struct 和 Receiver link package main import ( \"fyne.io/fyne/v2\" \"fyne.io/fyne/v2/app\" \"fyne.io/fyne/v2/container\" \"fyne.io/fyne/v2/widget\" ) type config struct { EditWidget *widget.Entry PreviewWidget *widget.RichText CurrentFile fyne.",
                content: "Markdown 编辑器\n此项目的要求和最终效果 link能够支持中文, 程序窗口左半边写 markdown, 右边则显示富文本, 也就是现在我们 Vs code 里面的 Preview(プレビュー)\n解决语言问题 linkFyne 默认字体不支持中文, 我们可以复制一下下面的测试文本, 基于我们第一个案例, 会发现是乱码。\npackage main import ( \"fmt\" \"fyne.io/fyne/v2/app\" \"fyne.io/fyne/v2/widget\" ) func main() { a:= app.New() w:= a.NewWindow(\"让我们一起来学习Go语言吧!\") w.SetContent(widget.NewLabel(\"让我们一起来学习Go语言吧!\")) w.ShowAndRun() fmt.Println(\"close!\") } 在项目文件夹中(必要文件), 找到字体文件(NotoSansHans-Regular.ttf)或者亦可以用你喜好的字体。将项目文件夹中的theme.go和util.go复制到项目目录下。\n然后, 在项目中添加如下代码:\ncustomFont := fyne.NewStaticResource(\"NotoSansHans.ttf\", loadFont(\"NotoSansHans-Regular.ttf\")) a.Settings().SetTheme(\u0026myTheme{font: customFont}) 只需要改loadFont内的内容即可。\n实战 Struct 和 Receiver link package main import ( \"fyne.io/fyne/v2\" \"fyne.io/fyne/v2/app\" \"fyne.io/fyne/v2/container\" \"fyne.io/fyne/v2/widget\" ) type config struct { EditWidget *widget.Entry PreviewWidget *widget.RichText CurrentFile fyne.URI MenuItem *fyne.MenuItem } 正式写代码 linkcontainer.NewHSplit对应的文档: https://docs.fyne.io/api/v2.4/container/split.html\nURI URL 辨析 link URI 是一个用于标识资源的字符串, 它可以是资源的名称、位置或两者的结合。URI 的概念是一个广义的概念, 包含了两类子集：URL 和 URN。\nURL(统一资源定位符) URL 是 URI 的一个子集, 用于指定资源的位置。URL 不仅标识资源, 还提供了定位资源的方法。URL 通常包括以下部分：\n方案(Scheme): 例如 http、https、ftp 等，表示访问资源的协议。 主机(Host): 资源所在的主机名或 IP 地址。 路径(Path): 资源在主机上的具体位置。 查询参数(Query Param): 附加的参数信息，用于传递额外的数据。 片段(Fragment): 资源的一部分，例如网页中的一个锚点。\n举一个例子(锚点): https://ja.wikipedia.org/wiki/Go_(プログラミング言語)#interface\n案例\nhttps://example.com/path/to/resource?query=param#fragment URI例子\nfile:///Users/username/Documents/example.md 代码是最终成品\nFilter(筛选器) link代码\nvar filter = storage.NewExtensionFileFilter([]string{\".md\", \".MD\"}) 提示:\nfunc HasSuffix(s, suffix string) bool { return len(s) \u003e= len(suffix) \u0026\u0026 s[len(s)-len(suffix):] == suffix } 表示方法\ns[len(s)-len(suffix):] 假设 s 为example.md\n放在不同的文件中 link目录说明 link myapp/ |-- main.go |-- test.go main.go及test.go第一行\npackage main main.go更多代码\nfunc main() { ... ... } 附注: 只要在同一个包, 顶层变量和函数就可以互相自由访问。\n生成一个图标 link随意地找一个生成器即可, 格式要求 Icon.png\n最终目录 link myapp/ |-- main.go |-- ui.go |-- config.go 这里只有 Import 相关的内容\nconfig.go\nimport ( \"io\" \"strings\" \"fyne.io/fyne/v2\" \"fyne.io/fyne/v2/dialog\" \"fyne.io/fyne/v2/storage\" ) ui.go\nimport ( \"fyne.io/fyne/v2\" \"fyne.io/fyne/v2/widget\" ) main.go\nimport ( \"fyne.io/fyne/v2\" \"fyne.io/fyne/v2/app\" \"fyne.io/fyne/v2/container\" \"fyne.io/fyne/v2/widget\" ) 综合代码 linkmain.go\ntype config struct { EditWidget *widget.Entry PreviewWidget *widget.RichText CurrentFile fyne.URI MenuItem *fyne.MenuItem BaseTitle string } var cfg config var filter = storage.NewExtensionFileFilter([]string{\".md\", \".MD\"}) func main() { a := app.New() customFont := fyne.NewStaticResource(\"NotoSansHans.ttf\", loadFont(\"NotoSansHans-Regular.ttf\")) a.Settings().SetTheme(\u0026myTheme{font: customFont}) w := a.NewWindow(\"Markdown编辑器\") cfg.BaseTitle = \"Markdown编辑器\" edit, preview := cfg.makeUI() cfg.createMenu(w) w.SetContent(container.NewHSplit(edit, preview)) w.Resize(fyne.Size{Width: 800, Height: 600}) w.CenterOnScreen() w.ShowAndRun() } ui.go\npackage main import ( \"fyne.io/fyne/v2\" \"fyne.io/fyne/v2/widget\" ) func (cfg *config) makeUI() (*widget.Entry, *widget.RichText){ edit := widget.NewMultiLineEntry() preview := widget.NewRichTextFromMarkdown(\"\") cfg.EditWidget = edit cfg.PreviewWidget = preview edit.OnChanged = preview.ParseMarkdown return edit, preview } func (cfg *config) createMenu(win fyne.Window){ open := fyne.NewMenuItem(\"打开...\", cfg.openFunc(win)) save := fyne.NewMenuItem(\"保存\", cfg.saveFunc(win)) cfg.MenuItem = save cfg.MenuItem.Disabled = true saveAs := fyne.NewMenuItem(\"另存为...\", cfg.saveAsFunc(win)) fileMenu := fyne.NewMenu(\"文件\", open, save, saveAs) menu := fyne.NewMainMenu(fileMenu) win.SetMainMenu(menu) } config.go\npackage main import ( \"io/ioutil\" \"strings\" \"fyne.io/fyne/v2\" \"fyne.io/fyne/v2/dialog\" \"fyne.io/fyne/v2/storage\" ) func (cfg *config) saveAsFunc(win fyne.Window) func(){ return func(){ saveDialog := dialog.NewFileSave(func(write fyne.URIWriteCloser, err error){ if err != nil{ dialog.ShowError(err, win) return } if write == nil{ return } if !strings.HasSuffix(strings.ToLower(write.URI().String()),\".md\"){ dialog.ShowInformation(\"错误\", \"必须是.md扩展名\", win) return } write.Write([]uint8(cfg.EditWidget.Text)) cfg.CurrentFile = write.URI() defer write.Close() win.SetTitle(cfg.BaseTitle + \"-\" + write.URI().Name()) cfg.MenuItem.Disabled = false },win) saveDialog.SetFileName(\"未命名.md\") saveDialog.SetFilter(filter) saveDialog.Show() } } func (cfg *config) openFunc(win fyne.Window) func() { return func(){ openDialog := dialog.NewFileOpen(func(read fyne.URIReadCloser, err error){ if err!=nil{ dialog.ShowError(err,win) return } if read == nil{ return } data, err := io.ReadAll(read) if err!=nil{ dialog.ShowError(err,win) return } defer read.Close() cfg.EditWidget.SetText(string(data)) cfg.CurrentFile = read.URI() win.SetTitle(cfg.BaseTitle + \"-\" + read.URI().Name()) cfg.MenuItem.Disabled = false },win) openDialog.SetFilter(filter) openDialog.Show() } } func (cfg *config) saveFunc(win fyne.Window) func() { return func(){ if cfg.CurrentFile != nil{ write, err := storage.Writer(cfg.CurrentFile) if err != nil{ dialog.ShowError(err, win) return } write.Write([]byte(cfg.EditWidget.Text)) defer write.Close() } } } 测试文件 link对应成品代码 link package main import ( \"testing\" \"fyne.io/fyne/v2/container\" \"fyne.io/fyne/v2/test\" ) func Test_makeUI(t *testing.T){ var testCfg config edit, preview := testCfg.makeUI() test.Type(edit, \"Gofjer\") if preview.String() != \"Gofjer\"{ t.Error(\"Failed!!!!\") } } 打包项目 link参考此文档即可: https://docs.fyne.io/started/packaging.html\n"
            }
        );
    index.add(
            {
                id:  39 ,
                href: "\/docs\/dev\/golang\/fyne\/project\/2.%E8%B6%A3%E5%91%B3%E6%95%B4%E6%B4%BB%E9%A1%B9%E7%9B%AE\/",
                title: "Fyne-趣味整活项目",
                description: "全部代码 link package main import ( \"time\" \"fyne.io/fyne/v2\" \"fyne.io/fyne/v2/app\" \"fyne.io/fyne/v2/container\" \"fyne.io/fyne/v2/dialog\" \"fyne.io/fyne/v2/widget\" ) func main() { // 创建一个 Fyne 应用 a := app.New() // 创建一个窗口 customFont := fyne.NewStaticResource(\"NotoSansHans.ttf\", loadFont(\"NotoSansHans-Regular.ttf\")) a.Settings().SetTheme(\u0026myTheme{font: customFont}) win := a.NewWindow(\"高端检测器\") // 创建一个按钮 btn := widget.NewButton(\"检测是否开机\", func() { // 创建一个进度条 progress := widget.NewProgressBarInfinite() progressContainer := container.NewVBox(progress) // 显示加载动画 loadingDialog := dialog.NewCustom(\"正在检测...\", \"取消\", progressContainer, win) loadingDialog.Show() // 模拟加载时间 go func(){ time.Sleep(10 * time.Second) // 10 秒模拟加载时间 // 关闭加载动画并弹出结果窗口 loadingDialog.",
                content: "全部代码 link package main import ( \"time\" \"fyne.io/fyne/v2\" \"fyne.io/fyne/v2/app\" \"fyne.io/fyne/v2/container\" \"fyne.io/fyne/v2/dialog\" \"fyne.io/fyne/v2/widget\" ) func main() { // 创建一个 Fyne 应用 a := app.New() // 创建一个窗口 customFont := fyne.NewStaticResource(\"NotoSansHans.ttf\", loadFont(\"NotoSansHans-Regular.ttf\")) a.Settings().SetTheme(\u0026myTheme{font: customFont}) win := a.NewWindow(\"高端检测器\") // 创建一个按钮 btn := widget.NewButton(\"检测是否开机\", func() { // 创建一个进度条 progress := widget.NewProgressBarInfinite() progressContainer := container.NewVBox(progress) // 显示加载动画 loadingDialog := dialog.NewCustom(\"正在检测...\", \"取消\", progressContainer, win) loadingDialog.Show() // 模拟加载时间 go func(){ time.Sleep(10 * time.Second) // 10 秒模拟加载时间 // 关闭加载动画并弹出结果窗口 loadingDialog.Hide() dialog.ShowInformation(\"结果\", \"电脑是开机的\", win) }() }) // 设置窗口内容 win.SetContent(container.NewVBox(btn)) win.Resize(fyne.Size{Width: 400, Height: 200}) win.CenterOnScreen() win.ShowAndRun() } Go goroutine 简单概念 linkGoroutine 是 Go 语言中的一种轻量级线程, 由 Go 运行时管理。Goroutine 使得并发编程变得更加简单和高效，可以通过关键字 go 启动。\n当然, 每一个并发执行的活动称为goroutine。当一个程序启动时, 只有一个goroutine来调用main函数, 称之为主goroutine。\n特点 link 轻量级：\nGoroutine 非常轻量级, 可以在同一个程序中启动成千上万个 Goroutine, 而不会造成过多的内存开销。 易于使用：\n只需在函数调用前加上 go 关键字, 即可启动一个新的 Goroutine。 并发执行：\nGoroutine 可以并发执行, 不同的 Goroutine 之间可以独立运行, 互不干扰。 调度器管理：\nGo 运行时会自动管理 Goroutine 的调度, 充分利用多核处理器的优势。 Goroutine 示例 link以下是一个简单的 Goroutine 示例：\npackage main import ( \"fmt\" \"time\" ) func sayHello() { for i := 0; i \u003c 5; i++ { fmt.Println(\"Hello\") time.Sleep(1 * time.Second) } } func main() { go sayHello() // 启动一个新的 Goroutine 执行 sayHello 函数 // 主 Goroutine 继续执行其他代码 for i := 0; i \u003c 5; i++ { fmt.Println(\"World\") time.Sleep(1 * time.Second) } // 等待 sayHello 函数执行完成 time.Sleep(6 * time.Second) } 输出情况:\n由于 sayHello 函数在一个新的 goroutine 中执行, 而 main 函数继续执行, 两个函数的输出将会交错在一起。具体的输出可能会有所不同, 有可能是如下面这样\nWorld Hello World Hello ... 而Up主的案例是这样。\nWorld Hello Hello World World Hello Hello World World Hello 上文这就是 Goroutine 的一个非常好的案例\n"
            }
        );
    index.add(
            {
                id:  40 ,
                href: "\/docs\/ops\/1.nginx%E9%85%8D%E7%BD%AE%E5%B0%8F%E5%85%A8\/",
                title: "1.Nginx配置小全",
                description: "Nginx是一款自由的、开源的、高性能的HTTP服务器和反向代理服务器；",
                content: "安装 nginx link下载 nginx 的压缩包文件到根目录，官网下载地址：nginx.org/download/nginx-x.xx.xx.tar.gz\nyum update #更新系统软件 cd / wget nginx.org/download/nginx-1.17.2.tar.gz 解压tar.gz压缩包文件，进去 nginx-1.17.2\ntar -xzvf nginx-1.17.2.tar.gz cd nginx-1.17.2 进入文件夹后进行配置检查\n通过安装前的配置检查，发现有报错。检查中发现一些依赖库没有找到，这时候需要先安装nginx的一些依赖库\nyum -y install pcre* #安装使nginx支持rewrite yum -y install gcc-c++ yum -y install zlib* yum -y install openssl openssl-devel 再次进行检查操作 ./configure 没发现报错显示，接下来进行编译并安装的操作\n// 检查模块支持 ./configure --prefix=/usr/local/nginx --with-http_ssl_module --with-http_v2_module --with-http_realip_module --with-http_addition_module --with-http_sub_module --with-http_dav_module --with-http_flv_module --with-http_mp4_module --with-http_gunzip_module --with-http_gzip_static_module --with-http_auth_request_module --with-http_random_index_module --with-http_secure_link_module --with-http_degradation_module --with-http_slice_module --with-http_stub_status_module --with-mail --with-mail_ssl_module --with-stream --with-stream_ssl_module --with-stream_realip_module --with-stream_ssl_preread_module --with-threads --user=www --group=www 这里得特别注意下，你以后需要用到的功能模块是否存在，不然以后添加新的包会比较麻烦。\n查看默认安装的模块支持\n命令 ls nginx-1.17.2 查看 nginx 的文件列表，可以发现里面有一个 auto 的目录。\n在这个 auto 目录中有一个 options 文件，这个文件里面保存的就是 nginx 编译过程中的所有选项配置。\n通过命令：cat nginx-1.17.2/auto/options | grep YES就可以查看\nnginx 编译安装时，怎么查看安装模块 (opens new window)\n编译并安装\n这里需要注意，模块的支持跟后续的nginx配置有关，比如 SSL，gzip 压缩等等，编译安装前最好检查需要配置的模块存不存在。\n查看 nginx 安装后在的目录，可以看到已经安装到 /usr/local/nginx 目录了\nwhereis nginx $nginx: /usr/local/nginx 启动 nginx 服务\ncd /usr/local/nginx/sbin/ ./nginx 服务启动的时候报错了：nginx: [emerg] bind() to 0.0.0.0:80 failed (98: Address already in use) ，通过命令查看本机网络地址和端口等一些信息，找到被占用的 80 端口 netstat -ntpl 的 tcp 连接，并杀死进程(kill 进程 pid)\nnetstat -ntpl kill 进程PID 继续启动 nginx 服务，启动成功\n在浏览器直接访问 ip 地址，页面出现 Welcome to Nginx! 则安装成功。\nnginx 配置 link基本结构 link main # 全局配置，对全局生效 ├── events # 配置影响 nginx 服务器或与用户的网络连接 ├── http # 配置代理，缓存，日志定义等绝大多数功能和第三方模块的配置 │ ├── upstream # 配置后端服务器具体地址，负载均衡配置不可或缺的部分 │ ├── server # 配置虚拟主机的相关参数，一个 http 块中可以有多个 server 块 │ ├── server │ │ ├── location # server 块可以包含多个 location 块，location 指令用于匹配 uri │ │ ├── location │ │ └── ... │ └── ... └── ... 主要配置含义 link main:nginx 的全局配置，对全局生效。 events:配置影响 nginx 服务器或与用户的网络连接。 http：可以嵌套多个 server，配置代理，缓存，日志定义等绝大多数功能和第三方模块的配置。 server：配置虚拟主机的相关参数，一个 http 中可以有多个server。 location：配置请求的路由，以及各种页面的处理情况。 upstream：配置后端服务器具体地址，负载均衡配置不可或缺的部分。 nginx.conf 配置文件的语法规则 link 配置文件由指令与指令块构成 每条指令以 “;” 分号结尾，指令与参数间以空格符号分隔 指令块以 {} 大括号将多条指令组织在一起 include 语句允许组合多个配置文件以提升可维护性 通过 # 符号添加注释，提高可读性 通过 $ 符号使用变量 部分指令的参数支持正则表达式，例如常用的 location 指令 内置变量 linknginx 常用的内置全局变量，你可以在配置中随意使用：\nTCP UDP $host 请求信息中的 Host，如果请求中没有 Host 行，则等于设置的服务器名 $request_method 客户端请求类型，如 GET、POST $remote_addr 客户端的 IP 地址 $args 请求中的参数 $content_length 请求头中的 Content-length 字段 $http_user_agent 客户端 agent 信息 $http_cookie 客户端cookie信息 $remote_port 客户端的端口 $server_protocol 请求使用的协议，如 HTTP/1.1 $server_addr 服务器地址 $server_name 服务器名称 $server_port 服务器的端口号 常用命令 link这里列举几个常用的命令：\nnginx -s reload # 向主进程发送信号，重新加载配置文件，热重启 nginx -s reopen # 重启 Nginx nginx -s stop # 快速关闭 nginx -s quit # 等待工作进程处理完成后关闭 nginx -T # 查看当前 Nginx 最终的配置 nginx -t -c \u003c配置路径\u003e # 检查配置是否有问题，如果已经在配置目录，则不需要 -c 以上命令通过 nginx -h 就可以查看到，还有其它不常用这里未列出。\nLinux 系统应用管理工具 systemd 关于 nginx 的常用命令：\nsystemctl start nginx # 启动 Nginx systemctl stop nginx # 停止 Nginx systemctl restart nginx # 重启 Nginx systemctl reload nginx # 重新加载 Nginx，用于修改配置后 systemctl enable nginx # 设置开机启动 Nginx systemctl disable nginx # 关闭开机启动 Nginx systemctl status nginx # 查看 Nginx 运行状态 配置 nginx 开机自启 link利用 systemctl 命令：\n如果用 yum install 命令安装的 nginx，yum 命令会自动创建 nginx.service 文件，直接用命令:\nsystemctl enable nginx # 设置开机启动 Nginx systemctl disable nginx # 关闭开机启动 Nginx 就可以设置开机自启，否则需要在系统服务目录里创建 nginx.service 文件。\n创建并打开 nginx.service 文件：\nvi /lib/systemd/system/nginx.service 内容如下：\n[Unit] Description=nginx After=network.target [Service] Type=forking ExecStart=/usr/local/nginx/sbin/nginx ExecReload=/usr/local/nginx/sbin/nginx -s reload ExecStop=/usr/local/nginx/sbin/nginx -s quit PrivateTmp=true [Install] WantedBy=multi-user.target :wq 保存退出，运行 systemctl daemon-reload 使文件生效。\n这样便可以通过以下命令操作 nginx 了：\nsystemctl start nginx.service # 启动nginx服务 systemctl enable nginx.service # 设置开机启动 systemctl disable nginx.service # 停止开机自启动 systemctl status nginx.service　# 查看服务当前状态 systemctl restart nginx.service # 重新启动服务 systemctl is-enabled nginx.service #查询服务是否开机启动 通过开机启动命令脚本实现开机自启\n创建开机启动命令脚本文件：\n在这个 nginx 文件中插入一下启动脚本代码，启动脚本代码来源网络复制，实测有效：\n#! /bin/bash # chkconfig: - 85 15 PATH=/usr/local/nginx DESC=\"nginx daemon\" NAME=nginx DAEMON=$PATH/sbin/$NAME CONFIGFILE=$PATH/conf/$NAME.conf PIDFILE=$PATH/logs/$NAME.pid scriptNAME=/etc/init.d/$NAME set -e [ -x \"$DAEMON\" ] || exit 0 do_start() { $DAEMON -c $CONFIGFILE || echo -n \"nginx already running\" } do_stop() { $DAEMON -s stop || echo -n \"nginx not running\" } do_reload() { $DAEMON -s reload || echo -n \"nginx can't reload\" } case \"$1\" in start) echo -n \"Starting $DESC: $NAME\" do_start echo \".\" ;; stop) echo -n \"Stopping $DESC: $NAME\" do_stop echo \".\" ;; reload|graceful) echo -n \"Reloading $DESC configuration...\" do_reload echo \".\" ;; restart) echo -n \"Restarting $DESC: $NAME\" do_stop do_start echo \".\" ;; *) echo \"Usage: $scriptNAME {start|stop|reload|restart}\" \u003e\u00262 exit 3 ;; esac exit 0 设置所有人都有对这个启动脚本 nginx 文件的执行权限：\nchmod a+x /etc/init.d/nginx 把nginx加入系统服务中：\n把服务设置为开机启动：\nreboot 重启系统生效，可以使用上面 systemctl 方法相同的命令：\nsystemctl start nginx.service # 启动nginx服务 systemctl enable nginx.service # 设置开机启动 systemctl disable nginx.service # 停止开机自启动 systemctl status nginx.service　# 查看服务当前状态 systemctl restart nginx.service # 重新启动服务 systemctl is-enabled nginx.service #查询服务是否开机启动 如果服务启动的时候出现 Restarting nginx daemon: nginxnginx: [error] open() \"/usr/local/nginx/logs/nginx.pid\" failed (2: No such file or directory) nginx not running 的错误，通过nginx -c 参数指定配置文件即可解决\n/usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf 如果服务启动中出现 nginx: [emerg] bind() to 0.0.0.0:80 failed (98: Address already in use) 的错误，可以先通过 service nginx stop 停止服务，再启动就好。\n配置 nginx 全局可用 link当你每次改了 nginx.conf 配置文件的内容都需要重新到 nginx 启动目录去执行命令，或者通过 -p 参数指向特定目录，会不会感觉很麻烦？\n例如： 直接执行 nginx -s reload 会报错 -bash: nginx: command not found，需要到 /usr/local/nginx/sbin 目录下面去执行，并且是执行 ./nginx -s reload。\n这里有两种方式可以解决，一种是通过脚本对 nginx 命令包装，这里介绍另外一种比较简单：通过把 nginx 配置到环境变量里，用 nginx 执行指令即可。步骤如下：\n1、编辑 /etc/profile\n2、在最后一行添加配置，:wq 保存\nexport PATH=$PATH:/usr/local/nginx/sbin 3、使配置立即生效\n这样就可以愉快的直接在全局使用 nginx 命令了。\nnginx 常用功能 link反向代理 link我们最常说的反向代理的是通过反向代理解决跨域问题。\n其实反向代理还可以用来控制缓存（代理缓存 proxy cache），进行访问控制等等，以及后面说的负载均衡其实都是通过反向代理来实现的。\nserver { listen 8080; # 用户访问 ip:8080/test 下的所有路径代理到 github location /test { proxy_pass https://github.com; } # 所有 /api 下的接口访问都代理到本地的 8888 端口 # 例如你本地运行的 java 服务的端口是 8888，接口都是以 /api 开头 location /api { proxy_pass http://127.0.0.1:8888; } } 访问控制 link server { location ~ ^/index.html { # 匹配 index.html 页面 除了 127.0.0.1 以外都可以访问 deny 192.168.1.1; deny 192.168.1.2; allow all; } } 上面的命令表示禁止 192.168.1.1 和 192.168.1.2 两个 ip 访问，其它全部允许。从上到下的顺序，匹配到了便跳出，可以按你的需求设置。\n负载均衡 link通过负载均衡充利用服务器资源，nginx 目前支持自带 4 种负载均衡策略，还有 2 种常用的第三方策略。\n轮询策略（默认）\n每个请求按时间顺序逐一分配到不同的后端服务器，如果有后端服务器挂掉，能自动剔除。但是如果其中某一台服务器压力太大，出现延迟，会影响所有分配在这台服务器下的用户。\nhttp { upstream test.com { server 192.168.1.12:8887; server 192.168.1.13:8888; } server { location /api { proxy_pass http://test.com; } } } 根据服务器权重\n例如要配置：10 次请求中大概 1 次访问到 8888 端口，9 次访问到 8887 端口：\nhttp { upstream test.com { server 192.168.1.12:8887 weight=9; server 192.168.1.13:8888 weight=1; } server { location /api { proxy_pass http://test.com; } } } 客户端 ip 绑定（ip_hash）\n来自同一个 ip 的请求永远只分配一台服务器，有效解决了动态网页存在的 session 共享问题。例如：比如把登录信息保存到了 session 中，那么跳转到另外一台服务器的时候就需要重新登录了。\n所以很多时候我们需要一个客户只访问一个服务器，那么就需要用 ip_hash 了。\nhttp { upstream test.com { ip_hash; server 192.168.1.12:8887; server 192.168.1.13:8888; } server { location /api { proxy_pass http://test.com; } } } 最小连接数策略\n将请求优先分配给压力较小的服务器，它可以平衡每个队列的长度，并避免向压力大的服务器添加更多的请求。\nhttp { upstream test.com { least_conn; server 192.168.1.12:8887; server 192.168.1.13:8888; } server { location /api { proxy_pass http://test.com; } } } 最快响应时间策略（依赖于第三方 NGINX Plus）\n依赖于 NGINX Plus，优先分配给响应时间最短的服务器。\nhttp { upstream test.com { fair; server 192.168.1.12:8887; server 192.168.1.13:8888; } server { location /api { proxy_pass http://test.com; } } } 按访问url的hash结果（第三方）\n按访问 url 的 hash 结果来分配请求，使每个 url 定向到同一个后端服务器，后端服务器为缓存时比较有效。 在 upstream 中加入 hash 语句，server 语句中不能写入 weight 等其他的参数，hash_method 是使用的 hash 算法\nhttp { upstream test.com { hash $request_uri; hash_method crc32; server 192.168.1.12:8887; server 192.168.1.13:8888; } server { location /api { proxy_pass http://test.com; } } } 采用 HAproxy 的 loadbalance uri 或者 nginx 的 upstream_hash 模块，都可以做到针对 url 进行哈希算法式的负载均衡转发。\ngzip 压缩 link开启 gzip 压缩可以大幅减少 http 传输过程中文件的大小，可以极大的提高网站的访问速度，基本是必不可少的优化操作：\ngzip on; # 开启gzip 压缩 # gzip_types # gzip_static on; # gzip_proxied expired no-cache no-store private auth; # gzip_buffers 16 8k; gzip_min_length 1k; gzip_comp_level 4; gzip_http_version 1.0; gzip_vary off; gzip_disable \"MSIE [1-6]\\.\"; 解释一下：\ngzip_types：要采用 gzip 压缩的 MIME 文件类型，其中 text/html 被系统强制启用； gzip_static：默认 off，该模块启用后，Nginx 首先检查是否存在请求静态文件的 gz 结尾的文件，如果有则直接返回该 .gz 文件内容； gzip_proxied：默认 off，nginx 做为反向代理时启用，用于设置启用或禁用从代理服务器上收到相应内容 gzip 压缩； gzip_buffers：获取多少内存用于缓存压缩结果，16 8k 表示以 8k*16 为单位获得； gzip_min_length：允许压缩的页面最小字节数，页面字节数从 header 头中的 Content-Length 中进行获取。默认值是 0，不管页面多大都压缩。建议设置成大于 1k 的字节数，小于 1k 可能会越压越大； gzip_comp_level：gzip 压缩比，压缩级别是 1-9，1 压缩级别最低，9 最高，级别越高压缩率越大，压缩时间越长，建议 4-6； gzip_http_version：默认 1.1，启用 gzip 所需的 HTTP 最低版本； gzip_vary：用于在响应消息头中添加 Vary：Accept-Encoding，使代理服务器根据请求头中的 Accept-Encoding 识别是否启用 gzip 压缩； gzip_disable 指定哪些不需要 gzip 压缩的浏览器 其中第 2 点，普遍是结合前端打包的时候打包成 gzip 文件后部署到服务器上，这样服务器就可以直接使用 gzip 的文件了，并且可以把压缩比例提高，这样 nginx 就不用压缩，也就不会影响速度。一般不追求极致的情况下，前端不用做任何配置就可以使用啦~\n附前端 webpack 开启 gzip 压缩配置，在 vue-cli3 的 vue.config.js 配置文件中： const CompressionWebpackPlugin = require('compression-webpack-plugin') module.exports = { // gzip 配置 configureWebpack: config =\u003e { if (process.env.NODE_ENV === 'production') { // 生产环境 return { plugins: [new CompressionWebpackPlugin({ test: /\\.js$|\\.html$|\\.css/, // 匹配文件名 threshold: 1024, // 文件压缩阈值，对超过 1k 的进行压缩 deleteOriginalAssets: false // 是否删除源文件 })] } } }, ... } HTTP服务器 linknginx 本身也是一个静态资源的服务器，当只有静态资源的时候，就可以使用 nginx 来做服务器：\nserver { listen 80; server_name localhost; location / { root /usr/local/app; index index.html; } } 这样如果访问 http://ip 就会默认访问到 /usr/local/app 目录下面的 index.html，如果一个网站只是静态页面的话，那么就可以通过这种方式来实现部署，比如一个静态官网。\n动静分离 link就是把动态和静态的请求分开。方式主要有两种：\n一种是纯粹把静态文件独立成单独的域名，放在独立的服务器上，也是目前主流推崇的方案 一种方法就是动态跟静态文件混合在一起发布， 通过 nginx 配置来分开 # 所有静态请求都由nginx处理，存放目录为 html location ~ \\.(gif|jpg|jpeg|png|bmp|swf|css|js)$ { root /usr/local/resource; expires 10h; # 设置过期时间为10小时 } # 所有动态请求都转发给 tomcat 处理 location ~ \\.(jsp|do)$ { proxy_pass 127.0.0.1:8888; } 注意上面设置了 expires，当 nginx 设置了 expires 后，例如设置为：expires 10d; 那么，所在的 location 或 if 的内容，用户在 10 天内请求的时候，都只会访问浏览器中的缓存，而不会去请求 nginx 。\n请求限制 link对于大流量恶意的访问，会造成带宽的浪费，给服务器增加压力。可以通过 nginx 对于同一 IP 的连接数以及并发数进行限制。合理的控制还可以用来防止 DDos 和 CC 攻击。\n关于请求限制主要使用 nginx 默认集成的 2 个模块：\nlimit_conn_module 连接频率限制模块 limit_req_module 请求频率限制模块 涉及到的配置主要是：\nlimit_req_zone 限制请求数 limit_conn_zone 限制并发连接数 通过 limit_req_zone 限制请求数\nhttp{ limit_conn_zone $binary_remote_addrzone=limit:10m; // 设置共享内存空间大 server{ location /{ limit_conn addr 5; # 同一用户地址同一时间只允许有5个连接。 } } } 如果共享内存空间被耗尽，服务器将会对后续所有的请求返回 503 (Service Temporarily Unavailable) 错误。\n当多个 limit_conn_zone 指令被配置时，所有的连接数限制都会生效。比如，下面配置不仅会限制单一 IP 来源的连接数，同时也会限制单一虚拟服务器的总连接数：\nlimit_conn_zone $binary_remote_addr zone=perip:10m; limit_conn_zone $server_name zone=perserver:10m; server { limit_conn perip 10; # 限制每个 ip 连接到服务器的数量 limit_conn perserver 2000; # 限制连接到服务器的总数 } 通过 limit_conn_zone 限制并发连接数\nlimit_req_zone $binary_remote_addr zone=creq:10 mrate=10r/s; server{ location /{ limit_req zone=creq burst=5; } } 限制平均每秒不超过一个请求，同时允许超过频率限制的请求数不多于5个。 如果不希望超过的请求被延迟，可以用 nodelay 参数,如：\nlimit_req zone=creq burst=5 nodelay;\n这里只是简单讲讲，让大家有这个概念，配置的时候可以深入去找找资料。\n正向代理 link正向代理，意思是一个位于客户端和原始服务器(origin server)之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标(原始服务器)，然后代理向原始服务器转交请求并将获得的内容返回给客户端。客户端才能使用正向代理，比如我们使用的 VPN 服务就是正向代理，直观区别（图片来源于 前端开发者必备的 Nginx 知识 (opens new window)）：\n配置正向代理：\nresolver 8.8.8.8 # 谷歌的域名解析地址 server { resolver_timeout 5s; // 设超时时间 location / { # 当客户端请求我的时候，我会把请求转发给它 # $host 要访问的主机名 $request_uri 请求路径 proxy_pass http://$host$request_uri; } } 正向代理的对象是客户端，服务器端看不到真正的客户端。\n图片防盗链 link server { listen 80; server_name *.test; # 图片防盗链 location ~* \\.(gif|jpg|jpeg|png|bmp|swf)$ { valid_referers none blocked server_names ~\\.google\\. ~\\.baidu\\. *.qq.com; # 只允许本机 IP 外链引用，将百度和谷歌也加入白名单有利于 SEO if ($invalid_referer){ return 403; } } } 以上设置就能防止其它网站利用外链访问我们的图片，有利于节省流量\n适配 PC 或移动设备 link根据用户设备不同返回不同样式的站点，以前经常使用的是纯前端的自适应布局，但是复杂的网站并不适合响应式，无论是复杂性和易用性上面还是不如分开编写的好，比如我们常见的淘宝、京东。\n根据用户请求的 user-agent 来判断是返回 PC 还是 H5 站点：\nserver { listen 80; server_name test.com; location / { root /usr/local/app/pc; # pc 的 html 路径 if ($http_user_agent ~* '(Android|webOS|iPhone|iPod|BlackBerry)') { root /usr/local/app/mobile; # mobile 的 html 路径 } index index.html; } } 设置二级域名 link新建一个 server 即可：\nserver { listen 80; server_name admin.test.com; // 二级域名 location / { root /usr/local/app/admin; # 二级域名的 html 路径 index index.html; } } 配置 HTTPS link这里我使用的是 certbot 免费证书，但申请一次有效期只有3个月（好像可以用 crontab 尝试配置自动续期，我暂时没试过）：\n先安装 certbot\nwget https://dl.eff.org/certbot-auto chmod a+x certbot-auto 申请证书（注意：需要把要申请证书的域名先解析到这台服务器上，才能申请）:\nsudo ./certbot-auto certonly --standalone --email admin@abc.com -d test.com -d www.test.com 执行上面指令，按提示操作。\nCertbot 会启动一个临时服务器来完成验证（会占用 80 端口或 443 端口，因此需要暂时关闭 Web 服务器），然后 Certbot 会把证书以文件的形式保存，包括完整的证书链文件和私钥文件。\n文件保存在 /etc/letsencrypt/live/ 下面的域名目录下。\n修改 nginx 配置：\nserver{ listen 443 ssl http2; // 这里还启用了 http/2.0 ssl_certificate /etc/letsencrypt/live/test.com/fullchain.pem; # 证书文件地址 ssl_certificate_key /etc/letsencrypt/live/test.com/privkey.pem; # 私钥文件地址 server_name test.com www.test.com; // 证书绑定的域名 } 配置 HTTP 转 HTTPS link server { listen 80; server_name test.com www.test.com; # 单域名重定向 if ($host = 'www.sherlocked93.club'){ return 301 https://www.sherlocked93.club$request_uri; } # 全局非 https 协议时重定向 if ($scheme != 'https') { return 301 https://$server_name$request_uri; } # 或者全部重定向 return 301 https://$server_name$request_uri; } 以上配置选择自己需要的一条即可，不用全部加。\n单页面项目 history 路由配置 link server { listen 80; server_name fe.sherlocked93.club; location / { root /usr/local/app/dist; # vue 打包后的文件夹 index index.html index.htm; try_files $uri $uri/ /index.html @rewrites; # 默认目录下的 index.html，如果都不存在则重定向 expires -1; # 首页一般没有强制缓存 add_header Cache-Control no-cache; } location @rewrites { // 重定向设置 rewrite ^(.+)$ /index.html break; } } vue-router (opens new window) 官网只有一句话 try_files $uri $uri/ /index.html;，而上面做了一些重定向处理。\n配置高可用集群（双机热备） link当主 nginx 服务器宕机之后，切换到备份的 nginx 服务器\n首先安装 keepalived:\nyum install keepalived -y 1\n然后编辑 /etc/keepalived/keepalived.conf 配置文件，并在配置文件中增加 vrrp_script 定义一个外围检测机制，并在 vrrp_instance 中通过定义 track_script 来追踪脚本执行过程，实现节点转移：\nglobal_defs{ notification_email { cchroot@gmail.com } notification_email_from test@firewall.loc smtp_server 127.0.0.1 smtp_connect_timeout 30 // 上面都是邮件配置 router_id LVS_DEVEL // 当前服务器名字，用 hostname 命令来查看 } vrrp_script chk_maintainace { // 检测机制的脚本名称为chk_maintainace script \"[[ -e/etc/keepalived/down ]] \u0026\u0026 exit 1 || exit 0\" // 可以是脚本路径或脚本命令 // script \"/etc/keepalived/nginx_check.sh\" // 比如这样的脚本路径 interval 2 // 每隔2秒检测一次 weight -20 // 当脚本执行成立，那么把当前服务器优先级改为-20 } vrrp_instanceVI_1 { // 每一个vrrp_instance就是定义一个虚拟路由器 state MASTER // 主机为MASTER，备用机为BACKUP interface eth0 // 网卡名字，可以从ifconfig中查找 virtual_router_id 51 // 虚拟路由的id号，一般小于255，主备机id需要一样 priority 100 // 优先级，master的优先级比backup的大 advert_int 1 // 默认心跳间隔 authentication { // 认证机制 auth_type PASS auth_pass 1111 // 密码 } virtual_ipaddress { // 虚拟地址vip 172.16.2.8 } } 其中检测脚本 nginx_check.sh，这里提供一个：\n#!/bin/bash A=`ps -C nginx --no-header | wc -l` if [ $A -eq 0 ];then /usr/sbin/nginx # 尝试重新启动nginx sleep 2 # 睡眠2秒 if [ `ps -C nginx --no-header | wc -l` -eq 0 ];then killall keepalived # 启动失败，将keepalived服务杀死。将vip漂移到其它备份节点 fi fi 复制一份到备份服务器，备份 nginx 的配置要将 state 后改为 BACKUP，priority 改为比主机小。 设置完毕后各自 service keepalived start 启动，经过访问成功之后，可以把 Master 机的 keepalived 停掉，此时 Master 机就不再是主机了 service keepalived stop，看访问虚拟 IP 时是否能够自动切换到备机 ip addr。\n再次启动 Master 的 keepalived，此时 vip 又变到了主机上。\n配置高可用集群的内容来源于：Nginx 从入门到实践，万字详解！ (opens new window)\n其它功能和技巧 link代理缓存 linknginx 的 http_proxy 模块，提供类似于 Squid 的缓存功能，使用 proxy_cache_path 来配置。\nnginx 可以对访问过的内容在 nginx 服务器本地建立副本，这样在一段时间内再次访问该数据，就不需要通过 nginx 服务器再次向后端服务器发出请求，减小数据传输延迟，提高访问速度：\nproxy_cache_path usr/local/cache levels=1:2 keys_zone=my_cache:10m; server { listen 80; server_name test.com; location / { proxy_cache my_cache; proxy_pass http://127.0.0.1:8888; proxy_set_header Host $host; } } 上面的配置表示： nginx 提供一块 10 M 的内存用于缓存，名字为 my_cache, levels 等级为 1:2，缓存存放的路径为 usr/local/cache。\n访问日志 link访问日志默认是注释的状态，需要可以打开和进行更详细的配置，一下是 nginx 的默认配置：\nhttp { log_format main '$remote_addr - $remote_user [$time_local] \"$request\" ' '$status $body_bytes_sent \"$http_referer\" ' '\"$http_user_agent\" \"$http_x_forwarded_for\"'; access_log logs/access.log main; } 错误日志 link错误日志放在 main 全局区块中，童鞋们打开 nginx.conf 就可以看见在配置文件中和下面一样的代码了：\n#error_log logs/error.log; #error_log logs/error.log notice; #error_log logs/error.log info; nginx 错误日志默认配置为：\nerror_log logs/error.log error;\n静态资源服务器 link server { listen 80; server_name static.bin; charset utf-8; # 防止中文文件名乱码 location /download { alias /usr/share/nginx/static; # 静态资源目录 autoindex on; # 开启静态资源列目录，浏览目录权限 autoindex_exact_size off; # on(默认)显示文件的确切大小，单位是byte；off显示文件大概大小，单位KB、MB、GB autoindex_localtime off; # off(默认)时显示的文件时间为GMT时间；on显示的文件时间为服务器时间 } } 禁止指定 user_agent linknginx 可以禁止指定的浏览器和爬虫框架访问：\n# http_user_agent 为浏览器标识 # 禁止 user_agent 为baidu、360和sohu，~*表示不区分大小写匹配 if ($http_user_agent ~* 'baidu|360|sohu') { return 404; } # 禁止 Scrapy 等工具的抓取 if ($http_user_agent ~* (Scrapy|Curl|HttpClient)) { return 403; } 请求过滤 link根据请求类型过滤\n# 非指定请求全返回 403 if ( $request_method !~ ^(GET|POST|HEAD)$ ) { return 403; } 根据状态码过滤\nerror_page 502 503 /50x.html; location = /50x.html { root /usr/share/nginx/html; } 这样实际上是一个内部跳转，当访问出现 502、503 的时候就能返回 50x.html 中的内容，这里需要注意是否可以找到 50x.html 页面，所以加了个 location 保证找到你自定义的 50x 页面。\n根据URL名称过滤\nif ($host = zy.com' ) { #其中$1是取自regex部分()里的内容,匹配成功后跳转到的URL。 rewrite ^/(.*)$ http://www.zy.com/$1 permanent； } location /test { // /test 全部重定向到首页 rewrite ^(.*)$ /index.html redirect; } ab 命令 linkab命令全称为：Apache bench，是 Apache 自带的压力测试工具，也可以测试 Nginx、IIS 等其他 Web 服务器:\n-n 总共的请求数 -c 并发的请求数 -t 测试所进行的最大秒数，默认值 为 50000 -p 包含了需要的 POST 的数据文件 -T POST数据所使用的 Content-type 头信息 ab -n 1000 -c 5000 http://127.0.0.1/ # 每次发送1000并发的请求数，请求数总数为5000。 1\n测试前需要安装 httpd-tools： yum install httpd-tools\n泛域名路径分离 link这是一个非常实用的技能，经常有时候我们可能需要配置一些二级或者三级域名，希望通过 nginx 自动指向对应目录，比如：\ntest1.doc.test.club 自动指向 /usr/local/html/doc/test1 服务器地址； test2.doc.test.club 自动指向 /usr/local/html/doc/test2 服务器地址； server { listen 80; server_name ~^([\\w-]+)\\.doc\\.test\\.club$; root /usr/local/html/doc/$1; } 泛域名转发 link和之前的功能类似，有时候我们希望把二级或者三级域名链接重写到我们希望的路径，让后端就可以根据路由解析不同的规则：\ntest1.serv.test.club/api?name=a 自动转发到 127.0.0.1:8080/test1/api?name=a test2.serv.test.club/api?name=a 自动转发到 127.0.0.1:8080/test2/api?name=a server { listen 80; server_name ~^([\\w-]+)\\.serv\\.test\\.club$; location / { proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header Host $http_host; proxy_set_header X-NginX-Proxy true; proxy_pass http://127.0.0.1:8080/$1$request_uri; } } 常见问题 linknginx 中怎么设置变量 link或许你不知道，nginx 的配置文件使用的是一门微型的编程语言。既然是编程语言，一般也就少不了“变量”这种东西，但是在 nginx 配置中，变量只能存放一种类型的值，因为也只存在一种类型的值，那就是字符串。\n例如我们在 nginx.conf 中有这样一行配置：\n上面使用了 set 配置指令对变量 $name进行了赋值操作，把 “chroot” 赋值给了 $name。nginx 变量名前面有一个 $ 符号，这是记法上的要求。所有的 Nginx 变量在 Nginx 配置文件中引用时都须带上 $ 前缀。这种表示方法和 Perl、PHP 这些语言是相似的。\n这种表示方法的用处在哪里呢，那就是可以直接把变量嵌入到字符串常量中以构造出新的字符串，例如你需要进行一个字符串拼接：\nserver { listen 80; server_name test.com; location / { set $temp hello; return \"$temp world\"; } } 以上当匹配成功的时候就会返回字符串 “hello world” 了。需要注意的是，当引用的变量名之后紧跟着变量名的构成字符时（比如后跟字母、数字以及下划线），我们就需要使用特别的记法来消除歧义，例如：\nserver { listen 80; server_name test.com; location / { set $temp \"hello \"; return \"${temp}world\"; } } 这里，我们在配置指令的参数值中引用变量 $temp 的时候，后面紧跟着 world 这个单词，所以如果直接写作 \"$tempworld\" 则 nginx 的计算引擎会将之识别为引用了变量 $tempworld. 为了解决这个问题，nginx 的字符串支持使用花括号在 $ 之后把变量名围起来，比如这里的 ${temp}，所以 上面这个例子返回的还是 “hello world”：\n$ curl 'http://test.com/' hello world 还需要注意的是，若是想输出 $ 符号本身，可以这样做：\ngeo $dollar { default \"$\"; } server { listen 80; server_name test.com; location / { set $temp \"hello \"; return \"${temp}world: $dollar\"; } } 上面用到了标准模块 ngx_geo 提供的配置指令 geo 来为变量 $dollar 赋予字符串 \"$\" ，这样，这里的返回值就是 “hello world: $” 了。\n附 nginx 内置预定义变量 link按字母顺序：\n变量名 定义 $arg_PARAMETER GET 请求中变量名 PARAMETER 参数的值 $args 这个变量等于 GET 请求中的参数，例如，foo=123\u0026bar=blahblah;这个变量只可以被修改 $binary_remote_addr 二进制码形式的客户端地址 $body_bytes_sent 传送页面的字节数 $content_length 请求头中的 Content-length 字段 $content_type 请求头中的 Content-Type 字段 $cookie_COOKIE cookie COOKIE 的值 $document_root 当前请求在 root 指令中指定的值 $document_uri 与 $uri 相同 $host 请求中的主机头(Host)字段，如果请求中的主机头不可用或者空，则为处理请求的 server 名称(处理请求的 server 的 server_name 指令的值)。值为小写，不包含端口。 $hostname 机器名使用 gethostname 系统调用的值 $http_HEADER HTTP 请求头中的内容，HEADER 为 HTTP 请求中的内容转为小写，-变为_(破折号变为下划线)，例如：$http_user_agent(Uaer-Agent 的值) $sent_http_HEADER HTTP 响应头中的内容，HEADER 为 HTTP 响应中的内容转为小写，-变为_(破折号变为下划线)，例如：$sent_http_cache_control、$sent_http_content_type… $is_args 如果 $args 设置，值为\"?\"，否则为\"\" $limit_rate 这个变量可以限制连接速率 $nginx_version 当前运行的 nginx 版本号 $query_string 与 $args 相同 $remote_addr 客户端的IP地址 $remote_port 客户端的端口 $remote_port 已经经过 Auth Basic Module 验证的用户名 $request_filename 当前连接请求的文件路径，由 root 或 alias 指令与 URI 请求生成 $request_body 这个变量（0.7.58+）包含请求的主要信息。在使用 proxy_pass 或 fastcgi_pass 指令的 location 中比较有意义 $request_body_file 客户端请求主体信息的临时文件名 $request_completion 如果请求成功，设为\"OK\"；如果请求未完成或者不是一系列请求中最后一部分则设为空 $request_method 这个变量是客户端请求的动作，通常为 GET 或 POST。包括 0.8.20 及之前的版本中，这个变量总为 main request 中的动作，如果当前请求是一个子请求，并不使用这个当前请求的动作 $request_uri 这个变量等于包含一些客户端请求参数的原始 URI，它无法修改，请查看 $uri 更改或重写 URI $scheme 所用的协议，例如 http 或者是 https，例如 rewrite ^(.+)$ $scheme://example.com$1 redirect $server_addr 服务器地址，在完成一次系统调用后可以确定这个值，如果要绕开系统调用，则必须在listen中指定地址并且使用bind参数 $server_name 服务器名称 $server_port 请求到达服务器的端口号 $server_protocol 请求使用的协议，通常是 HTTP/1.0、HTTP/1.1或HTTP/2 $uri 请求中的当前 URI(不带请求参数，参数位于 args ) ， 不 同 于 浏 览 器 传 递 的 args)，不同于浏览器传递的 args)，不同于浏览器传递的 request_uri 的值，它可以通过内部重定向，或者使用 index 指令进行修改。不包括协议和主机名，例如 /foo/bar.html 附 nginx 模块 linknginx 模块分类 link 核心模块：nginx 最基本最核心的服务，如进程管理、权限控制、日志记录； 标准 HTTP 模块：nginx 服务器的标准 HTTP 功能； 可选 HTTP 模块：处理特殊的 HTTP 请求 邮件服务模块：邮件服务 第三方模块：作为扩展，完成特殊功能 模块清单 link核心模块：\nngx_core ngx_errlog ngx_conf ngx_events ngx_event_core ngx_epll ngx_regex 标准 HTTP 模块：\nngx_http ngx_http_core #配置端口，URI 分析，服务器相应错误处理，别名控制 (alias) 等 ngx_http_log #自定义 access 日志 ngx_http_upstream #定义一组服务器，可以接受来自 proxy, Fastcgi,Memcache 的重定向；主要用作负载均衡 ngx_http_static ngx_http_autoindex #自动生成目录列表 ngx_http_index #处理以/结尾的请求，如果没有找到 index 页，则看是否开启了random_index；如开启，则用之，否则用 autoindex ngx_http_auth_basic #基于 http 的身份认证 (auth_basic) ngx_http_access #基于 IP 地址的访问控制 (deny,allow) ngx_http_limit_conn #限制来自客户端的连接的响应和处理速率 ngx_http_limit_req #限制来自客户端的请求的响应和处理速率 ngx_http_geo ngx_http_map #创建任意的键值对变量 ngx_http_split_clients ngx_http_referer #过滤 HTTP 头中 Referer 为空的对象 ngx_http_rewrite #通过正则表达式重定向请求 ngx_http_proxy ngx_http_fastcgi #支持 fastcgi ngx_http_uwsgi ngx_http_scgi ngx_http_memcached ngx_http_empty_gif #从内存创建一个 1×1 的透明 gif 图片，可以快速调用 ngx_http_browser #解析 http 请求头部的 User-Agent 值 ngx_http_charset #指定网页编码 ngx_http_upstream_ip_hash ngx_http_upstream_least_conn ngx_http_upstream_keepalive ngx_http_write_filter ngx_http_header_filter ngx_http_chunked_filter ngx_http_range_header ngx_http_gzip_filter ngx_http_postpone_filter ngx_http_ssi_filter ngx_http_charset_filter ngx_http_userid_filter ngx_http_headers_filter #设置 http 响应头 ngx_http_copy_filter ngx_http_range_body_filter ngx_http_not_modified_filter 可选 HTTP 模块:\nngx_http_addition #在响应请求的页面开始或者结尾添加文本信息 ngx_http_degradation #在低内存的情况下允许服务器返回 444 或者 204 错误 ngx_http_perl ngx_http_flv #支持将 Flash 多媒体信息按照流文件传输，可以根据客户端指定的开始位置返回 Flash ngx_http_geoip #支持解析基于 GeoIP 数据库的客户端请求 ngx_google_perftools ngx_http_gzip #gzip 压缩请求的响应 ngx_http_gzip_static #搜索并使用预压缩的以.gz 为后缀的文件代替一般文件响应客户端请求 ngx_http_image_filter #支持改变 png，jpeg，gif 图片的尺寸和旋转方向 ngx_http_mp4 #支持.mp4,.m4v,.m4a 等多媒体信息按照流文件传输，常与 ngx_http_flv 一起使用 ngx_http_random_index #当收到 / 结尾的请求时，在指定目录下随机选择一个文件作为 index ngx_http_secure_link #支持对请求链接的有效性检查 ngx_http_ssl #支持 https ngx_http_stub_status ngx_http_sub_module #使用指定的字符串替换响应中的信息 ngx_http_dav #支持 HTTP 和 WebDAV 协议中的 PUT/DELETE/MKCOL/COPY/MOVE 方法 ngx_http_xslt #将 XML 响应信息使用 XSLT 进行转换 邮件服务模块:\nngx_mail_core ngx_mail_pop3 ngx_mail_imap ngx_mail_smtp ngx_mail_auth_http ngx_mail_proxy ngx_mail_ssl 第三方模块：\necho-nginx-module #支持在 nginx 配置文件中使用 echo/sleep/time/exec 等类 Shell 命令 memc-nginx-module rds-json-nginx-module #使 nginx 支持 json 数据的处理 lua-nginx-module "
            }
        );
    index.add(
            {
                id:  41 ,
                href: "\/docs\/ops\/kubernetes\/1.kubernetes-v1.28.3%E4%BA%8C%E8%BF%9B%E5%88%B6%E9%83%A8%E7%BD%B2\/",
                title: "1.Kubernetes-v1.28.3高可用集群二进制部署(IPv4+IPv6双栈)",
                description: "Kubernetes（简称k8s）是Google在2014年6月开源的一个容器集群管理系统，使用Go语言开发，用于管理云平台中多个主机上的容器化的应用，Kubernetes的目标是让部署容器化的应用简单并且高效,Kubernetes提供了资源调度、部署管理、服务发现、扩容缩容、监控，维护等一整套功能。努力成为跨主机集群的自动部署、扩展以及运行应用程序容器的平台。 它支持一系列容器工具, 包括且不限于Docker等。",
                content: "介绍 link kubernetes（k8s）二进制高可用安装部署，支持IPv4+IPv6双栈。 我使用IPV6的目的是在公网进行访问，所以我配置了IPV6静态地址。 若您没有IPV6环境，或者不想使用IPv6，不对主机进行配置IPv6地址即可。 不配置IPV6，不影响后续，不过集群依旧是支持IPv6的。为后期留有扩展可能性。 若不要IPv6 ，不给网卡配置IPv6即可，不要对IPv6相关配置删除或操作，否则会出问题。 1.环境 link 主机名称 IP地址 说明 软件 192.168.1.60 外网节点 下载各种所需安装包 Master01 192.168.1.31 master节点 kube-apiserver、kube-controller-manager、kube-scheduler、etcd、\nkubelet、kube-proxy、nfs-client、haproxy、keepalived、nginx Master02 192.168.1.32 master节点 kube-apiserver、kube-controller-manager、kube-scheduler、etcd、\nkubelet、kube-proxy、nfs-client、haproxy、keepalived、nginx Master03 192.168.1.33 master节点 kube-apiserver、kube-controller-manager、kube-scheduler、etcd、\nkubelet、kube-proxy、nfs-client、haproxy、keepalived、nginx Node01 192.168.1.34 node节点 kubelet、kube-proxy、nfs-client、nginx Node02 192.168.1.35 node节点 kubelet、kube-proxy、nfs-client、nginx 192.168.1.36 VIP 网段 物理主机：192.168.1.0/24 service：10.96.0.0/12 pod：172.16.0.0/12\n安装包已经整理好：https://mirrors.chenby.cn/https://github.com/cby-chen/Kubernetes/releases/download/v1.28.3/kubernetes-v1.28.3.tar\n1.1.k8s基础系统环境配置 link1.2.配置IP link # 注意！ # 若虚拟机是进行克隆的那么网卡的UUID会重复 # 若UUID重复需要重新生成新的UUID # UUID重复无法获取到IPV6地址 # # 查看当前的网卡列表和 UUID： # nmcli con show # 删除要更改 UUID 的网络连接： # nmcli con delete uuid \u003c原 UUID\u003e # 重新生成 UUID： # nmcli con add type ethernet ifname \u003c接口名称\u003e con-name \u003c新名称\u003e # 重新启用网络连接： # nmcli con up \u003c新名称\u003e # 更改网卡的UUID ssh root@192.168.1.31 \"nmcli con delete uuid 708a1497-2192-43a5-9f03-2ab936fb3c44;nmcli con add type ethernet ifname eth0 con-name eth0;nmcli con up eth0\" ssh root@192.168.1.32 \"nmcli con delete uuid 708a1497-2192-43a5-9f03-2ab936fb3c44;nmcli con add type ethernet ifname eth0 con-name eth0;nmcli con up eth0\" ssh root@192.168.1.33 \"nmcli con delete uuid 708a1497-2192-43a5-9f03-2ab936fb3c44;nmcli con add type ethernet ifname eth0 con-name eth0;nmcli con up eth0\" ssh root@192.168.1.34 \"nmcli con delete uuid 708a1497-2192-43a5-9f03-2ab936fb3c44;nmcli con add type ethernet ifname eth0 con-name eth0;nmcli con up eth0\" ssh root@192.168.1.35 \"nmcli con delete uuid 708a1497-2192-43a5-9f03-2ab936fb3c44;nmcli con add type ethernet ifname eth0 con-name eth0;nmcli con up eth0\" # 参数解释 # # ssh ssh root@192.168.1.31 # 使用SSH登录到IP为192.168.1.31的主机，使用root用户身份。 # # nmcli con delete uuid 708a1497-2192-43a5-9f03-2ab936fb3c44 # 删除 UUID 为 708a1497-2192-43a5-9f03-2ab936fb3c44 的网络连接，这是 NetworkManager 中一种特定网络配置的唯一标识符。 # # nmcli con add type ethernet ifname eth0 con-name eth0 # 添加一种以太网连接类型，并指定接口名为 eth0，连接名称也为 eth0。 # # nmcli con up eth0 # 开启 eth0 这个网络连接。 # # 简单来说，这个命令的作用是删除一个特定的网络连接配置，并添加一个名为 eth0 的以太网连接，然后启用这个新的连接。 # 修改静态的IPv4地址 ssh root@192.168.1.104 \"nmcli con mod eth0 ipv4.addresses 192.168.1.31/24; nmcli con mod eth0 ipv4.gateway 192.168.1.1; nmcli con mod eth0 ipv4.method manual; nmcli con mod eth0 ipv4.dns \"8.8.8.8\"; nmcli con up eth0\" ssh root@192.168.1.106 \"nmcli con mod eth0 ipv4.addresses 192.168.1.32/24; nmcli con mod eth0 ipv4.gateway 192.168.1.1; nmcli con mod eth0 ipv4.method manual; nmcli con mod eth0 ipv4.dns \"8.8.8.8\"; nmcli con up eth0\" ssh root@192.168.1.107 \"nmcli con mod eth0 ipv4.addresses 192.168.1.33/24; nmcli con mod eth0 ipv4.gateway 192.168.1.1; nmcli con mod eth0 ipv4.method manual; nmcli con mod eth0 ipv4.dns \"8.8.8.8\"; nmcli con up eth0\" ssh root@192.168.1.109 \"nmcli con mod eth0 ipv4.addresses 192.168.1.34/24; nmcli con mod eth0 ipv4.gateway 192.168.1.1; nmcli con mod eth0 ipv4.method manual; nmcli con mod eth0 ipv4.dns \"8.8.8.8\"; nmcli con up eth0\" ssh root@192.168.1.110 \"nmcli con mod eth0 ipv4.addresses 192.168.1.35/24; nmcli con mod eth0 ipv4.gateway 192.168.1.1; nmcli con mod eth0 ipv4.method manual; nmcli con mod eth0 ipv4.dns \"8.8.8.8\"; nmcli con up eth0\" nmcli con mod eth0 ipv4.gateway 192.168.1.200; nmcli con mod eth0 ipv4.method manual; nmcli con mod eth0 ipv4.dns \"223.5.5.5\"; nmcli con up eth0 # 参数解释 # # ssh root@192.168.1.154 # 使用SSH登录到IP为192.168.1.154的主机，使用root用户身份。 # # \"nmcli con mod eth0 ipv4.addresses 192.168.1.31/24\" # 修改eth0网络连接的IPv4地址为192.168.1.31，子网掩码为 24。 # # \"nmcli con mod eth0 ipv4.gateway 192.168.1.1\" # 修改eth0网络连接的IPv4网关为192.168.1.1。 # # \"nmcli con mod eth0 ipv4.method manual\" # 将eth0网络连接的IPv4配置方法设置为手动。 # # \"nmcli con mod eth0 ipv4.dns \"8.8.8.8\" # 将eth0网络连接的IPv4 DNS服务器设置为 8.8.8.8。 # # \"nmcli con up eth0\" # 启动eth0网络连接。 # # 总体来说，这条命令是通过SSH远程登录到指定的主机，并使用网络管理命令 (nmcli) 修改eth0网络连接的配置，包括IP地址、网关、配置方法和DNS服务器，并启动该网络连接。 # 没有IPv6选择不配置即可 ssh root@192.168.1.31 \"nmcli con mod eth0 ipv6.addresses fc00:43f4:1eea:1::10; nmcli con mod eth0 ipv6.gateway fc00:43f4:1eea:1::1; nmcli con mod eth0 ipv6.method manual; nmcli con mod eth0 ipv6.dns \"2400:3200::1\"; nmcli con up eth0\" ssh root@192.168.1.32 \"nmcli con mod eth0 ipv6.addresses fc00:43f4:1eea:1::20; nmcli con mod eth0 ipv6.gateway fc00:43f4:1eea:1::1; nmcli con mod eth0 ipv6.method manual; nmcli con mod eth0 ipv6.dns \"2400:3200::1\"; nmcli con up eth0\" ssh root@192.168.1.33 \"nmcli con mod eth0 ipv6.addresses fc00:43f4:1eea:1::30; nmcli con mod eth0 ipv6.gateway fc00:43f4:1eea:1::1; nmcli con mod eth0 ipv6.method manual; nmcli con mod eth0 ipv6.dns \"2400:3200::1\"; nmcli con up eth0\" ssh root@192.168.1.34 \"nmcli con mod eth0 ipv6.addresses fc00:43f4:1eea:1::40; nmcli con mod eth0 ipv6.gateway fc00:43f4:1eea:1::1; nmcli con mod eth0 ipv6.method manual; nmcli con mod eth0 ipv6.dns \"2400:3200::1\"; nmcli con up eth0\" ssh root@192.168.1.35 \"nmcli con mod eth0 ipv6.addresses fc00:43f4:1eea:1::50; nmcli con mod eth0 ipv6.gateway fc00:43f4:1eea:1::1; nmcli con mod eth0 ipv6.method manual; nmcli con mod eth0 ipv6.dns \"2400:3200::1\"; nmcli con up eth0\" # 参数解释 # # ssh root@192.168.1.31 # 通过SSH连接到IP地址为192.168.1.31的远程主机，使用root用户进行登录。 # # \"nmcli con mod eth0 ipv6.addresses fc00:43f4:1eea:1::10\" # 使用nmcli命令修改eth0接口的IPv6地址为fc00:43f4:1eea:1::10。 # # \"nmcli con mod eth0 ipv6.gateway fc00:43f4:1eea:1::1\" # 使用nmcli命令修改eth0接口的IPv6网关为fc00:43f4:1eea:1::1。 # # \"nmcli con mod eth0 ipv6.method manual\" # 使用nmcli命令将eth0接口的IPv6配置方法修改为手动配置。 # # \"nmcli con mod eth0 ipv6.dns \"2400:3200::1\" # 使用nmcli命令设置eth0接口的IPv6 DNS服务器为2400:3200::1。 # # \"nmcli con up eth0\" # 使用nmcli命令启动eth0接口。 # # 这个命令的目的是在远程主机上配置eth0接口的IPv6地址、网关、配置方法和DNS服务器，并启动eth0接口。 # 查看网卡配置 # nmcli device show eth0 # nmcli con show eth0 [root@localhost ~]# cat /etc/sysconfig/network-scripts/ifcfg-eth0 TYPE=Ethernet PROXY_METHOD=none BROWSER_ONLY=no BOOTPROTO=none DEFROUTE=yes IPV4_FAILURE_FATAL=no IPV6INIT=yes IPV6_AUTOCONF=yes IPV6_DEFROUTE=yes IPV6_FAILURE_FATAL=no IPV6_ADDR_GEN_MODE=stable-privacy NAME=eth0 UUID=2aaddf95-3f36-4a48-8626-b55ebf7f53e7 DEVICE=eth0 ONBOOT=yes IPADDR=192.168.1.31 PREFIX=24 GATEWAY=192.168.1.1 DNS1=8.8.8.8 [root@localhost ~]# # 参数解释 # # TYPE=Ethernet # 指定连接类型为以太网。 # # PROXY_METHOD=none # 指定不使用代理方法。 # # BROWSER_ONLY=no # 指定不仅仅在浏览器中使用代理。 # # BOOTPROTO=none # 指定自动分配地址的方式为无（即手动配置IP地址）。 # # DEFROUTE=yes # 指定默认路由开启。 # # IPV4_FAILURE_FATAL=no # 指定IPv4连接失败时不宣告严重错误。 # # IPV6INIT=yes # 指定启用IPv6。 # # IPV6_AUTOCONF=no # 指定不自动配置IPv6地址。 # # IPV6_DEFROUTE=yes # 指定默认IPv6路由开启。 # # IPV6_FAILURE_FATAL=no # 指定IPv6连接失败时不宣告严重错误。 # # IPV6_ADDR_GEN_MODE=stable-privacy # 指定IPv6地址生成模式为稳定隐私模式。 # # NAME=eth0 # 指定设备名称为eth0。 # # UUID=424fd260-c480-4899-97e6-6fc9722031e8 # 指定设备的唯一标识符。 # # DEVICE=eth0 # 指定设备名称为eth0。 # # ONBOOT=yes # 指定开机自动启用这个连接。 # # IPADDR=192.168.1.31 # 指定IPv4地址为192.168.1.31。 # # PREFIX=24 # 指定IPv4地址的子网掩码为24。 # # GATEWAY=192.168.8.1 # 指定IPv4的网关地址为192.168.8.1。 # # DNS1=8.8.8.8 # 指定首选DNS服务器为8.8.8.8。 # # IPV6ADDR=fc00:43f4:1eea:1::10/128 # 指定IPv6地址为fc00:43f4:1eea:1::10，子网掩码为128。 # # IPV6_DEFAULTGW=fc00:43f4:1eea:1::1 # 指定IPv6的默认网关地址为fc00:43f4:1eea:1::1。 # # DNS2=2400:3200::1 # 指定备用DNS服务器为2400:3200::1。 1.3.设置主机名 link hostnamectl set-hostname k8s-master01 hostnamectl set-hostname k8s-master02 hostnamectl set-hostname k8s-master03 hostnamectl set-hostname k8s-node01 hostnamectl set-hostname k8s-node02 # 参数解释 # # 参数: set-hostname # 解释: 这是hostnamectl命令的一个参数，用于设置系统的主机名。 # # 参数: k8s-master01 # 解释: 这是要设置的主机名，将系统的主机名设置为\"k8s-master01\"。 1.4.配置yum源 link # 其他系统的源地址 # https://mirrors.tuna.tsinghua.edu.cn/help/ # 对于 Ubuntu sed -i 's/cn.archive.ubuntu.com/mirrors.ustc.edu.cn/g' /etc/apt/sources.list # 对于 CentOS 7 sudo sed -e 's|^mirrorlist=|#mirrorlist=|g' \\ -e 's|^#baseurl=http://mirror.centos.org/centos|baseurl=https://mirrors.tuna.tsinghua.edu.cn/centos|g' \\ -i.bak \\ /etc/yum.repos.d/CentOS-*.repo # 对于 CentOS 8 sudo sed -e 's|^mirrorlist=|#mirrorlist=|g' \\ -e 's|^#baseurl=http://mirror.centos.org/$contentdir|baseurl=https://mirrors.tuna.tsinghua.edu.cn/centos|g' \\ -i.bak \\ /etc/yum.repos.d/CentOS-*.repo # 对于私有仓库 sed -e 's|^mirrorlist=|#mirrorlist=|g' -e 's|^#baseurl=http://mirror.centos.org/\\$contentdir|baseurl=http://192.168.1.123/centos|g' -i.bak /etc/yum.repos.d/CentOS-*.repo # 参数解释 # # 以上命令是用于更改系统软件源的配置，以便从国内镜像站点下载软件包和更新。 # # 对于 Ubuntu 系统，将 /etc/apt/sources.list 文件中的软件源地址 cn.archive.ubuntu.com 替换为 mirrors.ustc.edu.cn。 # # 对于 CentOS 7 系统，将 /etc/yum.repos.d/CentOS-*.repo 文件中的 mirrorlist 注释掉，并将 baseurl 的值替换为 https://mirrors.tuna.tsinghua.edu.cn/centos。 # # 对于 CentOS 8 系统，同样将 /etc/yum.repos.d/CentOS-*.repo 文件中的 mirrorlist 注释掉，并将 baseurl 的值替换为 https://mirrors.tuna.tsinghua.edu.cn/centos。 # # 对于私有仓库，将 /etc/yum.repos.d/CentOS-*.repo 文件中的 mirrorlist 注释掉，并将 baseurl 的值替换为私有仓库地址 http://192.168.1.123/centos。 # # 这些命令通过使用 sed 工具和正则表达式，对相应的配置文件进行批量的替换操作，从而更改系统软件源配置。 1.5.安装一些必备工具 link # 对于 Ubuntu apt update \u0026\u0026 apt upgrade -y \u0026\u0026 apt install -y wget psmisc vim net-tools nfs-kernel-server telnet lvm2 git tar curl # 对于 CentOS 7 yum update -y \u0026\u0026 yum -y install wget psmisc vim net-tools nfs-utils telnet yum-utils device-mapper-persistent-data lvm2 git tar curl # 对于 CentOS 8 yum update -y \u0026\u0026 yum -y install wget psmisc vim net-tools nfs-utils telnet yum-utils device-mapper-persistent-data lvm2 git network-scripts tar curl 1.5.1 下载离线所需文件(可选) link在互联网服务器上安装一个一模一样的系统进行下载所需包\nCentOS7 link # 下载必要工具 yum -y install createrepo yum-utils wget epel* # 下载全量依赖包 repotrack createrepo wget psmisc vim net-tools nfs-utils telnet yum-utils device-mapper-persistent-data lvm2 git tar curl gcc keepalived haproxy bash-completion chrony sshpass ipvsadm ipset sysstat conntrack libseccomp # 删除libseccomp rm -rf libseccomp-*.rpm # 下载libseccomp wget http://rpmfind.net/linux/centos/8-stream/BaseOS/x86_64/os/Packages/libseccomp-2.5.1-1.el8.x86_64.rpm # 创建yum源信息 createrepo -u -d /data/centos7/ # 拷贝包到内网机器上 scp -r /data/centos7/ root@192.168.1.31: scp -r /data/centos7/ root@192.168.1.32: scp -r /data/centos7/ root@192.168.1.33: scp -r /data/centos7/ root@192.168.1.34: scp -r /data/centos7/ root@192.168.1.35: # 在内网机器上创建repo配置文件 rm -rf /etc/yum.repos.d/* cat \u003e /etc/yum.repos.d/123.repo \u003c\u003c EOF [cby] name=CentOS-$releasever - Media baseurl=file:///root/centos7/ gpgcheck=0 enabled=1 EOF # 安装下载好的包 yum clean all yum makecache yum install /root/centos7/* --skip-broken -y #### 备注 ##### # 安装完成后，可能还会出现yum无法使用那么再次执行 rm -rf /etc/yum.repos.d/* cat \u003e /etc/yum.repos.d/123.repo \u003c\u003c EOF [cby] name=CentOS-$releasever - Media baseurl=file:///root/centos7/ gpgcheck=0 enabled=1 EOF yum clean all yum makecache yum install /root/centos7/* --skip-broken -y #### 备注 ##### # 安装 chrony 和 libseccomp # yum install /root/centos7/libseccomp-2.5.1*.rpm -y # yum install /root/centos7/chrony-*.rpm -y CentOS8 link # 下载必要工具 yum -y install createrepo yum-utils wget epel* # 下载全量依赖包 repotrack wget psmisc vim net-tools nfs-utils telnet yum-utils device-mapper-persistent-data lvm2 git network-scripts tar curl gcc keepalived haproxy bash-completion chrony sshpass ipvsadm ipset sysstat conntrack libseccomp # 创建yum源信息 createrepo -u -d /data/centos8/ # 拷贝包到内网机器上 scp -r centos8/ root@192.168.1.31: scp -r centos8/ root@192.168.1.32: scp -r centos8/ root@192.168.1.33: scp -r centos8/ root@192.168.1.34: scp -r centos8/ root@192.168.1.35: # 在内网机器上创建repo配置文件 rm -rf /etc/yum.repos.d/* cat \u003e /etc/yum.repos.d/123.repo \u003c\u003c EOF [cby] name=CentOS-$releasever - Media baseurl=file:///root/centos8/ gpgcheck=0 enabled=1 EOF # 安装下载好的包 yum clean all yum makecache yum install /root/centos8/* --skip-broken -y #### 备注 ##### # 安装完成后，可能还会出现yum无法使用那么再次执行 rm -rf /etc/yum.repos.d/* cat \u003e /etc/yum.repos.d/123.repo \u003c\u003c EOF [cby] name=CentOS-$releasever - Media baseurl=file:///root/centos8/ gpgcheck=0 enabled=1 EOF yum clean all yum makecache yum install /root/centos8/* --skip-broken -y Ubuntu 下载包和依赖 link #!/bin/bash logfile=123.log ret=\"\" function getDepends() { echo \"fileName is\" $1\u003e\u003e$logfile # use tr to del \u003c \u003e ret=`apt-cache depends $1|grep Depends |cut -d: -f2 |tr -d \"\u003c\u003e\"` echo $ret|tee -a $logfile } # 需要获取其所依赖包的包 libs=\"wget psmisc vim net-tools nfs-kernel-server telnet lvm2 git tar curl gcc keepalived haproxy bash-completion chrony sshpass ipvsadm ipset sysstat conntrack libseccomp\" # download libs dependen. deep in 3 i=0 while [ $i -lt 3 ] ; do let i++ echo $i # download libs newlist=\" \" for j in $libs do added=\"$(getDepends $j)\" newlist=\"$newlist $added\" apt install $added --reinstall -d -y done libs=$newlist done # 创建源信息 apt install dpkg-dev sudo cp /var/cache/apt/archives/*.deb /data/ubuntu/ -r dpkg-scanpackages . /dev/null |gzip \u003e /data/ubuntu/Packages.gz -r # 拷贝包到内网机器上 scp -r ubuntu/ root@192.168.1.31: scp -r ubuntu/ root@192.168.1.32: scp -r ubuntu/ root@192.168.1.33: scp -r ubuntu/ root@192.168.1.34: scp -r ubuntu/ root@192.168.1.35: # 在内网机器上配置apt源 vim /etc/apt/sources.list cat /etc/apt/sources.list deb file:////root/ ubuntu/ # 安装deb包 apt install ./*.deb 1.6.选择性下载需要工具 link #!/bin/bash # 查看版本地址： # # https://github.com/containernetworking/plugins/releases/ # https://github.com/containerd/containerd/releases/ # https://github.com/kubernetes-sigs/cri-tools/releases/ # https://github.com/Mirantis/cri-dockerd/releases/ # https://github.com/etcd-io/etcd/releases/ # https://github.com/cloudflare/cfssl/releases/ # https://github.com/kubernetes/kubernetes/tree/master/CHANGELOG # https://download.docker.com/linux/static/stable/x86_64/ # https://github.com/opencontainers/runc/releases/ # https://mirrors.tuna.tsinghua.edu.cn/elrepo/kernel/el7/x86_64/RPMS/ # https://github.com/helm/helm/tags # http://nginx.org/download/ # Version numbers cni_plugins_version='v1.3.0' cri_containerd_cni_version='1.7.8' crictl_version='v1.28.0' cri_dockerd_version='0.3.7' etcd_version='v3.5.10' cfssl_version='1.6.4' kubernetes_server_version='1.28.3' docker_version='24.0.7' runc_version='1.1.10' kernel_version='5.4.260' helm_version='3.13.2' nginx_version='1.25.3' # URLs base_url='https://github.com' kernel_url=\"http://mirrors.tuna.tsinghua.edu.cn/elrepo/kernel/el7/x86_64/RPMS/kernel-lt-${kernel_version}-1.el7.elrepo.x86_64.rpm\" runc_url=\"${base_url}/opencontainers/runc/releases/download/v${runc_version}/runc.amd64\" docker_url=\"https://mirrors.ustc.edu.cn/docker-ce/linux/static/stable/x86_64/docker-${docker_version}.tgz\" cni_plugins_url=\"${base_url}/containernetworking/plugins/releases/download/${cni_plugins_version}/cni-plugins-linux-amd64-${cni_plugins_version}.tgz\" cri_containerd_cni_url=\"${base_url}/containerd/containerd/releases/download/v${cri_containerd_cni_version}/cri-containerd-cni-${cri_containerd_cni_version}-linux-amd64.tar.gz\" crictl_url=\"${base_url}/kubernetes-sigs/cri-tools/releases/download/${crictl_version}/crictl-${crictl_version}-linux-amd64.tar.gz\" cri_dockerd_url=\"${base_url}/Mirantis/cri-dockerd/releases/download/v${cri_dockerd_version}/cri-dockerd-${cri_dockerd_version}.amd64.tgz\" etcd_url=\"${base_url}/etcd-io/etcd/releases/download/${etcd_version}/etcd-${etcd_version}-linux-amd64.tar.gz\" cfssl_url=\"${base_url}/cloudflare/cfssl/releases/download/v${cfssl_version}/cfssl_${cfssl_version}_linux_amd64\" cfssljson_url=\"${base_url}/cloudflare/cfssl/releases/download/v${cfssl_version}/cfssljson_${cfssl_version}_linux_amd64\" helm_url=\"https://mirrors.huaweicloud.com/helm/v${helm_version}/helm-v${helm_version}-linux-amd64.tar.gz\" kubernetes_server_url=\"https://storage.googleapis.com/kubernetes-release/release/v${kubernetes_server_version}/kubernetes-server-linux-amd64.tar.gz\" nginx_url=\"http://nginx.org/download/nginx-${nginx_version}.tar.gz\" # Download packages packages=( $kernel_url $runc_url $docker_url $cni_plugins_url $cri_containerd_cni_url $crictl_url $cri_dockerd_url $etcd_url $cfssl_url $cfssljson_url $helm_url $kubernetes_server_url $nginx_url ) for package_url in \"${packages[@]}\"; do filename=$(basename \"$package_url\") if curl --parallel --parallel-immediate -k -L -C - -o \"$filename\" \"$package_url\"; then echo \"Downloaded $filename\" else echo \"Failed to download $filename\" exit 1 fi done 1.7.关闭防火墙 link # Ubuntu忽略，CentOS执行 systemctl disable --now firewalld 1.8.关闭SELinux link # Ubuntu忽略，CentOS执行 setenforce 0 sed -i 's#SELINUX=enforcing#SELINUX=disabled#g' /etc/selinux/config # 参数解释 # # setenforce 0 # 此命令用于设置 SELinux 的执行模式。0 表示关闭 SELinux。 # # sed -i 's#SELINUX=enforcing#SELINUX=disabled#g' /etc/selinux/config # 该命令使用 sed 工具来编辑 /etc/selinux/config 文件。其中 '-i' 参数表示直接修改原文件，而不是输出到终端或另一个文件。's#SELINUX=enforcing#SELINUX=disabled#g' 是 sed 的替换命令，它将文件中所有的 \"SELINUX=enforcing\" 替换为 \"SELINUX=disabled\"。这里的 '#' 是分隔符，用于替代传统的 '/' 分隔符，以避免与路径中的 '/' 冲突。 1.9.关闭交换分区 link sed -ri 's/.*swap.*/#\u0026/' /etc/fstab swapoff -a \u0026\u0026 sysctl -w vm.swappiness=0 cat /etc/fstab # /dev/mapper/centos-swap swap swap defaults 0 0 # 参数解释： # # -ri: 这个参数用于在原文件中替换匹配的模式。-r表示扩展正则表达式，-i允许直接修改文件。 # 's/.*swap.*/#\u0026/': 这是一个sed命令，用于在文件/etc/fstab中找到包含swap的行，并在行首添加#来注释掉该行。 # /etc/fstab: 这是一个文件路径，即/etc/fstab文件，用于存储文件系统表。 # swapoff -a: 这个命令用于关闭所有启用的交换分区。 # sysctl -w vm.swappiness=0: 这个命令用于修改vm.swappiness参数的值为0，表示系统在物理内存充足时更倾向于使用物理内存而非交换分区。 1.10.网络配置（俩种方式二选一） link # Ubuntu忽略，CentOS执行 # 方式一 # systemctl disable --now NetworkManager # systemctl start network \u0026\u0026 systemctl enable network # 方式二 cat \u003e /etc/NetworkManager/conf.d/calico.conf \u003c\u003c EOF [keyfile] unmanaged-devices=interface-name:cali*;interface-name:tunl* EOF systemctl restart NetworkManager # 参数解释 # # 这个参数用于指定不由 NetworkManager 管理的设备。它由以下两个部分组成 # # interface-name:cali* # 表示以 \"cali\" 开头的接口名称被排除在 NetworkManager 管理之外。例如，\"cali0\", \"cali1\" 等接口不受 NetworkManager 管理。 # # interface-name:tunl* # 表示以 \"tunl\" 开头的接口名称被排除在 NetworkManager 管理之外。例如，\"tunl0\", \"tunl1\" 等接口不受 NetworkManager 管理。 # # 通过使用这个参数，可以将特定的接口排除在 NetworkManager 的管理范围之外，以便其他工具或进程可以独立地管理和配置这些接口。 1.11.进行时间同步 link # 服务端 # apt install chrony -y yum install chrony -y cat \u003e /etc/chrony.conf \u003c\u003c EOF pool ntp.aliyun.com iburst driftfile /var/lib/chrony/drift makestep 1.0 3 rtcsync allow 192.168.1.0/24 local stratum 10 keyfile /etc/chrony.keys leapsectz right/UTC logdir /var/log/chrony EOF systemctl restart chronyd ; systemctl enable chronyd # 客户端 # apt install chrony -y yum install chrony -y cat \u003e /etc/chrony.conf \u003c\u003c EOF pool 192.168.1.31 iburst driftfile /var/lib/chrony/drift makestep 1.0 3 rtcsync keyfile /etc/chrony.keys leapsectz right/UTC logdir /var/log/chrony EOF systemctl restart chronyd ; systemctl enable chronyd #使用客户端进行验证 chronyc sources -v # 参数解释 # # pool ntp.aliyun.com iburst # 指定使用ntp.aliyun.com作为时间服务器池，iburst选项表示在初始同步时会发送多个请求以加快同步速度。 # # driftfile /var/lib/chrony/drift # 指定用于保存时钟漂移信息的文件路径。 # # makestep 1.0 3 # 设置当系统时间与服务器时间偏差大于1秒时，会以1秒的步长进行调整。如果偏差超过3秒，则立即进行时间调整。 # # rtcsync # 启用硬件时钟同步功能，可以提高时钟的准确性。 # # allow 192.168.0.0/24 # 允许192.168.0.0/24网段范围内的主机与chrony进行时间同步。 # # local stratum 10 # 将本地时钟设为stratum 10，stratum值表示时钟的准确度，值越小表示准确度越高。 # # keyfile /etc/chrony.keys # 指定使用的密钥文件路径，用于对时间同步进行身份验证。 # # leapsectz right/UTC # 指定时区为UTC。 # # logdir /var/log/chrony # 指定日志文件存放目录。 1.12.配置ulimit link ulimit -SHn 65535 cat \u003e\u003e /etc/security/limits.conf \u003c"
            }
        );
    index.add(
            {
                id:  42 ,
                href: "\/docs\/ops\/kubernetes\/2.kubernetes-v1.30.2%E4%BA%8C%E8%BF%9B%E5%88%B6%E9%83%A8%E7%BD%B2\/",
                title: "2.Kubernetes-v1.30.2高可用集群二进制部署(IPv4+IPv6双栈)",
                description: "Kubernetes（简称k8s）是Google在2014年6月开源的一个容器集群管理系统，使用Go语言开发，用于管理云平台中多个主机上的容器化的应用，Kubernetes的目标是让部署容器化的应用简单并且高效,Kubernetes提供了资源调度、部署管理、服务发现、扩容缩容、监控，维护等一整套功能。努力成为跨主机集群的自动部署、扩展以及运行应用程序容器的平台。 它支持一系列容器工具, 包括且不限于Docker等。",
                content: "介绍 link kubernetes（k8s）二进制高可用安装部署，支持IPv4+IPv6双栈。 我使用IPV6的目的是在公网进行访问，所以我配置了IPV6静态地址。 若您没有IPV6环境，或者不想使用IPv6，不对主机进行配置IPv6地址即可。 不配置IPV6，不影响后续，不过集群依旧是支持IPv6的。为后期留有扩展可能性。 若不要IPv6 ，不给网卡配置IPv6即可，不要对IPv6相关配置删除或操作，否则会出问题。 1.环境 link 主机名称 IP地址 说明 软件 192.168.1.60 外网节点 下载各种所需安装包 Master01 192.168.1.41 master节点 kube-apiserver、kube-controller-manager、kube-scheduler、etcd、\nkubelet、kube-proxy、nfs-client、haproxy、keepalived、nginx Master02 192.168.1.42 master节点 kube-apiserver、kube-controller-manager、kube-scheduler、etcd、\nkubelet、kube-proxy、nfs-client、haproxy、keepalived、nginx Master03 192.168.1.43 master节点 kube-apiserver、kube-controller-manager、kube-scheduler、etcd、\nkubelet、kube-proxy、nfs-client、haproxy、keepalived、nginx Node01 192.168.1.44 node节点 kubelet、kube-proxy、nfs-client、nginx Node02 192.168.1.45 node节点 kubelet、kube-proxy、nfs-client、nginx 192.168.1.46 VIP 网段 物理主机：192.168.1.0/24 service：10.96.0.0/12 pod：172.16.0.0/12\n安装包已经整理好：https://mirrors.chenby.cn/https://github.com/cby-chen/Kubernetes/releases/download/v1.30.2/kubernetes-v1.30.2.tar\n1.1.k8s基础系统环境配置 link1.2.配置IP link # 注意！ # 若虚拟机是进行克隆的那么网卡的UUID和MachineID会重复 # 需要重新生成新的UUIDUUID和MachineID # UUID和MachineID重复无法DHCP获取到IPV6地址 ssh root@192.168.1.155 \"rm -rf /etc/machine-id; systemd-machine-id-setup;reboot\" ssh root@192.168.1.158 \"rm -rf /etc/machine-id; systemd-machine-id-setup;reboot\" ssh root@192.168.1.160 \"rm -rf /etc/machine-id; systemd-machine-id-setup;reboot\" ssh root@192.168.1.161 \"rm -rf /etc/machine-id; systemd-machine-id-setup;reboot\" ssh root@192.168.1.162 \"rm -rf /etc/machine-id; systemd-machine-id-setup;reboot\" # # 查看当前的网卡列表和 UUID： # nmcli con show # 删除要更改 UUID 的网络连接： # nmcli con delete uuid \u003c原 UUID\u003e # 重新生成 UUID： # nmcli con add type ethernet ifname \u003c接口名称\u003e con-name \u003c新名称\u003e # 重新启用网络连接： # nmcli con up \u003c新名称\u003e # 更改网卡的UUID # 先配置静态IP之后使用ssh方式配置不断连 ssh root@192.168.1.41 \"nmcli con delete uuid 8e8afb37-9cb4-362e-ba72-82568cb54312;nmcli con add type ethernet ifname ens18 con-name ens18;nmcli con up ens18\" ssh root@192.168.1.42 \"nmcli con delete uuid 8e8afb37-9cb4-362e-ba72-82568cb54312;nmcli con add type ethernet ifname ens18 con-name ens18;nmcli con up ens18\" ssh root@192.168.1.43 \"nmcli con delete uuid 8e8afb37-9cb4-362e-ba72-82568cb54312;nmcli con add type ethernet ifname ens18 con-name ens18;nmcli con up ens18\" ssh root@192.168.1.44 \"nmcli con delete uuid 8e8afb37-9cb4-362e-ba72-82568cb54312;nmcli con add type ethernet ifname ens18 con-name ens18;nmcli con up ens18\" ssh root@192.168.1.45 \"nmcli con delete uuid 8e8afb37-9cb4-362e-ba72-82568cb54312;nmcli con add type ethernet ifname ens18 con-name ens18;nmcli con up ens18\" # 参数解释 # # ssh ssh root@192.168.1.41 # 使用SSH登录到IP为192.168.1.41的主机，使用root用户身份。 # # nmcli con delete uuid 708a1497-2192-43a5-9f03-2ab936fb3c44 # 删除 UUID 为 708a1497-2192-43a5-9f03-2ab936fb3c44 的网络连接，这是 NetworkManager 中一种特定网络配置的唯一标识符。 # # nmcli con add type ethernet ifname ens18 con-name ens18 # 添加一种以太网连接类型，并指定接口名为 ens18，连接名称也为 ens18。 # # nmcli con up ens18 # 开启 ens18 这个网络连接。 # # 简单来说，这个命令的作用是删除一个特定的网络连接配置，并添加一个名为 ens18 的以太网连接，然后启用这个新的连接。 # 修改静态的IPv4地址 ssh root@192.168.1.158 \"nmcli con mod ens18 ipv4.addresses 192.168.1.41/24; nmcli con mod ens18 ipv4.gateway 192.168.1.1; nmcli con mod ens18 ipv4.method manual; nmcli con mod ens18 ipv4.dns \"8.8.8.8\"; nmcli con up ens18\" ssh root@192.168.1.151 \"nmcli con mod ens18 ipv4.addresses 192.168.1.42/24; nmcli con mod ens18 ipv4.gateway 192.168.1.1; nmcli con mod ens18 ipv4.method manual; nmcli con mod ens18 ipv4.dns \"8.8.8.8\"; nmcli con up ens18\" ssh root@192.168.1.152 \"nmcli con mod ens18 ipv4.addresses 192.168.1.43/24; nmcli con mod ens18 ipv4.gateway 192.168.1.1; nmcli con mod ens18 ipv4.method manual; nmcli con mod ens18 ipv4.dns \"8.8.8.8\"; nmcli con up ens18\" ssh root@192.168.1.157 \"nmcli con mod ens18 ipv4.addresses 192.168.1.44/24; nmcli con mod ens18 ipv4.gateway 192.168.1.1; nmcli con mod ens18 ipv4.method manual; nmcli con mod ens18 ipv4.dns \"8.8.8.8\"; nmcli con up ens18\" ssh root@192.168.1.155 \"nmcli con mod ens18 ipv4.addresses 192.168.1.45/24; nmcli con mod ens18 ipv4.gateway 192.168.1.1; nmcli con mod ens18 ipv4.method manual; nmcli con mod ens18 ipv4.dns \"8.8.8.8\"; nmcli con up ens18\" # 参数解释 # # ssh root@192.168.1.154 # 使用SSH登录到IP为192.168.1.154的主机，使用root用户身份。 # # \"nmcli con mod ens18 ipv4.addresses 192.168.1.41/24\" # 修改ens18网络连接的IPv4地址为192.168.1.41，子网掩码为 24。 # # \"nmcli con mod ens18 ipv4.gateway 192.168.1.1\" # 修改ens18网络连接的IPv4网关为192.168.1.1。 # # \"nmcli con mod ens18 ipv4.method manual\" # 将ens18网络连接的IPv4配置方法设置为手动。 # # \"nmcli con mod ens18 ipv4.dns \"8.8.8.8\" # 将ens18网络连接的IPv4 DNS服务器设置为 8.8.8.8。 # # \"nmcli con up ens18\" # 启动ens18网络连接。 # # 总体来说，这条命令是通过SSH远程登录到指定的主机，并使用网络管理命令 (nmcli) 修改ens18网络连接的配置，包括IP地址、网关、配置方法和DNS服务器，并启动该网络连接。 # 没有固定IPv6选择不配置即可 ssh root@192.168.1.41 \"nmcli con mod ens18 ipv6.addresses fc00:43f4:1eea:1::10; nmcli con mod ens18 ipv6.gateway fc00:43f4:1eea:1::1; nmcli con mod ens18 ipv6.method manual; nmcli con mod ens18 ipv6.dns \"2400:3200::1\"; nmcli con up ens18\" ssh root@192.168.1.42 \"nmcli con mod ens18 ipv6.addresses fc00:43f4:1eea:1::20; nmcli con mod ens18 ipv6.gateway fc00:43f4:1eea:1::1; nmcli con mod ens18 ipv6.method manual; nmcli con mod ens18 ipv6.dns \"2400:3200::1\"; nmcli con up ens18\" ssh root@192.168.1.43 \"nmcli con mod ens18 ipv6.addresses fc00:43f4:1eea:1::30; nmcli con mod ens18 ipv6.gateway fc00:43f4:1eea:1::1; nmcli con mod ens18 ipv6.method manual; nmcli con mod ens18 ipv6.dns \"2400:3200::1\"; nmcli con up ens18\" ssh root@192.168.1.44 \"nmcli con mod ens18 ipv6.addresses fc00:43f4:1eea:1::40; nmcli con mod ens18 ipv6.gateway fc00:43f4:1eea:1::1; nmcli con mod ens18 ipv6.method manual; nmcli con mod ens18 ipv6.dns \"2400:3200::1\"; nmcli con up ens18\" ssh root@192.168.1.45 \"nmcli con mod ens18 ipv6.addresses fc00:43f4:1eea:1::50; nmcli con mod ens18 ipv6.gateway fc00:43f4:1eea:1::1; nmcli con mod ens18 ipv6.method manual; nmcli con mod ens18 ipv6.dns \"2400:3200::1\"; nmcli con up ens18\" # 参数解释 # # ssh root@192.168.1.41 # 通过SSH连接到IP地址为192.168.1.41的远程主机，使用root用户进行登录。 # # \"nmcli con mod ens18 ipv6.addresses fc00:43f4:1eea:1::10\" # 使用nmcli命令修改ens18接口的IPv6地址为fc00:43f4:1eea:1::10。 # # \"nmcli con mod ens18 ipv6.gateway fc00:43f4:1eea:1::1\" # 使用nmcli命令修改ens18接口的IPv6网关为fc00:43f4:1eea:1::1。 # # \"nmcli con mod ens18 ipv6.method manual\" # 使用nmcli命令将ens18接口的IPv6配置方法修改为手动配置。 # # \"nmcli con mod ens18 ipv6.dns \"2400:3200::1\" # 使用nmcli命令设置ens18接口的IPv6 DNS服务器为2400:3200::1。 # # \"nmcli con up ens18\" # 使用nmcli命令启动ens18接口。 # # 这个命令的目的是在远程主机上配置ens18接口的IPv6地址、网关、配置方法和DNS服务器，并启动ens18接口。 # 查看网卡配置 # nmcli device show ens18 # nmcli con show ens18 [root@localhost ~]# cat /etc/NetworkManager/system-connections/ens18.nmconnection [connection] id=ens18 uuid=97445eea-70e8-47a7-8be4-a707de271f5e type=ethernet interface-name=ens18 timestamp=1716705021 [ethernet] [ipv4] address1=192.168.1.41/24,192.168.1.1 dns=8.8.8.8; method=manual [ipv6] addr-gen-mode=default method=auto [proxy] [root@localhost ~]# # 参数解释 # 1. `[connection]`: # - `id`: 连接的唯一标识符，用于内部引用。 # - `uuid`: 连接的通用唯一标识符（UUID），确保在系统中的唯一性。 # - `type`: 指定连接的类型，本例中为以太网。 # - `interface-name`: 网络接口的名称（`ens18`），表示与此连接关联的物理或逻辑网络接口。 # - `timestamp`: 时间戳，指示连接配置上次修改的时间。 # 2. `[ethernet]`: # - 通常包含以太网特定的配置设置，如MAC地址或链路速度。 # 3. `[ipv4]`: # - `address1`: 以CIDR表示法指定IPv4地址和子网掩码（`192.168.1.41/24`）。还包括网关IP（`192.168.1.1`）。 # - `dns`: 指定要使用的DNS服务器（本例中为`8.8.8.8`），提供将域名转换为IP地址的手段。 # - `method`: 指定获取IPv4地址的方法。在本例中，设置为手动，表示IP地址是静态配置的。 # 4. `[ipv6]`: # - `addr-gen-mode`: 指定IPv6地址生成模式。设置为默认，通常意味着地址是根据接口的MAC地址生成的。 # - `method`: 指定获取IPv6地址的方法。在本例中，设置为自动，表示使用DHCPv6或SLAAC等协议进行自动配置。 # 5. `[proxy]`: # - 通常用于配置代理设置，如HTTP或SOCKS代理。 1.3.设置主机名 link hostnamectl set-hostname k8s-master01 hostnamectl set-hostname k8s-master02 hostnamectl set-hostname k8s-master03 hostnamectl set-hostname k8s-node01 hostnamectl set-hostname k8s-node02 # 参数解释 # # 参数: set-hostname # 解释: 这是hostnamectl命令的一个参数，用于设置系统的主机名。 # # 参数: k8s-master01 # 解释: 这是要设置的主机名，将系统的主机名设置为\"k8s-master01\"。 1.4.配置yum源 link # 其他系统的源地址 # https://help.mirrors.cernet.edu.cn/ # 对于私有仓库 sed -e 's|^mirrorlist=|#mirrorlist=|g' -e 's|^#baseurl=http://mirror.centos.org/\\$contentdir|baseurl=http://192.168.1.123/centos|g' -i.bak /etc/yum.repos.d/CentOS-*.repo # 对于 Ubuntu sed -i 's/cn.archive.ubuntu.com/mirrors.ustc.edu.cn/g' /etc/apt/sources.list # epel扩展源 sudo yum install -y epel-release sudo sed -e 's!^metalink=!#metalink=!g' \\ -e 's!^#baseurl=!baseurl=!g' \\ -e 's!https\\?://download\\.fedoraproject\\.org/pub/epel!https://mirror.nju.edu.cn/epel!g' \\ -e 's!https\\?://download\\.example/pub/epel!https://mirror.nju.edu.cn/epel!g' \\ -i /etc/yum.repos.d/epel{,-testing}.repo # 对于 CentOS 7 sudo sed -e 's|^mirrorlist=|#mirrorlist=|g' \\ -e 's|^#baseurl=http://mirror.centos.org/centos|baseurl=https://mirror.nju.edu.cn/centos|g' \\ -i.bak \\ /etc/yum.repos.d/CentOS-*.repo # 对于 CentOS 8 sudo sed -e 's|^mirrorlist=|#mirrorlist=|g' \\ -e 's|^#baseurl=http://mirror.centos.org/$contentdir|baseurl=https://mirror.nju.edu.cn/centos|g' \\ -i.bak \\ /etc/yum.repos.d/CentOS-*.repo # 对于CentOS 9 cat \u003c\u003c'EOF' \u003e /etc/yum.repos.d/centos.repo [baseos] name=CentOS Stream $releasever - BaseOS baseurl=https://mirrors.tuna.tsinghua.edu.cn/centos-stream/$releasever-stream/BaseOS/$basearch/os # metalink=https://mirrors.centos.org/metalink?repo=centos-baseos-$stream\u0026arch=$basearch\u0026protocol=https,http gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-centosofficial gpgcheck=1 repo_gpgcheck=0 metadata_expire=6h countme=1 enabled=1 [baseos-debuginfo] name=CentOS Stream $releasever - BaseOS - Debug baseurl=https://mirrors.tuna.tsinghua.edu.cn/centos-stream/$releasever-stream/BaseOS/$basearch/debug/tree/ # metalink=https://mirrors.centos.org/metalink?repo=centos-baseos-debug-$stream\u0026arch=$basearch\u0026protocol=https,http gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-centosofficial gpgcheck=1 repo_gpgcheck=0 metadata_expire=6h enabled=0 [baseos-source] name=CentOS Stream $releasever - BaseOS - Source baseurl=https://mirrors.tuna.tsinghua.edu.cn/centos-stream/$releasever-stream/BaseOS/source/tree/ # metalink=https://mirrors.centos.org/metalink?repo=centos-baseos-source-$stream\u0026arch=source\u0026protocol=https,http gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-centosofficial gpgcheck=1 repo_gpgcheck=0 metadata_expire=6h enabled=0 [appstream] name=CentOS Stream $releasever - AppStream baseurl=https://mirrors.tuna.tsinghua.edu.cn/centos-stream/$releasever-stream/AppStream/$basearch/os # metalink=https://mirrors.centos.org/metalink?repo=centos-appstream-$stream\u0026arch=$basearch\u0026protocol=https,http gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-centosofficial gpgcheck=1 repo_gpgcheck=0 metadata_expire=6h countme=1 enabled=1 [appstream-debuginfo] name=CentOS Stream $releasever - AppStream - Debug baseurl=https://mirrors.tuna.tsinghua.edu.cn/centos-stream/$releasever-stream/AppStream/$basearch/debug/tree/ # metalink=https://mirrors.centos.org/metalink?repo=centos-appstream-debug-$stream\u0026arch=$basearch\u0026protocol=https,http gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-centosofficial gpgcheck=1 repo_gpgcheck=0 metadata_expire=6h enabled=0 [appstream-source] name=CentOS Stream $releasever - AppStream - Source baseurl=https://mirrors.tuna.tsinghua.edu.cn/centos-stream/$releasever-stream/AppStream/source/tree/ # metalink=https://mirrors.centos.org/metalink?repo=centos-appstream-source-$stream\u0026arch=source\u0026protocol=https,http gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-centosofficial gpgcheck=1 repo_gpgcheck=0 metadata_expire=6h enabled=0 [crb] name=CentOS Stream $releasever - CRB baseurl=https://mirrors.tuna.tsinghua.edu.cn/centos-stream/$releasever-stream/CRB/$basearch/os # metalink=https://mirrors.centos.org/metalink?repo=centos-crb-$stream\u0026arch=$basearch\u0026protocol=https,http gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-centosofficial gpgcheck=1 repo_gpgcheck=0 metadata_expire=6h countme=1 enabled=1 [crb-debuginfo] name=CentOS Stream $releasever - CRB - Debug baseurl=https://mirrors.tuna.tsinghua.edu.cn/centos-stream/$releasever-stream/CRB/$basearch/debug/tree/ # metalink=https://mirrors.centos.org/metalink?repo=centos-crb-debug-$stream\u0026arch=$basearch\u0026protocol=https,http gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-centosofficial gpgcheck=1 repo_gpgcheck=0 metadata_expire=6h enabled=0 [crb-source] name=CentOS Stream $releasever - CRB - Source baseurl=https://mirrors.tuna.tsinghua.edu.cn/centos-stream/$releasever-stream/CRB/source/tree/ # metalink=https://mirrors.centos.org/metalink?repo=centos-crb-source-$stream\u0026arch=source\u0026protocol=https,http gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-centosofficial gpgcheck=1 repo_gpgcheck=0 metadata_expire=6h enabled=0 EOF cat \u003c\u003c'EOF' \u003e /etc/yum.repos.d/centos-addons.repo [highavailability] name=CentOS Stream $releasever - HighAvailability baseurl=https://mirrors.tuna.tsinghua.edu.cn/centos-stream/$releasever-stream/HighAvailability/$basearch/os # metalink=https://mirrors.centos.org/metalink?repo=centos-highavailability-$stream\u0026arch=$basearch\u0026protocol=https,http gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-centosofficial gpgcheck=1 repo_gpgcheck=0 metadata_expire=6h countme=1 enabled=0 [highavailability-debuginfo] name=CentOS Stream $releasever - HighAvailability - Debug baseurl=https://mirrors.tuna.tsinghua.edu.cn/centos-stream/$releasever-stream/HighAvailability/$basearch/debug/tree/ # metalink=https://mirrors.centos.org/metalink?repo=centos-highavailability-debug-$stream\u0026arch=$basearch\u0026protocol=https,http gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-centosofficial gpgcheck=1 repo_gpgcheck=0 metadata_expire=6h enabled=0 [highavailability-source] name=CentOS Stream $releasever - HighAvailability - Source baseurl=https://mirrors.tuna.tsinghua.edu.cn/centos-stream/$releasever-stream/HighAvailability/source/tree/ # metalink=https://mirrors.centos.org/metalink?repo=centos-highavailability-source-$stream\u0026arch=source\u0026protocol=https,http gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-centosofficial gpgcheck=1 repo_gpgcheck=0 metadata_expire=6h enabled=0 [nfv] name=CentOS Stream $releasever - NFV baseurl=https://mirrors.tuna.tsinghua.edu.cn/centos-stream/$releasever-stream/NFV/$basearch/os # metalink=https://mirrors.centos.org/metalink?repo=centos-nfv-$stream\u0026arch=$basearch\u0026protocol=https,http gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-centosofficial gpgcheck=1 repo_gpgcheck=0 metadata_expire=6h countme=1 enabled=0 [nfv-debuginfo] name=CentOS Stream $releasever - NFV - Debug baseurl=https://mirrors.tuna.tsinghua.edu.cn/centos-stream/$releasever-stream/NFV/$basearch/debug/tree/ # metalink=https://mirrors.centos.org/metalink?repo=centos-nfv-debug-$stream\u0026arch=$basearch\u0026protocol=https,http gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-centosofficial gpgcheck=1 repo_gpgcheck=0 metadata_expire=6h enabled=0 [nfv-source] name=CentOS Stream $releasever - NFV - Source baseurl=https://mirrors.tuna.tsinghua.edu.cn/centos-stream/$releasever-stream/NFV/source/tree/ # metalink=https://mirrors.centos.org/metalink?repo=centos-nfv-source-$stream\u0026arch=source\u0026protocol=https,http gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-centosofficial gpgcheck=1 repo_gpgcheck=0 metadata_expire=6h enabled=0 [rt] name=CentOS Stream $releasever - RT baseurl=https://mirrors.tuna.tsinghua.edu.cn/centos-stream/$releasever-stream/RT/$basearch/os # metalink=https://mirrors.centos.org/metalink?repo=centos-rt-$stream\u0026arch=$basearch\u0026protocol=https,http gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-centosofficial gpgcheck=1 repo_gpgcheck=0 metadata_expire=6h countme=1 enabled=0 [rt-debuginfo] name=CentOS Stream $releasever - RT - Debug baseurl=https://mirrors.tuna.tsinghua.edu.cn/centos-stream/$releasever-stream/RT/$basearch/debug/tree/ # metalink=https://mirrors.centos.org/metalink?repo=centos-rt-debug-$stream\u0026arch=$basearch\u0026protocol=https,http gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-centosofficial gpgcheck=1 repo_gpgcheck=0 metadata_expire=6h enabled=0 [rt-source] name=CentOS Stream $releasever - RT - Source baseurl=https://mirrors.tuna.tsinghua.edu.cn/centos-stream/$releasever-stream/RT/source/tree/ # metalink=https://mirrors.centos.org/metalink?repo=centos-rt-source-$stream\u0026arch=source\u0026protocol=https,http gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-centosofficial gpgcheck=1 repo_gpgcheck=0 metadata_expire=6h enabled=0 [resilientstorage] name=CentOS Stream $releasever - ResilientStorage baseurl=https://mirrors.tuna.tsinghua.edu.cn/centos-stream/$releasever-stream/ResilientStorage/$basearch/os # metalink=https://mirrors.centos.org/metalink?repo=centos-resilientstorage-$stream\u0026arch=$basearch\u0026protocol=https,http gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-centosofficial gpgcheck=1 repo_gpgcheck=0 metadata_expire=6h countme=1 enabled=0 [resilientstorage-debuginfo] name=CentOS Stream $releasever - ResilientStorage - Debug baseurl=https://mirrors.tuna.tsinghua.edu.cn/centos-stream/$releasever-stream/ResilientStorage/$basearch/debug/tree/ # metalink=https://mirrors.centos.org/metalink?repo=centos-resilientstorage-debug-$stream\u0026arch=$basearch\u0026protocol=https,http gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-centosofficial gpgcheck=1 repo_gpgcheck=0 metadata_expire=6h enabled=0 [resilientstorage-source] name=CentOS Stream $releasever - ResilientStorage - Source baseurl=https://mirrors.tuna.tsinghua.edu.cn/centos-stream/$releasever-stream/ResilientStorage/source/tree/ # metalink=https://mirrors.centos.org/metalink?repo=centos-resilientstorage-source-$stream\u0026arch=source\u0026protocol=https,http gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-centosofficial gpgcheck=1 repo_gpgcheck=0 metadata_expire=6h enabled=0 [extras-common] name=CentOS Stream $releasever - Extras packages baseurl=https://mirrors.tuna.tsinghua.edu.cn/centos-stream/SIGs/$releasever-stream/extras/$basearch/extras-common # metalink=https://mirrors.centos.org/metalink?repo=centos-extras-sig-extras-common-$stream\u0026arch=$basearch\u0026protocol=https,http gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-SIG-Extras-SHA512 gpgcheck=1 repo_gpgcheck=0 metadata_expire=6h countme=1 enabled=1 [extras-common-source] name=CentOS Stream $releasever - Extras packages - Source baseurl=https://mirrors.tuna.tsinghua.edu.cn/centos-stream/SIGs/$releasever-stream/extras/source/extras-common # metalink=https://mirrors.centos.org/metalink?repo=centos-extras-sig-extras-common-source-$stream\u0026arch=source\u0026protocol=https,http gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-SIG-Extras-SHA512 gpgcheck=1 repo_gpgcheck=0 metadata_expire=6h enabled=0 EOF 1.5.安装一些必备工具 link # 对于 Ubuntu apt update \u0026\u0026 apt upgrade -y \u0026\u0026 apt install -y wget psmisc vim net-tools nfs-kernel-server telnet lvm2 git tar curl # 对于 CentOS 7 yum update -y \u0026\u0026 yum -y install wget psmisc vim net-tools nfs-utils telnet yum-utils device-mapper-persistent-data lvm2 git tar curl # 对于 CentOS 8 yum update -y \u0026\u0026 yum -y install wget psmisc vim net-tools nfs-utils telnet yum-utils device-mapper-persistent-data lvm2 git network-scripts tar curl # 对于 CentOS 9 yum update -y \u0026\u0026 yum -y install wget psmisc vim net-tools nfs-utils telnet yum-utils device-mapper-persistent-data lvm2 git tar curl 1.5.1 下载离线所需文件(可选) link在互联网服务器上安装一个一模一样的系统进行下载所需包\nCentOS7 link # 下载必要工具 yum -y install createrepo yum-utils wget epel* # 下载全量依赖包 repotrack createrepo wget psmisc vim net-tools nfs-utils telnet yum-utils device-mapper-persistent-data lvm2 git tar curl gcc keepalived haproxy bash-completion chrony sshpass ipvsadm ipset sysstat conntrack libseccomp # 删除libseccomp rm -rf libseccomp-*.rpm # 下载libseccomp wget http://rpmfind.net/linux/centos/8-stream/BaseOS/x86_64/os/Packages/libseccomp-2.5.1-1.el8.x86_64.rpm # 创建yum源信息 createrepo -u -d /data/centos7/ # 拷贝包到内网机器上 scp -r /data/centos7/ root@192.168.1.41: scp -r /data/centos7/ root@192.168.1.42: scp -r /data/centos7/ root@192.168.1.43: scp -r /data/centos7/ root@192.168.1.44: scp -r /data/centos7/ root@192.168.1.45: # 在内网机器上创建repo配置文件 rm -rf /etc/yum.repos.d/* cat \u003e /etc/yum.repos.d/123.repo \u003c\u003c EOF [cby] name=CentOS-$releasever - Media baseurl=file:///root/centos7/ gpgcheck=0 enabled=1 EOF # 安装下载好的包 yum clean all yum makecache yum install /root/centos7/* --skip-broken -y #### 备注 ##### # 安装完成后，可能还会出现yum无法使用那么再次执行 rm -rf /etc/yum.repos.d/* cat \u003e /etc/yum.repos.d/123.repo \u003c\u003c EOF [cby] name=CentOS-$releasever - Media baseurl=file:///root/centos7/ gpgcheck=0 enabled=1 EOF yum clean all yum makecache yum install /root/centos7/*.rpm --skip-broken -y #### 备注 ##### # 安装 chrony 和 libseccomp # yum install /root/centos7/libseccomp-2.5.1*.rpm -y # yum install /root/centos7/chrony-*.rpm -y CentOS8 link # 下载必要工具 yum -y install createrepo yum-utils wget epel* # 下载全量依赖包 repotrack wget psmisc vim net-tools nfs-utils telnet yum-utils device-mapper-persistent-data lvm2 git network-scripts tar curl gcc keepalived haproxy bash-completion chrony sshpass ipvsadm ipset sysstat conntrack libseccomp # 创建yum源信息 createrepo -u -d /data/centos8/ # 拷贝包到内网机器上 scp -r centos8/ root@192.168.1.41: scp -r centos8/ root@192.168.1.42: scp -r centos8/ root@192.168.1.43: scp -r centos8/ root@192.168.1.44: scp -r centos8/ root@192.168.1.45: # 在内网机器上创建repo配置文件 rm -rf /etc/yum.repos.d/* cat \u003e /etc/yum.repos.d/123.repo \u003c\u003c EOF [cby] name=CentOS-$releasever - Media baseurl=file:///root/centos8/ gpgcheck=0 enabled=1 EOF # 安装下载好的包 yum clean all yum makecache yum install /root/centos8/* --skip-broken -y #### 备注 ##### # 安装完成后，可能还会出现yum无法使用那么再次执行 rm -rf /etc/yum.repos.d/* cat \u003e /etc/yum.repos.d/123.repo \u003c\u003c EOF [cby] name=CentOS-$releasever - Media baseurl=file:///root/centos8/ gpgcheck=0 enabled=1 EOF yum clean all yum makecache yum install /root/centos8/*.rpm --skip-broken -y CentOS9 link # 下载必要工具 yum -y install createrepo yum-utils wget epel* # 下载全量依赖包 repotrack wget psmisc vim net-tools nfs-utils telnet yum-utils device-mapper-persistent-data lvm2 git tar curl gcc keepalived haproxy bash-completion chrony sshpass ipvsadm ipset sysstat conntrack libseccomp # 创建yum源信息 createrepo -u -d centos9/ # 拷贝包到内网机器上 scp -r centos9/ root@192.168.1.41: scp -r centos9/ root@192.168.1.42: scp -r centos9/ root@192.168.1.43: scp -r centos9/ root@192.168.1.44: scp -r centos9/ root@192.168.1.45: # 在内网机器上创建repo配置文件 rm -rf /etc/yum.repos.d/* cat \u003e /etc/yum.repos.d/123.repo \u003c\u003c EOF [cby] name=CentOS-$releasever - Media baseurl=file:///root/centos9/ gpgcheck=0 enabled=1 EOF # 安装下载好的包 yum clean all yum makecache yum install /root/centos9/*.rpm --skip-broken -y Ubuntu 下载包和依赖 link #!/bin/bash logfile=123.log ret=\"\" function getDepends() { echo \"fileName is\" $1\u003e\u003e$logfile # use tr to del \u003c \u003e ret=`apt-cache depends $1|grep Depends |cut -d: -f2 |tr -d \"\u003c\u003e\"` echo $ret|tee -a $logfile } # 需要获取其所依赖包的包 libs=\"wget psmisc vim net-tools nfs-kernel-server telnet lvm2 git tar curl gcc keepalived haproxy bash-completion chrony sshpass ipvsadm ipset sysstat conntrack libseccomp\" # download libs dependen. deep in 3 i=0 while [ $i -lt 3 ] ; do let i++ echo $i # download libs newlist=\" \" for j in $libs do added=\"$(getDepends $j)\" newlist=\"$newlist $added\" apt install $added --reinstall -d -y done libs=$newlist done # 创建源信息 apt install dpkg-dev sudo cp /var/cache/apt/archives/*.deb /data/ubuntu/ -r dpkg-scanpackages . /dev/null |gzip \u003e /data/ubuntu/Packages.gz -r # 拷贝包到内网机器上 scp -r ubuntu/ root@192.168.1.41: scp -r ubuntu/ root@192.168.1.42: scp -r ubuntu/ root@192.168.1.43: scp -r ubuntu/ root@192.168.1.44: scp -r ubuntu/ root@192.168.1.45: # 在内网机器上配置apt源 vim /etc/apt/sources.list cat /etc/apt/sources.list deb file:////root/ ubuntu/ # 安装deb包 apt install ./*.deb 1.6.选择性下载需要工具 link #!/bin/bash # 查看版本地址： # # https://github.com/containernetworking/plugins/releases/ # https://github.com/containerd/containerd/releases/ # https://github.com/kubernetes-sigs/cri-tools/releases/ # https://github.com/Mirantis/cri-dockerd/releases/ # https://github.com/etcd-io/etcd/releases/ # https://github.com/cloudflare/cfssl/releases/ # https://github.com/kubernetes/kubernetes/tree/master/CHANGELOG # https://download.docker.com/linux/static/stable/x86_64/ # https://github.com/opencontainers/runc/releases/ # https://mirrors.tuna.tsinghua.edu.cn/elrepo/kernel/el7/x86_64/RPMS/ # https://github.com/helm/helm/tags # http://nginx.org/download/ # Version numbers cni_plugins_version='v1.5.1' cri_containerd_cni_version='1.7.18' crictl_version='v1.30.0' cri_dockerd_version='0.3.14' etcd_version='v3.5.13' cfssl_version='1.6.5' kubernetes_server_version='1.30.2' docker_version='26.1.4' runc_version='1.1.13' kernel_version='5.4.278' helm_version='3.15.2' nginx_version='1.27.0' # URLs base_url='https://github.com' kernel_url=\"http://mirrors.tuna.tsinghua.edu.cn/elrepo/kernel/el7/x86_64/RPMS/kernel-lt-${kernel_version}-1.el7.elrepo.x86_64.rpm\" runc_url=\"${base_url}/opencontainers/runc/releases/download/v${runc_version}/runc.amd64\" docker_url=\"https://mirrors.ustc.edu.cn/docker-ce/linux/static/stable/x86_64/docker-${docker_version}.tgz\" cni_plugins_url=\"${base_url}/containernetworking/plugins/releases/download/${cni_plugins_version}/cni-plugins-linux-amd64-${cni_plugins_version}.tgz\" cri_containerd_cni_url=\"${base_url}/containerd/containerd/releases/download/v${cri_containerd_cni_version}/cri-containerd-cni-${cri_containerd_cni_version}-linux-amd64.tar.gz\" crictl_url=\"${base_url}/kubernetes-sigs/cri-tools/releases/download/${crictl_version}/crictl-${crictl_version}-linux-amd64.tar.gz\" cri_dockerd_url=\"${base_url}/Mirantis/cri-dockerd/releases/download/v${cri_dockerd_version}/cri-dockerd-${cri_dockerd_version}.amd64.tgz\" etcd_url=\"${base_url}/etcd-io/etcd/releases/download/${etcd_version}/etcd-${etcd_version}-linux-amd64.tar.gz\" cfssl_url=\"${base_url}/cloudflare/cfssl/releases/download/v${cfssl_version}/cfssl_${cfssl_version}_linux_amd64\" cfssljson_url=\"${base_url}/cloudflare/cfssl/releases/download/v${cfssl_version}/cfssljson_${cfssl_version}_linux_amd64\" helm_url=\"https://mirrors.huaweicloud.com/helm/v${helm_version}/helm-v${helm_version}-linux-amd64.tar.gz\" kubernetes_server_url=\"https://storage.googleapis.com/kubernetes-release/release/v${kubernetes_server_version}/kubernetes-server-linux-amd64.tar.gz\" nginx_url=\"http://nginx.org/download/nginx-${nginx_version}.tar.gz\" # Download packages packages=( # $kernel_url $runc_url $docker_url $cni_plugins_url $cri_containerd_cni_url $crictl_url $cri_dockerd_url $etcd_url $cfssl_url $cfssljson_url $helm_url $kubernetes_server_url $nginx_url ) for package_url in \"${packages[@]}\"; do filename=$(basename \"$package_url\") if curl --parallel --parallel-immediate -k -L -C - -o \"$filename\" \"$package_url\"; then echo \"Downloaded $filename\" else echo \"Failed to download $filename\" exit 1 fi done 1.7.关闭防火墙 link # Ubuntu忽略，CentOS执行 systemctl disable --now firewalld 1.8.关闭SELinux link # Ubuntu忽略，CentOS执行 setenforce 0 sed -i 's#SELINUX=enforcing#SELINUX=disabled#g' /etc/selinux/config # 参数解释 # # setenforce 0 # 此命令用于设置 SELinux 的执行模式。0 表示关闭 SELinux。 # # sed -i 's#SELINUX=enforcing#SELINUX=disabled#g' /etc/selinux/config # 该命令使用 sed 工具来编辑 /etc/selinux/config 文件。其中 '-i' 参数表示直接修改原文件，而不是输出到终端或另一个文件。's#SELINUX=enforcing#SELINUX=disabled#g' 是 sed 的替换命令，它将文件中所有的 \"SELINUX=enforcing\" 替换为 \"SELINUX=disabled\"。这里的 '#' 是分隔符，用于替代传统的 '/' 分隔符，以避免与路径中的 '/' 冲突。 1.9.关闭交换分区 link sed -ri 's/.*swap.*/#\u0026/' /etc/fstab swapoff -a \u0026\u0026 sysctl -w vm.swappiness=0 cat /etc/fstab # /dev/mapper/centos-swap swap swap defaults 0 0 # 参数解释： # # -ri: 这个参数用于在原文件中替换匹配的模式。-r表示扩展正则表达式，-i允许直接修改文件。 # 's/.*swap.*/#\u0026/': 这是一个sed命令，用于在文件/etc/fstab中找到包含swap的行，并在行首添加#来注释掉该行。 # /etc/fstab: 这是一个文件路径，即/etc/fstab文件，用于存储文件系统表。 # swapoff -a: 这个命令用于关闭所有启用的交换分区。 # sysctl -w vm.swappiness=0: 这个命令用于修改vm.swappiness参数的值为0，表示系统在物理内存充足时更倾向于使用物理内存而非交换分区。 1.10.网络配置（俩种方式二选一） link # Ubuntu忽略，CentOS执行，CentOS9不支持方式一 # 方式一 # systemctl disable --now NetworkManager # systemctl start network \u0026\u0026 systemctl enable network # 方式二 cat \u003e /etc/NetworkManager/conf.d/calico.conf \u003c\u003c EOF [keyfile] unmanaged-devices=interface-name:cali*;interface-name:tunl* EOF systemctl restart NetworkManager # 参数解释 # # 这个参数用于指定不由 NetworkManager 管理的设备。它由以下两个部分组成 # # interface-name:cali* # 表示以 \"cali\" 开头的接口名称被排除在 NetworkManager 管理之外。例如，\"cali0\", \"cali1\" 等接口不受 NetworkManager 管理。 # # interface-name:tunl* # 表示以 \"tunl\" 开头的接口名称被排除在 NetworkManager 管理之外。例如，\"tunl0\", \"tunl1\" 等接口不受 NetworkManager 管理。 # # 通过使用这个参数，可以将特定的接口排除在 NetworkManager 的管理范围之外，以便其他工具或进程可以独立地管理和配置这些接口。 1.11.进行时间同步 link # 服务端 # apt install chrony -y yum install chrony -y cat \u003e /etc/chrony.conf \u003c\u003c EOF pool ntp.aliyun.com iburst driftfile /var/lib/chrony/drift makestep 1.0 3 rtcsync allow 192.168.1.0/24 local stratum 10 keyfile /etc/chrony.keys leapsectz right/UTC logdir /var/log/chrony EOF systemctl restart chronyd ; systemctl enable chronyd # 客户端 # apt install chrony -y yum install chrony -y cat \u003e /etc/chrony.conf \u003c\u003c EOF pool 192.168.1.41 iburst driftfile /var/lib/chrony/drift makestep 1.0 3 rtcsync keyfile /etc/chrony.keys leapsectz right/UTC logdir /var/log/chrony EOF systemctl restart chronyd ; systemctl enable chronyd #使用客户端进行验证 chronyc sources -v # 参数解释 # # pool ntp.aliyun.com iburst # 指定使用ntp.aliyun.com作为时间服务器池，iburst选项表示在初始同步时会发送多个请求以加快同步速度。 # # driftfile /var/lib/chrony/drift # 指定用于保存时钟漂移信息的文件路径。 # # makestep 1.0 3 # 设置当系统时间与服务器时间偏差大于1秒时，会以1秒的步长进行调整。如果偏差超过3秒，则立即进行时间调整。 # # rtcsync # 启用硬件时钟同步功能，可以提高时钟的准确性。 # # allow 192.168.0.0/24 # 允许192.168.0.0/24网段范围内的主机与chrony进行时间同步。 # # local stratum 10 # 将本地时钟设为stratum 10，stratum值表示时钟的准确度，值越小表示准确度越高。 # # keyfile /etc/chrony.keys # 指定使用的密钥文件路径，用于对时间同步进行身份验证。 # # leapsectz right/UTC # 指定时区为UTC。 # # logdir /var/log/chrony # 指定日志文件存放目录。 1.12.配置ulimit link ulimit -SHn 65535 cat \u003e\u003e /etc/security/limits.conf \u003c"
            }
        );
    index.add(
            {
                id:  43 ,
                href: "\/docs\/ops\/kubernetes\/3.%E5%8D%87%E7%BA%A7%E4%BA%8C%E8%BF%9B%E5%88%B6%E9%83%A8%E7%BD%B2%E7%9A%84kubernetes%E9%9B%86%E7%BE%A4\/",
                title: "3.升级二进制部署的kubernetes集群",
                description: "Kubernetes（简称k8s）是Google在2014年6月开源的一个容器集群管理系统，使用Go语言开发，用于管理云平台中多个主机上的容器化应用，Kubernetes的目标是让部署容器化的应用简单并且高效，Kubernetes提供了资源调度、部署管理、服务发现、扩容缩容、监控，维护等一整套功能。努力成为跨主机集群的自动部署、扩展以及运行应用程序容器的平台。 它支持一系列容器工具, 包括且不限于Docker等。",
                content: "基础操作 link查看当前版本信息 link [root@k8s-master01 ~]# kubectl get node NAME STATUS ROLES AGE VERSION k8s-master01 Ready 57d v1.23.6 k8s-master02 Ready 57d v1.23.6 k8s-master03 Ready 57d v1.23.6 k8s-node01 Ready 57d v1.23.6 k8s-node02 Ready 57d v1.23.6 [root@k8s-master01 ~]# 主机域名以及IP地址 link [root@k8s-master01 ~]# cat /etc/hosts | grep k8s 192.168.1.230 k8s-master01 192.168.1.231 k8s-master02 192.168.1.232 k8s-master03 192.168.1.233 k8s-node01 192.168.1.234 k8s-node02 [root@k8s-master01 ~]# 下载二进制安装包 link [root@k8s-master01 ~]# wget https://dl.k8s.io/v1.23.9/kubernetes-server-linux-amd64.tar.gz [root@k8s-master01 ~]# 解压二进制安装包 link [root@k8s-master01 ~]# tar xf kubernetes-server-linux-amd64.tar.gz [root@k8s-master01 ~]# 升级Maser link升级三台主节点上的客户端 link [root@k8s-master01 ~]# scp kubernetes/server/bin/kubectl root@192.168.1.230:/usr/local/bin/ [root@k8s-master01 ~]# [root@k8s-master01 ~]# scp kubernetes/server/bin/kubectl root@192.168.1.231:/usr/local/bin/ [root@k8s-master01 ~]# [root@k8s-master01 ~]# scp kubernetes/server/bin/kubectl root@192.168.1.232:/usr/local/bin/ [root@k8s-master01 ~]# 升级三台主节点api组件 link [root@k8s-master01 ~]# ssh root@192.168.1.230 \"systemctl stop kube-apiserver\" [root@k8s-master01 ~]# [root@k8s-master01 ~]# scp kubernetes/server/bin/kube-apiserver root@192.168.1.230:/usr/local/bin/ [root@k8s-master01 ~]# [root@k8s-master01 ~]# ssh root@192.168.1.230 \"systemctl start kube-apiserver\" [root@k8s-master01 ~]# [root@k8s-master01 ~]# kube-apiserver --version Kubernetes v1.23.9 [root@k8s-master01 ~]# 升级三台主节点控制器组件 link [root@k8s-master01 ~]# ssh root@192.168.1.230 \"systemctl stop kube-controller-manager\" [root@k8s-master01 ~]# [root@k8s-master01 ~]# scp kubernetes/server/bin/kube-controller-manager root@192.168.1.230:/usr/local/bin/ [root@k8s-master01 ~]# [root@k8s-master01 ~]# ssh root@192.168.1.230 \"systemctl start kube-controller-manager\" [root@k8s-master01 ~]# 升级三台主节点选择器组件 link [root@k8s-master01 ~]# ssh root@192.168.1.230 \"systemctl stop kube-scheduler\" [root@k8s-master01 ~]# [root@k8s-master01 ~]# scp kubernetes/server/bin/kube-scheduler root@192.168.1.230:/usr/local/bin/ [root@k8s-master01 ~]# [root@k8s-master01 ~]# ssh root@192.168.1.230 \"systemctl start kube-scheduler\" [root@k8s-master01 ~]# 升级Worker link每一台机器都要升级kubelet link [root@k8s-master01 ~]# ssh root@192.168.1.230 \"systemctl stop kubelet\" [root@k8s-master01 ~]# [root@k8s-master01 ~]# scp kubernetes/server/bin/kubelet root@192.168.1.230:/usr/local/bin/ [root@k8s-master01 ~]# [root@k8s-master01 ~]# ssh root@192.168.1.230 \"systemctl start kubelet\" [root@k8s-master01 ~]# [root@k8s-master01 ~]# ssh root@192.168.1.230 \"kubelet --version\" Kubernetes v1.23.9 [root@k8s-master01 ~]# 每一台机器都要升级kube-proxy link [root@k8s-master01 ~]# ssh root@192.168.1.230 \"systemctl stop kube-proxy\" [root@k8s-master01 ~]# [root@k8s-master01 ~]# scp kubernetes/server/bin/kube-proxy root@192.168.1.230:/usr/local/bin/ [root@k8s-master01 ~]# [root@k8s-master01 ~]# ssh root@192.168.1.230 \"systemctl start kube-proxy\" [root@k8s-master01 ~]# 验证 link [root@k8s-master01 ~]# kubectl get node NAME STATUS ROLES AGE VERSION k8s-master01 Ready 57d v1.23.9 k8s-master02 Ready 57d v1.23.9 k8s-master03 Ready 57d v1.23.9 k8s-node01 Ready 57d v1.23.9 k8s-node02 Ready 57d v1.23.9 [root@k8s-master01 ~]# [root@k8s-master01 ~]# kubectl version Client Version: version.Info{Major:\"1\", Minor:\"23\", GitVersion:\"v1.23.9\", GitCommit:\"c1de2d70269039fe55efb98e737d9a29f9155246\", GitTreeState:\"clean\", BuildDate:\"2022-07-13T14:26:51Z\", GoVersion:\"go1.17.11\", Compiler:\"gc\", Platform:\"linux/amd64\"} Server Version: version.Info{Major:\"1\", Minor:\"23\", GitVersion:\"v1.23.9\", GitCommit:\"c1de2d70269039fe55efb98e737d9a29f9155246\", GitTreeState:\"clean\", BuildDate:\"2022-07-13T14:19:57Z\", GoVersion:\"go1.17.11\", Compiler:\"gc\", Platform:\"linux/amd64\"} [root@k8s-master01 ~]# "
            }
        );
    index.add(
            {
                id:  44 ,
                href: "\/docs\/demo\/features\/",
                title: "Features",
                description: "A guide to the core features of the Lotus Docs theme.",
                content: ""
            }
        );
    index.add(
            {
                id:  45 ,
                href: "\/docs\/dev\/golang\/fyne\/project\/",
                title: "项目案例",
                description: "使用Fyne实现几个项目",
                content: ""
            }
        );
    index.add(
            {
                id:  46 ,
                href: "\/docs\/demo\/features\/syntax-highlighting\/",
                title: "Syntax Highlighting",
                description: "How to highlight code in Lotus Docs using the built-in The PrismJS library (or Chroma).",
                content: "Code Highlighters linkLotus Docs supports syntax highlighting by Prism (enabled by default via param.docs.prism in hugo.toml) or Hugo’s built-in code highlighter Chroma.\nFenced code blocks (code enclosed by triple backticks above and below) that specify a code language (declared right of the opening fence), will automatically highlight the code content as HTML e.g. ```html:\n```html Buy cool new product Checkout ``` Result - Prism Highlighter:\nBuy cool new product Checkout Result - Chroma Highlighter (param.docs.prism = false):\nPrism Features linkThe Prism highlighter features the following:\nCopy Code Button linkAll code blocks feature a button which copies the code to the clipboard when clicked. Hover over any code block and the copy button (content_copy) will appear in the top right hand corner.\nCode Block id linkEvery code block on a page has a unique id attribute, an auto-generated value calculated from the sha1 hash of the block’s contents combined with it’s position on the page.\nFor example, the following snippet can be linked via the unique id 80c9335:\npackage main import \"fmt\" func main() { fmt.Println(\"go\" + \"lang\") fmt.Println(\"1+1 =\", 1+1) fmt.Println(\"7.0/3.0 =\", 7.0/3.0) fmt.Println(true \u0026\u0026 false) fmt.Println(true || false) fmt.Println(!true) } Line Anchors linkSpecific sections of code can be linked and highlighted by combining the code block id with the desired line numbers or ranges.\nThe URL format follows, /#{code block id}.{line no. range}.\nFor example, /#80c9335.3,5,7-13 will link to (and highlight) lines 3, 5 and 7-13 in the code block above:\nThemes linkYou can change the Prism theme via the prismTheme parameter under [params.docs] in your config file.\ninfo Additional PrismJS themes will be adapted and added to Lotus Docs periodically. Keep an eye on new releases to know when. hugo.toml hugo.yaml hugo.json [params.docs] prismTheme = \"lotusdocs\" # (optional) - Set theme for PrismJS. Options include: lotusdocs (default), solarized-light, twilight, lucario params: docs: prismTheme: lotusdocs # (optional) - Set theme for PrismJS. Options include: lotusdocs (default), solarized-light, twilight, lucario { \"params\": { \"docs\": { \"prismTheme\": \"lotusdocs\" } } } Choose from the following theme options:\nlotusdocs (default) solarized-light twilight lucario Supported Languages linkBoth Prism \u0026 Chroma support a vast array of languages. See the links below for a complete list of languages supported by each highlighter:\nPrism (≈ 290 languages) Chroma (≈ 200 languages) Code Fence Translations link info For more extensive code highlighting options with Prism, consider using the "
            }
        );
    index.add(
            {
                id:  47 ,
                href: "\/docs\/demo\/features\/katex\/",
                title: "KaTex",
                description: "Fast Tex math rendering for your Lotus Docs site",
                content: "$$ f\\relax{x} = \\int_{-\\infty}^\\infty \\hat f(\\xi)\\ e^{2 \\pi i \\xi x} \\ d\\xi $$\nHow to use KaTex with Lotus Docs linkKaTex support is controlled by the katex parameter in your front matter (line 10 below). Add and set it to true in your front matter to enable KaTex support for that page. This means KaTex support and resources are active only for pages that require it.\n--- weight: 530 title: \"KaTex\" description: \"Fast Tex math rendering for your Lotus Docs site\" icon: \"function\" date: \"2023-08-26T20:43:23+01:00\" lastmod: \"2023-08-26T20:43:23+01:00\" draft: true toc: true katex: true --- Writing LaTex in Markdown linkEquations can be displayed either in block level or inline.\nBlock display linkType an equation using double dollar signs as the delimiter:\n$$ \\int \\frac{1}{x} dx = \\ln \\left| x \\right| + C $$ renders as:\n$$ \\int \\frac{1}{x} dx = \\ln \\left| x \\right| + C $$\nInline display linkType an equation using single dollar signs as the delimiter:\n$ \\int \\frac{1}{x} dx = \\ln \\left| x \\right| + C $ renders as:\n$ \\int \\frac{1}{x} dx = \\ln \\left| x \\right| + C $\nSyntax Rendering Issues linkAs a consequence of Hugo rendering to HTML before KaTex renders to math1, there are some instances in which the KaTex equation syntax requires heavy escaping or alterations before rendering correctly. This can be time-consuming and frustrating (especially for inexperienced users). To avoid this, a "
            }
        );
    index.add(
            {
                id:  48 ,
                href: "\/docs\/demo\/features\/mermaid\/",
                title: "Mermaid",
                description: "How to use the Mermaid diagramming and chart tool with Lotus Docs",
                content: "What is Mermaid? linkMermaid is a JavaScript-based diagramming and charting tool that uses Markdown-inspired text definitions and a renderer to create and modify complex diagrams. The main purpose of Mermaid is to help documentation catch up with development.\nHow to use Mermaid with Lotus Docs linkMermaid is enabled whenever content containing Mermaid diagram syntax is present in a page’s content. You can insert Mermaid diagrams by using the mermaid language identifier with triple backtick codeblocks:\n```mermaid sequenceDiagram Alice-\u003e\u003eJohn: Hello John, how are you? loop Healthcheck John-\u003e\u003eJohn: Fight against hypochondria end Note right of John: Rational thoughts! John--\u003e\u003eAlice: Great! John-\u003e\u003eBob: How about you? Bob--\u003e\u003eJohn: Jolly good! ``` Renders as:\nsequenceDiagram Alice-\u003e\u003eJohn: Hello John, how are you? loop Healthcheck John-\u003e\u003eJohn: Fight against hypochondria end Note right of John: Rational thoughts! John--\u003e\u003eAlice: Great! John-\u003e\u003eBob: How about you? Bob--\u003e\u003eJohn: Jolly good! Other diagram examples linkFlowchart linkflowchart LR A[Hard] --\u003e|Text| B(Round) B --\u003e C{Decision} C --\u003e|One| D[Result 1] C --\u003e|Two| E[Result 2] Gnatt Chart linkgantt section Section Completed :done, des1, 2014-01-06,2014-01-08 Active :active, des2, 2014-01-07, 3d Parallel 1 : des3, after des1, 1d Parallel 2 : des4, after des1, 1d Parallel 3 : des5, after des3, 1d Parallel 4 : des6, after des4, 1d Class diagram linkclassDiagram Class01 \u003c|-- AveryLongClass : Cool \u003c\u003e Class01 Class09 --\u003e C2 : Where am i? Class09 --* C3 Class09 --|\u003e Class07 Class07 : equals() Class07 : Object[] elementData Class01 : size() Class01 : int chimp Class01 : int gorilla class Class10 { \u003e\u003eservice\u003e\u003e int id size() } State diagram linkstateDiagram-v2 [*] --\u003e Still Still --\u003e [*] Still --\u003e Moving Moving --\u003e Still Moving --\u003e Crash Crash --\u003e [*] Pie Chart linkpie \"Dogs\" : 386 \"Cats\" : 85.9 \"Rats\" : 15 Git Graph link gitGraph commit commit branch develop checkout develop commit commit checkout main merge develop commit commit Bar chart (using gantt chart) linkgantt title Git Issues - days since last update dateFormat X axisFormat %s section Issue19062 71 : 0, 71 section Issue19401 36 : 0, 36 section Issue193 34 : 0, 34 section Issue7441 9 : 0, 9 section Issue1300 5 : 0, 5 User Journey diagram link journey title My working day section Go to work Make tea: 5: Me Go upstairs: 3: Me Do work: 1: Me, Cat section Go home Go downstairs: 5: Me Sit down: 3: Me C4 diagram linkC4Context title System Context diagram for Internet Banking System Person(customerA, \"Banking Customer A\", \"A customer of the bank, with personal bank accounts.\") Person(customerB, \"Banking Customer B\") Person_Ext(customerC, \"Banking Customer C\") System(SystemAA, \"Internet Banking System\", \"Allows customers to view information about their bank accounts, and make payments.\") Person(customerD, \"Banking Customer D\", \"A customer of the bank, with personal bank accounts.\") Enterprise_Boundary(b1, \"BankBoundary\") { SystemDb_Ext(SystemE, \"Mainframe Banking System\", \"Stores all of the core banking information about customers, accounts, transactions, etc.\") System_Boundary(b2, \"BankBoundary2\") { System(SystemA, \"Banking System A\") System(SystemB, \"Banking System B\", \"A system of the bank, with personal bank accounts.\") } System_Ext(SystemC, \"E-mail system\", \"The internal Microsoft Exchange e-mail system.\") SystemDb(SystemD, \"Banking System D Database\", \"A system of the bank, with personal bank accounts.\") Boundary(b3, \"BankBoundary3\", \"boundary\") { SystemQueue(SystemF, \"Banking System F Queue\", \"A system of the bank, with personal bank accounts.\") SystemQueue_Ext(SystemG, \"Banking System G Queue\", \"A system of the bank, with personal bank accounts.\") } } BiRel(customerA, SystemAA, \"Uses\") BiRel(SystemAA, SystemE, \"Uses\") Rel(SystemAA, SystemC, \"Sends e-mails\", \"SMTP\") Rel(SystemC, customerA, \"Sends e-mails to\") "
            }
        );
    index.add(
            {
                id:  49 ,
                href: "\/docs\/demo\/shortcodes\/",
                title: "Shortcodes",
                description: "Lotus Docs Custom Shortcodes.",
                content: ""
            }
        );
    index.add(
            {
                id:  50 ,
                href: "\/docs\/demo\/shortcodes\/alerts\/",
                title: "Alerts",
                description: "How to use Alert Shortcodes to render custom page alerts in markdown.",
                content: "Adding a Page Alert linkPage alerts can be added to your markdown using the following shortcode:\n{{\u003c alert text=\"This is the default alert. It consists of a default theme colour and icon.\" /\u003e}} The above code results in the following alert:\nnotifications This is the default alert. It consists of a default theme colour and icon. Alert with Context linkAdd context to an alert via the context parameter:\n{{\u003c alert context=\"info\" text=\"This is an alert with an info context. It consists of the info theme colour and icon.\" /\u003e}} Here’s what is rendered:\ninfo This is an alert with an info context. It consists of the info theme colour and icon. Additional alert contexts include success, danger, warning, primary, light and dark:\ncheck_circle This is an alert with a success context. It consists of the success theme colour and icon. report This is an alert with a danger context. It consists of the danger theme colour and icon. warning This is an alert with a warning context. It consists of the warning theme colour and icon. info This is an alert with a primary context. Its theme and icon colors match those of the current primary theme colour. This is an alert with a light context. It consists of the light theme colour. The light alert has no default icon. This is an alert with a dark context. It consists of the dark theme colour. The dark alert has no default icon. Alert with Custom Emoji Icon linkThe default icon for an alert context can be substituted with an emoji using the icon parameter:\n{{\u003c alert icon=\"🍅\" context=\"info\" text=\"This is an info context alert with a tomato emoji replacing the default icon. The info theme colour remains unchanged.\" /\u003e}} 🍅 This is an info context alert with a tomato emoji replacing the default icon. The info theme colour remains unchanged. Alert with No Icon linkSetting the icon parameter to an empty space, icon=\" \", will render an alert with no icon:\n{{\u003c alert icon=\" \" context=\"info\" text=\"This info context alert has no icon.\" /\u003e}} This info context alert has no icon. warning N.B. The icon parameter must contain a space. Setting it to icon=\"\" will render the default icon.\nRender Markdown \u0026 HTML inside an Alert link warning So % delimited alerts render correctly, ensure you have unsafe = true set under [markup.goldmark.renderer] in your hugo.toml configuration file1.\nUse a paired shortcode with the % delimiter2 to render Markdown and HTML inside an alert:\n{{% alert icon=\"🛒\" context=\"success\" %}} This ***paired shortcode*** alert contains a **markdown** list and header: #### My Shopping List: 1. Tomatoes 2. Bananas 3. Pineapples and a sentence styled using HTML tags such as \\ and \\ {{% /alert %}} 🛒\nThis paired shortcode alert contains a markdown list and header:\nMy Shopping List: link Tomatoes Bananas Pineapples and a sentence styled using HTML tags such as and Markdown alerts do not seem to display background color ↩︎\nShortcodes with Markdown - gohugo.io ↩︎\n"
            }
        );
    index.add(
            {
                id:  51 ,
                href: "\/docs\/demo\/shortcodes\/tables\/",
                title: "Tables",
                description: "How to use the Lotus Docs table shortcode to render great looking markdown tables",
                content: "The table shortcode enables Lotus Docs to take advantage of Bootstrap’s opt-in table styling.\nRegular Tables linkBy default Lotus Docs renders regular Markdown tables with some very basic styling:\n| Tables | Are | Cool | |----------|:-------------:|------:| | col 1 is | left-aligned | $1600 | | col 2 is | centered | $12 | | col 3 is | right-aligned | $1 | Result:\nTables Are Cool col 1 is left-aligned $1600 col 2 is centered $12 col 3 is right-aligned $1 Shortcode Tables linkThe the table shortcode allows you to implement a number of Bootstrap’s table styling classes. The table shortcode without any options will render a basic bordered table with a borderless floating table head:\n{{\u003c table \u003e}} | Animal | Sounds | Legs | |---------|--------|-----| | `Cat` | Meow | 4 | | `Dog` | Woof | 4 | | `Cricket` | Chirp | 6 | {{\u003c /table \u003e}} Animal Sounds Legs Cat Meow 4 Dog Woof 4 Cricket Chirp 6 warning Since the table shortcode works by implementing Bootstrap’s opt-in table styling, not all Bootstrap’s table styles are compatible with Lotus Docs. All compatible options are documented on this page.\nStriped Rows linkUse the table-striped option to add zebra-striping to the table rows.\n{{\u003c table \"table-striped\" \u003e}} ... .. {{\u003c /table \u003e}} Parameter Default Value Description google_fonts N/A An array of Google fonts and sizes to load. e.g.\ngoogle_fonts = [[\"Poppins\", \"300, 400, 600, 700\"],[\"Source Code Pro\", \"500, 700\"]]\nThis will load the Google Poppins and Source Code Pro fonts in the specified sizes. sans_serif_font System Font Set the Sans Serif font. e.g. \"Poppins\" secondary_font System Font Set the Secondary font. e.g. \"Poppins\" Striped Columns linkUse the table-striped-columns option to add zebra-striping to the table columns.\n{{\u003c table \"table-striped-columns\" \u003e}} ... .. {{\u003c /table \u003e}} Parameter Default Value Description google_fonts N/A An array of Google fonts and sizes to load. e.g.\ngoogle_fonts = [[\"Poppins\", \"300, 400, 600, 700\"],[\"Source Code Pro\", \"500, 700\"]]\nThis will load the Google Poppins and Source Code Pro fonts in the specified sizes. sans_serif_font System Font Set the Sans Serif font. e.g. \"Poppins\" secondary_font System Font Set the Secondary font. e.g. \"Poppins\" Hoverable Rows linkUse the table-hover option to enable a hover state on the table rows.\n{{\u003c table \"table-hover\" \u003e}} ... .. {{\u003c /table \u003e}} Parameter Default Value Description google_fonts N/A An array of Google fonts and sizes to load. e.g.\ngoogle_fonts = [[\"Poppins\", \"300, 400, 600, 700\"],[\"Source Code Pro\", \"500, 700\"]]\nThis will load the Google Poppins and Source Code Pro fonts in the specified sizes. sans_serif_font System Font Set the Sans Serif font. e.g. \"Poppins\" secondary_font System Font Set the Secondary font. e.g. \"Poppins\" Tables without borders linkUse the table-borderless option a table without borders.\n{{\u003c table \"table-borderless\" \u003e}} ... .. {{\u003c /table \u003e}} Parameter Default Value Description google_fonts N/A An array of Google fonts and sizes to load. e.g.\ngoogle_fonts = [[\"Poppins\", \"300, 400, 600, 700\"],[\"Source Code Pro\", \"500, 700\"]]\nThis will load the Google Poppins and Source Code Pro fonts in the specified sizes. sans_serif_font System Font Set the Sans Serif font. e.g. \"Poppins\" secondary_font System Font Set the Secondary font. e.g. \"Poppins\" Small Tables linkAdd table-sm or table-xs to make any table more compact by reducing the cell padding.\nParameter Default Value Description google_fonts N/A An array of Google fonts and sizes to load. e.g.\ngoogle_fonts = [[\"Poppins\", \"300, 400, 600, 700\"],[\"Source Code Pro\", \"500, 700\"]]\nThis will load the Google Poppins and Source Code Pro fonts in the specified sizes. sans_serif_font System Font Set the Sans Serif font. e.g. \"Poppins\" secondary_font System Font Set the Secondary font. e.g. \"Poppins\" Parameter Default Value Description google_fonts N/A An array of Google fonts and sizes to load. e.g.\ngoogle_fonts = [[\"Poppins\", \"300, 400, 600, 700\"],[\"Source Code Pro\", \"500, 700\"]]\nThis will load the Google Poppins and Source Code Pro fonts in the specified sizes. sans_serif_font System Font Set the Sans Serif font. e.g. \"Poppins\" secondary_font System Font Set the Secondary font. e.g. \"Poppins\" Responsive Tables linkAdd the table-responsive option to make a table responsive:\nAnimal Sounds Legs Cat Meow 4 Dog Woof 4 Cricket Chirp 6 Combining Table Options linkCombine table shortcode options to create your desired effect:\n{{\u003c table \"table-striped table-sm table-borderless\" \u003e}} ... .. {{\u003c /table \u003e}} Parameter Default Value Description google_fonts N/A An array of Google fonts and sizes to load. e.g.\ngoogle_fonts = [[\"Poppins\", \"300, 400, 600, 700\"],[\"Source Code Pro\", \"500, 700\"]]\nThis will load the Google Poppins and Source Code Pro fonts in the specified sizes. sans_serif_font System Font Set the Sans Serif font. e.g. \"Poppins\" secondary_font System Font Set the Secondary font. e.g. \"Poppins\" "
            }
        );
    index.add(
            {
                id:  52 ,
                href: "\/docs\/demo\/shortcodes\/tabs\/",
                title: "Tabs",
                description: "How to use the Lotus Docs tabs shortcode to render Bootstrap Tabs",
                content: "The tabs shortcode leverages Bootstrap’s Tabs styling to easily add Tabs to your markdown content. The shortcode is actually a combination of two separate shortcodes (tab and tabs) working together.\nYou need a minimum of one tab shortcode nested inside a tabs shortcode for the component to function:\n{{\u003c tabs tabTotal=\"1\"\u003e}} {{% tab tabName=\"Tab 1\" %}} **Tab 1 Content** {{% /tab %}} {{\u003c /tabs \u003e}} Basic Tabs linkThe following example demonstrates how to create a basic multi tab navigation component using the tabs and tab shortcodes.\n{{\u003c tabs tabTotal=\"3\"\u003e}} {{% tab tabName=\"Windows\" %}} **Windows Content** Example content specific to **Windows** operating systems {{% /tab %}} {{% tab tabName=\"MacOS\" %}} **MacOS Content** Example content specific to **Mac** operating systems {{% /tab %}} {{% tab tabName=\"Linux\" %}} **Linux Content** Example content specific to **Linux** operating systems {{% /tab %}} {{\u003c /tabs \u003e}} Renders:\nWindows MacOS Linux Windows Content\nExample content specific to Windows operating systems\nMacOS Content\nExample content specific to Mac operating systems\nLinux Content\nExample content specific to Linux operating systems\nRight Aligned Tabs link {{\u003c tabs tabTotal=\"3\" tabRightAlign=\"2\"\u003e}} {{% tab tabName=\"Tab 1\" %}} **Tab 1 Content** {{% /tab %}} {{% tab tabName=\"Tab 2\" %}} **Tab 2 Content** {{% /tab %}} {{% tab tabName=\"Tab 3\" %}} **Tab 3 Content** {{% /tab %}} {{\u003c /tabs \u003e}} Renders:\nTab 1 Tab 2 Tab 3 Tab 1 Content\nTab 2 Content\nTab 3 Content\nHow does it work? linktabs.html linkThis is the parent shortcode that wraps around all nested tab shortcodes in the tab group and generates the tab navigation.\nVariable Description tabTotal This variable is used to generate the tab navigation. Simply set it to the amount of tab shortcodes you have. In the above example, since there are three nested tab shortcodes, you would set tabTotal to 3. tabRightAlign This is an optional variable that if used will right align the tab number you inputted and all tabs after it. In the above example, since tabRightAlign is set to two, tabs 2 and 3 will be right aligned. tab.html linkThis is a child shortcode that is nested inside tabs shortcodes. Each tab shortcode equals one tab so add as many as you need. Please note, make sure tabTotal in the tabs shortcode is equal to the amount of tab shortcodes you define.\nVariable Description tabName This variable defines the title of the tab. Credit linkBoth tab and tabs shortcodes documented above are a modified versions of the open source Hugo Dynamic Tabs shortcodes. Thank you rvanhorn 👍.\n"
            }
        );
    index.add(
            {
                id:  53 ,
                href: "\/docs\/demo\/shortcodes\/prism\/",
                title: "Prism",
                description: "How to use the Prism Shortcode for syntax highlighting code blocks.",
                content: "Prism Shortcode linkWhen Prism is enabled in hugo.toml syntax highlighting can also be achieved using a paired Prism shortcode. The code language is declared using the lang parameter:\n{{\u003c prism lang=\"html\" \u003e}} Buy cool new product Checkout {{\u003c /prism \u003e}} All code blocks highlighted by Prism feature the Copy to Clipboard Button plugin. Hover over (or tap if on mobile) the examples above and the copy button appears in the top right hand corner of the code block. Click this button to copy the code to your clipboard.\nLine Highlighting linkThe Prism shortcode can highlight specific lines and/or line ranges in code blocks using the line parameter:\n{{\u003c prism lang=\"html\" line=\"2-4,6\" \u003e}} ... {{\u003c /prism \u003e}} See the rendered example below:\nBuy cool new product Checkout Line Numbers linkAdd line numbers to your code with the line-numbers=\"true\" parameter:\nBuy cool new product Checkout The number at which the line starts can be specified by the start parameter. e.g. start=\"48\":\nBuy cool new product Checkout Line Number Anchors linkSpecific lines in highlighted code blocks can be linked when both the line-numbers and linkable-line-numbers options are true:\n{{\u003c prism lang=\"html\" linkable-line-numbers=\"true\" line-numbers=\"true\" \u003e}} ... {{\u003c /prism \u003e}} Rendered code block:\nBuy cool new product Checkout Clicking on any of the line numbers above will update the hash of the current page to link to that specific line.\ninfo All elements of Prism code blocks have an auto-generated id attribute. This id is a combination of the unique hash of the code block content plus it’s unique position on the page. The generated hash can be overridden using a Custom id set via the id option.\nThe url format follows #{hash-id}.{lines}, where {hash-id} is the auto-generated hash value of the code block and {lines} is one or more lines or line ranges that follows the line highlighting format.\nFor example, line 8 in the code block below can be linked using the following anchor #adea9eb.8:\nBuy cool new product Checkout Combined Line Parameters linkPrism’s Line Highlighting \u0026 Line Numbers plugins are compatible with each other. So the line \u0026 line-numbers options can be combined to display both, line numbers and highlight specified lines in a code block:\n{{\u003c prism lang=\"html\" line-numbers=\"true\" line=\"2-4,6\" \u003e}} ... {{\u003c /prism \u003e}} This renders the following code block:\nBuy cool new product Checkout Combining line \u0026 start options requires the use of the line-offset option:\n{{\u003c prism lang=\"html\" line-numbers=\"true\" start=\"48\" line=\"49-51,54\" line-offset=\"48\" \u003e}} ... {{\u003c /prism \u003e}} This renders the following code block:\nBuy cool new product Checkout File Highlight linkExternal files can be fetched and highlighted using the File Highlight option. Use the src parameter to retrieve an external file, like so:\n{{\u003c prism src=\"https://raw.githubusercontent.com/colinwilson/lotusdocs/release/SECURITY.md\" /\u003e}} Result:\nUse the src-range parameter to retrieve a specific line range from an external file. src-range=\"32,46\" will fetch lines 32 to 46 of the file specified by the src parameter:\n{{\u003c prism src-range=\"32,46\" src=\"https://raw.githubusercontent.com/colinwilson/lotusdocs/release/data/landing.yaml\" line-numbers=\"true\" /\u003e}} src-range can be used with the line-numbers option to number the retrieved range. So the above shortcode produces the following code block:\ninfo See Prism’s docs for more info on the File Highlight plugin.\nDisable Prism linkPrism syntax highlighting can be disabled by setting [params.docs.prism] to false in the hugo.toml configuration file.\nCommand Line linkTBC\n"
            }
        );
    index.add(
            {
                id:  54 ,
                href: "\/docs\/demo\/shortcodes\/markdownify\/",
                title: "Markdownify",
                description: "A simple shortcode to render content as Markdown.",
                content: "This shortcode parses its content as markdown.\nUsage linkThe following:\n{{\u003c markdownify \u003e}} **Bold Text**: Above a code block. ```html Hello World {{\u003c /markdownify \u003e}} Renders:\nBold Text: Above a code block.\nHello World Nested Shortcodes linkThe markdownify shortcode is especially useful in cases where you require portions of content nested inside another shortcode be parsed as Markdown.\nFor example, here’s a paragraph of markdown text and a prism shortcode codeblock nested within a tabs shortcode:\n{{\u003c tabs tabTotal=\"1\" \u003e}} {{\u003c tab tabName=\"Tab 1\" \u003e}} {{\u003c markdownify \u003e}} ### Markdownified Text Some `markdownified` text inside a `tabs` shortcode {{\u003c /markdownify \u003e}} {{\u003c prism lang=\"html\" line=\"3,6\" \u003e}} A code block using the Prism Shortcode This shortcode is nested inside a Tabs shortcode {{\u003c /prism \u003e}} {{\u003c /tab \u003e}} {{\u003c /tabs \u003e}} Renders:\nTab 1 Markdownified Text\nSome markdownified text inside a tabs shortcode\nA code block using the Prism Shortcode This shortcode is nested inside a Tabs shortcode "
            }
        );
    index.add(
            {
                id:  55 ,
                href: "\/docs\/demo\/shortcodes\/katex\/",
                title: "KaTex",
                description: "A Shortcode to render KaTex syntax in your Lotus Docs site",
                content: "Lotus Docs has "
            }
        );
    search.addEventListener('input', show_results, true);

    function show_results(){
        const maxResult =  5 ;
        const minlength =  0 ;
        var searchQuery = sanitizeHTML(this.value);
        var results = index.search(searchQuery, {limit: maxResult, enrich: true});

        
        const flatResults = new Map(); 
        for (const result of results.flatMap(r => r.result)) {
        if (flatResults.has(result.doc.href)) continue;
        flatResults.set(result.doc.href, result.doc);
        }

        suggestions.innerHTML = "";
        suggestions.classList.remove('d-none');

        
        if (searchQuery.length < minlength) {
            const minCharMessage = document.createElement('div')
            minCharMessage.innerHTML = `Please type at least <strong>${minlength}</strong> characters`
            minCharMessage.classList.add("suggestion__no-results");
            suggestions.appendChild(minCharMessage);
            return;
        } else {
            
            if (flatResults.size === 0 && searchQuery) {
                const noResultsMessage = document.createElement('div')
                noResultsMessage.innerHTML = "No results for" + ` "<strong>${searchQuery}</strong>"`
                noResultsMessage.classList.add("suggestion__no-results");
                suggestions.appendChild(noResultsMessage);
                return;
            }
        }

        
        for(const [href, doc] of flatResults) {
            const entry = document.createElement('div');
            suggestions.appendChild(entry);

            const a = document.createElement('a');
            a.href = href;
            entry.appendChild(a);

            const title = document.createElement('span');
            title.textContent = doc.title;
            title.classList.add("suggestion__title");
            a.appendChild(title);

            const description = document.createElement('span');
            description.textContent = doc.description;
            description.classList.add("suggestion__description");
            a.appendChild(description);

            suggestions.appendChild(entry);

            if(suggestions.childElementCount == maxResult) break;
        }
    }
    }());
</script>
        
    </body>
</html>